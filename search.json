[{"title":"三十而立","url":"/zh-CN/32e6cd525cc3/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  生日快乐\n\n\n\n  \n    \n  \n\n\n\n","categories":["纪念日"],"tags":["日常","生日"]},{"title":"罪恶黑名单 第七季 第七集 汉娜·海耶斯","url":"/zh-CN/b1368e761a44/","content":"\n剧情介绍　　特工小组调查了一名州长神秘失踪和突然重现的事件。与此同时，雷德和登贝监视着与卡塔莉娜·罗斯托娃关系密切的一个人，而卡塔莉娜无意间将阿格尼丝卷入了她自己的行动中。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"看见 第一季 第五集 真实面貌","url":"/zh-CN/88f6afdd6ccf/","content":"\n剧情介绍　　随着塔马克蒂·琼的军队逐渐逼近巴巴和他的家人，玛格拉的过去逐渐浮出水面。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"海上钢琴师","url":"/zh-CN/59ad24642972/","content":"\n剧情介绍　　本片讲述了一个钢琴天才传奇的一生。\n　　1900年，Virginian号豪华邮轮上，一个孤儿被遗弃在头等舱，由船上的水手抚养长大，取名1900（蒂姆•罗斯 饰）。1900慢慢长大，显示出了无师自通的非凡钢琴天赋，在船上的乐队表演钢琴，每个听过他演奏的人，都被深深打动。爵士乐鼻祖杰尼听说了1900的高超技艺，专门上船和他比赛，最后自叹弗如，黯然离去。　　可惜，这一切的事情都发生在海上，1900从来不愿踏上陆地，直到有一天，他爱上了一个女孩，情愫在琴键上流淌。他会不会为了爱情，踏上陆地开始新的生活，用他的琴声惊艳世界？他将怎样谱写自己非凡的人生。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"女超人 第五季 第七集 震颤","url":"/zh-CN/64868bc46f8e/","content":"\n剧情介绍　　女超人在与利维坦的对抗中终于得知了莉娜的真相。同时，琼恩·琼恩发现了关于他哥哥下落的关键线索。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第一季 第七集 真相大白","url":"/zh-CN/620119b90dd0/","content":"\n剧情介绍　　凯特和索菲必须与她们的过去和解，同时凯特开始质疑自己能在多大程度上信任她的前恋人。凯特和卢克与一位老朋友相遇。玛丽为凯恩家族的命运而苦恼，而凯瑟琳则寻求雅各布的帮助。爱丽丝和一个新同伙又策划了一个邪恶的计划，但她的动机却比表面看起来更加复杂。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"黑客军团 第四季 第七集 407 需要代理身份验证","url":"/zh-CN/3fe54a961446/","content":"\n剧情介绍　　我不喜欢任何数据\n\n","categories":["剧集"],"tags":["日常","USA Network"]},{"title":"MacBook Pro 16 英寸 （Intel，2019年）","url":"/zh-CN/f076f8a0f760/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  MacBook Pro\n  笔记本有了新定义。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"黑闪电 第三季 第六集 抵抗之书：第一章：敲开天堂之门","url":"/zh-CN/857112b4c2a8/","content":"\n剧情介绍　　杰斐逊在对家人的忠诚与拯救弗里兰的使命之间感到左右为难。与此同时，安妮莎对格蕾丝的承诺越来越深。最后，珍妮弗做出了一个有趣的发现。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第六季 第六集 威尔斯寻找监视者 拉尔夫接替巴里","url":"/zh-CN/c1cefbf50a6e/","content":"\n剧情介绍　　尽管拉尔夫尽了最大的努力，罗索却竭尽全力。弗罗斯特（Frost）将拉尔夫（Ralph）送到STAR Labs，在那里Barry给他输了血。然而，一丝罗索的血液进入了巴里的血液。使他昏倒。以他的母亲诺拉（Nora）的形式出现的“ 速度力量”，告诉他罗索的血液包含他的意识，并且正在慢慢感染他，并使他能够接触巴里的思想；包括了解他的秘密身份和即将死亡。罗索以他对他的记忆，试图说服巴里加入他。向他承诺不仅可以避免他的死亡，而且可以避免无数其他人的死亡。速度军试图劝阻巴里，但是当他怀疑他是他们的棋子时，意外地激怒了他，他在服役期间将永远无法得到他想要的东西。思科和弗罗斯特最终使巴里复活，但是当艾里斯（Iris）来检查他时，她很快意识到不是他。Barry被完全感染，袭击了他的朋友，并向Rosso报告，Rosso准备实施他的中风。在其他地方，艾里斯（Iris），卡米拉（Kamilla）和阿莱格拉（Allegra）调查了将埃斯佩兰萨（Esperanza）变成杀手的组织。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"绿箭侠 第八季 第五集 力量","url":"/zh-CN/77bfa4c69ed6/","content":"\n剧情介绍　　在得知对抗监视者（The Monitor）的关键后，奥利弗和他的团队返回俄罗斯，执行任务以收集所需的材料。在此过程中，康纳（Connor）与自己过去的一位人物重逢。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"Hexo+NexT建站美化","url":"/zh-CN/d1d9a468f052/","content":"\n版本\n\n\n框架\n版本\n\n\n\nWinodws\n10.0.19045.6466\n\n\nNode.js\n25.5.0\n\n\nNPM\n11.9.0\n\n\nGit\n2.53.0\n\n\nHexo\n8.1.1\n\n\nNexT\n8.27.0\n\n\n\n环境安装Node.js 安装下载地址下载最新版本，安装。\nC:\\Windows\\system32&gt;node -vv25.5.0\n\nC:\\Windows\\system32&gt;npm -v11.9.0\n\nGit 安装下载地址下载最新版本，安装。\nC:\\Windows\\system32&gt;git -vgit version 2.53.0.windows.1\n\nHexo 安装C:\\Windows\\system32&gt;npm install -g hexo-clichanged 54 packages in 10s\n\n进入D:\\Hexo\nD:\\Hexo&gt;hexo initINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO  Install dependenciesINFO  Start blogging with Hexo!\n\nNexT 安装保持在D:\\Hexo\nD:\\Hexo&gt;git clone https://github.com/next-theme/hexo-theme-next themes/nextCloning into &#x27;themes/next&#x27;...remote: Enumerating objects: 7904, done.remote: Counting objects: 100% (1187/1187), done.remote: Compressing objects: 100% (250/250), done.remote: Total 7904 (delta 1038), reused 937 (delta 937), pack-reused 6717 (from 4)Receiving objects: 100% (7904/7904), 1.66 MiB | 2.94 MiB/s, done.Resolving deltas: 100% (5024/5024), done.\n\n到此，环境安装完成。\n\n美化配置依赖在D:\\Hexo目录下找到package.json\n&#123;//修改前&#123;  &quot;name&quot;: &quot;hexo-site&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;hexo generate&quot;,    &quot;clean&quot;: &quot;hexo clean&quot;,    &quot;deploy&quot;: &quot;hexo deploy&quot;,    &quot;server&quot;: &quot;hexo server&quot;  &#125;,  &quot;hexo&quot;: &#123;    &quot;version&quot;: &quot;8.1.1&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;hexo&quot;: &quot;^8.0.0&quot;,    &quot;hexo-generator-archive&quot;: &quot;^2.0.0&quot;,    &quot;hexo-generator-category&quot;: &quot;^2.0.0&quot;,    &quot;hexo-generator-index&quot;: &quot;^4.0.0&quot;,    &quot;hexo-generator-tag&quot;: &quot;^2.0.0&quot;,    &quot;hexo-renderer-ejs&quot;: &quot;^2.0.0&quot;,    &quot;hexo-renderer-marked&quot;: &quot;^7.0.0&quot;,    &quot;hexo-renderer-stylus&quot;: &quot;^3.0.1&quot;,    &quot;hexo-server&quot;: &quot;^3.0.0&quot;,    &quot;hexo-theme-landscape&quot;: &quot;^1.0.0&quot;  &#125;&#125;\n\n//修改后&#123;  &quot;name&quot;: &quot;hexo-site&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;hexo generate&quot;,    &quot;clean&quot;: &quot;hexo clean&quot;,    &quot;deploy&quot;: &quot;hexo deploy&quot;,    &quot;server&quot;: &quot;hexo server&quot;  &#125;,  &quot;hexo&quot;: &#123;    &quot;version&quot;: &quot;8.1.1&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;hexo&quot;: &quot;^8.0.0&quot;,    &quot;hexo-deployer-git&quot;: &quot;^4.0.0&quot;,    &quot;hexo-generator-archive&quot;: &quot;^2.0.0&quot;,    &quot;hexo-generator-category&quot;: &quot;^2.0.0&quot;,    &quot;hexo-generator-feed&quot;: &quot;^3.0.0&quot;,    &quot;hexo-generator-index&quot;: &quot;^4.0.0&quot;,    &quot;hexo-generator-searchdb&quot;: &quot;^1.4.1&quot;,    &quot;hexo-generator-sitemap&quot;: &quot;^3.0.1&quot;,    &quot;hexo-generator-tag&quot;: &quot;^2.0.0&quot;,    &quot;hexo-renderer-ejs&quot;: &quot;^2.0.0&quot;,    &quot;hexo-renderer-marked&quot;: &quot;^6.3.0&quot;,    &quot;hexo-renderer-stylus&quot;: &quot;^3.0.1&quot;,    &quot;hexo-server&quot;: &quot;^3.0.0&quot;,    &quot;hexo-theme-next&quot;: &quot;^8.20.0&quot;,    &quot;hexo-wordcount&quot;: &quot;^6.0.1&quot;  &#125;&#125;\n\n安装依赖\nD:\\Hexo&gt;npm installadded 29 packages, removed 1 package, and audited 268 packages in 12s28 packages are looking for funding  run `npm fund` for detailsfound 0 vulnerabilities\n\n修改网站配置文件在D:\\Hexo目录下找到_config.yml\n# 修改前# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexosubtitle: &#x27;&#x27;description: &#x27;&#x27;keywords:author: John Doelanguage: entimezone: &#x27;&#x27;# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: http://example.compermalink: :year/:month/:day/:title/permalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link:  enable: true # Open external links in new tab  field: site # Apply to the whole site  exclude: &#x27;&#x27;filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truesyntax_highlighter: highlight.jshighlight:  line_number: true  auto_detect: false  tab_replace: &#x27;&#x27;  wrap: true  hljs: falseprismjs:  preprocess: true  line_number: true  tab_replace: &#x27;&#x27;# Home page setting# path: Root path for your blogs index page. (default = &#x27;&#x27;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:  path: &#x27;&#x27;  per_page: 10  order_by: -date# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;updated_option: &#x27;mtime&#x27;# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Include / Exclude file(s)## include:/exclude: options only apply to the &#x27;source/&#x27; folderinclude:exclude:ignore:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: &#x27;&#x27;\n\n# 修改后# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 胡心小筑subtitle: 随笔   |   札记description: 好学若饥，谦卑若愚keywords:author: _mhxcAlfredlanguage: zh-CNtimezone: Asia/Shanghai# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://blog.mhxcalfred.com/# permalink: :year/:month/:day/:title/permalink: :lang/:hash/permalink_defaults:pretty_urls:  trailing_index: false # Set to false to remove trailing &#x27;index.html&#x27; from permalinks  trailing_html: false # Set to false to remove trailing &#x27;.html&#x27; from permalinks# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:  -  README.md  -  404.html  -  robots.txt# Writingnew_post_name: :lang/:title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link:  enable: true # Open external links in new tab  field: site # Apply to the whole site  exclude: &#x27;&#x27;filename_case: 0render_drafts: falsepost_asset_folder: truemarked:  prependRoot: true  postAsset: truerelative_link: falsefuture: true# syntax_highlighter: highlight.jshighlight:  enable: true  line_number: true  auto_detect: false  tab_replace: &#x27;&#x27;  wrap: true  hljs: falseprismjs:  enable: false  preprocess: true  line_number: true  tab_replace: &#x27;&#x27;# Home page setting# path: Root path for your blogs index page. (default = &#x27;&#x27;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:  path: &#x27;&#x27;  per_page: 10  order_by: -date# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY年MM月DD日 第WW周 第DDDD天 ddddtime_format: HH:mm:ss## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;updated_option: &#x27;mtime&#x27;# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Include / Exclude file(s)## include:/exclude: options only apply to the &#x27;source/&#x27; folderinclude:exclude:ignore:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/# theme: landscapetheme: next# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: https://github.com/mhxcAlfred/mhxcAlfred.github.io.git  branch: master\n\n修改主题配置文件在D:\\Hexo\\themes\\next目录下找到_config.yml\n复制文件到D:\\Hexo\\目录下，并重命名为_config.next.yml\n# 修改前# ===============================================================# It&#x27;s recommended to use Alternate Theme Config to configure NexT# Modifying this file may result in merge conflict# See: https://theme-next.js.org/docs/getting-started/configuration# ===============================================================# ---------------------------------------------------------------# Theme Core Configuration Settings# See: https://theme-next.js.org/docs/theme-settings/# ---------------------------------------------------------------# Allow to cache content generation.cache:  enable: true# Remove unnecessary files after hexo generate.minify: false# Define custom file paths.# Create your custom files in site directory `source/_data` and uncomment needed files below.custom_file_path:  #head: source/_data/head.njk  #header: source/_data/header.njk  #sidebar: source/_data/sidebar.njk  #postMeta: source/_data/post-meta.njk  #postBodyStart: source/_data/post-body-start.njk  #postBodyEnd: source/_data/post-body-end.njk  #footer: source/_data/footer.njk  #bodyEnd: source/_data/body-end.njk  #variable: source/_data/variables.styl  #mixin: source/_data/mixins.styl  #style: source/_data/styles.styl# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini# Dark Modedarkmode: true# Light-Dark Modelightdark:  enable: false  # Add @supports (color: light-dark(red, red)) check  check_supports: true# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------favicon:  small: /images/favicon-16x16-next.png  medium: /images/favicon-32x32-next.png  apple_touch_icon: /images/apple-touch-icon-next.png  safari_pinned_tab: /images/logo.svg  #android_manifest: /manifest.json# Custom Logo (Warning: Do not support scheme Mist)custom_logo: #/uploads/custom-logo.png# Creative Commons 4.0 International License.# See: https://creativecommons.org/about/cclicenses/creative_commons:  # Available values: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | cc-zero  license: by-nc-sa  # Available values: big | small  size: small  sidebar: false  post: false  # You can set a language value if you prefer a translated version of CC license, e.g. deed.zh  # CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org  language:# Open graph settings# See: https://hexo.io/docs/helpers#open-graphopen_graph:  enable: true  options:    #twitter_card: &lt;twitter:card&gt;    #twitter_id: &lt;twitter:creator&gt;    #twitter_site: &lt;twitter:site&gt;    #twitter_image: &lt;twitter:image&gt;    #google_plus: &lt;g+:profile_link&gt;    #fb_admins: &lt;fb:admin_id&gt;    #fb_app_id: &lt;fb:app_id&gt;# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# Usage: `Key: /link/ || icon`# Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-sensitive.# Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.# External url should start with http:// or https://menu:  #home: / || fa fa-home  #about: /about/ || fa fa-user  #tags: /tags/ || fa fa-tags  #categories: /categories/ || fa fa-th  #archives: /archives/ || fa fa-archive  #schedule: /schedule/ || fa fa-calendar  #sitemap: /sitemap.xml || fa fa-sitemap  #commonweal: /404/ || fa fa-heartbeat# Enable / Disable menu icons / item badges.menu_settings:  icons: true  badges: false# ---------------------------------------------------------------# Sidebar Settings# See: https://theme-next.js.org/docs/theme-settings/sidebar# ---------------------------------------------------------------sidebar:  # Sidebar position. Available values: left | right  position: left  # Sidebar width.  # Applicable to Muse | Mist and mobile of Pisces | Gemini.  width_expanded: 320  # Applicable to desktop of Pisces | Gemini.  width_dual_column: 240  # Sidebar display.  # Applicable to Muse | Mist and mobile of Pisces | Gemini.  # Available values:  #  - post    expand on posts automatically. Default.  #  - always  expand for all pages automatically.  #  - hide    expand only when click on the sidebar toggle icon.  #  - remove  totally remove sidebar including sidebar toggle.  display: post  # Sidebar padding in pixels.  padding: 18  # Sidebar offset from top menubar in pixels (only for Pisces | Gemini).  offset: 12# Sidebar Avataravatar:  # Replace the default image and set the url here.  url: #/images/avatar.gif  # If true, the avatar will be displayed in circle.  rounded: false  # If true, the avatar will be rotated with the cursor.  rotated: false# Posts / Categories / Tags in sidebar.site_state: true# Social Links# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.social:  #GitHub: https://github.com/yourname || fab fa-github  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope  #Weibo: https://weibo.com/yourname || fab fa-weibo  #Twitter: https://twitter.com/yourname || fab fa-twitter  #FB Page: https://www.facebook.com/yourname || fab fa-facebook  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow  #YouTube: https://youtube.com/yourname || fab fa-youtube  #Instagram: https://instagram.com/yourname || fab fa-instagram  #Skype: skype:yourname?call|chat || fab fa-skypesocial_icons:  enable: true  icons_only: false  transition: false# Blog rollslinks_settings:  icon: fa fa-globe  # Available values: block | inline  layout: blocklinks:  #Title: https://example.com# Table of Contents in the Sidebar# Front-matter variable (nonsupport wrap expand_all).toc:  enable: true  # Automatically add list number to toc.  number: true  # If true, all words will placed on next lines if header width longer then sidebar width.  wrap: false  # If true, all level of TOC in a post will be displayed, rather than the activated part of it.  expand_all: false  # Maximum heading depth of generated toc.  max_depth: 6# ---------------------------------------------------------------# Footer Settings# See: https://theme-next.js.org/docs/theme-settings/footer# ---------------------------------------------------------------# Show multilingual switcher in footer.language_switcher: falsefooter:  # Specify the year when the site was setup. If not defined, current year will be used.  #since: 2021  # Icon between year and copyright info.  icon:    # Icon name in Font Awesome. See: https://fontawesome.com/icons    name: fa fa-heart    # If you want to animate the icon, set it to true.    animated: false    # Change the color of icon, using Hex Code.    color: &quot;#ff0000&quot;  # If not defined, `author` from Hexo `_config.yml` will be used.  # Set to `false` to disable the copyright statement.  copyright:  # Powered by Hexo &amp; NexT  powered: true  # Beian ICP and gongan information for Chinese users. See: https://beian.miit.gov.cn, https://beian.mps.gov.cn  beian:    enable: false    icp:    # The digit in the num of gongan beian.    gongan_id:    # The full num of gongan beian.    gongan_num:    # The icon for gongan beian. Login and See: https://beian.mps.gov.cn/web/business/businessHome/website    gongan_icon_url:# ---------------------------------------------------------------# Post Settings# See: https://theme-next.js.org/docs/theme-settings/posts# ---------------------------------------------------------------# Use `description` in front-matter to specify post excerpt.excerpt_description: true# Read more button# If true, the read more button will be displayed in excerpt section.read_more_btn: true# Post meta display settingspost_meta:  item_text: true  created_at: true  updated_at:    enable: true    another_day: true  categories: true# Post wordcount display settings# Dependencies: https://github.com/next-theme/hexo-word-countersymbols_count_time:  separated_meta: true  item_text_total: false# Use icon instead of the symbol # to indicate the tag at the bottom of the posttag_icon: false# Donate (Sponsor) settings# Front-matter variable (nonsupport animation).reward_settings:  # If true, a donate button will be displayed in every article by default.  enable: false  animation: falsereward:  #wechatpay: /images/wechatpay.png  #alipay: /images/alipay.png  #paypal: /images/paypal.png  #bitcoin: /images/bitcoin.png# Subscribe through Telegram Channel, Twitter, etc.# Usage: `Key: permalink || icon` (Font Awesome)follow_me:  #Twitter: https://twitter.com/username || fab fa-twitter  #Telegram: https://t.me/channel_name || fab fa-telegram  #WeChat: /images/wechat_channel.png || fab fa-weixin  #RSS: /atom.xml || fa fa-rss# Related popular posts# Dependencies: https://github.com/next-theme/hexo-posts-embedding# Or: https://github.com/sergeyzwezdin/hexo-related-postsrelated_posts:  enable: false  icon: fa fa-signs-post# Post edit# Easily browse and edit blog source code online.post_edit:  enable: false  url: https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name/ # Link for view source  #url: https://github.com/user-name/repo-name/edit/branch-name/subdirectory-name/ # Link for fork &amp; edit# Show previous post and next post in post footer if exists# Available values: left | right | falsepost_navigation: left# ---------------------------------------------------------------# Custom Page Settings# See: https://theme-next.js.org/docs/theme-settings/custom-pages# ---------------------------------------------------------------# TagCloud settings for tags page.tagcloud:  min: 12 # Minimum font size in px  max: 30 # Maximum font size in px  amount: 200 # Total amount of tags  orderby: name # Order of tags  order: 1 # Sort order# Google Calendar# Share your recent schedule to others via calendar page.calendar:  calendar_id: &lt;required&gt; # Your Google account E-Mail  api_key: &lt;required&gt;  orderBy: startTime  showLocation: false  offsetMax: 72 # Time Range  offsetMin: 4 # Time Range  showDeleted: false  singleEvents: true  maxResults: 250# ---------------------------------------------------------------# Misc Theme Settings# See: https://theme-next.js.org/docs/theme-settings/miscellaneous# ---------------------------------------------------------------# Preload styles and preconnect CDN for fonts and plugins.# For more information: https://www.w3.org/TR/resource-hints/#preconnectpreconnect: false# Set the text alignment in posts / pages.text_align:  # Available values: start | end | left | right | center | justify | justify-all | match-parent  desktop: justify  mobile: justify# Reduce padding / margin indents on devices with narrow width.mobile_layout_economy: false# Browser header panel color.theme_color:  light: &quot;#222&quot;  dark: &quot;#222&quot;# Override browsers&#x27; default behavior.body_scrollbar:  # Place the scrollbar over the content.  overlay: false  # Reserving space for the scrollbar gutter even if the content is not overflowing.  stable: falsecodeblock:  # Code Highlight theme  # All available themes: https://theme-next.js.org/highlight/  theme:    light: default    dark: stackoverflow-dark  prism:    light: prism    dark: prism-dark  # Add copy button on codeblock  copy_button:    enable: false    # Available values: default | flat | mac    style:  # Fold code block  fold:    enable: false    height: 500  # Display language name  language: falseback2top:  enable: true  # Back to top in sidebar.  sidebar: false  # Scroll percent label in b2t button.  scrollpercent: false# Reading progress barreading_progress:  enable: false  # Available values: left | right  start_at: left  # Available values: top | bottom  position: top  reversed: false  color: &quot;#37c6c0&quot;  height: 3px# Bookmark Supportbookmark:  enable: false  # Customize the color of the bookmark.  color: &quot;#222&quot;  # If auto, save the reading progress when closing the page or clicking the bookmark-icon.  # If manual, only save it by clicking the bookmark-icon.  save: auto# `Follow me on GitHub` banner in the top-right corner.github_banner:  enable: false  permalink: https://github.com/yourname# ---------------------------------------------------------------# Font Settings# ---------------------------------------------------------------# Find fonts on Google Fonts (https://fonts.google.com)# All fonts set here will have the following styles:#   light | light italic | normal | normal italic | bold | bold italic# Be aware that setting too much fonts will cause site loading slowly# ---------------------------------------------------------------# Web Safe fonts are recommended for `global` (and `title`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---------------------------------------------------------------font:  enable: false  # Uri of fonts host, e.g. https://fonts.googleapis.com (Default).  host:  # Font options:  # `external: true` will load this font family from `host` above.  # `family: Times New Roman`. Without any quotes.  # `size: x.x`. Use `em` as unit. Default: 1 (16px)  # Global font settings used for all elements inside &lt;body&gt;.  global:    external: true    family: Lato    size:  # Font settings for site title (.site-title).  title:    external: true    family:    size:  # Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).  headings:    external: true    family:    size:  # Font settings for posts (.post-body).  posts:    external: true    family:  # Font settings for &lt;code&gt; and code blocks.  codes:    external: true    family:# ---------------------------------------------------------------# SEO Settings# See: https://theme-next.js.org/docs/theme-settings/seo# ---------------------------------------------------------------# If true, site-subtitle will be added to the title of index page.# Remember to set up your site-subtitle in Hexo `_config.yml` (e.g. subtitle: Subtitle)index_with_subtitle: false# Automatically add external URL with Base64 encrypt &amp; decrypt.exturl: false# If true, an icon will be attached to each external URLexturl_icon: true# Google Webmaster tools verification.# See: https://developers.google.com/searchgoogle_site_verification:# Bing Webmaster tools verification.# See: https://www.bing.com/webmastersbing_site_verification:# Yandex Webmaster tools verification.# See: https://webmaster.yandex.ruyandex_site_verification:# Baidu Webmaster tools verification.# See: https://ziyuan.baidu.com/sitebaidu_site_verification:# ---------------------------------------------------------------# Tags Settings# See: https://theme-next.js.org/docs/tag-plugins/# ---------------------------------------------------------------# Note tag (bootstrap callout)note:  # Note tag style values:  #  - simple    bootstrap callout old alert style. Default.  #  - modern    bootstrap callout new (v2-v3) alert style.  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.  #  - disabled  disable all CSS styles import of note tag.  style: simple  icons: false  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).  # Offset also applied to label tag variables. This option can work with disabled note tag.  light_bg_offset: 0# Tabs tagtabs:  # Make the nav bar of tabs with long content stick to the top.  sticky: false  transition:    tabs: false    labels: true# PDF tag# NexT will try to load pdf files natively, if failed, pdf.js will be used.# So, you have to install the dependency of pdf.js if you want to use pdf tag and make it available to all browsers.# Dependencies: https://github.com/next-theme/theme-next-pdfpdf:  enable: false  # Default height  height: 500px# Mermaid tagmermaid:  enable: false  # Available themes: default | dark | forest | neutral  theme:    light: default    dark: dark# WaveDrom tagwavedrom:  enable: false# ---------------------------------------------------------------# Third Party Plugins &amp; Services Settings# See: https://theme-next.js.org/docs/third-party-services/# More plugins: https://github.com/next-theme/awesome-next# ---------------------------------------------------------------# ---------------------------------------------------------------# Math Formulas Render Support# See: https://theme-next.js.org/docs/third-party-services/math-equations# Warning: Please install / uninstall the relevant renderer according to the documentation.# Server-side plugin: https://github.com/next-theme/hexo-filter-mathjax# ---------------------------------------------------------------math:  # Default (false) will load mathjax / katex script on demand.  # That is it only render those page which has `mathjax: true` in front-matter.  # If you set it to true, it will load mathjax / katex script EVERY PAGE.  every_page: false  mathjax:    enable: false    # Available values: none | ams | all    tags: none  katex:    enable: false    # See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex    copy_tex: false# ---------------------------------------------------------------# External Libraries# See: https://theme-next.js.org/docs/third-party-services/external-libraries# ---------------------------------------------------------------# Easily enable fast Ajax navigation on your website.# For more information: https://github.com/next-theme/pjaxpjax: false# FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images.# For more information: https://fancyapps.com/fancybox/fancybox: false# Medium Zoom is a JavaScript library for zooming images like Medium.# Warning: Do not enable both `fancybox` and `mediumzoom`.# For more information: https://medium-zoom.francoischalifour.commediumzoom: false# Vanilla JavaScript plugin for lazyloading images.# For more information: https://apoorv.pro/lozad.js/demo/lazyload: false# Automatically insert whitespace between CJK and half-width characters.# For more information: https://github.com/vinta/pangu.js# Server-side plugin: https://github.com/next-theme/hexo-pangupangu: false# Prefetch links based on what is in the user&#x27;s viewport.# For more information: https://getquick.link# Front-matter variable (nonsupport home archive).quicklink:  enable: false  # Home page and archive page can be controlled through home and archive options below.  # This configuration item is independent of `enable`.  home: false  archive: false  # Default (true) will initialize quicklink after the load event fires.  delay: true  # Custom a time in milliseconds by which the browser must execute prefetching.  timeout: 3000  # Default (true) will attempt to use the fetch() API if supported (rather than link[rel=prefetch]).  priority: true# ---------------------------------------------------------------# Animation Settings# ---------------------------------------------------------------# Use Animate.css to animate everything.# For more information: https://animate.stylemotion:  enable: true  async: false  duration: 200  transition:    # All available transition variants: https://theme-next.js.org/animate/    menu_item: fadeInDown    post_block: fadeIn    post_header: fadeInDown    post_body: fadeInDown    coll_header: fadeInLeft    # Only for Pisces | Gemini.    sidebar: fadeInUp# Progress bar in the top during page loading.# For more information: https://github.com/CodeByZach/pacepace:  enable: false  # All available colors:  # black | blue | green | orange | pink | purple | red | silver | white | yellow  color: blue  # All available themes:  # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple  # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal  theme: minimal# Generate a ribbon in your website with HTML5 canvas.# For more information: https://github.com/hustcc/ribbon.jscanvas_ribbon:  enable: false  size: 300 # The width of the ribbon  alpha: 0.6 # The transparency of the ribbon  zIndex: -1 # The display level of the ribbon# ---------------------------------------------------------------# Comments Settings# See: https://theme-next.js.org/docs/third-party-services/comments# More comment system plugins: https://github.com/next-theme/awesome-next/blob/main/README.md#comment# ---------------------------------------------------------------# Multiple Comment System Supportcomments:  # Available values: tabs | buttons  style: tabs  # Choose a comment system to be displayed by default.  # Available values: disqus | disqusjs | livere | gitalk | utterances | isso  active:  # Setting `true` means remembering the comment system selected by the visitor.  storage: true  # Lazyload all comment systems.  lazyload: false  # Modify texts or order for any naves, here are some examples.  nav:    #disqus:    #  text: Load Disqus    #  order: -1    #gitalk:    #  order: -2# Disqus# For more information: https://disqus.comdisqus:  enable: false  shortname:  count: true# DisqusJS# For more information: https://disqusjs.skk.moedisqusjs:  enable: false  # API Endpoint of Disqus API (https://disqus.com/api/docs/).  # Leave api empty if you are able to connect to Disqus API. Otherwise you need a reverse proxy for it.  # For example:  # api: https://disqus.skk.moe/disqus/  api:  apikey: # Register new application from https://disqus.com/api/applications/  shortname: # See: https://disqus.com/admin/settings/general/# LiveRe comments system# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: # &lt;your_uid&gt;# Gitalk# For more information: https://gitalk.github.iogitalk:  enable: false  github_id: # GitHub repo owner  repo: # Repository name to store issues  client_id: # GitHub Application Client ID  client_secret: # GitHub Application Client Secret  admin_user: # GitHub repo owner and collaborators, only these guys can initialize gitHub issues  distraction_free_mode: true # Facebook-like distraction free mode  # When the official proxy is not available, you can change it to your own proxy address  proxy: https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token # This is official proxy address  # Gitalk&#x27;s display language depends on user&#x27;s browser or system environment  # If you want everyone visiting your site to see a uniform language, you can set a force language value  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW  language:  # If you want to customize the content of the initialized Issue, please edit the body parameter.  # For example:  # body: Comments for post $&#123;title&#125;, see $&#123;url&#125;  body:# Utterances# For more information: https://utteranc.esutterances:  enable: false  repo: user-name/repo-name # Github repository owner and name  # Available values: pathname | url | title | og:title  issue_term: pathname  # Available values: github-light | github-dark | preferred-color-scheme | github-dark-orange | icy-dark | dark-blue | photon-dark | boxy-light  theme: github-light# Isso# For more information: https://isso-comments.deisso: # &lt;data_isso&gt;# ---------------------------------------------------------------# Post Widgets &amp; Content Sharing Services# See: https://theme-next.js.org/docs/third-party-services/post-widgets# ---------------------------------------------------------------# AddToAny Share. See: https://www.addtoany.comaddtoany:  enable: false  # Example: bottons: [facebook, twitter]  buttons:# ---------------------------------------------------------------# Statistics and Analytics# See: https://theme-next.js.org/docs/third-party-services/statistics-and-analytics# ---------------------------------------------------------------# Google Analytics# See: https://analytics.google.comgoogle_analytics:  tracking_id: # &lt;app_id&gt;  # By default, NexT will load an external gtag.js script on your site.  # If you only need the pageview feature, set the following option to true to get a better performance.  only_pageview: false  # only needed if you are using `only_pageview` mode, https://developers.google.com/analytics/devguides/collection/protocol/ga4  measure_protocol_api_secret:# Baidu Analytics# See: https://tongji.baidu.combaidu_analytics: # &lt;app_id&gt;# Cloudflare Web Analytics# See: https://www.cloudflare.com/web-analytics/cloudflare_analytics:# Microsoft Clarity Analytics# See: https://clarity.microsoft.com/clarity_analytics: # &lt;project_id&gt;# Matomo Analytics# See: https://matomo.org/matomo:  enable: false  server_url: # https://www.example.com/  site_id: # &lt;your site id&gt;# Umami Analytics# See: https://umami.is/umami:  enable: false  script_url: # https://umami.example.com/script.js  website_id: # &lt;your website id&gt;  host_url: # &lt;your umami site url&gt;# Plausible Analytics# See: https://plausible.io/plausible:  enable: false  script_url: # https://plausible.io/js/script.js  site_domain: # www.example.com# Another tool to show number of visitors to each article.# Visit https://console.firebase.google.com/u/0/ to get apiKey and projectId.# Visit https://firebase.google.com/docs/firestore/ to get more information about firestore.firestore:  enable: false  collection: articles # Required, a string collection name to access firestore database  apiKey: # Required  projectId: # Required# Show Views / Visitors of the website / page with busuanzi.# For more information: http://ibruce.info/2015/04/04/busuanzi/busuanzi_count:  enable: false  total_visitors: true  total_visitors_icon: fa fa-user  total_views: true  total_views_icon: fa fa-eye  post_views: true  post_views_icon: far fa-eye# ---------------------------------------------------------------# Search Services# See: https://theme-next.js.org/docs/third-party-services/search-services# ---------------------------------------------------------------# Algolia Search# For more information: https://www.algolia.comalgolia_search:  enable: false  hits:    per_page: 10# Local Search# Dependencies: https://github.com/next-theme/hexo-generator-searchdblocal_search:  enable: false  # Show top n results per article, show all results by setting to -1  top_n_per_article: 1  # Unescape html strings to the readable one.  unescape: false  # Preload the search data when the page loads.  preload: false# ---------------------------------------------------------------# Chat Services# See: https://theme-next.js.org/docs/third-party-services/chat-services# ---------------------------------------------------------------# A button to open designated chat widget in sidebar.# Firstly, you need to enable and configure the chat service.chat:  enable: false  icon: fa fa-comment # Icon name in Font Awesome, set to `false` to disable icon.# Chatra is a functional, easy to use piece of chat software for websites.# For more information: https://chatra.com# Dashboard: https://app.chatra.io/settings/generalchatra:  enable: false  async: true  id: # Visit Dashboard to get your ChatraID  #embed: # Unfinished experimental feature for developers. See: https://chatra.com/help/api/#injectto# Tidio is a powerful, all-in-one customer service tool.# For more information: https://www.tidio.com# Dashboard: https://www.tidio.com/panel/dashboardtidio:  enable: false  key: # Public Key, get it from dashboard. See: https://www.tidio.com/panel/settings/developer# ---------------------------------------------------------------# CDN Settings# See: https://theme-next.js.org/docs/advanced-settings/vendors# ---------------------------------------------------------------vendors:  # The CDN provider of NexT internal scripts.  # Available values: local | jsdelivr | unpkg | cdnjs | custom  # Warning: If you are using the latest master branch of NexT, please set `internal: local`  internal: local  # The default CDN provider of third-party plugins.  # Available values: local | jsdelivr | unpkg | cdnjs | custom  # Dependencies for `plugins: local`: https://github.com/next-theme/plugins  plugins: cdnjs  # Custom CDN URL  # For example:  # custom_cdn_url: https://cdn.jsdelivr.net/npm/$&#123;npm_name&#125;@$&#123;version&#125;/$&#123;minified&#125;  # custom_cdn_url: https://cdnjs.cloudflare.com/ajax/libs/$&#123;cdnjs_name&#125;/$&#123;version&#125;/$&#123;cdnjs_file&#125;  custom_cdn_url:# Assets# Accelerate delivery of static files using a CDN# The js option is only valid when vendors.internal is local.css: cssjs: jsimages: images\n\n# 修改后# ===============================================================# It&#x27;s recommended to use Alternate Theme Config to configure NexT# Modifying this file may result in merge conflict# See: https://theme-next.js.org/docs/getting-started/configuration# ===============================================================# ---------------------------------------------------------------# Theme Core Configuration Settings# See: https://theme-next.js.org/docs/theme-settings/# ---------------------------------------------------------------# Allow to cache content generation.cache:  enable: true# Remove unnecessary files after hexo generate.minify: true# Define custom file paths.# Create your custom files in site directory `source/_data` and uncomment needed files below.custom_file_path:  #head: source/_data/head.njk  #header: source/_data/header.njk  #sidebar: source/_data/sidebar.njk  #postMeta: source/_data/post-meta.njk  #postBodyStart: source/_data/post-body-start.njk  #postBodyEnd: source/_data/post-body-end.njk  #footer: source/_data/footer.njk  #bodyEnd: source/_data/body-end.njk  #variable: source/_data/variables.styl  #mixin: source/_data/mixins.styl  #style: source/_data/styles.styl# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini# Dark Modedarkmode: true# Light-Dark Modelightdark:  enable: true  # Add @supports (color: light-dark(red, red)) check  check_supports: true# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------favicon:  small: /images/favicon-16x16-_mhxcAlfred.png  medium: /images/favicon-32x32-_mhxcAlfred.png  apple_touch_icon: /images/apple-touch-icon-_mhxcAlfred.png  safari_pinned_tab: /images/logo-_mhxcAlfred.svg  android_manifest: /images/manifest.json# Custom Logo (Warning: Do not support scheme Mist)custom_logo: #/images/logo-_mhxcAlfred.svg# Creative Commons 4.0 International License.# See: https://creativecommons.org/about/cclicenses/creative_commons:  # Available values: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | cc-zero  license: by-nc-sa  # Available values: big | small  size: big  sidebar: false  post: true  # You can set a language value if you prefer a translated version of CC license, e.g. deed.zh  # CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org  language: deed.zh# Open graph settings# See: https://hexo.io/docs/helpers#open-graphopen_graph:  enable: true  options:    #twitter_card: &lt;twitter:card&gt;    #twitter_id: &lt;twitter:creator&gt;    #twitter_site: &lt;twitter:site&gt;    #twitter_image: &lt;twitter:image&gt;    #google_plus: &lt;g+:profile_link&gt;    #fb_admins: &lt;fb:admin_id&gt;    #fb_app_id: &lt;fb:app_id&gt;# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# Usage: `Key: /link/ || icon`# Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-sensitive.# Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.# External url should start with http:// or https://menu:  home: / || fa fa-home  archives: /archives/ || fa fa-archive  categories: /categories/ || fa fa-th  tags: /tags/ || fa fa-tags  # schedule: /schedule/ || fa fa-calendar  sitemap: /sitemap.xml || fa fa-sitemap  RSS: /atom.xml || fa fa-rss  # Anniversary: /anniversary/ || fa fa-cake-candles  # commonweal: /404/ || fa fa-heartbeat  about: /about/ || fa fa-user# Enable / Disable menu icons / item badges.menu_settings:  icons: true  badges: false# ---------------------------------------------------------------# Sidebar Settings# See: https://theme-next.js.org/docs/theme-settings/sidebar# ---------------------------------------------------------------sidebar:  # Sidebar position. Available values: left | right  #position: left  position: right  # Sidebar width.  # Applicable to Muse | Mist and mobile of Pisces | Gemini.  width_expanded: 320  # Applicable to desktop of Pisces | Gemini.  width_dual_column: 240  # Sidebar display.  # Applicable to Muse | Mist and mobile of Pisces | Gemini.  # Available values:  #  - post    expand on posts automatically. Default.  #  - always  expand for all pages automatically.  #  - hide    expand only when click on the sidebar toggle icon.  #  - remove  totally remove sidebar including sidebar toggle.  display: hide  # Sidebar padding in pixels.  padding: 18  # Sidebar offset from top menubar in pixels (only for Pisces | Gemini).  offset: 12# Sidebar Avataravatar:  # Replace the default image and set the url here.  url: /images/logo-_mhxcAlfred.svg  # If true, the avatar will be displayed in circle.  rounded: true  # If true, the avatar will be rotated with the cursor.  rotated: true# Posts / Categories / Tags in sidebar.site_state: true# Social Links# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.social:  #GitHub: https://github.com/mhxcAlfred || fab fa-github  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope  #Weibo: https://weibo.com/yourname || fab fa-weibo  #Twitter: https://twitter.com/yourname || fab fa-twitter  #FB Page: https://www.facebook.com/yourname || fab fa-facebook  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow  #YouTube: https://youtube.com/yourname || fab fa-youtube  #Instagram: https://instagram.com/yourname || fab fa-instagram  #Skype: skype:yourname?call|chat || fab fa-skypesocial_icons:  enable: true  icons_only: true  transition: false# Blog rollslinks_settings:  icon: fa fa-globe  # Available values: block | inline  layout: blocklinks:  #Title: https://example.com# Table of Contents in the Sidebar# Front-matter variable (nonsupport wrap expand_all).toc:  enable: true  # Automatically add list number to toc.  number: true  # If true, all words will placed on next lines if header width longer then sidebar width.  wrap: false  # If true, all level of TOC in a post will be displayed, rather than the activated part of it.  expand_all: false  # Maximum heading depth of generated toc.  max_depth: 6# ---------------------------------------------------------------# Footer Settings# See: https://theme-next.js.org/docs/theme-settings/footer# ---------------------------------------------------------------# Show multilingual switcher in footer.language_switcher: falsefooter:  # Specify the year when the site was setup. If not defined, current year will be used.  since: 2019  # Icon between year and copyright info.  icon:    # Icon name in Font Awesome. See: https://fontawesome.com/icons    name: fa fa-heart    # If you want to animate the icon, set it to true.    animated: true    # Change the color of icon, using Hex Code.    color: &quot;#ff0000&quot;  # If not defined, `author` from Hexo `_config.yml` will be used.  # Set to `false` to disable the copyright statement.  copyright:  # Powered by Hexo &amp; NexT  powered: true  # Tongji  tongji:    enable: true  # Running time  running_time:    enable: true  # Birthday  birthday:    enable: true  # Beian ICP and gongan information for Chinese users. See: https://beian.miit.gov.cn, https://beian.mps.gov.cn  beian:    enable: false    icp:    # The digit in the num of gongan beian.    gongan_id:    # The full num of gongan beian.    gongan_num:    # The icon for gongan beian. Login and See: https://beian.mps.gov.cn/web/business/businessHome/website    gongan_icon_url:# ---------------------------------------------------------------# Post Settings# See: https://theme-next.js.org/docs/theme-settings/posts# ---------------------------------------------------------------# Use `description` in front-matter to specify post excerpt.excerpt_description: true# Read more button# If true, the read more button will be displayed in excerpt section.read_more_btn: true# Post meta display settingspost_meta:  item_text: true  created_at: true  updated_at:    enable: true    another_day: true  categories: truepassage_end_tag:  enabled: true# Post wordcount display settings# Dependencies: https://github.com/next-theme/hexo-word-countersymbols_count_time:  separated_meta: true  item_text_total: false# Use icon instead of the symbol # to indicate the tag at the bottom of the posttag_icon: true# Donate (Sponsor) settings# Front-matter variable (nonsupport animation).reward_settings:  # If true, a donate button will be displayed in every article by default.  enable: false  animation: truereward:  wechatpay: /images/wechatpay.png  alipay: /images/alipay.png  #paypal: /images/paypal.png  #bitcoin: /images/bitcoin.png# Subscribe through Telegram Channel, Twitter, etc.# Usage: `Key: permalink || icon` (Font Awesome)follow_me:  #Twitter: https://twitter.com/username || fab fa-twitter  #Telegram: https://t.me/channel_name || fab fa-telegram  #WeChat: /images/wechat_channel.png || fab fa-weixin  #RSS: /atom.xml || fa fa-rss# Related popular posts# Dependencies: https://github.com/next-theme/hexo-posts-embedding# Or: https://github.com/sergeyzwezdin/hexo-related-postsrelated_posts:  enable: false  icon: fa fa-signs-post# Post edit# Easily browse and edit blog source code online.post_edit:  enable: false  url: https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name/ # Link for view source  #url: https://github.com/user-name/repo-name/edit/branch-name/subdirectory-name/ # Link for fork &amp; edit# Show previous post and next post in post footer if exists# Available values: left | right | falsepost_navigation: left# ---------------------------------------------------------------# Custom Page Settings# See: https://theme-next.js.org/docs/theme-settings/custom-pages# ---------------------------------------------------------------# TagCloud settings for tags page.tagcloud:  min: 18 # Minimum font size in px  max: 18 # Maximum font size in px  amount: 200 # Total amount of tags  orderby: name # Order of tags  order: 1 # Sort order# Google Calendar# Share your recent schedule to others via calendar page.calendar:  calendar_id: &lt;required&gt; # Your Google account E-Mail  api_key: &lt;required&gt;  orderBy: startTime  showLocation: false  offsetMax: 72 # Time Range  offsetMin: 4 # Time Range  showDeleted: false  singleEvents: true  maxResults: 250# ---------------------------------------------------------------# Misc Theme Settings# See: https://theme-next.js.org/docs/theme-settings/miscellaneous# ---------------------------------------------------------------# Preload styles and preconnect CDN for fonts and plugins.# For more information: https://www.w3.org/TR/resource-hints/#preconnectpreconnect: false# Set the text alignment in posts / pages.text_align:  # Available values: start | end | left | right | center | justify | justify-all | match-parent  desktop: justify  mobile: justify# Reduce padding / margin indents on devices with narrow width.mobile_layout_economy: false# Browser header panel color.theme_color:  light: &quot;#222&quot;  dark: &quot;#222&quot;# Override browsers&#x27; default behavior.body_scrollbar:  # Place the scrollbar over the content.  overlay: false  # Reserving space for the scrollbar gutter even if the content is not overflowing.  stable: falsecodeblock:  # Code Highlight theme  # All available themes: https://theme-next.js.org/highlight/  theme:    light: github    dark: github-dark  prism:    light: prism    dark: prism-dark  # Add copy button on codeblock  copy_button:    enable: true    # Available values: default | flat | mac    style: mac  # Fold code block  fold:    enable: true    height: 500  # Display language name  language: trueback2top:  enable: true  # Back to top in sidebar.  sidebar: true  # Scroll percent label in b2t button.  scrollpercent: true# Reading progress barreading_progress:  enable: false  # Available values: left | right  start_at: left  # Available values: top | bottom  position: top  reversed: false  color: &quot;#37c6c0&quot;  height: 3px# Bookmark Supportbookmark:  enable: false  # Customize the color of the bookmark.  color: &quot;#222&quot;  # If auto, save the reading progress when closing the page or clicking the bookmark-icon.  # If manual, only save it by clicking the bookmark-icon.  save: auto# `Follow me on GitHub` banner in the top-right corner.github_banner:  enable: true  permalink: https://github.com/mhxcAlfred# ---------------------------------------------------------------# Font Settings# ---------------------------------------------------------------# Find fonts on Google Fonts (https://fonts.google.com)# All fonts set here will have the following styles:#   light | light italic | normal | normal italic | bold | bold italic# Be aware that setting too much fonts will cause site loading slowly# ---------------------------------------------------------------# Web Safe fonts are recommended for `global` (and `title`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---------------------------------------------------------------font:  enable: true  # Uri of fonts host, e.g. https://fonts.googleapis.com (Default).  host: https://fonts.googleapis.com  # Font options:  # `external: true` will load this font family from `host` above.  # `family: Times New Roman`. Without any quotes.  # `size: x.x`. Use `em` as unit. Default: 1 (16px)  # Global font settings used for all elements inside &lt;body&gt;.  global:    external: true    family: &quot;Noto Sans SC&quot;    size:  # Font settings for site title (.site-title).  title:    external: true    family: &quot;Noto Sans SC&quot;    size:  # Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).  headings:    external: true    family: &quot;Noto Sans SC&quot;    size:  # Font settings for posts (.post-body).  posts:    external: true    family: &quot;Noto Sans SC&quot;  # Font settings for &lt;code&gt; and code blocks.  codes:    external: true    family: &quot;JetBrains Mono&quot;# ---------------------------------------------------------------# SEO Settings# See: https://theme-next.js.org/docs/theme-settings/seo# ---------------------------------------------------------------# If true, site-subtitle will be added to the title of index page.# Remember to set up your site-subtitle in Hexo `_config.yml` (e.g. subtitle: Subtitle)index_with_subtitle: false# Automatically add external URL with Base64 encrypt &amp; decrypt.exturl: false# If true, an icon will be attached to each external URLexturl_icon: true# Google Webmaster tools verification.# See: https://developers.google.com/searchgoogle_site_verification:# Bing Webmaster tools verification.# See: https://www.bing.com/webmastersbing_site_verification:# Yandex Webmaster tools verification.# See: https://webmaster.yandex.ruyandex_site_verification:# Baidu Webmaster tools verification.# See: https://ziyuan.baidu.com/sitebaidu_site_verification:# ---------------------------------------------------------------# Tags Settings# See: https://theme-next.js.org/docs/tag-plugins/# ---------------------------------------------------------------# Note tag (bootstrap callout)note:  # Note tag style values:  #  - simple    bootstrap callout old alert style. Default.  #  - modern    bootstrap callout new (v2-v3) alert style.  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.  #  - disabled  disable all CSS styles import of note tag.  style: simple  icons: false  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).  # Offset also applied to label tag variables. This option can work with disabled note tag.  light_bg_offset: 0# Tabs tagtabs:  # Make the nav bar of tabs with long content stick to the top.  sticky: false  transition:    tabs: false    labels: true# PDF tag# NexT will try to load pdf files natively, if failed, pdf.js will be used.# So, you have to install the dependency of pdf.js if you want to use pdf tag and make it available to all browsers.# Dependencies: https://github.com/next-theme/theme-next-pdfpdf:  enable: false  # Default height  height: 500px# Mermaid tagmermaid:  enable: false  # Available themes: default | dark | forest | neutral  theme:    light: default    dark: dark# WaveDrom tagwavedrom:  enable: false# ---------------------------------------------------------------# Third Party Plugins &amp; Services Settings# See: https://theme-next.js.org/docs/third-party-services/# More plugins: https://github.com/next-theme/awesome-next# ---------------------------------------------------------------# ---------------------------------------------------------------# Math Formulas Render Support# See: https://theme-next.js.org/docs/third-party-services/math-equations# Warning: Please install / uninstall the relevant renderer according to the documentation.# Server-side plugin: https://github.com/next-theme/hexo-filter-mathjax# ---------------------------------------------------------------math:  # Default (false) will load mathjax / katex script on demand.  # That is it only render those page which has `mathjax: true` in front-matter.  # If you set it to true, it will load mathjax / katex script EVERY PAGE.  every_page: true  mathjax:    enable: true    # Available values: none | ams | all    tags: none  katex:    enable: false    # See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex    copy_tex: false# ---------------------------------------------------------------# External Libraries# See: https://theme-next.js.org/docs/third-party-services/external-libraries# ---------------------------------------------------------------# Easily enable fast Ajax navigation on your website.# For more information: https://github.com/next-theme/pjaxpjax: false# FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images.# For more information: https://fancyapps.com/fancybox/fancybox: false# Medium Zoom is a JavaScript library for zooming images like Medium.# Warning: Do not enable both `fancybox` and `mediumzoom`.# For more information: https://medium-zoom.francoischalifour.commediumzoom: false# Vanilla JavaScript plugin for lazyloading images.# For more information: https://apoorv.pro/lozad.js/demo/lazyload: false# Automatically insert whitespace between CJK and half-width characters.# For more information: https://github.com/vinta/pangu.js# Server-side plugin: https://github.com/next-theme/hexo-pangupangu: false# Prefetch links based on what is in the user&#x27;s viewport.# For more information: https://getquick.link# Front-matter variable (nonsupport home archive).quicklink:  enable: false  # Home page and archive page can be controlled through home and archive options below.  # This configuration item is independent of `enable`.  home: false  archive: false  # Default (true) will initialize quicklink after the load event fires.  delay: true  # Custom a time in milliseconds by which the browser must execute prefetching.  timeout: 3000  # Default (true) will attempt to use the fetch() API if supported (rather than link[rel=prefetch]).  priority: true# ---------------------------------------------------------------# Animation Settings# ---------------------------------------------------------------# Use Animate.css to animate everything.# For more information: https://animate.stylemotion:  enable: true  async: false  duration: 200  transition:    # All available transition variants: https://theme-next.js.org/animate/    menu_item: fadeInDown    post_block: fadeIn    post_header: fadeInDown    post_body: fadeInDown    coll_header: fadeInLeft    # Only for Pisces | Gemini.    sidebar: fadeInUp# Progress bar in the top during page loading.# For more information: https://github.com/CodeByZach/pacepace:  enable: true  # All available colors:  # black | blue | green | orange | pink | purple | red | silver | white | yellow  color: blue  # All available themes:  # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple  # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal  theme: minimal# Generate a ribbon in your website with HTML5 canvas.# For more information: https://github.com/hustcc/ribbon.jscanvas_ribbon:  enable: false  size: 300 # The width of the ribbon  alpha: 0.6 # The transparency of the ribbon  zIndex: -1 # The display level of the ribbon# ---------------------------------------------------------------# Comments Settings# See: https://theme-next.js.org/docs/third-party-services/comments# More comment system plugins: https://github.com/next-theme/awesome-next/blob/main/README.md#comment# ---------------------------------------------------------------# Multiple Comment System Supportcomments:  # Available values: tabs | buttons  style: tabs  # Choose a comment system to be displayed by default.  # Available values: disqus | disqusjs | livere | gitalk | utterances | isso  active: gitalk  # Setting `true` means remembering the comment system selected by the visitor.  storage: true  # Lazyload all comment systems.  lazyload: false  # Modify texts or order for any naves, here are some examples.  nav:    #disqus:    #  text: Load Disqus    #  order: -1    #gitalk:    #  order: -2# Disqus# For more information: https://disqus.comdisqus:  enable: false  shortname:  count: true# DisqusJS# For more information: https://disqusjs.skk.moedisqusjs:  enable: false  # API Endpoint of Disqus API (https://disqus.com/api/docs/).  # Leave api empty if you are able to connect to Disqus API. Otherwise you need a reverse proxy for it.  # For example:  # api: https://disqus.skk.moe/disqus/  api:  apikey: # Register new application from https://disqus.com/api/applications/  shortname: # See: https://disqus.com/admin/settings/general/# LiveRe comments system# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: # &lt;your_uid&gt;# Gitalk# For more information: https://gitalk.github.iogitalk:  enable: true  github_id: mhxcAlfred # GitHub repo owner  repo: mhxcAlfred.github.io # Repository name to store issues  client_id:  # GitHub Application Client ID  client_secret:  # GitHub Application Client Secret  admin_user: mhxcAlfred # GitHub repo owner and collaborators, only these guys can initialize gitHub issues  distraction_free_mode: true # Facebook-like distraction free mode  # When the official proxy is not available, you can change it to your own proxy address  proxy: https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token # This is official proxy address  # Gitalk&#x27;s display language depends on user&#x27;s browser or system environment  # If you want everyone visiting your site to see a uniform language, you can set a force language value  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW  language: zh-CN  # If you want to customize the content of the initialized Issue, please edit the body parameter.  # For example:  # body: Comments for post $&#123;title&#125;, see $&#123;url&#125;  body:# Utterances# For more information: https://utteranc.esutterances:  enable: false  repo: user-name/repo-name # Github repository owner and name  # Available values: pathname | url | title | og:title  issue_term: pathname  # Available values: github-light | github-dark | preferred-color-scheme | github-dark-orange | icy-dark | dark-blue | photon-dark | boxy-light  theme: github-light# Isso# For more information: https://isso-comments.deisso: # &lt;data_isso&gt;# ---------------------------------------------------------------# Post Widgets &amp; Content Sharing Services# See: https://theme-next.js.org/docs/third-party-services/post-widgets# ---------------------------------------------------------------# AddToAny Share. See: https://www.addtoany.comaddtoany:  enable: false  # Example: bottons: [facebook, twitter]  buttons:# ---------------------------------------------------------------# Statistics and Analytics# See: https://theme-next.js.org/docs/third-party-services/statistics-and-analytics# ---------------------------------------------------------------# Google Analytics# See: https://analytics.google.comgoogle_analytics:  tracking_id: # &lt;app_id&gt;  # By default, NexT will load an external gtag.js script on your site.  # If you only need the pageview feature, set the following option to true to get a better performance.  only_pageview: false  # only needed if you are using `only_pageview` mode, https://developers.google.com/analytics/devguides/collection/protocol/ga4  measure_protocol_api_secret:# Baidu Analytics# See: https://tongji.baidu.combaidu_analytics: # &lt;app_id&gt;# Cloudflare Web Analytics# See: https://www.cloudflare.com/web-analytics/cloudflare_analytics:# Microsoft Clarity Analytics# See: https://clarity.microsoft.com/clarity_analytics: # &lt;project_id&gt;# Matomo Analytics# See: https://matomo.org/matomo:  enable: false  server_url: # https://www.example.com/  site_id: # &lt;your site id&gt;# Umami Analytics# See: https://umami.is/umami:  enable: false  script_url: # https://umami.example.com/script.js  website_id: # &lt;your website id&gt;  host_url: # &lt;your umami site url&gt;# Plausible Analytics# See: https://plausible.io/plausible:  enable: false  script_url: # https://plausible.io/js/script.js  site_domain: # www.example.com# Another tool to show number of visitors to each article.# Visit https://console.firebase.google.com/u/0/ to get apiKey and projectId.# Visit https://firebase.google.com/docs/firestore/ to get more information about firestore.firestore:  enable: false  collection: articles # Required, a string collection name to access firestore database  apiKey: # Required  projectId: # Required# Show Views / Visitors of the website / page with busuanzi.# For more information: http://ibruce.info/2015/04/04/busuanzi/busuanzi_count:  enable: true  total_visitors: true  total_visitors_icon: fa fa-user  total_views: true  total_views_icon: fa fa-eye  post_views: true  post_views_icon: far fa-eye# ---------------------------------------------------------------# Search Services# See: https://theme-next.js.org/docs/third-party-services/search-services# ---------------------------------------------------------------# Algolia Search# For more information: https://www.algolia.comalgolia_search:  enable: false  hits:    per_page: 10# Local Search# Dependencies: https://github.com/next-theme/hexo-generator-searchdblocal_search:  enable: true  # Show top n results per article, show all results by setting to -1  top_n_per_article: 1  # Unescape html strings to the readable one.  unescape: true  # Preload the search data when the page loads.  preload: true# ---------------------------------------------------------------# Chat Services# See: https://theme-next.js.org/docs/third-party-services/chat-services# ---------------------------------------------------------------# A button to open designated chat widget in sidebar.# Firstly, you need to enable and configure the chat service.chat:  enable: false  icon: fa fa-comment # Icon name in Font Awesome, set to `false` to disable icon.# Chatra is a functional, easy to use piece of chat software for websites.# For more information: https://chatra.com# Dashboard: https://app.chatra.io/settings/generalchatra:  enable: false  async: true  id: # Visit Dashboard to get your ChatraID  #embed: # Unfinished experimental feature for developers. See: https://chatra.com/help/api/#injectto# Tidio is a powerful, all-in-one customer service tool.# For more information: https://www.tidio.com# Dashboard: https://www.tidio.com/panel/dashboardtidio:  enable: false  key: # Public Key, get it from dashboard. See: https://www.tidio.com/panel/settings/developer# ---------------------------------------------------------------# CDN Settings# See: https://theme-next.js.org/docs/advanced-settings/vendors# ---------------------------------------------------------------vendors:  # The CDN provider of NexT internal scripts.  # Available values: local | jsdelivr | unpkg | cdnjs | custom  # Warning: If you are using the latest master branch of NexT, please set `internal: local`  internal: local  # The default CDN provider of third-party plugins.  # Available values: local | jsdelivr | unpkg | cdnjs | custom  # Dependencies for `plugins: local`: https://github.com/next-theme/plugins  plugins: cdnjs  # Custom CDN URL  # For example:  # custom_cdn_url: https://cdn.jsdelivr.net/npm/$&#123;npm_name&#125;@$&#123;version&#125;/$&#123;minified&#125;  # custom_cdn_url: https://cdnjs.cloudflare.com/ajax/libs/$&#123;cdnjs_name&#125;/$&#123;version&#125;/$&#123;cdnjs_file&#125;  custom_cdn_url:# Assets# Accelerate delivery of static files using a CDN# The js option is only valid when vendors.internal is local.css: cssjs: jsimages: images\n\n文章终止在D:\\Hexo\\themes\\next\\layout\\_macro目录下新建passage-end-tag.njk\n&lt;div&gt;    &#123;% if not is_index %&#125;        &lt;div style=&quot;text-align:center;color: #ccc;font-size:36px;&quot;&gt;本文结束&lt;/div&gt;        &lt;div style=&quot;text-align:center;color: #ccc;font-size:36px;&quot;&gt;&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;    &lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;    &lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;&lt;/div&gt;        &lt;div style=&quot;text-align:center;color: #ccc;font-size:36px;&quot;&gt;感谢您的阅读&lt;/i&gt;&lt;/div&gt;    &#123;% endif %&#125;&lt;/div&gt;\n\n在D:\\Hexo\\themes\\next\\layout\\_macro目录下找到post.njk\n&#123;##### 修改前 #####&#125;&#123;##################&#125;&#123;### POST BLOCK ###&#125;&#123;##################&#125;&lt;div class=&quot;post-block&quot;&gt;  &#123;# Gallery support #&#125;  &#123;&#123; post_gallery(post.photos) &#125;&#125;  &lt;article itemscope itemtype=&quot;http://schema.org/Article&quot; class=&quot;post-content&quot; lang=&quot;&#123;&#123; post.lang &#125;&#125;&quot;&gt;    &lt;link itemprop=&quot;mainEntityOfPage&quot; href=&quot;&#123;&#123; post.permalink &#125;&#125;&quot;&gt;    &lt;span hidden itemprop=&quot;author&quot; itemscope itemtype=&quot;http://schema.org/Person&quot;&gt;      &lt;meta itemprop=&quot;image&quot; content=&quot;&#123;&#123; url_for(theme.avatar.url or theme.images + &#x27;/avatar.gif&#x27;) &#125;&#125;&quot;&gt;      &lt;meta itemprop=&quot;name&quot; content=&quot;&#123;&#123; author &#125;&#125;&quot;&gt;    &lt;/span&gt;    &lt;span hidden itemprop=&quot;publisher&quot; itemscope itemtype=&quot;http://schema.org/Organization&quot;&gt;      &lt;meta itemprop=&quot;name&quot; content=&quot;&#123;&#123; title &#125;&#125;&quot;&gt;      &lt;meta itemprop=&quot;description&quot; content=&quot;&#123;&#123; description &#125;&#125;&quot;&gt;    &lt;/span&gt;    &lt;span hidden itemprop=&quot;post&quot; itemscope itemtype=&quot;http://schema.org/CreativeWork&quot;&gt;      &lt;meta itemprop=&quot;name&quot; content=&quot;&#123;&#123; escape_html(page.title or &#x27;&#x27;) + &#x27; | &#x27; + title &#125;&#125;&quot;&gt;      &lt;meta itemprop=&quot;description&quot; content=&quot;&#123;&#123; escape_html(page.description or &#x27;&#x27;) &#125;&#125;&quot;&gt;    &lt;/span&gt;    &#123;%- if post.header !== false %&#125;      &lt;header class=&quot;post-header&quot;&gt;        &lt;&#123;% if is_index %&#125;h2&#123;% else %&#125;h1&#123;% endif %&#125; class=&quot;post-title&#123;% if post.direction and post.direction.toLowerCase() === &#x27;rtl&#x27; %&#125; rtl&#123;% endif %&#125;&quot; itemprop=&quot;name headline&quot;&gt;          &#123;# Link posts #&#125;          &#123;%- if post.link %&#125;            &#123;%- if post.sticky &gt; 0 %&#125;              &lt;span class=&quot;post-sticky-flag&quot; title=&quot;&#123;&#123; __(&#x27;post.sticky&#x27;) &#125;&#125;&quot;&gt;                &lt;i class=&quot;fa fa-thumbtack&quot;&gt;&lt;/i&gt;              &lt;/span&gt;            &#123;%- endif %&#125;            &#123;%- set postTitleIcon = &#x27;&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&#x27; %&#125;            &#123;%- set postText = post.title or post.link %&#125;            &#123;&#123;- next_url(post.link, postText + postTitleIcon, &#123;class: &#x27;post-title-link post-title-link-external&#x27;, itemprop: &#x27;url&#x27;&#125;) &#125;&#125;          &#123;% elif is_index %&#125;            &#123;%- if post.sticky &gt; 0 %&#125;              &lt;span class=&quot;post-sticky-flag&quot; title=&quot;&#123;&#123; __(&#x27;post.sticky&#x27;) &#125;&#125;&quot;&gt;                &lt;i class=&quot;fa fa-thumbtack&quot;&gt;&lt;/i&gt;              &lt;/span&gt;            &#123;%- endif %&#125;            &#123;&#123;- next_url(post.path, post.title or __(&#x27;post.untitled&#x27;), &#123;class: &#x27;post-title-link&#x27;, itemprop: &#x27;url&#x27;&#125;) &#125;&#125;          &#123;%- else %&#125;            &#123;&#123;- post.title &#125;&#125;            &#123;&#123;- post_edit(post.source) &#125;&#125;          &#123;%- endif %&#125;        &lt;/&#123;% if is_index %&#125;h2&#123;% else %&#125;h1&#123;% endif %&#125;&gt;        &lt;div class=&quot;post-meta-container&quot;&gt;          &#123;&#123; partial(&#x27;_partials/post/post-meta.njk&#x27;) &#125;&#125;          &#123;%- if post.description and (not theme.excerpt_description or not is_index) %&#125;            &lt;div class=&quot;post-description&quot;&gt;&#123;&#123; post.description &#125;&#125;&lt;/div&gt;          &#123;%- endif %&#125;        &lt;/div&gt;      &lt;/header&gt;    &#123;%- endif %&#125;    &#123;#################&#125;    &#123;### POST BODY ###&#125;    &#123;#################&#125;    &lt;div class=&quot;post-body&#123;% if post.direction and post.direction.toLowerCase() === &#x27;rtl&#x27; %&#125; rtl&#123;% endif %&#125;&quot; itemprop=&quot;articleBody&quot;&gt;      &#123;%- if is_index %&#125;        &#123;%- if post.description and theme.excerpt_description %&#125;          &lt;p&gt;&#123;&#123; post.description &#125;&#125;&lt;/p&gt;          &lt;!--noindex--&gt;          &#123;%- if theme.read_more_btn %&#125;            &lt;div class=&quot;post-button&quot;&gt;              &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt;                &#123;&#123; __(&#x27;post.read_more&#x27;) &#125;&#125; &amp;raquo;              &lt;/a&gt;            &lt;/div&gt;          &#123;%- endif %&#125;          &lt;!--/noindex--&gt;        &#123;% elif post.excerpt %&#125;          &#123;&#123; post.excerpt &#125;&#125;          &lt;!--noindex--&gt;          &#123;%- if theme.read_more_btn %&#125;            &lt;div class=&quot;post-button&quot;&gt;              &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;#more&quot; rel=&quot;contents&quot;&gt;                &#123;&#123; __(&#x27;post.read_more&#x27;) &#125;&#125; &amp;raquo;              &lt;/a&gt;            &lt;/div&gt;          &#123;%- endif %&#125;          &lt;!--/noindex--&gt;        &#123;% else %&#125;          &#123;&#123; post.content &#125;&#125;        &#123;%- endif %&#125;      &#123;% else %&#125;        &#123;&#123;- next_inject(&#x27;postBodyStart&#x27;) &#125;&#125;        &#123;&#123;- post.content &#125;&#125;      &#123;%- endif %&#125;    &lt;/div&gt;    &#123;#####################&#125;    &#123;### END POST BODY ###&#125;    &#123;#####################&#125;    &lt;footer class=&quot;post-footer&quot;&gt;      &#123;%- if is_index %&#125;        &lt;div class=&quot;post-eof&quot;&gt;&lt;/div&gt;      &#123;% else %&#125;        &#123;&#123;- next_inject(&#x27;postBodyEnd&#x27;) &#125;&#125;        &#123;%- if post.reward_settings.enable %&#125;          &#123;&#123; partial(&#x27;_partials/post/post-reward.njk&#x27;) &#125;&#125;        &#123;%- endif %&#125;        &#123;%- if theme.creative_commons.license and theme.creative_commons.post and post.copyright !== false %&#125;          &#123;&#123; partial(&#x27;_partials/post/post-copyright.njk&#x27;) &#125;&#125;        &#123;%- endif %&#125;        &#123;%- if theme.follow_me %&#125;          &#123;&#123; partial(&#x27;_partials/post/post-followme.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;        &#123;%- endif %&#125;        &#123;%- if post.tags and post.tags.length %&#125;          &#123;%- set tag_indicate = &#x27;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;&#x27; if theme.tag_icon else &#x27;#&#x27; %&#125;          &lt;div class=&quot;post-tags&quot;&gt;            &#123;%- for tag in post.tags.toArray() %&#125;              &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;&#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;            &#123;%- endfor %&#125;          &lt;/div&gt;        &#123;%- endif %&#125;        &#123;&#123; partial(&#x27;_partials/post/post-share.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;        &#123;%- if theme.post_navigation and (post.prev or post.next) %&#125;          &#123;%- set prev = post.prev if theme.post_navigation === &#x27;right&#x27; else post.next %&#125;          &#123;%- set next = post.next if theme.post_navigation === &#x27;right&#x27; else post.prev %&#125;          &lt;div class=&quot;post-nav&quot;&gt;            &lt;div class=&quot;post-nav-item&quot;&gt;              &#123;%- if prev %&#125;                &lt;a href=&quot;&#123;&#123; url_for(prev.path) &#125;&#125;&quot; rel=&quot;prev&quot; title=&quot;&#123;&#123; escape_html(prev.title or &#x27;&#x27;) &#125;&#125;&quot;&gt;                  &lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;/i&gt; &#123;&#123; prev.title &#125;&#125;                &lt;/a&gt;              &#123;%- endif %&#125;            &lt;/div&gt;            &lt;div class=&quot;post-nav-item&quot;&gt;              &#123;%- if next %&#125;                &lt;a href=&quot;&#123;&#123; url_for(next.path) &#125;&#125;&quot; rel=&quot;next&quot; title=&quot;&#123;&#123; escape_html(next.title or &#x27;&#x27;) &#125;&#125;&quot;&gt;                  &#123;&#123; next.title &#125;&#125; &lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;                &lt;/a&gt;              &#123;%- endif %&#125;            &lt;/div&gt;          &lt;/div&gt;        &#123;%- endif %&#125;      &#123;%- endif %&#125;    &lt;/footer&gt;  &lt;/article&gt;&lt;/div&gt;&#123;######################&#125;&#123;### END POST BLOCK ###&#125;&#123;######################&#125;\n\n&#123;##### 修改后 #####&#125;&#123;##################&#125;&#123;### POST BLOCK ###&#125;&#123;##################&#125;&lt;div class=&quot;post-block&quot;&gt;  &#123;# Gallery support #&#125;  &#123;&#123; post_gallery(post.photos) &#125;&#125;  &lt;article itemscope itemtype=&quot;http://schema.org/Article&quot; class=&quot;post-content&quot; lang=&quot;&#123;&#123; post.lang &#125;&#125;&quot;&gt;    &lt;link itemprop=&quot;mainEntityOfPage&quot; href=&quot;&#123;&#123; post.permalink &#125;&#125;&quot;&gt;    &lt;span hidden itemprop=&quot;author&quot; itemscope itemtype=&quot;http://schema.org/Person&quot;&gt;      &lt;meta itemprop=&quot;image&quot; content=&quot;&#123;&#123; url_for(theme.avatar.url or theme.images + &#x27;/avatar.gif&#x27;) &#125;&#125;&quot;&gt;      &lt;meta itemprop=&quot;name&quot; content=&quot;&#123;&#123; author &#125;&#125;&quot;&gt;    &lt;/span&gt;    &lt;span hidden itemprop=&quot;publisher&quot; itemscope itemtype=&quot;http://schema.org/Organization&quot;&gt;      &lt;meta itemprop=&quot;name&quot; content=&quot;&#123;&#123; title &#125;&#125;&quot;&gt;      &lt;meta itemprop=&quot;description&quot; content=&quot;&#123;&#123; description &#125;&#125;&quot;&gt;    &lt;/span&gt;    &lt;span hidden itemprop=&quot;post&quot; itemscope itemtype=&quot;http://schema.org/CreativeWork&quot;&gt;      &lt;meta itemprop=&quot;name&quot; content=&quot;&#123;&#123; escape_html(page.title or &#x27;&#x27;) + &#x27; | &#x27; + title &#125;&#125;&quot;&gt;      &lt;meta itemprop=&quot;description&quot; content=&quot;&#123;&#123; escape_html(page.description or &#x27;&#x27;) &#125;&#125;&quot;&gt;    &lt;/span&gt;    &#123;%- if post.header !== false %&#125;      &lt;header class=&quot;post-header&quot;&gt;        &lt;&#123;% if is_index %&#125;h2&#123;% else %&#125;h1&#123;% endif %&#125; class=&quot;post-title&#123;% if post.direction and post.direction.toLowerCase() === &#x27;rtl&#x27; %&#125; rtl&#123;% endif %&#125;&quot; itemprop=&quot;name headline&quot;&gt;          &#123;# Link posts #&#125;          &#123;%- if post.link %&#125;            &#123;%- if post.sticky &gt; 0 %&#125;              &lt;span class=&quot;post-sticky-flag&quot; title=&quot;&#123;&#123; __(&#x27;post.sticky&#x27;) &#125;&#125;&quot;&gt;                &lt;i class=&quot;fa fa-thumbtack&quot;&gt;&lt;/i&gt;              &lt;/span&gt;            &#123;%- endif %&#125;            &#123;%- set postTitleIcon = &#x27;&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&#x27; %&#125;            &#123;%- set postText = post.title or post.link %&#125;            &#123;&#123;- next_url(post.link, postText + postTitleIcon, &#123;class: &#x27;post-title-link post-title-link-external&#x27;, itemprop: &#x27;url&#x27;&#125;) &#125;&#125;          &#123;% elif is_index %&#125;            &#123;%- if post.sticky &gt; 0 %&#125;              &lt;span class=&quot;post-sticky-flag&quot; title=&quot;&#123;&#123; __(&#x27;post.sticky&#x27;) &#125;&#125;&quot;&gt;                &lt;i class=&quot;fa fa-thumbtack&quot;&gt;&lt;/i&gt;              &lt;/span&gt;            &#123;%- endif %&#125;            &#123;&#123;- next_url(post.path, post.title or __(&#x27;post.untitled&#x27;), &#123;class: &#x27;post-title-link&#x27;, itemprop: &#x27;url&#x27;&#125;) &#125;&#125;          &#123;%- else %&#125;            &#123;&#123;- post.title &#125;&#125;            &#123;&#123;- post_edit(post.source) &#125;&#125;          &#123;%- endif %&#125;        &lt;/&#123;% if is_index %&#125;h2&#123;% else %&#125;h1&#123;% endif %&#125;&gt;        &lt;div class=&quot;post-meta-container&quot;&gt;          &#123;&#123; partial(&#x27;_partials/post/post-meta.njk&#x27;) &#125;&#125;          &#123;%- if post.description and (not theme.excerpt_description or not is_index) %&#125;            &lt;div class=&quot;post-description&quot;&gt;&#123;&#123; post.description &#125;&#125;&lt;/div&gt;          &#123;%- endif %&#125;        &lt;/div&gt;      &lt;/header&gt;    &#123;%- endif %&#125;    &#123;#################&#125;    &#123;### POST BODY ###&#125;    &#123;#################&#125;    &lt;div class=&quot;post-body&#123;% if post.direction and post.direction.toLowerCase() === &#x27;rtl&#x27; %&#125; rtl&#123;% endif %&#125;&quot; itemprop=&quot;articleBody&quot;&gt;      &#123;%- if is_index %&#125;        &#123;%- if post.description and theme.excerpt_description %&#125;          &lt;p&gt;&#123;&#123; post.description &#125;&#125;&lt;/p&gt;          &lt;!--noindex--&gt;          &#123;%- if theme.read_more_btn %&#125;            &lt;div class=&quot;post-button&quot;&gt;              &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt;                &#123;&#123; __(&#x27;post.read_more&#x27;) &#125;&#125; &amp;raquo;              &lt;/a&gt;            &lt;/div&gt;          &#123;%- endif %&#125;          &lt;!--/noindex--&gt;        &#123;% elif post.excerpt %&#125;          &#123;&#123; post.excerpt &#125;&#125;          &lt;!--noindex--&gt;          &#123;%- if theme.read_more_btn %&#125;            &lt;div class=&quot;post-button&quot;&gt;              &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;#more&quot; rel=&quot;contents&quot;&gt;                &#123;&#123; __(&#x27;post.read_more&#x27;) &#125;&#125; &amp;raquo;              &lt;/a&gt;            &lt;/div&gt;          &#123;%- endif %&#125;          &lt;!--/noindex--&gt;        &#123;% else %&#125;          &#123;&#123; post.content &#125;&#125;        &#123;%- endif %&#125;      &#123;% else %&#125;        &#123;&#123;- next_inject(&#x27;postBodyStart&#x27;) &#125;&#125;        &#123;&#123;- post.content &#125;&#125;      &#123;%- endif %&#125;    &lt;/div&gt;    &#123;%- if not is_index %&#125;       \t&#123;% include &#x27;passage-end-tag.njk&#x27; %&#125;    &#123;%- endif %&#125;    &#123;#####################&#125;    &#123;### END POST BODY ###&#125;    &#123;#####################&#125;    &lt;footer class=&quot;post-footer&quot;&gt;      &#123;%- if is_index %&#125;        &lt;div class=&quot;post-eof&quot;&gt;&lt;/div&gt;      &#123;% else %&#125;        &#123;&#123;- next_inject(&#x27;postBodyEnd&#x27;) &#125;&#125;        &#123;%- if post.reward_settings.enable %&#125;          &#123;&#123; partial(&#x27;_partials/post/post-reward.njk&#x27;) &#125;&#125;        &#123;%- endif %&#125;        &#123;%- if theme.creative_commons.license and theme.creative_commons.post and post.copyright !== false %&#125;          &#123;&#123; partial(&#x27;_partials/post/post-copyright.njk&#x27;) &#125;&#125;        &#123;%- endif %&#125;        &#123;%- if theme.follow_me %&#125;          &#123;&#123; partial(&#x27;_partials/post/post-followme.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;        &#123;%- endif %&#125;        &#123;%- if post.tags and post.tags.length %&#125;          &#123;%- set tag_indicate = &#x27;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;&#x27; if theme.tag_icon else &#x27;#&#x27; %&#125;          &lt;div class=&quot;post-tags&quot;&gt;            &#123;%- for tag in post.tags.toArray() %&#125;              &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;&#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;            &#123;%- endfor %&#125;          &lt;/div&gt;        &#123;%- endif %&#125;        &#123;&#123; partial(&#x27;_partials/post/post-share.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;        &#123;%- if theme.post_navigation and (post.prev or post.next) %&#125;          &#123;%- set prev = post.prev if theme.post_navigation === &#x27;right&#x27; else post.next %&#125;          &#123;%- set next = post.next if theme.post_navigation === &#x27;right&#x27; else post.prev %&#125;          &lt;div class=&quot;post-nav&quot;&gt;            &lt;div class=&quot;post-nav-item&quot;&gt;              &#123;%- if prev %&#125;                &lt;a href=&quot;&#123;&#123; url_for(prev.path) &#125;&#125;&quot; rel=&quot;prev&quot; title=&quot;&#123;&#123; escape_html(prev.title or &#x27;&#x27;) &#125;&#125;&quot;&gt;                  &lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;/i&gt; &#123;&#123; prev.title &#125;&#125;                &lt;/a&gt;              &#123;%- endif %&#125;            &lt;/div&gt;            &lt;div class=&quot;post-nav-item&quot;&gt;              &#123;%- if next %&#125;                &lt;a href=&quot;&#123;&#123; url_for(next.path) &#125;&#125;&quot; rel=&quot;next&quot; title=&quot;&#123;&#123; escape_html(next.title or &#x27;&#x27;) &#125;&#125;&quot;&gt;                  &#123;&#123; next.title &#125;&#125; &lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;                &lt;/a&gt;              &#123;%- endif %&#125;            &lt;/div&gt;          &lt;/div&gt;        &#123;%- endif %&#125;      &#123;%- endif %&#125;    &lt;/footer&gt;  &lt;/article&gt;&lt;/div&gt;&#123;######################&#125;&#123;### END POST BLOCK ###&#125;&#123;######################&#125;\n\n修改网页统计在D:\\Hexo\\themes\\next\\layout\\_partials目录下找到footer.njk\n&#123;##### 修改前 #####&#125;&#123;%- if theme.footer.beian.enable %&#125;  &lt;div class=&quot;beian&quot;&gt;    &#123;&#123;- next_url(&#x27;https://beian.miit.gov.cn&#x27;, theme.footer.beian.icp + &#x27; &#x27;) &#125;&#125;    &#123;%- if theme.footer.beian.gongan_icon_url %&#125;      &lt;img src=&quot;&#123;&#123; url_for(theme.footer.beian.gongan_icon_url) &#125;&#125;&quot; alt=&quot;&quot;&gt;    &#123;%- endif %&#125;    &#123;%- if theme.footer.beian.gongan_id and theme.footer.beian.gongan_num %&#125;      &#123;&#123;- next_url(&#x27;https://beian.mps.gov.cn/#/query/webSearch?code=&#x27; + theme.footer.beian.gongan_id, theme.footer.beian.gongan_num + &#x27; &#x27;) &#125;&#125;    &#123;%- endif %&#125;  &lt;/div&gt;&#123;%- endif %&#125;&#123;%- if theme.footer.copyright !== false %&#125;  &lt;div class=&quot;copyright&quot;&gt;    &#123;%- set copyright_year = date(null, &#x27;YYYY&#x27;) %&#125;    &amp;copy; &#123;% if theme.footer.since and theme.footer.since != copyright_year %&#125;&#123;&#123; theme.footer.since &#125;&#125; – &#123;% endif %&#125;    &lt;span itemprop=&quot;copyrightYear&quot;&gt;&#123;&#123; copyright_year &#125;&#125;&lt;/span&gt;    &lt;span class=&quot;with-love&quot;&gt;      &lt;i class=&quot;&#123;&#123; theme.footer.icon.name &#125;&#125;&quot;&gt;&lt;/i&gt;    &lt;/span&gt;    &lt;span class=&quot;author&quot; itemprop=&quot;copyrightHolder&quot;&gt;&#123;&#123; theme.footer.copyright or author &#125;&#125;&lt;/span&gt;  &lt;/div&gt;&#123;%- endif %&#125;&#123;%- if config.symbols_count_time.total_symbols or config.symbols_count_time.total_time %&#125;&lt;div class=&quot;wordcount&quot;&gt;  &#123;%- if config.symbols_count_time.total_symbols %&#125;  &lt;span class=&quot;post-meta-item&quot;&gt;    &lt;span class=&quot;post-meta-item-icon&quot;&gt;      &lt;i class=&quot;fa fa-chart-line&quot;&gt;&lt;/i&gt;    &lt;/span&gt;    &#123;%- if theme.symbols_count_time.item_text_total %&#125;      &lt;span&gt;&#123;&#123; __(&#x27;symbols_count_time.count_total&#x27;) + __(&#x27;symbol.colon&#x27;) &#125;&#125;&lt;/span&gt;    &#123;%- endif %&#125;    &lt;span title=&quot;&#123;&#123; __(&#x27;symbols_count_time.count_total&#x27;) &#125;&#125;&quot;&gt;&#123;&#123; symbolsCountTotal(site) &#125;&#125;&lt;/span&gt;  &lt;/span&gt;  &#123;%- endif %&#125;  &#123;%- if config.symbols_count_time.total_time %&#125;  &lt;span class=&quot;post-meta-item&quot;&gt;    &lt;span class=&quot;post-meta-item-icon&quot;&gt;      &lt;i class=&quot;fa fa-coffee&quot;&gt;&lt;/i&gt;    &lt;/span&gt;    &#123;%- if theme.symbols_count_time.item_text_total %&#125;      &lt;span&gt;&#123;&#123; __(&#x27;symbols_count_time.time_total&#x27;) &#125;&#125; &amp;asymp;&lt;/span&gt;    &#123;%- endif %&#125;    &lt;span title=&quot;&#123;&#123; __(&#x27;symbols_count_time.time_total&#x27;) &#125;&#125;&quot;&gt;&#123;&#123; symbolsTimeTotal(site, config.symbols_count_time.awl, config.symbols_count_time.wpm, __(&#x27;symbols_count_time.time_minutes&#x27;)) &#125;&#125;&lt;/span&gt;  &lt;/span&gt;  &#123;%- endif %&#125;&lt;/div&gt;&#123;%- endif %&#125;&#123;%- if theme.busuanzi_count.enable %&#125;&lt;div class=&quot;busuanzi-count&quot;&gt;  &#123;%- if theme.busuanzi_count.total_visitors %&#125;    &lt;span class=&quot;post-meta-item&quot; id=&quot;busuanzi_container_site_uv&quot;&gt;      &lt;span class=&quot;post-meta-item-icon&quot;&gt;        &lt;i class=&quot;&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;&gt;&lt;/i&gt;      &lt;/span&gt;      &lt;span class=&quot;site-uv&quot; title=&quot;&#123;&#123; __(&#x27;footer.total_visitors&#x27;) &#125;&#125;&quot;&gt;        &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;      &lt;/span&gt;    &lt;/span&gt;  &#123;%- endif %&#125;  &#123;%- if theme.busuanzi_count.total_views %&#125;    &lt;span class=&quot;post-meta-item&quot; id=&quot;busuanzi_container_site_pv&quot;&gt;      &lt;span class=&quot;post-meta-item-icon&quot;&gt;        &lt;i class=&quot;&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;&quot;&gt;&lt;/i&gt;      &lt;/span&gt;      &lt;span class=&quot;site-pv&quot; title=&quot;&#123;&#123; __(&#x27;footer.total_views&#x27;) &#125;&#125;&quot;&gt;        &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;      &lt;/span&gt;    &lt;/span&gt;  &#123;%- endif %&#125;&lt;/div&gt;&#123;%- endif %&#125;&#123;%- if theme.footer.powered %&#125;  &lt;div class=&quot;powered-by&quot;&gt;    &#123;%- set next_site = &#x27;https://theme-next.js.org&#x27; if theme.scheme === &#x27;Gemini&#x27; else &#x27;https://theme-next.js.org/&#x27; + theme.scheme | lower + &#x27;/&#x27; %&#125;    &#123;&#123;- __(&#x27;footer.powered&#x27;, next_url(&#x27;https://hexo.io&#x27;, &#x27;Hexo&#x27;) + &#x27; &amp; &#x27; + next_url(next_site, &#x27;NexT.&#x27; + theme.scheme)) &#125;&#125;  &lt;/div&gt;&#123;%- endif %&#125;&#123;&#123;- next_inject(&#x27;footer&#x27;) &#125;&#125;\n\n&#123;##### 修改后 #####&#125;&#123;%- if theme.footer.beian.enable %&#125;  &lt;div class=&quot;beian&quot;&gt;    &#123;&#123;- next_url(&#x27;https://beian.miit.gov.cn&#x27;, theme.footer.beian.icp + &#x27; &#x27;) &#125;&#125;    &#123;%- if theme.footer.beian.gongan_icon_url %&#125;      &lt;img src=&quot;&#123;&#123; url_for(theme.footer.beian.gongan_icon_url) &#125;&#125;&quot; alt=&quot;&quot;&gt;    &#123;%- endif %&#125;    &#123;%- if theme.footer.beian.gongan_id and theme.footer.beian.gongan_num %&#125;      &#123;&#123;- next_url(&#x27;https://beian.mps.gov.cn/#/query/webSearch?code=&#x27; + theme.footer.beian.gongan_id, theme.footer.beian.gongan_num + &#x27; &#x27;) &#125;&#125;    &#123;%- endif %&#125;  &lt;/div&gt;&#123;%- endif %&#125;&#123;%- if theme.footer.copyright !== false %&#125;  &lt;div class=&quot;copyright&quot;&gt;    &#123;%- set copyright_year = date(null, &#x27;YYYY&#x27;) %&#125;    &amp;copy; &#123;% if theme.footer.since and theme.footer.since != copyright_year %&#125;&#123;&#123; theme.footer.since &#125;&#125; – &#123;% endif %&#125;    &lt;span itemprop=&quot;copyrightYear&quot;&gt;&#123;&#123; copyright_year &#125;&#125;&lt;/span&gt;    &lt;span class=&quot;with-love&quot;&gt;      &lt;i class=&quot;&#123;&#123; theme.footer.icon.name &#125;&#125;&quot;&gt;&lt;/i&gt;    &lt;/span&gt;    &lt;span class=&quot;author&quot; itemprop=&quot;copyrightHolder&quot;&gt;&#123;&#123; theme.footer.copyright or author &#125;&#125;&lt;/span&gt;  &lt;/div&gt;&#123;%- endif %&#125;&#123;%- if theme.footer.powered %&#125;  &lt;div class=&quot;powered-by&quot;&gt;    &lt;a href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;    &lt;span class=&quot;post-meta-item&quot;&gt;&lt;/span&gt;    &lt;a href=&quot;https://theme-next.js.org/muse/&quot;&gt;NexT&lt;/a&gt;    &lt;span class=&quot;post-meta-item&quot;&gt;&lt;/span&gt;    &lt;a href=&quot;https://github.com/gitalk/gitalk&quot;&gt;Gitalk&lt;/a&gt;  &lt;/div&gt;&#123;%- endif %&#125;&#123;%- if theme.footer.tongji.enable %&#125;  &lt;div&gt;    &lt;span class=&quot;post-meta-item&quot;&gt;      &lt;span&gt;全站共 &lt;/span&gt;        &lt;span class=&quot;post-count&quot;&gt; &#123;&#123; totalcount(site) &#125;&#125; &lt;/span&gt;      &lt;span&gt; 字&lt;/span&gt;    &lt;/span&gt;  &lt;/div&gt;  &lt;div&gt;    &#123;%- if theme.busuanzi_count.total_visitors %&#125;      &lt;span class=&quot;post-meta-item&quot; id=&quot;busuanzi_container_site_uv&quot;&gt;        &lt;span&gt;承蒙 &lt;/span&gt;        &lt;span class=&quot;site-uv&quot; title=&quot;&#123;&#123; __(&#x27;footer.total_visitors&#x27;) &#125;&#125;&quot;&gt;          &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;        &lt;/span&gt;        &lt;span&gt; 位朋友&lt;/span&gt;      &lt;/span&gt;    &#123;%- endif %&#125;  &lt;/div&gt;  &lt;div&gt;    &#123;%- if theme.busuanzi_count.total_views %&#125;      &lt;span class=&quot;post-meta-item&quot; id=&quot;busuanzi_container_site_pv&quot;&gt;        &lt;span&gt;造访 &lt;/span&gt;        &lt;span class=&quot;site-pv&quot; title=&quot;&#123;&#123; __(&#x27;footer.total_views&#x27;) &#125;&#125;&quot;&gt;          &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;        &lt;/span&gt;        &lt;span&gt; 次&lt;/span&gt;      &lt;/span&gt;    &#123;%- endif %&#125;  &lt;/div&gt;&#123;%- endif %&#125;&#123;%- if theme.footer.running_time.enable and theme.footer.birthday.enable %&#125;  &lt;div&gt;    &lt;span class=&quot;post-meta-item&quot;&gt;      &lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;      &lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;      &lt;script src=&quot;/js/runningtime.js&quot;&gt;&lt;/script&gt;    &lt;/span&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;span class=&quot;post-meta-item&quot;&gt;      &lt;a href=&quot;/anniversary/&quot;&gt;        &lt;span id=&quot;btimeDate&quot;&gt;载入天数...&lt;/span&gt;        &lt;span id=&quot;btimes&quot;&gt;载入时分秒...&lt;/span&gt;        &lt;script src=&quot;/js/birthday.js&quot;&gt;&lt;/script&gt;      &lt;/a&gt;    &lt;/span&gt;  &lt;/div&gt;&#123;%- endif %&#125;&#123;&#123;- next_inject(&#x27;footer&#x27;) &#125;&#125;\n\n修改鼠标点击动画和动态背景在D:\\Hexo\\themes\\next\\layout目录下找到_layout.njk\n&#123;##### 修改前 #####&#125;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&#123;&#123; page.lang &#125;&#125;&quot;&gt;&lt;head&gt;  &#123;&#123; partial(&#x27;_partials/head/head.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;%- include &#x27;_partials/head/head-unique.njk&#x27; -%&#125;  &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;  &#123;&#123; partial(&#x27;_third-party/analytics/index.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;&#123; partial(&#x27;_scripts/index.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;&#123; partial(&#x27;_third-party/index.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;&#123; partial(&#x27;_third-party/statistics/index.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;%- include &#x27;_third-party/math/index.njk&#x27; -%&#125;  &#123;%- include &#x27;_third-party/quicklink.njk&#x27; -%&#125;  &#123;&#123;- next_inject(&#x27;head&#x27;) &#125;&#125;  &lt;noscript&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; url_for(theme.css) &#125;&#125;/noscript.css&quot;&gt;  &lt;/noscript&gt;&lt;/head&gt;&lt;body itemscope itemtype=&quot;http://schema.org/WebPage&quot;&#123;% if theme.motion.enable %&#125; class=&quot;use-motion&quot;&#123;% endif %&#125;&gt;  &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;  &lt;main class=&quot;main&quot;&gt;    &lt;div class=&quot;column&quot;&gt;      &lt;header class=&quot;header&quot; itemscope itemtype=&quot;http://schema.org/WPHeader&quot;&gt;        &#123;%- include &#x27;_partials/header/index.njk&#x27; -%&#125;      &lt;/header&gt;      &#123;%- if theme.sidebar.display !== &#x27;remove&#x27; %&#125;        &#123;% block sidebar %&#125;&#123;% endblock %&#125;      &#123;%- endif %&#125;    &lt;/div&gt;    &lt;div class=&quot;main-inner &#123;% block class %&#125;&#123;% endblock %&#125;&quot;&gt;      &#123;%- include &#x27;_partials/header/sub-menu.njk&#x27; -%&#125;      &#123;% block content %&#125;&#123;% endblock %&#125;      &#123;%- include &#x27;_partials/comments.njk&#x27; -%&#125;    &lt;/div&gt;  &lt;/main&gt;  &lt;footer class=&quot;footer&quot;&gt;    &lt;div class=&quot;footer-inner&quot;&gt;      &#123;%- include &#x27;_partials/languages.njk&#x27; -%&#125;      &#123;&#123; partial(&#x27;_partials/footer.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;    &lt;/div&gt;  &lt;/footer&gt;  &#123;&#123; partial(&#x27;_partials/widgets.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;&#123;- next_inject(&#x27;bodyEnd&#x27;) &#125;&#125;&lt;/body&gt;&lt;/html&gt;\n\n&#123;##### 修改后 #####&#125;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&#123;&#123; page.lang &#125;&#125;&quot;&gt;&lt;head&gt;  &#123;&#123; partial(&#x27;_partials/head/head.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;%- include &#x27;_partials/head/head-unique.njk&#x27; -%&#125;  &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;  &#123;&#123; partial(&#x27;_third-party/analytics/index.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;&#123; partial(&#x27;_scripts/index.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;&#123; partial(&#x27;_third-party/index.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;&#123; partial(&#x27;_third-party/statistics/index.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;%- include &#x27;_third-party/math/index.njk&#x27; -%&#125;  &#123;%- include &#x27;_third-party/quicklink.njk&#x27; -%&#125;  &#123;&#123;- next_inject(&#x27;head&#x27;) &#125;&#125;  &lt;noscript&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; url_for(theme.css) &#125;&#125;/noscript.css&quot;&gt;  &lt;/noscript&gt;&lt;/head&gt;&lt;body itemscope itemtype=&quot;http://schema.org/WebPage&quot;&#123;% if theme.motion.enable %&#125; class=&quot;use-motion&quot;&#123;% endif %&#125;&gt;  &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;  &lt;main class=&quot;main&quot;&gt;    &lt;div class=&quot;column&quot;&gt;      &lt;header class=&quot;header&quot; itemscope itemtype=&quot;http://schema.org/WPHeader&quot;&gt;        &#123;%- include &#x27;_partials/header/index.njk&#x27; -%&#125;      &lt;/header&gt;      &#123;%- if theme.sidebar.display !== &#x27;remove&#x27; %&#125;        &#123;% block sidebar %&#125;&#123;% endblock %&#125;      &#123;%- endif %&#125;    &lt;/div&gt;    &lt;div class=&quot;main-inner &#123;% block class %&#125;&#123;% endblock %&#125;&quot;&gt;      &#123;%- include &#x27;_partials/header/sub-menu.njk&#x27; -%&#125;      &#123;% block content %&#125;&#123;% endblock %&#125;      &#123;%- include &#x27;_partials/comments.njk&#x27; -%&#125;    &lt;/div&gt;  &lt;/main&gt;  &lt;footer class=&quot;footer&quot;&gt;    &lt;div class=&quot;footer-inner&quot;&gt;      &#123;%- include &#x27;_partials/languages.njk&#x27; -%&#125;      &#123;&#123; partial(&#x27;_partials/footer.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;    &lt;/div&gt;  &lt;/footer&gt;  &#123;&#123; partial(&#x27;_partials/widgets.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;  &#123;&#123;- next_inject(&#x27;bodyEnd&#x27;) &#125;&#125;  &lt;script&gt;    window.addEventListener(&#x27;load&#x27;, function() &#123;      // 鼠标点击爱心      var clickLove = document.createElement(&#x27;script&#x27;);      clickLove.src = &quot;/js/clicklove.js&quot;;      clickLove.type = &quot;text/javascript&quot;;      document.body.appendChild(clickLove);      // 页面动态线条，仅大屏设备加载      if(window.innerWidth &gt; 768)&#123;        var canvasNest = document.createElement(&#x27;script&#x27;);        canvasNest.src = &quot;/js/canvas-nest.min.js&quot;;        canvasNest.type = &quot;text/javascript&quot;;        canvasNest.setAttribute(&#x27;color&#x27;, &#x27;2,129,249&#x27;); // 线条颜色        document.body.appendChild(canvasNest);      &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n修改归档页在D:\\Hexo\\themes\\next\\source\\css\\_common\\components\\pages目录下找到categories.styl\n// 修改前.category-all-page &#123;  .category-all-title &#123;    text-align: center;  &#125;  .category-all &#123;    margin-top: 20px;  &#125;  .category-list &#123;    list-style: none;    margin: 0;    padding: 0;  &#125;  .category-list-item &#123;    margin: 5px 10px;  &#125;  .category-list-count &#123;    font-size: $font-size-smallest;    badge();  &#125;  .category-list-child &#123;    padding-left: 10px;  &#125;&#125;\n\n// 修改后.category-all-page &#123;  .category-all-title &#123;    text-align: center;  &#125;  .category-all &#123;    margin-top: 20px;  &#125;  .category-list &#123;    list-style: none;    margin: 0;    padding: 0;    display: flex;    justify-content: center;    align-items: center;    flex-flow: row wrap;  &#125;  .category-list-item &#123;    margin: 10px 10px;    padding: 10px;    -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 1);    -moz-box-shadow: 0 0 5px rgba(0, 0, 0, 1);  &#125;  if (hexo-config(&#x27;darkmode&#x27;)) &#123;    @media (prefers-color-scheme: dark) &#123;      .category-list-item &#123;        margin: 10px 10px;        padding: 10px;        -webkit-box-shadow: 0 0 5px rgba(255, 255, 255, 1);        -moz-box-shadow: 0 0 5px rgba(255, 255, 255, 1);      &#125;    &#125;  &#125;  .category-list-count &#123;    font-size: $font-size-smallest;    badge();  &#125;  .category-list-child &#123;    padding-left: 10px;  &#125;&#125;\n\n修改黑暗模式在D:\\Hexo\\themes\\next\\source\\css\\_common\\components\\post目录下找到index.styl\n// 修改前.rtl &#123;  &amp;.post-body &#123;    p, a, h1, h2, h3, h4, h5, h6, li, ul, ol &#123;      direction: rtl;      font-family: UKIJ Ekran;    &#125;  &#125;  &amp;.post-title &#123;    font-family: UKIJ Ekran;  &#125;&#125;.post-button &#123;  margin-top: 40px;  text-align: $scheme-text-align;&#125;.use-motion &#123;  if (hexo-config(&#x27;motion.transition.post_block&#x27;)) &#123;    .post-block, .pagination, .comments &#123;      visibility: hidden;    &#125;  &#125;  if (hexo-config(&#x27;motion.transition.post_header&#x27;)) &#123;    .post-header &#123;      visibility: hidden;    &#125;  &#125;  if (hexo-config(&#x27;motion.transition.post_body&#x27;)) &#123;    .post-body &#123;      visibility: hidden;    &#125;  &#125;  if (hexo-config(&#x27;motion.transition.coll_header&#x27;)) &#123;    .collection-header &#123;      visibility: hidden;    &#125;  &#125;&#125;@import &#x27;post-collapse&#x27;;@import &#x27;post-body&#x27;;@import &#x27;post-gallery&#x27;;@import &#x27;post-header&#x27;;@import &#x27;post-nav&#x27;;@import &#x27;post-footer&#x27;;@import &#x27;post-widgets&#x27;;@import &#x27;post-reward&#x27;;@import &#x27;post-followme&#x27;;\n\n// 修改后.rtl &#123;  &amp;.post-body &#123;    p, a, h1, h2, h3, h4, h5, h6, li, ul, ol &#123;      direction: rtl;      font-family: UKIJ Ekran;    &#125;  &#125;  &amp;.post-title &#123;    font-family: UKIJ Ekran;  &#125;&#125;.post-button &#123;  margin-top: 40px;  text-align: $scheme-text-align;&#125;.use-motion &#123;  if (hexo-config(&#x27;motion.transition.post_block&#x27;)) &#123;    .post-block&#123;      margin-top: 60px;      margin-bottom: 60px;      padding: 25px;      -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 1);      -moz-box-shadow: 0 0 5px rgba(0, 0, 0, 1);    &#125; .post-block, .pagination, .comments &#123;      margin-top: 60px;      margin-bottom: 60px;      padding: 25px;      -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 1);      -moz-box-shadow: 0 0 5px rgba(0, 0, 0, 1);    &#125;  &#125;  if (hexo-config(&#x27;motion.transition.post_header&#x27;)) &#123;    .post-header &#123;      visibility: hidden;    &#125;  &#125;  if (hexo-config(&#x27;motion.transition.post_body&#x27;)) &#123;    .post-body &#123;      visibility: hidden;    &#125;  &#125;  if (hexo-config(&#x27;motion.transition.coll_header&#x27;)) &#123;    .collection-header &#123;      visibility: hidden;    &#125;  &#125;&#125;if (hexo-config(&#x27;darkmode&#x27;)) &#123;  @media (prefers-color-scheme: dark) &#123;    .use-motion &#123;      if (hexo-config(&#x27;motion.transition.post_block&#x27;)) &#123;        .post-block&#123;          margin-top: 60px;          margin-bottom: 60px;          padding: 25px;          -webkit-box-shadow: 0 0 5px rgba(255, 255, 255, 1);          -moz-box-shadow: 0 0 5px rgba(255, 255, 255, 1);        &#125; .pagination, .comments &#123;          margin-top: 60px;          margin-bottom: 60px;          padding: 25px;          -webkit-box-shadow: 0 0 5px rgba(255, 255, 255, 1);          -moz-box-shadow: 0 0 5px rgba(255, 255, 255, 1);        &#125;      &#125;      if (hexo-config(&#x27;motion.transition.post_header&#x27;)) &#123;        .post-header &#123;          visibility: hidden;        &#125;      &#125;      if (hexo-config(&#x27;motion.transition.post_body&#x27;)) &#123;        .post-body &#123;          visibility: hidden;        &#125;      &#125;      if (hexo-config(&#x27;motion.transition.coll_header&#x27;)) &#123;        .collection-header &#123;          visibility: hidden;        &#125;      &#125;    &#125;  &#125;&#125;@import &#x27;post-collapse&#x27;;@import &#x27;post-body&#x27;;@import &#x27;post-gallery&#x27;;@import &#x27;post-header&#x27;;@import &#x27;post-nav&#x27;;@import &#x27;post-footer&#x27;;@import &#x27;post-widgets&#x27;;@import &#x27;post-reward&#x27;;@import &#x27;post-followme&#x27;;\n\n删除文章间短横线在D:\\Hexo\\themes\\next\\source\\css\\_common\\components\\post目录下找到post-footer.styl\n// 修改前// Flexbox layout makes it possible to reorder the child// elements of .post-footer through the `order` CSS property// Fix issue #16// To do: use `gap` instead of `margin`// See https://caniuse.com/flexbox-gap.post-footer &#123;  flex-column();&#125;.post-eof &#123;  background: $grey-light;  height: 1px;  margin: $post-eof-margin-top auto $post-eof-margin-bottom;  width: 8%;  .post-block:last-of-type &amp; &#123;    display: none;  &#125;&#125;if (hexo-config(&#x27;creative_commons.post&#x27;)) &#123;  .post-copyright ul &#123;    list-style: none;    overflow: hidden;    padding: .5em 1em;    position: relative;    post-card();    &amp;::after &#123;      content: &#x27;\\f25e&#x27;;      font-family: &#x27;Font Awesome 7 Brands&#x27;;      font-size: 200px;      opacity: $watermark-opacity;      position: absolute;      right: -50px;      top: -150px;    &#125;  &#125;&#125;.post-tags &#123;  margin-top: 40px;  text-align: $scheme-text-align;  a &#123;    display: inline-block;    font-size: $font-size-smaller;    &amp;:not(:last-child) &#123;      margin-right: 10px;    &#125;  &#125;&#125;\n\n// 修改后// Flexbox layout makes it possible to reorder the child// elements of .post-footer through the `order` CSS property// Fix issue #16// To do: use `gap` instead of `margin`// See https://caniuse.com/flexbox-gap.post-footer &#123;  flex-column();&#125;.post-eof &#123;  background: $grey-light;  //height: 1px;  //margin: $post-eof-margin-top auto $post-eof-margin-bottom;  //width: 8%;  .post-block:last-of-type &amp; &#123;    display: none;  &#125;&#125;if (hexo-config(&#x27;creative_commons.post&#x27;)) &#123;  .post-copyright ul &#123;    list-style: none;    overflow: hidden;    padding: .5em 1em;    position: relative;    post-card();    &amp;::after &#123;      content: &#x27;\\f25e&#x27;;      font-family: &#x27;Font Awesome 7 Brands&#x27;;      font-size: 200px;      opacity: $watermark-opacity;      position: absolute;      right: -50px;      top: -150px;    &#125;  &#125;&#125;.post-tags &#123;  margin-top: 40px;  text-align: $scheme-text-align;  a &#123;    display: inline-block;    font-size: $font-size-smaller;    &amp;:not(:last-child) &#123;      margin-right: 10px;    &#125;  &#125;&#125;\n\n修改宽度在D:\\Hexo\\themes\\next\\source\\css\\_variables目录下找到base.styl\n// 修改前//// Variables// ==================================================// Color system// --------------------------------------------------$whitesmoke   = #f5f5f5;$gainsboro    = #eee;$grey-lighter = #ddd;$grey-light   = #ccc;$grey         = #bbb;$grey-dark    = #999;$grey-dim     = #666;$black-light  = #555;$black-dim    = #333;$black-deep   = #222;$red          = #ff2a2a;$blue-bright  = #87daff;$blue         = #0684bd;$blue-deep    = #262a30;$orange       = #fc6423;// Transition// --------------------------------------------------$transition-duration = .2s;$transition-ease     = $transition-duration ease-in-out;$transition-ease-in  = $transition-duration ease-in;$transition-ease-out = $transition-duration ease-out;// Scaffolding// Settings for some of the most global styles.// --------------------------------------------------// Global text color on &lt;body&gt;$text-color                   = $black-light;$text-color-dark              = $grey-light;// Global link color.$link-color                   = $black-light;$link-color-dark              = $grey-light;$link-hover-color             = $black-deep;$link-hover-color-dark        = $gainsboro;$link-decoration-color        = $grey-dark;$blockquote-color             = $grey-dim;$blockquote-color-dark        = $grey;// Global border color.$border-color                 = $grey-light;// Background color for &lt;body&gt;$body-bg-color                = white;$body-bg-color-dark           = #282828;$content-bg-color             = white;$content-bg-color-dark        = $black-dim;// Selection$selection-bg                 = $blue-deep;$selection-color              = $gainsboro;$selection-bg-dark            = $grey;$selection-color-dark         = $black-dim;// Dark mode color$card-bg-color                = $whitesmoke;$card-bg-color-dark           = $black-light;$menu-item-bg-color           = $whitesmoke;$menu-item-bg-color-dark      = $black-light;$theme-color                  = convert(hexo-config(&#x27;theme_color.light&#x27;));$theme-color-dark             = convert(hexo-config(&#x27;theme_color.dark&#x27;));$scheme-text-align            = center;// Typography// Font, line-height, and elements colors.// --------------------------------------------------get_font_family(config) &#123;  $custom-family = hexo-config(&#x27;font.&#x27; + config + &#x27;.family&#x27;);  return $custom-family is a &#x27;string&#x27; ? unquote($custom-family) : null;&#125;// Font families.$font-family-chinese      = &#x27;PingFang SC&#x27;, &#x27;Microsoft YaHei&#x27;;$font-family-base         = $font-family-chinese, sans-serif;$font-family-base         = get_font_family(&#x27;global&#x27;), $font-family-chinese, sans-serif if get_font_family(&#x27;global&#x27;);$font-family-logo         = $font-family-base;$font-family-logo         = get_font_family(&#x27;title&#x27;), $font-family-base if get_font_family(&#x27;title&#x27;);$font-family-headings     = $font-family-base;$font-family-headings     = get_font_family(&#x27;headings&#x27;), $font-family-base if get_font_family(&#x27;headings&#x27;);$font-family-posts        = $font-family-base;$font-family-posts        = get_font_family(&#x27;posts&#x27;), $font-family-base if get_font_family(&#x27;posts&#x27;);$font-family-monospace    = consolas, Menlo, monospace, $font-family-chinese;$font-family-monospace    = get_font_family(&#x27;codes&#x27;), consolas, Menlo, monospace, $font-family-chinese if get_font_family(&#x27;codes&#x27;);// Font size$font-size-base           = (hexo-config(&#x27;font.enable&#x27;) and hexo-config(&#x27;font.global.size&#x27;) is a &#x27;unit&#x27;) ? unit(hexo-config(&#x27;font.global.size&#x27;), em) : 1em;$font-size-smallest       = .75em;$font-size-smaller        = .8125em;$font-size-small          = .875em;$font-size-medium         = 1em;$font-size-large          = 1.125em;$font-size-larger         = 1.25em;$font-size-largest        = 1.5em;// Headings font size$font-size-headings-step  = .125em;$font-size-headings-base  = (hexo-config(&#x27;font.enable&#x27;) and hexo-config(&#x27;font.headings.size&#x27;) is a &#x27;unit&#x27;) ? unit(hexo-config(&#x27;font.headings.size&#x27;), em) : 1.625em;// Global line height$line-height-base         = 2;$line-height-code-block   = 1.6; // Can&#x27;t be less than 1.3;// Z-index master list// --------------------------------------------------// Fix issue https://github.com/next-theme/theme-next-docs/issues/54$zindex-0       = 5;$zindex-1       = 10;$zindex-2       = 20;$zindex-3       = 30;$zindex-4       = 40;$zindex-5       = 50;// Table// --------------------------------------------------$table-border-color             = $grey-lighter;$table-font-size                = $font-size-small;$table-cell-border-bottom-color = $grey-lighter;$table-row-odd-bg-color         = #f9f9f9;$table-row-odd-bg-color-dark    = #282828;$table-row-hover-bg-color       = $whitesmoke;$table-row-hover-bg-color-dark  = #363636;// Code &amp; Code Blocks// --------------------------------------------------$code-font-family               = $font-family-monospace;$highlight-background        = convert(hexo-config(&#x27;highlight.light.background&#x27;));$highlight-foreground        = convert(hexo-config(&#x27;highlight.light.foreground&#x27;));$highlight-gutter-background = mix($highlight-background, $highlight-foreground, 90%);$highlight-gutter-foreground = mix($highlight-background, $highlight-foreground, 10%);$highlight-background-dark        = convert(hexo-config(&#x27;highlight.dark.background&#x27;));$highlight-foreground-dark        = convert(hexo-config(&#x27;highlight.dark.foreground&#x27;));$highlight-gutter-background-dark = mix($highlight-background-dark, $highlight-foreground-dark, 90%);$highlight-gutter-foreground-dark = mix($highlight-background-dark, $highlight-foreground-dark, 10%);// Buttons// --------------------------------------------------$btn-default-radius                    = 0;$btn-default-bg                        = $black-deep;$btn-default-bg-dark                   = $black-deep;$btn-default-color                     = white;$btn-default-color-dark                = $text-color-dark;$btn-default-border-color              = $black-deep;$btn-default-border-color-dark         = $black-light;$btn-default-hover-bg                  = white;$btn-default-hover-bg-dark             = $grey-dim;$btn-default-hover-color               = $black-deep;$btn-default-hover-color-dark          = $text-color-dark;$btn-default-hover-border-color        = $black-deep;$btn-default-hover-border-color-dark   = $grey-dim;// Pagination// --------------------------------------------------$pagination-border              = $gainsboro;$pagination-link-bg             = transparent;$pagination-link-color          = $link-color;$pagination-link-border         = $gainsboro;$pagination-link-hover-bg       = transparent;$pagination-link-hover-color    = $link-color;$pagination-link-hover-border   = var(--link-hover-color);$pagination-active-bg           = $grey-light;$pagination-active-color        = var(--content-bg-color);$pagination-active-border       = $grey-light;// Layout sizes// --------------------------------------------------$content-desktop                = 700px;$content-desktop-large          = 800px;$content-desktop-largest        = 900px;$content-desktop-padding        = 40px;$content-tablet-padding         = 10px;$content-mobile-padding         = 8px;// Headband// --------------------------------------------------$headband-height                = 3px;$headband-bg                    = var(--theme-color);// Site Meta// --------------------------------------------------$brand-color                    = white;$brand-hover-color              = white;$brand-color-dark               = $grey-lighter;$brand-hover-color-dark         = $grey-lighter;$brand-padding                  = 0 40px;$site-subtitle-margin           = 10px 0;$font-size-title                = (hexo-config(&#x27;font.enable&#x27;) and hexo-config(&#x27;font.title.size&#x27;) is a &#x27;unit&#x27;) ? unit(hexo-config(&#x27;font.title.size&#x27;), em) : 1.375em;$font-size-subtitle             = $font-size-smaller;$subtitle-color                 = $grey-dark;$site-subtitle-color            = $grey-dark;// Posts Collpase// --------------------------------------------------$posts-collapse-margin          = 35px;$posts-collapse-margin-mobile   = 0;// Tag Cloud// --------------------------------------------------$tag-cloud-start      = #aaa;$tag-cloud-end        = #111;$tag-cloud-start-dark = #555;$tag-cloud-end-dark   = #eee;// Sidebar// Variables for sidebar section elements.// --------------------------------------------------$sidebar-width                        = hexo-config(&#x27;sidebar.width_expanded&#x27;) is a &#x27;unit&#x27; ? hexo-config(&#x27;sidebar.width_expanded&#x27;) : 320;$sidebar-width-expanded               = unit($sidebar-width, &#x27;px&#x27;);$sidebar-padding                      = hexo-config(&#x27;sidebar.padding&#x27;) is a &#x27;unit&#x27; ? unit(hexo-config(&#x27;sidebar.padding&#x27;), px) : 18px;$sidebar-offset                       = hexo-config(&#x27;sidebar.offset&#x27;) is a &#x27;unit&#x27; ? unit(hexo-config(&#x27;sidebar.offset&#x27;), px) : 12px;$sidebar-nav-color                    = $grey-dim;$sidebar-nav-hover-color              = $whitesmoke;$sidebar-highlight                    = $blue-bright;$site-author-image-width              = 96px;$site-author-image-border-width       = 2px;$site-author-image-border-color       = $black-dim;$site-author-name-margin              = 5px 0 0;$site-author-name-color               = $whitesmoke;$site-author-name-weight              = normal;$site-description-font-size           = $font-size-medium;$site-description-color               = $grey-dark;$site-description-margin-top          = 5px;$site-state-item-count-font-size      = $font-size-larger;$site-state-item-name-font-size       = $font-size-small;$site-state-item-name-color           = inherit;// Components// --------------------------------------------------// Back to top$b2t-opacity                  = .8;$b2t-opacity-hover            = 1;$b2t-position-bottom          = -100px;$b2t-position-bottom-on       = 30px;$b2t-position-right           = 30px;$b2t-position-right-mobile    = 20px;$b2t-font-size                = 12px;$b2t-color                    = white;$b2t-bg-color                 = $black-deep;$sidebar-toggle-inner-size    = 16px;$sidebar-toggle-padding       = 5px;$sidebar-toggle-size          = $sidebar-toggle-inner-size + $sidebar-toggle-padding * 2;$sidebar-toggle-alignment     = hexo-config(&#x27;sidebar.position&#x27;) == &#x27;left&#x27; ? &#x27;left&#x27; : &#x27;right&#x27;;//  .post-expand .post-eof//  In Muse scheme, margin above and below the post separator$post-eof-margin-top          = 80px; //  or 160px for more white space;$post-eof-margin-bottom       = 60px; //  or 120px for less white space;$post-card-margin             = 1em 0 0;$post-reward-img-width        = 180px;$post-followme-img-width      = $post-reward-img-width;// Note colors// --------------------------------------------------// Read note light_bg_offset from NexT config and set in &#x27;$lbg%&#x27; to use it as string variable.$lbg = hexo-config(&#x27;note.light_bg_offset&#x27;) is a &#x27;unit&#x27; ? unit(hexo-config(&#x27;note.light_bg_offset&#x27;), &#x27;%&#x27;) : 0;$note-types = &#x27;default&#x27; &#x27;primary&#x27; &#x27;info&#x27; &#x27;success&#x27; &#x27;warning&#x27; &#x27;danger&#x27;;$note-border-radius         = 3px;$note-border = &#123;  default : #777,  primary : #6f42c1,  info    : #428bca,  success : #5cb85c,  warning : #f0ad4e,  danger  : #d9534f&#125;;$note-bg = &#123;  default : lighten(spin($note-border.default, 0), 94% + $lbg),  primary : lighten(spin($note-border.primary, 10), 92% + $lbg),  info    : lighten(spin($note-border.info, -10), 91% + $lbg),  success : lighten(spin($note-border.success, 10), 90% + $lbg),  warning : lighten(spin($note-border.warning, 10), 88% + $lbg),  danger  : lighten(spin($note-border.danger, -10), 92% + $lbg)&#125;;$note-text = &#123;  default : $note-border.default,  primary : $note-border.primary,  info    : $note-border.info,  success : $note-border.success,  warning : $note-border.warning,  danger  : $note-border.danger&#125;;$note-icon = &#123;  default : &#x27;\\f0a9&#x27;,  primary : &#x27;\\f055&#x27;,  info    : &#x27;\\f05a&#x27;,  success : &#x27;\\f058&#x27;,  warning : &#x27;\\f06a&#x27;,  danger  : &#x27;\\f056&#x27;&#125;;$note-modern-border = &#123;  default : #e1e1e1,  primary : #e1c2ff,  info    : #b3e5ef,  success : #d0e6be,  warning : #fae4cd,  danger  : #ebcdd2&#125;;$note-modern-bg = &#123;  default : lighten(spin($note-modern-border.default, 10), 60% + ($lbg * 4)),  primary : lighten(spin($note-modern-border.primary, 10), 40% + ($lbg * 4)),  info    : lighten(spin($note-modern-border.info, 10), 50% + ($lbg * 4)),  success : lighten(spin($note-modern-border.success, 10), 40% + ($lbg * 4)),  warning : lighten(spin($note-modern-border.warning, 10), 43% + ($lbg * 4)),  danger  : lighten(spin($note-modern-border.danger, 10), 35% + ($lbg * 4))&#125;;$note-modern-text = &#123;  default : $grey-dim,  primary : #6f42c1,  info    : #31708f,  success : #3c763d,  warning : #8a6d3b,  danger  : #a94442&#125;;$note-modern-hover = &#123;  default : darken(spin($note-modern-text.default, -10), 32%),  primary : darken(spin($note-modern-text.primary, -10), 22%),  info    : darken(spin($note-modern-text.info, -10), 32%),  success : darken(spin($note-modern-text.success, -10), 27%),  warning : darken(spin($note-modern-text.warning, -10), 18%),  danger  : darken(spin($note-modern-text.danger, -10), 22%)&#125;;transform-map(map, transform) &#123;  new-map = &#123;  &#125;  for key, val in map &#123;    new-map[key] = transform(val);  &#125;  return new-map;&#125;$note-modern-border-dark = transform-map($note-modern-hover,  @(val) &#123;           lighten(val, 10%)       &#125;);$note-modern-bg-dark     = transform-map($note-modern-text,   @(val) &#123; desaturate(darken(val, 20%), 20%) &#125;);$note-modern-text-dark   = transform-map($note-modern-bg,     @(val) &#123;            darken(val, 10%)       &#125;);$note-modern-hover-dark  = transform-map($note-modern-border, @(val) &#123;           lighten(val, 75%)       &#125;);// Tabs border radius// --------------------------------------------------$tbr                        = 0;// Label colors// --------------------------------------------------$label = &#123;  default : lighten(spin($note-border.default, 0), 89% + $lbg),  primary : lighten(spin($note-border.primary, 10), 87% + $lbg),  info    : lighten(spin($note-border.info, -10), 86% + $lbg),  success : lighten(spin($note-border.success, 10), 85% + $lbg),  warning : lighten(spin($note-border.warning, 10), 83% + $lbg),  danger  : lighten(spin($note-border.danger, -10), 87% + $lbg)&#125;;// Badge colors// --------------------------------------------------$badge-padding = 1px 4px;$badge-border-radius = 0;$badge-background = $gainsboro;$badge-color = $black-light;$badge-text-shadow = none;$watermark-opacity = .1;\n\n// 修改后//// Variables// ==================================================// Color system// --------------------------------------------------$whitesmoke   = #f5f5f5;$gainsboro    = #eee;$grey-lighter = #ddd;$grey-light   = #ccc;$grey         = #bbb;$grey-dark    = #999;$grey-dim     = #666;$black-light  = #555;$black-dim    = #333;$black-deep   = #222;$red          = #ff2a2a;$blue-bright  = #87daff;$blue         = #0684bd;$blue-deep    = #262a30;$orange       = #fc6423;// Transition// --------------------------------------------------$transition-duration = .2s;$transition-ease     = $transition-duration ease-in-out;$transition-ease-in  = $transition-duration ease-in;$transition-ease-out = $transition-duration ease-out;// Scaffolding// Settings for some of the most global styles.// --------------------------------------------------// Global text color on &lt;body&gt;$text-color                   = $black-light;$text-color-dark              = $grey-light;// Global link color.$link-color                   = $black-light;$link-color-dark              = $grey-light;$link-hover-color             = $black-deep;$link-hover-color-dark        = $gainsboro;$link-decoration-color        = $grey-dark;$blockquote-color             = $grey-dim;$blockquote-color-dark        = $grey;// Global border color.$border-color                 = $grey-light;// Background color for &lt;body&gt;$body-bg-color                = white;$body-bg-color-dark           = #282828;$content-bg-color             = white;$content-bg-color-dark        = $black-dim;// Selection$selection-bg                 = $blue-deep;$selection-color              = $gainsboro;$selection-bg-dark            = $grey;$selection-color-dark         = $black-dim;// Dark mode color$card-bg-color                = $whitesmoke;$card-bg-color-dark           = $black-light;$menu-item-bg-color           = $whitesmoke;$menu-item-bg-color-dark      = $black-light;$theme-color                  = convert(hexo-config(&#x27;theme_color.light&#x27;));$theme-color-dark             = convert(hexo-config(&#x27;theme_color.dark&#x27;));$scheme-text-align            = center;// Typography// Font, line-height, and elements colors.// --------------------------------------------------get_font_family(config) &#123;  $custom-family = hexo-config(&#x27;font.&#x27; + config + &#x27;.family&#x27;);  return $custom-family is a &#x27;string&#x27; ? unquote($custom-family) : null;&#125;// Font families.$font-family-chinese      = &#x27;PingFang SC&#x27;, &#x27;Microsoft YaHei&#x27;;$font-family-base         = $font-family-chinese, sans-serif;$font-family-base         = get_font_family(&#x27;global&#x27;), $font-family-chinese, sans-serif if get_font_family(&#x27;global&#x27;);$font-family-logo         = $font-family-base;$font-family-logo         = get_font_family(&#x27;title&#x27;), $font-family-base if get_font_family(&#x27;title&#x27;);$font-family-headings     = $font-family-base;$font-family-headings     = get_font_family(&#x27;headings&#x27;), $font-family-base if get_font_family(&#x27;headings&#x27;);$font-family-posts        = $font-family-base;$font-family-posts        = get_font_family(&#x27;posts&#x27;), $font-family-base if get_font_family(&#x27;posts&#x27;);$font-family-monospace    = consolas, Menlo, monospace, $font-family-chinese;$font-family-monospace    = get_font_family(&#x27;codes&#x27;), consolas, Menlo, monospace, $font-family-chinese if get_font_family(&#x27;codes&#x27;);// Font size$font-size-base           = (hexo-config(&#x27;font.enable&#x27;) and hexo-config(&#x27;font.global.size&#x27;) is a &#x27;unit&#x27;) ? unit(hexo-config(&#x27;font.global.size&#x27;), em) : 1em;$font-size-smallest       = .75em;$font-size-smaller        = .8125em;$font-size-small          = .875em;$font-size-medium         = 1em;$font-size-large          = 1.125em;$font-size-larger         = 1.25em;$font-size-largest        = 1.5em;// Headings font size$font-size-headings-step  = .125em;$font-size-headings-base  = (hexo-config(&#x27;font.enable&#x27;) and hexo-config(&#x27;font.headings.size&#x27;) is a &#x27;unit&#x27;) ? unit(hexo-config(&#x27;font.headings.size&#x27;), em) : 1.625em;// Global line height$line-height-base         = 2;$line-height-code-block   = 1.6; // Can&#x27;t be less than 1.3;// Z-index master list// --------------------------------------------------// Fix issue https://github.com/next-theme/theme-next-docs/issues/54$zindex-0       = 5;$zindex-1       = 10;$zindex-2       = 20;$zindex-3       = 30;$zindex-4       = 40;$zindex-5       = 50;// Table// --------------------------------------------------$table-border-color             = $grey-lighter;$table-font-size                = $font-size-small;$table-cell-border-bottom-color = $grey-lighter;$table-row-odd-bg-color         = #f9f9f9;$table-row-odd-bg-color-dark    = #282828;$table-row-hover-bg-color       = $whitesmoke;$table-row-hover-bg-color-dark  = #363636;// Code &amp; Code Blocks// --------------------------------------------------$code-font-family               = $font-family-monospace;$highlight-background        = convert(hexo-config(&#x27;highlight.light.background&#x27;));$highlight-foreground        = convert(hexo-config(&#x27;highlight.light.foreground&#x27;));$highlight-gutter-background = mix($highlight-background, $highlight-foreground, 90%);$highlight-gutter-foreground = mix($highlight-background, $highlight-foreground, 10%);$highlight-background-dark        = convert(hexo-config(&#x27;highlight.dark.background&#x27;));$highlight-foreground-dark        = convert(hexo-config(&#x27;highlight.dark.foreground&#x27;));$highlight-gutter-background-dark = mix($highlight-background-dark, $highlight-foreground-dark, 90%);$highlight-gutter-foreground-dark = mix($highlight-background-dark, $highlight-foreground-dark, 10%);// Buttons// --------------------------------------------------$btn-default-radius                    = 0;$btn-default-bg                        = $black-deep;$btn-default-bg-dark                   = $black-deep;$btn-default-color                     = white;$btn-default-color-dark                = $text-color-dark;$btn-default-border-color              = $black-deep;$btn-default-border-color-dark         = $black-light;$btn-default-hover-bg                  = white;$btn-default-hover-bg-dark             = $grey-dim;$btn-default-hover-color               = $black-deep;$btn-default-hover-color-dark          = $text-color-dark;$btn-default-hover-border-color        = $black-deep;$btn-default-hover-border-color-dark   = $grey-dim;// Pagination// --------------------------------------------------$pagination-border              = $gainsboro;$pagination-link-bg             = transparent;$pagination-link-color          = $link-color;$pagination-link-border         = $gainsboro;$pagination-link-hover-bg       = transparent;$pagination-link-hover-color    = $link-color;$pagination-link-hover-border   = var(--link-hover-color);$pagination-active-bg           = $grey-light;$pagination-active-color        = var(--content-bg-color);$pagination-active-border       = $grey-light;// Layout sizes// --------------------------------------------------//$content-desktop                = 700px;//$content-desktop-large          = 800px;//$content-desktop-largest        = 900px;$content-desktop                = 90%;$content-desktop-large          = 90%;$content-desktop-largest        = 90%;$content-desktop-padding        = 40px;$content-tablet-padding         = 10px;$content-mobile-padding         = 8px;// Headband// --------------------------------------------------$headband-height                = 3px;$headband-bg                    = var(--theme-color);// Site Meta// --------------------------------------------------$brand-color                    = white;$brand-hover-color              = white;$brand-color-dark               = $grey-lighter;$brand-hover-color-dark         = $grey-lighter;$brand-padding                  = 0 40px;$site-subtitle-margin           = 10px 0;$font-size-title                = (hexo-config(&#x27;font.enable&#x27;) and hexo-config(&#x27;font.title.size&#x27;) is a &#x27;unit&#x27;) ? unit(hexo-config(&#x27;font.title.size&#x27;), em) : 1.375em;$font-size-subtitle             = $font-size-smaller;$subtitle-color                 = $grey-dark;$site-subtitle-color            = $grey-dark;// Posts Collpase// --------------------------------------------------$posts-collapse-margin          = 35px;$posts-collapse-margin-mobile   = 0;// Tag Cloud// --------------------------------------------------$tag-cloud-start      = #aaa;$tag-cloud-end        = #111;$tag-cloud-start-dark = #555;$tag-cloud-end-dark   = #eee;// Sidebar// Variables for sidebar section elements.// --------------------------------------------------$sidebar-width                        = hexo-config(&#x27;sidebar.width_expanded&#x27;) is a &#x27;unit&#x27; ? hexo-config(&#x27;sidebar.width_expanded&#x27;) : 320;$sidebar-width-expanded               = unit($sidebar-width, &#x27;px&#x27;);$sidebar-padding                      = hexo-config(&#x27;sidebar.padding&#x27;) is a &#x27;unit&#x27; ? unit(hexo-config(&#x27;sidebar.padding&#x27;), px) : 18px;$sidebar-offset                       = hexo-config(&#x27;sidebar.offset&#x27;) is a &#x27;unit&#x27; ? unit(hexo-config(&#x27;sidebar.offset&#x27;), px) : 12px;$sidebar-nav-color                    = $grey-dim;$sidebar-nav-hover-color              = $whitesmoke;$sidebar-highlight                    = $blue-bright;$site-author-image-width              = 96px;$site-author-image-border-width       = 2px;$site-author-image-border-color       = $black-dim;$site-author-name-margin              = 5px 0 0;$site-author-name-color               = $whitesmoke;$site-author-name-weight              = normal;$site-description-font-size           = $font-size-medium;$site-description-color               = $grey-dark;$site-description-margin-top          = 5px;$site-state-item-count-font-size      = $font-size-larger;$site-state-item-name-font-size       = $font-size-small;$site-state-item-name-color           = inherit;// Components// --------------------------------------------------// Back to top$b2t-opacity                  = .8;$b2t-opacity-hover            = 1;$b2t-position-bottom          = -100px;$b2t-position-bottom-on       = 30px;$b2t-position-right           = 30px;$b2t-position-right-mobile    = 20px;$b2t-font-size                = 12px;$b2t-color                    = white;$b2t-bg-color                 = $black-deep;$sidebar-toggle-inner-size    = 16px;$sidebar-toggle-padding       = 5px;$sidebar-toggle-size          = $sidebar-toggle-inner-size + $sidebar-toggle-padding * 2;$sidebar-toggle-alignment     = hexo-config(&#x27;sidebar.position&#x27;) == &#x27;left&#x27; ? &#x27;left&#x27; : &#x27;right&#x27;;//  .post-expand .post-eof//  In Muse scheme, margin above and below the post separator$post-eof-margin-top          = 80px; //  or 160px for more white space;$post-eof-margin-bottom       = 60px; //  or 120px for less white space;$post-card-margin             = 1em 0 0;$post-reward-img-width        = 180px;$post-followme-img-width      = $post-reward-img-width;// Note colors// --------------------------------------------------// Read note light_bg_offset from NexT config and set in &#x27;$lbg%&#x27; to use it as string variable.$lbg = hexo-config(&#x27;note.light_bg_offset&#x27;) is a &#x27;unit&#x27; ? unit(hexo-config(&#x27;note.light_bg_offset&#x27;), &#x27;%&#x27;) : 0;$note-types = &#x27;default&#x27; &#x27;primary&#x27; &#x27;info&#x27; &#x27;success&#x27; &#x27;warning&#x27; &#x27;danger&#x27;;$note-border-radius         = 3px;$note-border = &#123;  default : #777,  primary : #6f42c1,  info    : #428bca,  success : #5cb85c,  warning : #f0ad4e,  danger  : #d9534f&#125;;$note-bg = &#123;  default : lighten(spin($note-border.default, 0), 94% + $lbg),  primary : lighten(spin($note-border.primary, 10), 92% + $lbg),  info    : lighten(spin($note-border.info, -10), 91% + $lbg),  success : lighten(spin($note-border.success, 10), 90% + $lbg),  warning : lighten(spin($note-border.warning, 10), 88% + $lbg),  danger  : lighten(spin($note-border.danger, -10), 92% + $lbg)&#125;;$note-text = &#123;  default : $note-border.default,  primary : $note-border.primary,  info    : $note-border.info,  success : $note-border.success,  warning : $note-border.warning,  danger  : $note-border.danger&#125;;$note-icon = &#123;  default : &#x27;\\f0a9&#x27;,  primary : &#x27;\\f055&#x27;,  info    : &#x27;\\f05a&#x27;,  success : &#x27;\\f058&#x27;,  warning : &#x27;\\f06a&#x27;,  danger  : &#x27;\\f056&#x27;&#125;;$note-modern-border = &#123;  default : #e1e1e1,  primary : #e1c2ff,  info    : #b3e5ef,  success : #d0e6be,  warning : #fae4cd,  danger  : #ebcdd2&#125;;$note-modern-bg = &#123;  default : lighten(spin($note-modern-border.default, 10), 60% + ($lbg * 4)),  primary : lighten(spin($note-modern-border.primary, 10), 40% + ($lbg * 4)),  info    : lighten(spin($note-modern-border.info, 10), 50% + ($lbg * 4)),  success : lighten(spin($note-modern-border.success, 10), 40% + ($lbg * 4)),  warning : lighten(spin($note-modern-border.warning, 10), 43% + ($lbg * 4)),  danger  : lighten(spin($note-modern-border.danger, 10), 35% + ($lbg * 4))&#125;;$note-modern-text = &#123;  default : $grey-dim,  primary : #6f42c1,  info    : #31708f,  success : #3c763d,  warning : #8a6d3b,  danger  : #a94442&#125;;$note-modern-hover = &#123;  default : darken(spin($note-modern-text.default, -10), 32%),  primary : darken(spin($note-modern-text.primary, -10), 22%),  info    : darken(spin($note-modern-text.info, -10), 32%),  success : darken(spin($note-modern-text.success, -10), 27%),  warning : darken(spin($note-modern-text.warning, -10), 18%),  danger  : darken(spin($note-modern-text.danger, -10), 22%)&#125;;transform-map(map, transform) &#123;  new-map = &#123;  &#125;  for key, val in map &#123;    new-map[key] = transform(val);  &#125;  return new-map;&#125;$note-modern-border-dark = transform-map($note-modern-hover,  @(val) &#123;           lighten(val, 10%)       &#125;);$note-modern-bg-dark     = transform-map($note-modern-text,   @(val) &#123; desaturate(darken(val, 20%), 20%) &#125;);$note-modern-text-dark   = transform-map($note-modern-bg,     @(val) &#123;            darken(val, 10%)       &#125;);$note-modern-hover-dark  = transform-map($note-modern-border, @(val) &#123;           lighten(val, 75%)       &#125;);// Tabs border radius// --------------------------------------------------$tbr                        = 0;// Label colors// --------------------------------------------------$label = &#123;  default : lighten(spin($note-border.default, 0), 89% + $lbg),  primary : lighten(spin($note-border.primary, 10), 87% + $lbg),  info    : lighten(spin($note-border.info, -10), 86% + $lbg),  success : lighten(spin($note-border.success, 10), 85% + $lbg),  warning : lighten(spin($note-border.warning, 10), 83% + $lbg),  danger  : lighten(spin($note-border.danger, -10), 87% + $lbg)&#125;;// Badge colors// --------------------------------------------------$badge-padding = 1px 4px;$badge-border-radius = 0;$badge-background = $gainsboro;$badge-color = $black-light;$badge-text-shadow = none;$watermark-opacity = .1;\n\n在D:\\Hexo\\themes\\next\\source\\css\\_variables目录下找到Mist.styl\n// 修改前// Variables of Mist scheme// ==================================================@import &#x27;Muse&#x27;;$scheme-text-align          = left;$content-padding-bottom     = 80px;$posts-first-padding        = 80px;$posts-first-padding-mobile = 60px;$link-decoration-color   = $grey-light;$content-bg-color        = $whitesmoke;$menu-item-bg-color      = $grey-lighter;$brand-color             = $black-deep;$brand-hover-color       = $brand-color;$brand-padding           = 2px 1px;$posts-collapse-left     = 0;$btn-default-bg                 = transparent;$btn-default-color              = var(--link-color);$btn-default-hover-bg           = transparent;$btn-default-border-color       = var(--link-color);$btn-default-hover-color        = var(--link-hover-color);$btn-default-hover-border-color = var(--link-hover-color);$badge-background    = white;$badge-border-radius = 10px;$badge-text-shadow   = 1px 1px 0 rgba(0, 0, 0, .1);\n\n// 修改后// Variables of Mist scheme// ==================================================@import &#x27;Muse&#x27;;$scheme-text-align          = left;$content-padding-bottom     = 60px;$posts-first-padding        = 25px;$posts-first-padding-mobile = 35px;$link-decoration-color   = $grey-light;$content-bg-color        = $whitesmoke;$menu-item-bg-color      = $grey-lighter;$brand-color             = $black-deep;$brand-hover-color       = $brand-color;$brand-padding           = 2px 1px;$posts-collapse-left     = 0;$btn-default-bg                 = transparent;$btn-default-color              = var(--link-color);$btn-default-hover-bg           = transparent;$btn-default-border-color       = var(--link-color);$btn-default-hover-color        = var(--link-hover-color);$btn-default-hover-border-color = var(--link-hover-color);$badge-background    = white;$badge-border-radius = 10px;$badge-text-shadow   = 1px 1px 0 rgba(0, 0, 0, .1);\n\n在D:\\Hexo\\themes\\next\\source\\css\\_variables目录下找到Muse.styl\n// 修改前// Variables of Muse scheme// ==================================================$content-padding-bottom     = 60px;$posts-first-padding        = 70px;$posts-first-padding-mobile = 35px;\n\n// 修改后// Variables of Muse scheme// ==================================================$content-padding-bottom     = 60px;$posts-first-padding        = 25px;$posts-first-padding-mobile = 35px;\n\n修改黑暗模式的颜色及背景在D:\\Hexo\\themes\\next\\source\\css目录下找到_colors.styl\n// 修改前:root &#123;  --body-bg-color: $body-bg-color;  --content-bg-color: $content-bg-color;  --card-bg-color: $card-bg-color;  --text-color: $text-color;  --selection-bg: $selection-bg;  --selection-color: $selection-color;  --blockquote-color: $blockquote-color;  --link-color: $link-color;  --link-hover-color: $link-hover-color;  --brand-color: $brand-color;  --brand-hover-color: $brand-hover-color;  --table-row-odd-bg-color: $table-row-odd-bg-color;  --table-row-hover-bg-color: $table-row-hover-bg-color;  --menu-item-bg-color: $menu-item-bg-color;  --theme-color: $theme-color;  --btn-default-bg: $btn-default-bg;  --btn-default-color: $btn-default-color;  --btn-default-border-color: $btn-default-border-color;  --btn-default-hover-bg: $btn-default-hover-bg;  --btn-default-hover-color: $btn-default-hover-color;  --btn-default-hover-border-color: $btn-default-hover-border-color;  --highlight-background: $highlight-background;  --highlight-foreground: $highlight-foreground;  --highlight-gutter-background: $highlight-gutter-background;  --highlight-gutter-foreground: $highlight-gutter-foreground;  color-scheme: light;&#125;if (hexo-config(&#x27;darkmode&#x27;)) &#123;  @media (prefers-color-scheme: dark) &#123;    :root &#123;      --body-bg-color: $body-bg-color-dark;      --content-bg-color: $content-bg-color-dark;      --card-bg-color: $card-bg-color-dark;      --text-color: $text-color-dark;      --selection-bg: $selection-bg-dark;      --selection-color: $selection-color-dark;      --blockquote-color: $blockquote-color-dark;      --link-color: $link-color-dark;      --link-hover-color: $link-hover-color-dark;      --brand-color: $brand-color-dark;      --brand-hover-color: $brand-hover-color-dark;      --table-row-odd-bg-color: $table-row-odd-bg-color-dark;      --table-row-hover-bg-color: $table-row-hover-bg-color-dark;      --menu-item-bg-color: $menu-item-bg-color-dark;      --theme-color: $theme-color-dark;      --btn-default-bg: $btn-default-bg-dark;      --btn-default-color: $btn-default-color-dark;      --btn-default-border-color: $btn-default-border-color-dark;      --btn-default-hover-bg: $btn-default-hover-bg-dark;      --btn-default-hover-color: $btn-default-hover-color-dark;      --btn-default-hover-border-color: $btn-default-hover-border-color-dark;      --highlight-background: $highlight-background-dark;      --highlight-foreground: $highlight-foreground-dark;      --highlight-gutter-background: $highlight-gutter-background-dark;      --highlight-gutter-foreground: $highlight-gutter-foreground-dark;      color-scheme: dark;    &#125;    img &#123;      opacity: .75;      &amp;:hover &#123;        opacity: .9;      &#125;    &#125;    iframe &#123;      color-scheme: light;    &#125;  &#125;&#125;if (hexo-config(&#x27;lightdark.enable&#x27;)) &#123;  +light-dark-block() &#123;    :root &#123;      --body-bg-color: light-dark($body-bg-color, $body-bg-color-dark);      --content-bg-color: light-dark($content-bg-color, $content-bg-color-dark);      --card-bg-color: light-dark($card-bg-color, $card-bg-color-dark);      --text-color: light-dark($text-color, $text-color-dark);      --selection-bg: light-dark($selection-bg, $selection-bg-dark);      --selection-color: light-dark($selection-color, $selection-color-dark);      --blockquote-color: light-dark($blockquote-color, $blockquote-color-dark);      --link-color: light-dark($link-color, $link-color-dark);      --link-hover-color: light-dark($link-hover-color, $link-hover-color-dark);      --brand-color: light-dark($brand-color, $brand-color-dark);      --brand-hover-color: light-dark($brand-hover-color, $brand-hover-color-dark);      --table-row-odd-bg-color: light-dark($table-row-odd-bg-color, $table-row-odd-bg-color-dark);      --table-row-hover-bg-color: light-dark($table-row-hover-bg-color, $table-row-hover-bg-color-dark);      --menu-item-bg-color: light-dark($menu-item-bg-color, $menu-item-bg-color-dark);      --theme-color: light-dark($theme-color, $theme-color-dark);      --btn-default-bg: light-dark($btn-default-bg, $btn-default-bg-dark);      --btn-default-color: light-dark($btn-default-color, $btn-default-color-dark);      --btn-default-border-color: light-dark($btn-default-border-color, $btn-default-border-color-dark);      --btn-default-hover-bg: light-dark($btn-default-hover-bg, $btn-default-hover-bg-dark);      --btn-default-hover-color: light-dark($btn-default-hover-color, $btn-default-hover-color-dark);      --btn-default-hover-border-color: light-dark($btn-default-hover-border-color, $btn-default-hover-border-color-dark);      color-scheme: light dark;      img &#123;        opacity: light-dark(1, .75);        &amp;:hover &#123;          opacity: light-dark(1, .9);        &#125;      &#125;      iframe &#123;        color-scheme: light;      &#125;    &#125;  &#125;&#125;\n\n// 修改后:root &#123;  --body-bg-color: $body-bg-color;  --content-bg-color: $content-bg-color;  --card-bg-color: $card-bg-color;  --text-color: $text-color;  --selection-bg: $selection-bg;  --selection-color: $selection-color;  --blockquote-color: $blockquote-color;  --link-color: $link-color;  --link-hover-color: $link-hover-color;  --brand-color: $brand-color;  --brand-hover-color: $brand-hover-color;  --table-row-odd-bg-color: $table-row-odd-bg-color;  --table-row-hover-bg-color: $table-row-hover-bg-color;  --menu-item-bg-color: $menu-item-bg-color;  --theme-color: $theme-color;  --btn-default-bg: $btn-default-bg;  --btn-default-color: $btn-default-color;  --btn-default-border-color: $btn-default-border-color;  --btn-default-hover-bg: $btn-default-hover-bg;  --btn-default-hover-color: $btn-default-hover-color;  --btn-default-hover-border-color: $btn-default-hover-border-color;  --highlight-background: $highlight-background;  --highlight-foreground: $highlight-foreground;  --highlight-gutter-background: $highlight-gutter-background;  --highlight-gutter-foreground: $highlight-gutter-foreground;  body&#123;    background: url(/images/leather.svg);    background-size: 600px, 600px;    background-repeat: repeat;    background-attachment: fixed;    background-position: center;  &#125;  color-scheme: light;&#125;if (hexo-config(&#x27;darkmode&#x27;)) &#123;  @media (prefers-color-scheme: dark) &#123;    :root &#123;      --body-bg-color: $body-bg-color-dark;      --content-bg-color: $content-bg-color-dark;      --card-bg-color: $card-bg-color-dark;      --text-color: $text-color-dark;      --selection-bg: $selection-bg-dark;      --selection-color: $selection-color-dark;      --blockquote-color: $blockquote-color-dark;      --link-color: $link-color-dark;      --link-hover-color: $link-hover-color-dark;      --brand-color: $brand-color-dark;      --brand-hover-color: $brand-hover-color-dark;      --table-row-odd-bg-color: $table-row-odd-bg-color-dark;      --table-row-hover-bg-color: $table-row-hover-bg-color-dark;      --menu-item-bg-color: $menu-item-bg-color-dark;      --theme-color: $theme-color-dark;      --btn-default-bg: $btn-default-bg-dark;      --btn-default-color: $btn-default-color-dark;      --btn-default-border-color: $btn-default-border-color-dark;      --btn-default-hover-bg: $btn-default-hover-bg-dark;      --btn-default-hover-color: $btn-default-hover-color-dark;      --btn-default-hover-border-color: $btn-default-hover-border-color-dark;      --highlight-background: $highlight-background-dark;      --highlight-foreground: $highlight-foreground-dark;      --highlight-gutter-background: $highlight-gutter-background-dark;      --highlight-gutter-foreground: $highlight-gutter-foreground-dark;      body&#123;        background: url(/images/leather_dark.svg);        background-size: 600px, 600px;        background-repeat: repeat;        background-attachment: fixed;        background-position: center;      &#125;      color-scheme: dark;    &#125;    img &#123;      opacity: .75;      &amp;:hover &#123;        opacity: .9;      &#125;    &#125;    iframe &#123;      color-scheme: light;    &#125;  &#125;&#125;if (hexo-config(&#x27;lightdark.enable&#x27;)) &#123;  +light-dark-block() &#123;    :root &#123;      --body-bg-color: light-dark($body-bg-color, $body-bg-color-dark);      --content-bg-color: light-dark($content-bg-color, $content-bg-color-dark);      --card-bg-color: light-dark($card-bg-color, $card-bg-color-dark);      --text-color: light-dark($text-color, $text-color-dark);      --selection-bg: light-dark($selection-bg, $selection-bg-dark);      --selection-color: light-dark($selection-color, $selection-color-dark);      --blockquote-color: light-dark($blockquote-color, $blockquote-color-dark);      --link-color: light-dark($link-color, $link-color-dark);      --link-hover-color: light-dark($link-hover-color, $link-hover-color-dark);      --brand-color: light-dark($brand-color, $brand-color-dark);      --brand-hover-color: light-dark($brand-hover-color, $brand-hover-color-dark);      --table-row-odd-bg-color: light-dark($table-row-odd-bg-color, $table-row-odd-bg-color-dark);      --table-row-hover-bg-color: light-dark($table-row-hover-bg-color, $table-row-hover-bg-color-dark);      --menu-item-bg-color: light-dark($menu-item-bg-color, $menu-item-bg-color-dark);      --theme-color: light-dark($theme-color, $theme-color-dark);      --btn-default-bg: light-dark($btn-default-bg, $btn-default-bg-dark);      --btn-default-color: light-dark($btn-default-color, $btn-default-color-dark);      --btn-default-border-color: light-dark($btn-default-border-color, $btn-default-border-color-dark);      --btn-default-hover-bg: light-dark($btn-default-hover-bg, $btn-default-hover-bg-dark);      --btn-default-hover-color: light-dark($btn-default-hover-color, $btn-default-hover-color-dark);      --btn-default-hover-border-color: light-dark($btn-default-hover-border-color, $btn-default-hover-border-color-dark);      color-scheme: light dark;      img &#123;        opacity: light-dark(1, .75);        &amp;:hover &#123;          opacity: light-dark(1, .9);        &#125;      &#125;      iframe &#123;        color-scheme: light;      &#125;    &#125;  &#125;&#125;\n\n至此，美化完成。\n\n","categories":["教程"],"tags":["建站","Hexo","NexT","美化"]},{"title":"Markdown 基本语法","url":"/zh-CN/37eb8784fd5f/","content":"\n总览\n几乎所有 Markdown 应用程序都支持 John Gruber 原始设计文档中列出的 Markdown 基本语法。\n\n\n标题\n要创建标题，请在单词或短语前面添加井号 (#) 。井号的数量代表了标题的级别。\n\n\n还可以在文本下方添加任意数量的 &#x3D;&#x3D; 号来标识一级标题，或者 – 号来标识二级标题。\n\n示例#### 标题4##### 标题5###### 标题6\n效果\n标题4标题5标题6\n最佳实践\n当井号（#）和标题文本之间没有空格时，各 Markdown 应用程序的处理方式是不一样的。为了兼容考虑，请在井号和标题文本之间添加一个空格。\n\n\n强调\n通过将文本设置为粗体或斜体来强调其重要性。\n\n\n要加粗文本，请在单词或短语的前后各添加两个星号（ asterisks ）或下划线（ underscores ）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（ asterisks ）。\n\n\n要用斜体显示文本，请在单词或短语前后添加一个星号（ asterisk ）或下划线（ underscore ）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。\n\n\n要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。\n\n示例**这是加粗的文字**__这是加粗的文字__这是**加粗**的文字*这是倾斜的文字*_这是倾斜的文字_这是*倾斜*的文字***这是加粗斜体的文字***___这是加粗斜体的文字_____*这是加粗斜体的文字*__**_这是加粗斜体的文字_**这是***加粗斜体***的文字\n效果这是加粗的文字这是加粗的文字这是加粗的文字这是倾斜的文字这是倾斜的文字这是倾斜的文字这是加粗斜体的文字这是加粗斜体的文字这是加粗斜体的文字这是加粗斜体的文字这是加粗斜体的文字\n最佳实践\nMarkdown 应用程序在如何处理单词或短语中间的下划线上并不一致。为兼容考虑，在单词或短语中间部分加粗的话，请使用星号（ asterisks ）。\n\n\nMarkdown 的众多应用程序在如何处理单词中间的下划线上意见不一致。为了兼容起见，请用星号标注单词中间的斜体来表示着重。\n\n\nMarkdown 应用程序在处理单词或短语中间添加的下划线上并不一致。为了实现兼容性，请使用星号将单词或短语的中间部分加粗并以斜体显示，以示重要。\n\n\n列表\n你可以将多个条目组织成有序或无序列表。\n\n\n要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\n\n\n要创建无序列表，请在每个列表项前面添加破折号 ( - )、星号 ( * ) 或加号 ( + ) 。缩进一个或多个列表项可创建嵌套列表。\n\n如果你需要以数字开头并且紧跟一个英文句号（也就是 .）的无序列表项，则可以使使用反斜线（\\）来 转义 这个英文句号。\n\n\n示例1. Red2. Green3. Blue\n1. Red1. Green1. Blue\n1. Red4. Green9. Blue\n1. Red2. Green    1. Green 1    2. Green 23. Blue\n- Red- Green- Blue\n* Red* Green* Blue\n+ Red+ Green+ Blue\n- Red- Green    - Green 1    - Green 2- Blue\n- 1989\\. 最好的一年- 2019\\. 第二好的一年\n效果\nRed\nGreen\nBlue\n\n\n\nRed\nGreen\nBlue\n\n\n\nRed\nGreen\nBlue\n\n\n\nRed\nGreen\nGreen 1\nGreen 2\n\n\nBlue\n\n\n\nRed\nGreen\nBlue\n\n\n\nRed\nGreen\nBlue\n\n\n\nRed\nGreen\nBlue\n\n\n\nRed\nGreen\nGreen 1\nGreen 2\n\n\nBlue\n\n\n\n1989. 最好的一年\n2019. 第二好的一年\n\n\n最佳实践\nCommonMark 和其它几种轻量级标记语言可以让你使用括号（)）作为分隔符（例如 1) Red），但并非所有的 Markdown 应用程序都支持此种用法，因此，从兼容的角度来看，此用法不推荐。为了兼容起见，请只使用英文句点作为分隔符。\n\n\nMarkdown 应用程序在如何处理同一列表中混用不同分隔符上并不一致。为了兼容起见，请不要在同一个列表中混用不同的分隔符，最好选定一种分隔符并一直用下去。\n\n\n块引用\n要创建块引用，请在段落前添加一个 &gt; 符号。\n\n\n块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。\n\n\n块引用可以包含其他 Markdown 格式的元素。\n\n示例&gt;这是引用的内容&gt;&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;这是引用的内容\n&gt;## 标题2&gt;- Red&gt;- Green&gt;- Blue&gt;&gt;这是**加粗***斜体**的文字\n效果\n这是引用的内容\n\n这是引用的内容\n\n这是引用的内容\n\n\n\n\n这是引用的内容\n\nRed\nGreen\nBlue\n\n这是加粗*斜体**的文字\n\n最佳实践\n为了兼容性，请在块引号之前和之后放置空行。\n\n代码\n要将单词或短语表示为代码，请将其包裹在反引号 ( &#96; ) 中。\n\n\n如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号( &#96;&#96; )中。\n\n\n要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。\n\n示例#include &lt;stdio.h&gt;int main() &#123;// 打印 Hello, World!printf(&quot;Hello, World!\\n&quot;);return 0;&#125;\n效果#include &lt;stdio.h&gt;\nint main() &#123;\n    // 打印 Hello, World!\n    printf(&quot;Hello, World!\\n&quot;);\n    return 0;\n&#125;\n\n分割线示例---- - - - -********________\n效果\n\n\n\n\n\n\n链接\n要创建链接，请将链接文本括在方括号中，后面紧跟着括在圆括号中的 URL（例如 (https://blog.mhxcalfred.com) ）。\n\n示例我的网站 [胡心小筑](https://blog.mhxcalfred.com)。\n效果我的网站 胡心小筑。\n\n图片\n要添加图片，首先请添加感叹号（!），然后紧跟着是方括号，方括号中可添加替代文本（alt text，即图片显示失败后显示此文本），最后跟着圆括号，圆括号中添加图片资源的路径或 URL。你可以选择在圆括号中的 URL 之后添加标题（即 title 属性）。\n\n示例![测试](201911200001.jpg)&#123;% asset_img 201911200001.jpg 测试 %&#125;\n效果\n\n\n\n","categories":["教程"],"tags":["Markdown"]},{"title":"Markdown 扩展语法","url":"/zh-CN/ebb2eba847fb/","content":"\n总览\n即便 John Gruber 的原始设计文档中所列出的 Markdown 基本语法 已经囊括了许多满足日常所需的元素，但对于某些人来说仍然不够。这就是 Markdown 扩展语法出现的缘由。\n\n\n一些个人和组织通过添加表格（tables）、代码块（code blocks）、语法高亮、将 URL 自动转换为链接和脚注（footnotes）等额外的元素来扩展 Markdown 的基本语法。这些额外添加的元素可以通过使用构建于 Markdown 之上的轻量级标记语言或通过向兼容的 Markdown 解析器添加扩展来启用这些新元素。\n\n\n表格\n如需添加表格，请使用三个或更多个连字符（ — ）来为每个列创建表头，并使用管道符（ | ）来分隔每个列。为兼容考虑，你还应该在行的两侧添加管道符。\n\n\n通过在标题行中的连字符（ hyphens ）的左侧或右侧或两侧添加冒号（ : ），可以将对应列中的文本向左或向右或居中对齐。\n\n示例|First Header | Second Header | Third Header||:----------- | :-----------: | -----------:||Content Cell | Content Cell  | Content Cell||Content Cell | Content Cell  | Content Cell|\n效果\n\n\nFirst Header\nSecond Header\nThird Header\n\n\n\nContent Cell\nContent Cell\nContent Cell\n\n\nContent Cell\nContent Cell\nContent Cell\n\n\n最佳实践\n你可以为表格中的文本设置格式。例如，可以添加 链接（ links ）、代码（ code ）（注意，只能为单词或短语添加反引号 ( &#96; ) ，不能添加 代码块（ code blocks ））以及 强调（ emphasis ）。\n\n\n不支持的格式包括标题（ headings ）、块引用（ blockquotes ）、列表（ lists ）、水平分割线（ horizontal rules ）、图片（ images ）或 HTML 标记。\n\n\n代码块\nMarkdown 的基本语法允许你通过缩进四个空格或一个制表符来创建 代码块 。如果你觉得不方便，可以试试围栏代码块（ fenced code blocks ）。根据 Markdown 解析器或编辑器的不同，代码块的前后可以使用三个反引号（ &#96;&#96;&#96; ）或三个波浪号（ ~~~ ）来标记围栏代码块。\n\n\n许多 Markdown 解析器都支持围栏代码块的语法高亮功能。此功能允许你为编写代码所用的编程语言添加带颜色的语法高亮显示。如需添加语法高亮，请在围栏代码块前的反引号旁指定所用的编程语言。\n\n示例~~~C#include &lt;stdio.h&gt;int main() {        // 打印 Hello, World!        printf(&quot;Hello, World!\\n&quot;);        return 0;}~~~  \n效果#include &lt;stdio.h&gt;int main() &#123;    // 打印 Hello, World!    printf(&quot;Hello, World!\\n&quot;);    return 0;&#125;\n\n\n删除线\n你可以贯穿单词的中心放一条横线从而删除这些单词。其效果看起来是这样的： 这样 。此功能允许你标记某些单词是错误的，不应该出现在文档中。在单词前面和后面分别放置两个波浪号（ ~~ ） 来表示删除这些单词。\n\n示例~~这是删除的文字~~\n效果这是删除的文字\n\n任务列表\n任务列表（task lists 或者 checklists）允许你创建带有复选框的项目列表。在支持任务列表的 Markdown 应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项前面添加破折号（-）和中间带空格的方括号（[ ]）。要选中复选框，请在方括号中间添加一个 x ，即（[\\x]）。\n\n示例- [x] 复选1- [x] 复选2- [ ] 复选3\n效果\n 复选1\n 复选2\n 复选3\n\n\n表情符号\n有两种方式可以将表情符号添加到 Markdown 文档中：将表情符号复制并粘贴到 Markdown 格式的文本中。\n\n\n在大多数情况下，你可以简单地从 Emojipedia 等来源复制表情符号，然后将其粘贴到文档中。许多 Markdown 应用程序就会自动以 Markdown 格式的文本来显示表情符号。从 Markdown 应用程序导出的 HTML 和 PDF 文件也是可以显示表情符号的。\n\n示例这是个表情: ❤️\n效果这是个表情: ❤️\n\n公式示例$$e=mc^2$$\n$$\\frac{\\partial u}{\\partial t}= h^2 \\left( \\frac{\\partial^2 u}{\\partial x^2} +\\frac{\\partial^2 u}{\\partial y^2} +\\frac{\\partial^2 u}{\\partial z^2}\\right)$$\n$$cos 2\\theta = \\cos^2 \\theta - \\sin^2 \\theta = 2 \\cos^2 \\theta - 1$$\n$$\\begin{aligned}\\dot{x} &amp; = \\sigma(y-x) \\\\\\\\\\dot{y} &amp; = \\rho x - y - xz \\\\\\\\\\dot{z} &amp; = -\\beta z + xy\\end{aligned}$$\n$$\\begin{aligned}a &amp;= b + c \\\\\\\\&amp;= d + e + f + g \\\\\\\\&amp;= h + i\\end{aligned}$$\n效果$$e&#x3D;mc^2$$\n$$\\frac{\\partial u}{\\partial t}&#x3D; h^2 \\left( \\frac{\\partial^2 u}{\\partial x^2} +\\frac{\\partial^2 u}{\\partial y^2} +\\frac{\\partial^2 u}{\\partial z^2}\\right)$$\n$$cos 2\\theta &#x3D; \\cos^2 \\theta - \\sin^2 \\theta &#x3D; 2 \\cos^2 \\theta - 1$$\n$$\\begin{aligned}\\dot{x} &amp; &#x3D; \\sigma(y-x) \\\\\\dot{y} &amp; &#x3D; \\rho x - y - xz \\\\\\dot{z} &amp; &#x3D; -\\beta z + xy\\end{aligned}$$\n$$\\begin{aligned}a &amp;&#x3D; b + c \\\\  &amp;&#x3D; d + e + f + g \\\\  &amp;&#x3D; h + i\\end{aligned}$$\n\n","categories":["教程"],"tags":["Markdown"]},{"title":"孤独的美食家 第八季 第八集 鸟取县鸟取市的鲣鱼和荷尔蒙面","url":"/zh-CN/32d6f2935659/","content":"\n剧情介绍　　出差篇中，原作漫画的作画担当者，已故的谷口次郎的故乡鸟取市为舞台。松重饰演的井之头五郎将首次登陆原作漫画第2卷的第6集，对粉丝来说可以说是圣地。井之头五郎因为工作去了鸟取。欣赏吉川贤一（远山俊也）推荐的市政府名产拉面后，出席了进口杂货的派对。不擅长喝酒的五郎无法拒绝被招待的红酒，犯了某失态。第二天变更了预定，吃完午饭后决定回家，但是店里全都在准备中。走了10多分钟终于出现的是母亲（渡边惠理饰）和女儿（伊藤修子饰）经营的远离繁华街道的情绪飘浮着的铁板烧店。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"曼达洛人 第一季 第三集 罪孽","url":"/zh-CN/03b4926a90df/","content":"\n剧情介绍　　曼达洛人带着伤痕回到客户处领取奖励。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"食戟之灵 第四季 神之皿 第七集 两位女王","url":"/zh-CN/04101641cbe9/","content":"\n剧情介绍　　激烈的战斗进入了第四回合！中央剩下的三名成员是司瑛士、小林龙胆和茜久保桃。叛军队也全力以赴，派出了一色慧、塔克米和薙切绘里奈！绘里奈终于参战，她的对手是茜久保桃！这场不容有失的战斗正式打响！\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"小雪","url":"/zh-CN/7bbf4878ee7e/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小雪\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小雪"]},{"title":"看见 第一季 第六集 丝绸","url":"/zh-CN/a5821f2a09fa/","content":"\n剧情介绍　　巴巴和他的家人遭到背叛。凯恩女王施展她的狡诈手段应对新的冲突。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"罪恶黑名单 第七季 第八集 哈瓦拉达","url":"/zh-CN/eefd808cdc4d/","content":"\n剧情介绍　　为了寻找一位老朋友的下落，雷德指示特工小组追查一名专门从事不可追踪资金转移的黑名单人物。同时，莉兹从女儿阿格尼丝那里收到了一些令人不安的消息。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"黑客军团 第四季 第八集 408 请求超时","url":"/zh-CN/c6a04d5e13ca/","content":"\n剧情介绍　　珍妮丝想要所有的东西。艾略特震惊了。\n\n","categories":["剧集"],"tags":["日常","USA Network"]},{"title":"力扣00001.两数之和","url":"/zh-CN/4ce06535e6e9/","content":"\n题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：\n输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。\n\n示例 2：\n输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2]\n\n示例 3：\n输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1]\n\n提示：\n$2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4$\n$-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9$\n$-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9$\n\n只会存在一个有效答案\n进阶：你可以想出一个时间复杂度小于 $O(n^2)$ 的算法吗？\n\n解决方法C++class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int, int&gt; hash_map;        for (int i = 0; i &lt; nums.size(); ++i) &#123;            int complement = target - nums[i];            if (hash_map.find(complement) != hash_map.end()) &#123;                return &#123;hash_map[complement], i&#125;;            &#125;            hash_map[nums[i]] = i;        &#125;        return &#123;&#125;;    &#125;&#125;;\n\n结果执行用时 : 12 ms, 击败 70.06% 使用 C++ 的用户\n内存消耗 : 10.2 MB, 击败 0.82% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) &#123;            int complement = target - nums[i];            if (map.containsKey(complement)) &#123;                return new int[]&#123;map.get(complement), i&#125;;            &#125;            map.put(nums[i], i);        &#125;        return new int[]&#123;&#125;;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 99.50% 使用 Java 的用户\n内存消耗 : 43.02 MB, 击败 5.10% 使用 Java 的用户\n\nPythonclass Solution(object):    def twoSum(self, nums, target):        &quot;&quot;&quot;        :type nums: List[int]        :type target: int        :rtype: List[int]        &quot;&quot;&quot;        num_indices = &#123;&#125;        for i, num in enumerate(nums):            complement = target - num            if complement in num_indices:                return [num_indices[complement], i]            num_indices[num] = i        return []\n\n结果执行用时 : 24 ms, 击败 78.55% 使用 Python 的用户\n内存消耗 : 13.66 MB, 击败 65.80% 使用 Python 的用户\n\nPython3class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        num_indices = &#123;&#125;        for i, num in enumerate(nums):            complement = target - num            if complement in num_indices:                return [num_indices[complement], i]            num_indices[num] = i        return []\n\n结果执行用时 : 40 ms, 击败 92.95% 使用 Python3 的用户\n内存消耗 : 17.39 MB, 击败 13.79% 使用 Python3 的用户\n\nC/** * Note: The returned array must be malloced, assume caller calls free(). */int* twoSum(int* nums, int numsSize, int target, int* returnSize) &#123;    int* result = (int*)malloc(2 * sizeof(int));    *returnSize = 0;    for (int i = 0; i &lt; numsSize - 1; i++) &#123;        for (int j = i + 1; j &lt; numsSize; j++) &#123;            if (nums[i] + nums[j] == target) &#123;                result[0] = i;                result[1] = j;                *returnSize = 2;                return result;            &#125;        &#125;    &#125;    free(result);    return NULL;&#125;\n\n结果执行用时 : 120 ms, 击败 67.82% 使用 C 的用户\n内存消耗 : 6.93 MB, 击败 49.60% 使用 C 的用户\n\nC#public class Solution &#123;    public int[] TwoSum(int[] nums, int target) &#123;        Dictionary&lt;int, int&gt; numIndices = new Dictionary&lt;int, int&gt;();        for (int i = 0; i &lt; nums.Length; i++) &#123;            int complement = target - nums[i];            if (numIndices.ContainsKey(complement)) &#123;                return new int[]&#123;numIndices[complement], i&#125;;            &#125;            numIndices[nums[i]] = i;        &#125;        return new int[]&#123;&#125;;    &#125;&#125;\n\n结果执行用时 : 140 ms, 击败 73.82% 使用 C# 的用户\n内存消耗 : 43.81 MB, 击败 32.02% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123;    const numIndices = new Map();    for (let i = 0; i &lt; nums.length; i++) &#123;        const complement = target - nums[i];        if (numIndices.has(complement)) &#123;            return [numIndices.get(complement), i];        &#125;        numIndices.set(nums[i], i);    &#125;    return [];&#125;;\n\n结果执行用时 : 68 ms, 击败 71.65% 使用 JavaScript 的用户\n内存消耗 : 42.16 MB, 击败 40.42% 使用 JavaScript 的用户\n\nTypeScriptfunction twoSum(nums: number[], target: number): number[] &#123;    const numIndices: Map&lt;number, number&gt; = new Map();    for (let i = 0; i &lt; nums.length; i++) &#123;        const complement: number = target - nums[i];        if (numIndices.has(complement)) &#123;            return [numIndices.get(complement)!, i];        &#125;        numIndices.set(nums[i], i);    &#125;    return [];&#125;\n\n结果执行用时 : 72 ms, 击败 68.51% 使用 TypeScript 的用户\n内存消耗 : 44.71 MB, 击败 30.74% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @param Integer $target     * @return Integer[]     */    function twoSum($nums, $target) &#123;        $numIndices = array();        foreach ($nums as $index =&gt; $num) &#123;            $complement = $target - $num;            if (array_key_exists($complement, $numIndices)) &#123;                return array($numIndices[$complement], $index);            &#125;            $numIndices[$num] = $index;        &#125;        return array();    &#125;&#125;\n\n结果执行用时 : 8 ms, 击败 99.66% 使用 PHP 的用户\n内存消耗 : 20.01 MB, 击败 7.01% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123;        var numIndices = [Int: Int]()        for (index, num) in nums.enumerated() &#123;            let complement = target - num            if let complementIndex = numIndices[complement] &#123;                return [complementIndex, index]            &#125;            numIndices[num] = index        &#125;        return []    &#125;&#125;\n\n结果执行用时 : 36 ms, 击败 93.84% 使用 Swift 的用户\n内存消耗 : 14.39 MB, 击败 7.81% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun twoSum(nums: IntArray, target: Int): IntArray &#123;        val numIndices = HashMap&lt;Int, Int&gt;()        for (i in nums.indices) &#123;            val complement = target - nums[i]            if (numIndices.containsKey(complement)) &#123;                return intArrayOf(numIndices[complement]!!, i)            &#125;            numIndices[nums[i]] = i        &#125;        return intArrayOf()    &#125;&#125;\n\n结果执行用时 : 204 ms, 击败 66.38% 使用 Kotlin 的用户\n内存消耗 : 37.57 MB, 击败 63.17% 使用 Kotlin 的用户\n\nDartclass Solution &#123;    List&lt;int&gt; twoSum(List&lt;int&gt; nums, int target) &#123;    Map&lt;int, int&gt; numIndices = &#123;&#125;;    for (int i = 0; i &lt; nums.length; i++) &#123;        int complement = target - nums[i];        if (numIndices.containsKey(complement)) &#123;        return [numIndices[complement]!, i];        &#125;        numIndices[nums[i]] = i;    &#125;    return [];    &#125;&#125;\n\n结果执行用时 : 256 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 155.91 MB, 击败 20.20% 使用 Dart 的用户\n\nGofunc twoSum(nums []int, target int) []int &#123;    numIndices := make(map[int]int)    for i, num := range nums &#123;        complement := target - num        if idx, ok := numIndices[complement]; ok &#123;            return []int&#123;idx, i&#125;        &#125;        numIndices[num] = i    &#125;    return []int&#123;&#125;&#125;\n\n结果执行用时 : 4 ms, 击败 94.26% 使用 Go 的用户\n内存消耗 : 4.02 MB, 击败 63.86% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @param &#123;Integer&#125; target# @return &#123;Integer[]&#125;def two_sum(nums, target)    num_indices = &#123;&#125;    nums.each_with_index do |num, index|        complement = target - num        if num_indices.key?(complement)            return [num_indices[complement], index]        end        num_indices[num] = index    end    return []end\n\n结果执行用时 : 68 ms, 击败 75.61% 使用 Ruby 的用户\n内存消耗 : 207.09 MB, 击败 41.46% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def twoSum(nums: Array[Int], target: Int): Array[Int] = &#123;    var numIndices = Map.empty[Int, Int]    for ((num, index) &lt;- nums.zipWithIndex) &#123;      val complement = target - num      if (numIndices.contains(complement)) &#123;        return Array(numIndices(complement), index)      &#125;      numIndices += (num -&gt; index)    &#125;    Array.empty[Int]  &#125;&#125;\n\n结果执行用时 : 564 ms, 击败 58.23% 使用 Scala 的用户\n内存消耗 : 55.63 MB, 击败 29.12% 使用 Scala 的用户\n\nRustuse std::collections::HashMap;impl Solution &#123;    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; &#123;        let mut num_indices = HashMap::new();        for (index, &amp;num) in nums.iter().enumerate() &#123;            let complement = target - num;            if let Some(&amp;complement_index) = num_indices.get(&amp;complement) &#123;                return vec![complement_index as i32, index as i32];            &#125;            num_indices.insert(num, index);        &#125;        vec![]    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.44 MB, 击败 29.41% 使用 Rust 的用户\n\nRacket(define (two-sum nums target)  (define (find-indexes nums index seen)    (cond      ((null? nums) &#x27;())      ((hash-has-key? seen (- target (car nums)))       (list (hash-ref seen (- target (car nums))) index))      (else       (hash-set! seen (car nums) index)       (find-indexes (cdr nums) (+ index 1) seen))))  (find-indexes nums 0 (make-hash)))\n\n结果执行用时 : 280 ms, 击败 42.86% 使用 Racket 的用户\n内存消耗 : 124.89 MB, 击败 14.29% 使用 Racket 的用户\n\nErlang-spec two_sum(Nums :: [integer()], Target :: integer()) -&gt; [integer()].two_sum(Nums, Target) -&gt;    lists:reverse(get_indices(Nums, Target, 0, length(Nums), #&#123;&#125;)).get_indices(_, _, _, 0, _) -&gt;    [];get_indices(Nums, Target, Index1, Index2, Seen) -&gt;    Head = hd(Nums),    RestNums = tl(Nums),    case maps:is_key(Target - Head, Seen) of        true -&gt;            [maps:get(Target - Head, Seen), Index1];        false -&gt;            NewSeen = maps:put(Head, Index1, Seen),            get_indices(RestNums, Target, Index1 + 1, Index2 - 1, NewSeen)    end.\n\n结果执行用时 : 216 ms, 击败 81.25% 使用 Erlang 的用户\n内存消耗 : 48.04 MB, 击败 50.00% 使用 Erlang 的用户\n\nElixirdefmodule Solution do  @spec two_sum(nums :: [integer], target :: integer) :: [integer]  def two_sum(nums, target) do    two_sum_helper(nums, target, 0, %&#123;&#125;)  end  defp two_sum_helper([], _, _, _), do: []  defp two_sum_helper([num | rest], target, index, seen) do    complement = target - num    case Map.get(seen, complement) do      nil -&gt;        two_sum_helper(rest, target, index + 1, Map.put(seen, num, index))      comp_index -&gt;        [comp_index, index]    end  endend\n\n结果执行用时 : 272 ms, 击败 77.78% 使用 Elixir 的用户\n内存消耗 : 61.56 MB, 击败 11.11% 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"黑闪电 第三季 第七集 抵抗之书：第二章：亨得森的创作","url":"/zh-CN/68f46abcd032/","content":"\n剧情介绍　　安妮莎与杰斐逊进行了一次心与心的交流，她告诉他，她需要黑闪电的帮助，把超能力难民带出安全区。与此同时，甘比恳求琳恩帮助他进入“坑”区域。最后，珍妮弗与布兰登的关系愈发亲密。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00002.两数相加","url":"/zh-CN/2cec71fed826/","content":"\n题目描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例 1：\n\n\n输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]输出：[7,0,8]解释：342 + 465 &#x3D; 807.\n\n示例 2：\n输入：l1 &#x3D; [0], l2 &#x3D; [0]输出：[0]\n\n示例 3：\n输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]输出：[8,9,9,9,0,0,0,1]\n\n提示：\n每个链表中的节点数在范围 [1, 100] 内\n0 &lt;&#x3D; Node.val &lt;&#x3D; 9\n题目数据保证列表表示的数字不含前导零\n\n\n解决方法C++/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        ListNode* dummy = new ListNode(0);        ListNode* current = dummy;        int carry = 0;        while (l1 || l2 || carry) &#123;            int val1 = (l1 != nullptr) ? l1-&gt;val : 0;            int val2 = (l2 != nullptr) ? l2-&gt;val : 0;            int sum = val1 + val2 + carry;            carry = sum / 10;            current-&gt;next = new ListNode(sum % 10);            current = current-&gt;next;            if (l1) l1 = l1-&gt;next;            if (l2) l2 = l2-&gt;next;        &#125;        return dummy-&gt;next;    &#125;&#125;;\n\n结果执行用时 : 24 ms, 击败 71.16% 使用 C++ 的用户\n内存消耗 : 70.01 MB, 击败 74.88% 使用 C++ 的用户\n\nJava/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        ListNode dummy = new ListNode(0);        ListNode current = dummy;        int carry = 0;        while (l1 != null || l2 != null || carry &gt; 0) &#123;            int val1 = (l1 != null) ? l1.val : 0;            int val2 = (l2 != null) ? l2.val : 0;            int sum = val1 + val2 + carry;            carry = sum / 10;            current.next = new ListNode(sum % 10);            current = current.next;            if (l1 != null) l1 = l1.next;            if (l2 != null) l2 = l2.next;        &#125;        return dummy.next;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 42.10 MB, 击败 49.96% 使用 Java 的用户\n\nPython# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution(object):    def addTwoNumbers(self, l1, l2):        &quot;&quot;&quot;        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        &quot;&quot;&quot;        dummy = ListNode(0)        current = dummy        carry = 0        while l1 or l2 or carry:            val1 = l1.val if l1 else 0            val2 = l2.val if l2 else 0            total = val1 + val2 + carry            carry = total // 10            current.next = ListNode(total % 10)            current = current.next            if l1:                l1 = l1.next            if l2:                l2 = l2.next        return dummy.next\n\n结果执行用时 : 40 ms, 击败 91.45% 使用 Python 的用户\n内存消耗 : 12.86 MB, 击败 97.89% 使用 Python 的用户\n\nPython3# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:        dummy = ListNode(0)        current = dummy        carry = 0        while l1 or l2 or carry:            val1 = l1.val if l1 else 0            val2 = l2.val if l2 else 0            total = val1 + val2 + carry            carry = total // 10            current.next = ListNode(total % 10)            current = current.next            if l1:                l1 = l1.next            if l2:                l2 = l2.next        return dummy.next\n\n结果执行用时 : 68 ms, 击败 38.97% 使用 Python3 的用户\n内存消耗 : 16.16 MB, 击败 17.37% 使用 Python3 的用户\n\nC/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     struct ListNode *next; * &#125;; */struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123;    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));    struct ListNode* current = dummy;    int carry = 0;    while (l1 != NULL || l2 != NULL || carry != 0) &#123;        int val1 = (l1 != NULL) ? l1-&gt;val : 0;        int val2 = (l2 != NULL) ? l2-&gt;val : 0;        int sum = val1 + val2 + carry;        carry = sum / 10;        current-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode));        current = current-&gt;next;        current-&gt;val = sum % 10;        current-&gt;next = NULL;        if (l1 != NULL) l1 = l1-&gt;next;        if (l2 != NULL) l2 = l2-&gt;next;    &#125;    struct ListNode* result = dummy-&gt;next;    free(dummy);    return result;&#125;\n\n结果执行用时 : 20 ms, 击败 14.59% 使用 C 的用户\n内存消耗 : 8.39 MB, 击败 27.32% 使用 C 的用户\n\nC#/** * Definition for singly-linked list. * public class ListNode &#123; *     public int val; *     public ListNode next; *     public ListNode(int val=0, ListNode next=null) &#123; *         this.val = val; *         this.next = next; *     &#125; * &#125; */public class Solution &#123;    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) &#123;        ListNode dummy = new ListNode(0);        ListNode current = dummy;        int carry = 0;        while (l1 != null || l2 != null || carry != 0) &#123;            int val1 = (l1 != null) ? l1.val : 0;            int val2 = (l2 != null) ? l2.val : 0;            int sum = val1 + val2 + carry;            carry = sum / 10;            current.next = new ListNode(sum % 10);            current = current.next;            if (l1 != null) l1 = l1.next;            if (l2 != null) l2 = l2.next;        &#125;        return dummy.next;    &#125;&#125;\n\n结果执行用时 : 72 ms, 击败 99.82% 使用 C# 的用户\n内存消耗 : 50.63 MB, 击败 5.13% 使用 C# 的用户\n\nJavaScript/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; */var addTwoNumbers = function(l1, l2) &#123;    let dummy = new ListNode(0);    let current = dummy;    let carry = 0;    while (l1 !== null || l2 !== null || carry !== 0) &#123;        let val1 = (l1 !== null) ? l1.val : 0;        let val2 = (l2 !== null) ? l2.val : 0;        let sum = val1 + val2 + carry;        carry = Math.floor(sum / 10);        current.next = new ListNode(sum % 10);        current = current.next;        if (l1 !== null) l1 = l1.next;        if (l2 !== null) l2 = l2.next;    &#125;    return dummy.next;&#125;;\n\n结果执行用时 : 92 ms, 击败 81.79% 使用 JavaScript 的用户\n内存消耗 : 45.96 MB, 击败 55.34% 使用 JavaScript 的用户\n\nTypeScript/** * Definition for singly-linked list. * class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null &#123;    let dummy = new ListNode(0);    let current = dummy;    let carry = 0;    while (l1 !== null || l2 !== null || carry !== 0) &#123;        let val1 = (l1 !== null) ? l1.val : 0;        let val2 = (l2 !== null) ? l2.val : 0;        let sum = val1 + val2 + carry;        carry = Math.floor(sum / 10);        current.next = new ListNode(sum % 10);        current = current.next;        if (l1 !== null) l1 = l1.next;        if (l2 !== null) l2 = l2.next;    &#125;    return dummy.next;&#125;\n\n结果执行用时 : 124 ms, 击败 15.47% 使用 TypeScript 的用户\n内存消耗 : 56.84 MB, 击败 5.07% 使用 TypeScript 的用户\n\nPHP/** * Definition for a singly-linked list. * class ListNode &#123; *     public $val = 0; *     public $next = null; *     function __construct($val = 0, $next = null) &#123; *         $this-&gt;val = $val; *         $this-&gt;next = $next; *     &#125; * &#125; */class Solution &#123;    /**     * @param ListNode $l1     * @param ListNode $l2     * @return ListNode     */    function addTwoNumbers($l1, $l2) &#123;        $dummy = new ListNode(0);        $current = $dummy;        $carry = 0;        while ($l1 !== null || $l2 !== null || $carry !== 0) &#123;            $val1 = ($l1 !== null) ? $l1-&gt;val : 0;            $val2 = ($l2 !== null) ? $l2-&gt;val : 0;            $sum = $val1 + $val2 + $carry;            $carry = intval($sum / 10);            $current-&gt;next = new ListNode($sum % 10);            $current = $current-&gt;next;            if ($l1 !== null) $l1 = $l1-&gt;next;            if ($l2 !== null) $l2 = $l2-&gt;next;        &#125;        return $dummy-&gt;next;    &#125;&#125;\n\n结果执行用时 : 12 ms, 击败 87.39% 使用 PHP 的用户\n内存消耗 : 18.92 MB, 击败 76.12% 使用 PHP 的用户\n\nSwift/** * Definition for singly-linked list. * public class ListNode &#123; *     public var val: Int *     public var next: ListNode? *     public init() &#123; self.val = 0; self.next = nil; &#125; *     public init(_ val: Int) &#123; self.val = val; self.next = nil; &#125; *     public init(_ val: Int, _ next: ListNode?) &#123; self.val = val; self.next = next; &#125; * &#125; */class Solution &#123;    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;        let dummy = ListNode(0)        var current: ListNode? = dummy        var carry = 0        var l1 = l1        var l2 = l2        while l1 != nil || l2 != nil || carry != 0 &#123;            let val1 = l1?.val ?? 0            let val2 = l2?.val ?? 0            let sum = val1 + val2 + carry            carry = sum / 10            current?.next = ListNode(sum % 10)            current = current?.next            l1 = l1?.next            l2 = l2?.next        &#125;        return dummy.next    &#125;&#125;\n\n结果执行用时 : 36 ms, 击败 65.63% 使用 Swift 的用户\n内存消耗 : 13.84 MB, 击败 50.15% 使用 Swift 的用户\n\nKotlin/** * Example: * var li = ListNode(5) * var v = li.`val` * Definition for singly-linked list. * class ListNode(var `val`: Int) &#123; *     var next: ListNode? = null * &#125; */class Solution &#123;    fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? &#123;        val dummy = ListNode(0)        var current: ListNode? = dummy        var carry = 0        var p1 = l1        var p2 = l2        while (p1 != null || p2 != null || carry != 0) &#123;            val val1 = p1?.`val` ?: 0            val val2 = p2?.`val` ?: 0            val sum = val1 + val2 + carry            carry = sum / 10            current?.next = ListNode(sum % 10)            current = current?.next            p1 = p1?.next            p2 = p2?.next        &#125;        return dummy.next    &#125;&#125;\n\n结果执行用时 : 224 ms, 击败 29.05% 使用 Kotlin 的用户\n内存消耗 : 43.02 MB, 击败 41.21% 使用 Kotlin 的用户\n\nDart/** * Definition for singly-linked list. * class ListNode &#123; *   int val; *   ListNode? next; *   ListNode([this.val = 0, this.next]); * &#125; */class Solution &#123;  ListNode? addTwoNumbers(ListNode? l1, ListNode? l2) &#123;    ListNode dummy = ListNode(0);    ListNode? current = dummy;    int carry = 0;    while (l1 != null || l2 != null || carry != 0) &#123;      int val1 = l1?.val ?? 0;      int val2 = l2?.val ?? 0;      int sum = val1 + val2 + carry;      carry = sum ~/ 10;      current!.next = ListNode(sum % 10);      current = current.next;      if (l1 != null) l1 = l1.next;      if (l2 != null) l2 = l2.next;    &#125;    return dummy.next;  &#125;&#125;\n\n结果执行用时 : 312 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 160.98 MB, 击败 85.71% 使用 Dart 的用户\n\nGo/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123;    dummy := &amp;ListNode&#123;&#125; // 创建一个哑节点    current := dummy    carry := 0    for l1 != nil || l2 != nil || carry != 0 &#123;        val1, val2 := 0, 0        if l1 != nil &#123;            val1 = l1.Val            l1 = l1.Next        &#125;        if l2 != nil &#123;            val2 = l2.Val            l2 = l2.Next        &#125;        sum := val1 + val2 + carry        carry = sum / 10        current.Next = &amp;ListNode&#123;Val: sum % 10&#125;        current = current.Next    &#125;    return dummy.Next&#125;\n\n结果执行用时 : 12 ms, 击败 31.30% 使用 Go 的用户\n内存消耗 : 4.15 MB, 击败 90.24% 使用 Go 的用户\n\nRuby# Definition for singly-linked list.# class ListNode#     attr_accessor :val, :next#     def initialize(val = 0, _next = nil)#         @val = val#         @next = _next#     end# end# @param &#123;ListNode&#125; l1# @param &#123;ListNode&#125; l2# @return &#123;ListNode&#125;def add_two_numbers(l1, l2)    dummy = ListNode.new(0)    current = dummy    carry = 0    while l1 || l2 || carry != 0        val1 = l1 ? l1.val : 0        val2 = l2 ? l2.val : 0        sum = val1 + val2 + carry        carry = sum / 10        current.next = ListNode.new(sum % 10)        current = current.next        l1 = l1.next if l1        l2 = l2.next if l2    end    dummy.nextend\n\n结果执行用时 : 100 ms, 击败 40.00% 使用 Ruby 的用户\n内存消耗 : 206.91 MB, 击败 8.00% 使用 Ruby 的用户\n\nScala/** * Definition for singly-linked list. * class ListNode(_x: Int = 0, _next: ListNode = null) &#123; *   var next: ListNode = _next *   var x: Int = _x * &#125; */object Solution &#123;  def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = &#123;    var dummy = new ListNode()    var current = dummy    var carry = 0    var p1 = l1    var p2 = l2    while (p1 != null || p2 != null || carry != 0) &#123;      val x = if (p1 != null) p1.x else 0      val y = if (p2 != null) p2.x else 0      val sum = x + y + carry      carry = sum / 10      current.next = new ListNode(sum % 10)      current = current.next      if (p1 != null) p1 = p1.next      if (p2 != null) p2 = p2.next    &#125;    dummy.next  &#125;&#125;\n\n结果执行用时 : 588 ms, 击败 53.33% 使用 Scala 的用户\n内存消耗 : 57.63 MB, 击败 66.67% 使用 Scala 的用户\n\nRust// Definition for singly-linked list.// #[derive(PartialEq, Eq, Clone, Debug)]// pub struct ListNode &#123;//   pub val: i32,//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;// &#125;//// impl ListNode &#123;//   #[inline]//   fn new(val: i32) -&gt; Self &#123;//     ListNode &#123;//       next: None,//       val//     &#125;//   &#125;// &#125;impl Solution &#123;    pub fn add_two_numbers(l1: Option&lt;Box&lt;ListNode&gt;&gt;, l2: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; &#123;        Self::add_two(&amp;l1, &amp;l2, 0)    &#125;    fn add_two(l1: &amp;Option&lt;Box&lt;ListNode&gt;&gt;, l2: &amp;Option&lt;Box&lt;ListNode&gt;&gt;, carry: i32) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; &#123;        match (l1, l2) &#123;            (None, None) =&gt; &#123;                if carry == 0 &#123;                    return None;                &#125;                Some(Box::new(ListNode::new(carry)))            &#125;            (None, Some(n2)) =&gt; Self::add_two(l2, l1, carry),            (Some(n1), None) =&gt; &#123;                let mut l1 = n1.clone();                let sum = carry + l1.val;                l1.val = sum % 10;                l1.next = Self::add_two(&amp;n1.next, &amp;None, sum / 10);                Some(l1)            &#125;            (Some(n1), Some(n2)) =&gt; &#123;                let mut l1 = n1.clone();                let mut l2 = n2.clone();                let sum = carry + l1.val + l2.val;                l1.val = sum % 10;                l1.next = Self::add_two(&amp;l1.next, &amp;l2.next, sum / 10);                Some(l1)            &#125;        &#125;    &#125;&#125;\n\n结果执行用时 : 12 ms, 击败 2.21% 使用 Rust 的用户\n内存消耗 : 2.15 MB, 击败 42.59% 使用 Rust 的用户\n\nRacket; Definition for singly-linked list:#|; val : integer?; next : (or/c list-node? #f)(struct list-node  (val next) #:mutable #:transparent); constructor(define (make-list-node [val 0])  (list-node val #f))|#(define (add-two-numbers l1 l2)  (define (calculate-carry x)    (quotient/remainder x 10))  (let loop ([list1 l1] [list2 l2] [remainder 0])    (match* (list1 list2)      [(#f #f) (if (zero? remainder) #f (make-list-node remainder))]      [((list-node val rest) #f)       (define-values (new-remainder result) (calculate-carry (+ val remainder)))       (list-node result (loop rest #f new-remainder))]      [(#f (list-node val rest))       (define-values (new-remainder result) (calculate-carry (+ val remainder)))       (list-node result (loop #f rest new-remainder))]      [((list-node val1 rest1) (list-node val2 rest2))       (define-values (new-remainder result) (calculate-carry (+ val1 val2 remainder)))       (list-node result (loop rest1 rest2 new-remainder))])))\n\n结果执行用时 : 280 ms, 击败 14.29% 使用 Racket 的用户\n内存消耗 : 124.67 MB, 击败 28.57% 使用 Racket 的用户\n\nErlang%% Definition for singly-linked list.%%%% -record(list_node, &#123;val = 0 :: integer(),%%                     next = null :: &#x27;null&#x27; | #list_node&#123;&#125;&#125;).-spec add_two_numbers(L1 :: #list_node&#123;&#125; | null, L2 :: #list_node&#123;&#125; | null) -&gt; #list_node&#123;&#125; | null.add_two_numbers(L1, L2) -&gt;    add_two_numbers(L1, L2, 0).add_two_numbers(null, null, 0) -&gt;    null;add_two_numbers(null, L2, Carry) -&gt;    add_carry(L2, Carry);add_two_numbers(L1, null, Carry) -&gt;    add_carry(L1, Carry);add_two_numbers(#list_node&#123;val = Val1, next = Next1&#125; = L1, #list_node&#123;val = Val2, next = Next2&#125;, Carry) -&gt;    &#123;Sum, NewCarry&#125; = calculate_carry(Val1 + Val2 + Carry),    #list_node&#123;val = Sum, next = add_two_numbers(Next1, Next2, NewCarry)&#125;.calculate_carry(Sum) when Sum &lt; 10 -&gt;    &#123;Sum, 0&#125;;calculate_carry(Sum) -&gt;    &#123;Sum rem 10, 1&#125;.add_carry(null, 0) -&gt;    null;add_carry(null, Carry) -&gt;    #list_node&#123;val = Carry, next = null&#125;;add_carry(#list_node&#123;val = Val, next = Next&#125;, Carry) -&gt;    &#123;Sum, NewCarry&#125; = calculate_carry(Val + Carry),    #list_node&#123;val = Sum, next = add_carry(Next, NewCarry)&#125;.\n\n结果执行用时 : 296 ms, 击败 20.00% 使用 Erlang 的用户\n内存消耗 : 49.96 MB, 击败 60.00% 使用 Erlang 的用户\n\nElixir# Definition for singly-linked list.## defmodule ListNode do#   @type t :: %__MODULE__&#123;#           val: integer,#           next: ListNode.t() | nil#         &#125;#   defstruct val: 0, next: nil# enddefmodule Solution do  @spec add_two_numbers(ListNode.t() | nil, ListNode.t() | nil) :: ListNode.t() | nil  def add_two_numbers(nil, nil), do: nil  def add_two_numbers(nil, l2), do: l2  def add_two_numbers(l1, nil), do: l1  def add_two_numbers(%ListNode&#123;val: val1, next: next1&#125; = l1, %ListNode&#123;val: val2, next: next2&#125; = l2) do    &#123;sum, carry&#125; = calculate_sum_and_carry(val1 + val2)    new_node = %ListNode&#123;val: sum, next: add_two_numbers(next1, next2)&#125;    adjust_node(new_node, carry)  end  defp calculate_sum_and_carry(sum) when sum &lt; 10, do: &#123;sum, 0&#125;  defp calculate_sum_and_carry(sum), do: &#123;rem(sum, 10), 1&#125;  defp adjust_node(node, 0), do: node  defp adjust_node(node, carry), do: %ListNode&#123;node | next: add_carry(node.next, carry)&#125;  defp add_carry(nil, 0), do: nil  defp add_carry(nil, carry), do: %ListNode&#123;val: carry, next: nil&#125;  defp add_carry(%ListNode&#123;val: val, next: next&#125;, carry) do    &#123;sum, new_carry&#125; = calculate_sum_and_carry(val + carry)    %ListNode&#123;val: sum, next: add_carry(next, new_carry)&#125;  endend\n\n结果执行用时 : 364 ms, 击败 100.00% 使用 Elixir 的用户\n内存消耗 : 68.29 MB, 击败 -% 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"闪电侠 第六季 第七集 巴里·艾伦的最后动摇 （1）","url":"/zh-CN/1324a73f95e6/","content":"\n剧情介绍　　罗索（Rosso）在他的控制下，袭击了中心城市，并将其大部分公民转变为他的“血兄弟姐妹”。思科和艾里斯（Iris）争论如何挽救巴里（Barry）和阻止罗索（Rosso），但他们的两个计划都失败了。但是，罗索（Rosso）选择不将其转换为制定计划的最后阶段。带着粒子加速器将他的血液散布在整个市中心。当他进入公司时，思科和艾里斯意识到在他们的最后一次相遇中，巴里利用他与罗索的联系秘密地拯救了他们，并告诉他们如何击败他。Flash结合了Rosso的血液，粒子加速器和Allegra的力量，颠覆了Rosso治愈中央城的计划。罗索（Rosso）挫败了他的计划，化身为鲜血怪物，杀死了Flash并重新开始，只是因为母亲的幻觉而分心，足以让速捷将他困在朗克的监狱中。当罗索被还给ARGUS的监护人Flash团队在危机爆发前度过了他们的最后时刻，就像红色的天空笼罩着他们一样。同时，纳什（Nash）在昏暗的灯光将他拉入室内之前，发现了符号墙。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"绿箭侠 第八季 第六集 重置","url":"/zh-CN/48ab206928c8/","content":"\n剧情介绍　　在被莱拉（Lyla）背叛后，奥利弗陷入了一个生死攸关的境地，这个情境似乎非常熟悉。与此同时，劳雷尔（Laurel）也有机会与过去和解，为自己曾经的错误弥补。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"杨丞琳 删·拾 以后","url":"/zh-CN/b3efe46b4434/","content":"\n专辑介绍取自谐音“三十以后”，《删·拾以后》这张专辑，是杨丞琳在迈向出道二十周年之际，一场“大人视角”的爱情回顾。\n已过而立，爱情不仅是甜蜜的关系，更是舍得的功夫。专辑中许多歌曲一再重申：删除放下，才能重拾爱情。《节日快乐》的舍得，在于“当我不再能够拥有你的笑”；《删拾》则更加坚定：“删拾后，你会有答案。”有些时刻，杨丞琳也会让我们在《Love Is Love》这样的歌曲里，重新看到纯真简单的爱情；但更多的是爱里的低谷、承受以及放手，一步步在《不可惜》《脸孔》《泥土》《我不认识你》这些歌曲之中捡拾感情碎片，在挫折中堆叠人生高度。\n柔情、深情、爱情，仍是杨丞琳的调性。而在此基础上，她力求成长，对音乐制作投入更多热情。出道以来，她不仅首次担任专辑制作人兼唱片策划，更找来陈绮贞、陈珊妮、ØZI、陈建骐等金牌创作阵容，共同带来一场而立之后，对青春的回顾整理。 \n展示正面侧面背面\n","categories":["音乐"],"tags":["杨丞琳","Apple Music"]},{"title":"力扣00003.无重复字符的最长子串","url":"/zh-CN/e515cf11c2a4/","content":"\n题目描述给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n示例 1：\n输入: s &#x3D; “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。\n\n示例 2：\n输入: s &#x3D; “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。\n\n示例 3：\n输入: s &#x3D; “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。\n\n提示：\n$0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 10^4$\ns 由英文字母、数字、符号和空格组成\n\n\n解决方法C++class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        unordered_map&lt;char, int&gt; charIndex;        int maxLength = 0, start = 0;        for (int i = 0; i &lt; s.length(); ++i) &#123;            if (charIndex.find(s[i]) != charIndex.end() &amp;&amp; charIndex[s[i]] &gt;= start) &#123;                start = charIndex[s[i]] + 1;            &#125; else &#123;                maxLength = max(maxLength, i - start + 1);            &#125;            charIndex[s[i]] = i;        &#125;        return maxLength;    &#125;&#125;;\n\n结果执行用时 : 12 ms, 击败 81.24% 使用 C++ 的用户\n内存消耗 : 8.53 MB, 击败 67.64% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int lengthOfLongestSubstring(String s) &#123;        HashMap&lt;Character, Integer&gt; charIndex = new HashMap&lt;&gt;();        int maxLength = 0, start = 0;        for (int i = 0; i &lt; s.length(); i++) &#123;            char currentChar = s.charAt(i);            if (charIndex.containsKey(currentChar) &amp;&amp; charIndex.get(currentChar) &gt;= start) &#123;                start = charIndex.get(currentChar) + 1;            &#125; else &#123;                maxLength = Math.max(maxLength, i - start + 1);            &#125;            charIndex.put(currentChar, i);        &#125;        return maxLength;    &#125;&#125;\n\n结果执行用时 : 5 ms, 击败 63.77% 使用 Java 的用户\n内存消耗 : 43.25 MB, 击败 7.96% 使用 Java 的用户\n\nPythonclass Solution(object):    def lengthOfLongestSubstring(self, s):        char_index = &#123;&#125;        max_length = start = 0        for i, char in enumerate(s):            if char in char_index and char_index[char] &gt;= start:                start = char_index[char] + 1            else:                max_length = max(max_length, i - start + 1)            char_index[char] = i        return max_length\n\n结果执行用时 : 36 ms, 击败 94.92% 使用 Python 的用户\n内存消耗 : 13.45 MB, 击败 66.22% 使用 Python 的用户\n\nPython3class Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        char_index = &#123;&#125;        max_length = start = 0        for i, char in enumerate(s):            if char in char_index and char_index[char] &gt;= start:                start = char_index[char] + 1            else:                max_length = max(max_length, i - start + 1)            char_index[char] = i        return max_length\n\n结果执行用时 : 48 ms, 击败 99.64% 使用 Python3 的用户\n内存消耗 : 18.11 MB, 击败 5.01% 使用 Python3 的用户\n\nCint lengthOfLongestSubstring(char* s) &#123;    int charIndex[128];    int maxLength = 0, start = 0;    for (int i = 0; i &lt; 128; i++) &#123;        charIndex[i] = -1;    &#125;    for (int i = 0; s[i] != &#x27;\\0&#x27;; i++) &#123;        char currentChar = s[i];        if (charIndex[currentChar] &gt;= start) &#123;            start = charIndex[currentChar] + 1;        &#125; else &#123;            maxLength = (i - start + 1) &gt; maxLength ? (i - start + 1) : maxLength;        &#125;        charIndex[currentChar] = i;    &#125;    return maxLength;&#125;\n\n结果执行用时 : 4 ms, 击败 83.04% 使用 C 的用户\n内存消耗 : 6.39 MB, 击败 81.61% 使用 C 的用户\n\nC#public class Solution &#123;    public int LengthOfLongestSubstring(string s) &#123;        int[] charIndex = new int[128];        int maxLength = 0, start = 0;        for (int i = 0; i &lt; 128; i++) &#123;            charIndex[i] = -1;        &#125;        for (int i = 0; i &lt; s.Length; i++) &#123;            char currentChar = s[i];            if (charIndex[currentChar] &gt;= start) &#123;                start = charIndex[currentChar] + 1;            &#125; else &#123;                maxLength = Math.Max(maxLength, i - start + 1);            &#125;            charIndex[currentChar] = i;        &#125;        return maxLength;    &#125;&#125;\n\n结果执行用时 : 44 ms, 击败 99.93% 使用 C# 的用户\n内存消耗 : 40.70 MB, 击败 27.18% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123;    let charIndex = &#123;&#125;;    let maxLength = 0;    let start = 0;    for (let i = 0; i &lt; s.length; i++) &#123;        let char = s[i];        if (charIndex[char] !== undefined &amp;&amp; charIndex[char] &gt;= start) &#123;            start = charIndex[char] + 1;        &#125; else &#123;            maxLength = Math.max(maxLength, i - start + 1);        &#125;        charIndex[char] = i;    &#125;    return maxLength;&#125;;\n\n结果执行用时 : 84 ms, 击败 59.77% 使用 JavaScript 的用户\n内存消耗 : 46.90 MB, 击败 30.01% 使用 JavaScript 的用户\n\nTypeScriptfunction lengthOfLongestSubstring(s: string): number &#123;    let charIndex: &#123; [key: string]: number &#125; = &#123;&#125;;    let maxLength = 0;    let start = 0;    for (let i = 0; i &lt; s.length; i++) &#123;        let char = s[i];        if (charIndex[char] !== undefined &amp;&amp; charIndex[char] &gt;= start) &#123;            start = charIndex[char] + 1;        &#125; else &#123;            maxLength = Math.max(maxLength, i - start + 1);        &#125;        charIndex[char] = i;    &#125;    return maxLength;&#125;\n\n结果执行用时 : 88 ms, 击败 58.76% 使用 TypeScript 的用户\n内存消耗 : 47.76 MB, 击败 38.63% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String $s     * @return Integer     */    function lengthOfLongestSubstring($s) &#123;        $charIndex = [];        $maxLength = 0;        $start = 0;        for ($i = 0; $i &lt; strlen($s); $i++) &#123;            $char = $s[$i];            if (array_key_exists($char, $charIndex) &amp;&amp; $charIndex[$char] &gt;= $start) &#123;                $start = $charIndex[$char] + 1;            &#125; else &#123;                $maxLength = max($maxLength, $i - $start + 1);            &#125;            $charIndex[$char] = $i;        &#125;        return $maxLength;    &#125;&#125;\n\n结果执行用时 : 20 ms, 击败 49.42% 使用 PHP 的用户\n内存消耗 : 19.57 MB, 击败 10.46% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123;        var charIndex = [Character: Int]()        var maxLength = 0        var start = 0        for (i, char) in s.enumerated() &#123;            if let index = charIndex[char], index &gt;= start &#123;                start = index + 1            &#125; else &#123;                maxLength = max(maxLength, i - start + 1)            &#125;            charIndex[char] = i        &#125;        return maxLength    &#125;&#125;\n\n结果执行用时 : 16 ms, 击败 62.76% 使用 Swift 的用户\n内存消耗 : 15.63 MB, 击败 5.14% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun lengthOfLongestSubstring(s: String): Int &#123;        val charIndex = mutableMapOf&lt;Char, Int&gt;()        var maxLength = 0        var start = 0        for (i in s.indices) &#123;            val char = s[i]            if (charIndex.containsKey(char) &amp;&amp; charIndex[char]!! &gt;= start) &#123;                start = charIndex[char]!! + 1            &#125; else &#123;                maxLength = maxLength.coerceAtLeast(i - start + 1)            &#125;            charIndex[char] = i        &#125;        return maxLength    &#125;&#125;\n\n结果执行用时 : 208 ms, 击败 60.94% 使用 Kotlin 的用户\n内存消耗 : 36.87 MB, 击败 39.48% 使用 Kotlin 的用户\n\nDartclass Solution &#123;    int lengthOfLongestSubstring(String s) &#123;    Map&lt;String, int&gt; charIndex = &#123;&#125;;    int maxLength = 0, start = 0;    for (int i = 0; i &lt; s.length; i++) &#123;        String char = s[i];        if (charIndex.containsKey(char) &amp;&amp; charIndex[char]! &gt;= start) &#123;        start = charIndex[char]! + 1;        &#125; else &#123;        maxLength = maxLength &gt; i - start + 1 ? maxLength : i - start + 1;        &#125;        charIndex[char] = i;    &#125;    return maxLength;    &#125;&#125;\n\n结果执行用时 : 352 ms, 击败 41.18% 使用 Dart 的用户\n内存消耗 : 147.63 MB, 击败 97.06% 使用 Dart 的用户\n\nGofunc lengthOfLongestSubstring(s string) int &#123;    charIndex := make(map[byte]int)    maxLength, start := 0, 0    for i := 0; i &lt; len(s); i++ &#123;        if index, exists := charIndex[s[i]]; exists &amp;&amp; index &gt;= start &#123;            start = index + 1        &#125; else &#123;            maxLength = max(maxLength, i-start+1)        &#125;        charIndex[s[i]] = i    &#125;    return maxLength&#125;\n\n结果执行用时 : 4 ms, 击败 88.47% 使用 Go 的用户\n内存消耗 : 3.07 MB, 击败 23.56% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; s# @return &#123;Integer&#125;def length_of_longest_substring(s)    char_index = &#123;&#125;    max_length = start = 0    s.each_char.with_index do |char, i|        if char_index.key?(char) &amp;&amp; char_index[char] &gt;= start            start = char_index[char] + 1        else            max_length = [max_length, i - start + 1].max        end        char_index[char] = i    end    max_lengthend\n\n结果执行用时 : 80 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.75 MB, 击败 15.79% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def lengthOfLongestSubstring(s: String): Int = &#123;    var charIndex = Map[Char, Int]()    var maxLength = 0    var start = 0    for (i &lt;- s.indices) &#123;      val char = s(i)      if (charIndex.contains(char) &amp;&amp; charIndex(char) &gt;= start) &#123;        start = charIndex(char) + 1      &#125; else &#123;        maxLength = maxLength.max(i - start + 1)      &#125;      charIndex += (char -&gt; i)    &#125;    maxLength  &#125;&#125;\n\n结果执行用时 : 596 ms, 击败 38.89% 使用 Scala 的用户\n内存消耗 : 58.82 MB, 击败 5.55% 使用 Scala 的用户\n\nRustuse std::collections::HashMap;impl Solution &#123;    pub fn length_of_longest_substring(s: String) -&gt; i32 &#123;        let mut char_index = HashMap::new(); // 用于存储字符的索引        let mut max_length = 0;        let mut start = 0;        for (i, c) in s.chars().enumerate() &#123;            if let Some(&amp;index) = char_index.get(&amp;c) &#123;                if index &gt;= start &#123;                    start = index + 1;                &#125;            &#125;            max_length = max_length.max(i - start + 1);            char_index.insert(c, i);        &#125;        max_length as i32    &#125;&#125;\n\n结果执行用时 : 4 ms, 击败 69.79% 使用 Rust 的用户\n内存消耗 : 2.14 MB, 击败 61.59% 使用 Rust 的用户\n\nRacket(define (length-of-longest-substring s)  (define left 0)  (define cur-len 0)  (define max-len 0)  (define lookup (mutable-set))  (define (update-lengths! c)    (let loop ()      (when (set-member? lookup c)        (set-remove! lookup (string-ref s left))        (set! left (+ left 1))        (set! cur-len (- cur-len 1))        (loop))))    (for ([c s])    (update-lengths! c)    (set-add! lookup c)    (set! cur-len (+ cur-len 1))    (set! max-len (max cur-len max-len)))    max-len)\n\n结果执行用时 : 224 ms, 击败 66.67% 使用 Racket 的用户\n内存消耗 : 99.09 MB, 击败 66.67% 使用 Racket 的用户\n\nErlang-spec length_of_longest_substring(S :: unicode:unicode_binary()) -&gt; integer().length_of_longest_substring(S) -&gt;    StrList = unicode:characters_to_list(S),    the_max_length(StrList, 0, queue:new(), sets:new([&#123;version, 2&#125;]), 0).the_max_length([Char | RestChars], Length, Window, CharSet, MaxLength) -&gt;    case sets:is_element(Char, CharSet) of        false -&gt;              the_max_length(RestChars, Length + 1, queue:in(Char, Window), sets:add_element(Char, CharSet), MaxLength);        true -&gt;             &#123;CharSet1, Win1&#125; = remove_from_window(CharSet, Window, Char),            the_max_length(RestChars, queue:len(Win1) + 1, queue:in(Char, Win1), sets:add_element(Char, CharSet1), max(MaxLength, Length))    end;the_max_length([], Length, _, _, MaxLength) -&gt; max(MaxLength, Length).remove_from_window(CharSet, Window, Char) -&gt;    case queue:is_empty(Window) of        true -&gt; &#123;CharSet, Window&#125;;        false -&gt;            &#123;&#123;value, W&#125;, Win1&#125; = queue:out(Window),            CharSet1 = sets:del_element(W, CharSet),            case sets:is_element(Char, CharSet1) of                true -&gt;                     remove_from_window(CharSet1, Win1, Char);                false -&gt; &#123;CharSet1, Win1&#125;            end    end.\n\n结果执行用时 : 300 ms, 击败 100.00% 使用 Erlang 的用户\n内存消耗 : 58.43 MB, 击败 100.00% 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00004.寻找两个正序数组的中位数","url":"/zh-CN/142cf4ce617d/","content":"\n题目描述给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n算法的时间复杂度应该为 O(log (m+n)) 。\n示例 1：\n输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]输出：2.00000解释：合并数组 &#x3D; [1,2,3] ，中位数 2\n\n示例 2：\n输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]输出：2.50000解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5\n\n提示：\nnums1.length &#x3D;&#x3D; m\nnums2.length &#x3D;&#x3D; n\n0 &lt;&#x3D; m &lt;&#x3D; 1000\n0 &lt;&#x3D; n &lt;&#x3D; 1000\n1 &lt;&#x3D; m + n &lt;&#x3D; 2000\n$-10^6 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 10^6$\n\n\n解决方法C++class Solution &#123;public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int m = nums1.size();        int n = nums2.size();        if (m &gt; n) &#123;            swap(nums1, nums2);            swap(m, n);        &#125;        int left = 0, right = m;        int halfLen = (m + n + 1) / 2;        while (left &lt;= right) &#123;            int partition1 = (left + right) / 2;            int partition2 = halfLen - partition1;            int maxLeft1 = (partition1 == 0) ? INT_MIN : nums1[partition1 - 1];            int minRight1 = (partition1 == m) ? INT_MAX : nums1[partition1];            int maxLeft2 = (partition2 == 0) ? INT_MIN : nums2[partition2 - 1];            int minRight2 = (partition2 == n) ? INT_MAX : nums2[partition2];            if (maxLeft1 &lt;= minRight2 &amp;&amp; maxLeft2 &lt;= minRight1) &#123;                if ((m + n) % 2 == 0) &#123;                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0;                &#125; else &#123;                    return max(maxLeft1, maxLeft2);                &#125;            &#125; else if (maxLeft1 &gt; minRight2) &#123;                right = partition1 - 1;            &#125; else &#123;                left = partition1 + 1;            &#125;        &#125;        return 0.0;    &#125;&#125;;\n\n结果执行用时 : 28 ms, 击败 63.85% 使用 C++ 的用户\n内存消耗 : 87.49 MB, 击败 90.99% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;        int m = nums1.length;        int n = nums2.length;        if (m &gt; n) &#123;            int[] temp = nums1;            nums1 = nums2;            nums2 = temp;            int tmp = m;            m = n;            n = tmp;        &#125;        int left = 0, right = m, halfLen = (m + n + 1) / 2;        while (left &lt;= right) &#123;            int partition1 = (left + right) / 2;            int partition2 = halfLen - partition1;            int maxLeft1 = (partition1 == 0) ? Integer.MIN_VALUE : nums1[partition1 - 1];            int minRight1 = (partition1 == m) ? Integer.MAX_VALUE : nums1[partition1];            int maxLeft2 = (partition2 == 0) ? Integer.MIN_VALUE : nums2[partition2 - 1];            int minRight2 = (partition2 == n) ? Integer.MAX_VALUE : nums2[partition2];            if (maxLeft1 &lt;= minRight2 &amp;&amp; maxLeft2 &lt;= minRight1) &#123;                if ((m + n) % 2 == 0) &#123;                    return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;                &#125; else &#123;                    return Math.max(maxLeft1, maxLeft2);                &#125;            &#125; else if (maxLeft1 &gt; minRight2) &#123;                right = partition1 - 1;            &#125; else &#123;                left = partition1 + 1;            &#125;        &#125;        return 0.0;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 44.79 MB, 击败 5.05% 使用 Java 的用户\n\nPythonclass Solution(object):    def findMedianSortedArrays(self, nums1, nums2):        def find_kth(nums1, start1, nums2, start2, k):            if start1 &gt;= len(nums1):                return nums2[start2 + k - 1]            if start2 &gt;= len(nums2):                return nums1[start1 + k - 1]            if k == 1:                return min(nums1[start1], nums2[start2])            mid_val1 = nums1[start1 + k // 2 - 1] if start1 + k // 2 - 1 &lt; len(nums1) else float(&#x27;inf&#x27;)            mid_val2 = nums2[start2 + k // 2 - 1] if start2 + k // 2 - 1 &lt; len(nums2) else float(&#x27;inf&#x27;)            if mid_val1 &lt; mid_val2:                return find_kth(nums1, start1 + k // 2, nums2, start2, k - k // 2)            else:                return find_kth(nums1, start1, nums2, start2 + k // 2, k - k // 2)        total_len = len(nums1) + len(nums2)        if total_len % 2 == 1:            return find_kth(nums1, 0, nums2, 0, total_len // 2 + 1)        else:            return (find_kth(nums1, 0, nums2, 0, total_len // 2) + find_kth(nums1, 0, nums2, 0, total_len // 2 + 1)) / 2.0\n\n结果执行用时 : 44 ms, 击败 36.83% 使用 Python 的用户\n内存消耗 : 13.29 MB, 击败 18.41% 使用 Python 的用户\n\nPython3class Solution:    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:        def find_kth(nums1, start1, nums2, start2, k):            if start1 &gt;= len(nums1):                return nums2[start2 + k - 1]            if start2 &gt;= len(nums2):                return nums1[start1 + k - 1]            if k == 1:                return min(nums1[start1], nums2[start2])            mid_val1 = nums1[start1 + k // 2 - 1] if start1 + k // 2 - 1 &lt; len(nums1) else float(&#x27;inf&#x27;)            mid_val2 = nums2[start2 + k // 2 - 1] if start2 + k // 2 - 1 &lt; len(nums2) else float(&#x27;inf&#x27;)            if mid_val1 &lt; mid_val2:                return find_kth(nums1, start1 + k // 2, nums2, start2, k - k // 2)            else:                return find_kth(nums1, start1, nums2, start2 + k // 2, k - k // 2)        total_len = len(nums1) + len(nums2)        if total_len % 2 == 1:            return find_kth(nums1, 0, nums2, 0, total_len // 2 + 1)        else:            return (find_kth(nums1, 0, nums2, 0, total_len // 2) + find_kth(nums1, 0, nums2, 0, total_len // 2 + 1)) / 2.0\n\n结果执行用时 : 52 ms, 击败 65.76% 使用 Python3 的用户\n内存消耗 : 18.09 MB, 击败 5.00% 使用 Python3 的用户\n\nCdouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) &#123;    int totalSize = nums1Size + nums2Size;    int *mergedArray = (int *)malloc(sizeof(int) * totalSize);    int i = 0, j = 0, k = 0;    while (i &lt; nums1Size &amp;&amp; j &lt; nums2Size) &#123;        if (nums1[i] &lt;= nums2[j]) &#123;            mergedArray[k++] = nums1[i++];        &#125; else &#123;            mergedArray[k++] = nums2[j++];        &#125;    &#125;    while (i &lt; nums1Size) &#123;        mergedArray[k++] = nums1[i++];    &#125;    while (j &lt; nums2Size) &#123;        mergedArray[k++] = nums2[j++];    &#125;    if (totalSize % 2 == 0) &#123;        return (double)(mergedArray[totalSize / 2 - 1] + mergedArray[totalSize / 2]) / 2.0;    &#125; else &#123;        return (double)mergedArray[totalSize / 2];    &#125;&#125;\n\n结果执行用时 : 12 ms, 击败 83.01% 使用 C 的用户\n内存消耗 : 7.38 MB, 击败 15.06% 使用 C 的用户\n\nC#public class Solution &#123;    public double FindMedianSortedArrays(int[] nums1, int[] nums2) &#123;        int m = nums1.Length;        int n = nums2.Length;        if (m &gt; n) &#123;            int[] temp = nums1;            nums1 = nums2;            nums2 = temp;            int tmp = m;            m = n;            n = tmp;        &#125;        int left = 0, right = m, halfLen = (m + n + 1) / 2;        while (left &lt;= right) &#123;            int partition1 = (left + right) / 2;            int partition2 = halfLen - partition1;            int maxLeft1 = (partition1 == 0) ? int.MinValue : nums1[partition1 - 1];            int minRight1 = (partition1 == m) ? int.MaxValue : nums1[partition1];            int maxLeft2 = (partition2 == 0) ? int.MinValue : nums2[partition2 - 1];            int minRight2 = (partition2 == n) ? int.MaxValue : nums2[partition2];            if (maxLeft1 &lt;= minRight2 &amp;&amp; maxLeft2 &lt;= minRight1) &#123;                if ((m + n) % 2 == 0) &#123;                    return (Math.Max(maxLeft1, maxLeft2) + Math.Min(minRight1, minRight2)) / 2.0;                &#125; else &#123;                    return Math.Max(maxLeft1, maxLeft2);                &#125;            &#125; else if (maxLeft1 &gt; minRight2) &#123;                right = partition1 - 1;            &#125; else &#123;                left = partition1 + 1;            &#125;        &#125;        return 0.0;    &#125;&#125;\n\n结果执行用时 : 84 ms, 击败 97.55% 使用 C# 的用户\n内存消耗 : 53.73 MB, 击败 5.22% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */var findMedianSortedArrays = function(nums1, nums2) &#123;    const mergedArray = [...nums1, ...nums2].sort((a, b) =&gt; a - b);    const totalLength = mergedArray.length;    if (totalLength % 2 === 0) &#123;        const midIndex = totalLength / 2;        return (mergedArray[midIndex - 1] + mergedArray[midIndex]) / 2;    &#125; else &#123;        return mergedArray[Math.floor(totalLength / 2)];    &#125;&#125;;\n\n结果执行用时 : 108 ms, 击败 38.49% 使用 JavaScript 的用户\n内存消耗 : 54.34 MB, 击败 5.09% 使用 JavaScript 的用户\n\nTypeScriptfunction findMedianSortedArrays(nums1: number[], nums2: number[]): number &#123;  const n = nums1.length + nums2.length;  return (findKth(nums1, nums2, n &gt;&gt; 1) + findKth(nums1, nums2, (n - 1) &gt;&gt; 1)) / 2;  function findKth(nums1: number[], nums2: number[], k: number): number &#123;    if (nums1.length === 0) return nums2[k];    if (nums2.length === 0) return nums1[k];    const i1 = nums1.length &gt;&gt; 1;    const i2 = nums2.length &gt;&gt; 1;    const m1 = nums1[i1];    const m2 = nums2[i2];    if (i1 + i2 &lt; k) &#123;      if (m1 &gt; m2) &#123;        return findKth(nums1, nums2.slice(i2 + 1), k - (i2 + 1));      &#125; else &#123;        return findKth(nums1.slice(i1 + 1), nums2, k - (i1 + 1));      &#125;    &#125; else &#123;      if (m1 &gt; m2) &#123;        return findKth(nums1.slice(0, i1), nums2, k);      &#125; else &#123;        return findKth(nums1, nums2.slice(0, i2), k);      &#125;    &#125;  &#125;&#125;\n\n结果执行用时 : 88 ms, 击败 95.23% 使用 TypeScript 的用户\n内存消耗 : 46.54 MB, 击败 55.23% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums1     * @param Integer[] $nums2     * @return Float     */    function findMedianSortedArrays($nums1, $nums2) &#123;        $m = count($nums1);        $n = count($nums2);        if ($m &gt; $n) &#123;            $temp = $nums1;            $nums1 = $nums2;            $nums2 = $temp;            $temp = $m;            $m = $n;            $n = $temp;        &#125;        $left = 0;        $right = $m;        $halfLen = intval(($m + $n + 1) / 2);        while ($left &lt;= $right) &#123;            $partition1 = intval(($left + $right) / 2);            $partition2 = $halfLen - $partition1;            $maxLeft1 = ($partition1 == 0) ? PHP_INT_MIN : $nums1[$partition1 - 1];            $minRight1 = ($partition1 == $m) ? PHP_INT_MAX : $nums1[$partition1];            $maxLeft2 = ($partition2 == 0) ? PHP_INT_MIN : $nums2[$partition2 - 1];            $minRight2 = ($partition2 == $n) ? PHP_INT_MAX : $nums2[$partition2];            if ($maxLeft1 &lt;= $minRight2 &amp;&amp; $maxLeft2 &lt;= $minRight1) &#123;                if (($m + $n) % 2 == 0) &#123;                    return (max($maxLeft1, $maxLeft2) + min($minRight1, $minRight2)) / 2.0;                &#125; else &#123;                    return max($maxLeft1, $maxLeft2);                &#125;            &#125; elseif ($maxLeft1 &gt; $minRight2) &#123;                $right = $partition1 - 1;            &#125; else &#123;                $left = $partition1 + 1;            &#125;        &#125;        return 0.0;    &#125;&#125;\n\n结果执行用时 : 20 ms, 击败 96.20% 使用 PHP 的用户\n内存消耗 : 19.61 MB, 击败 5.06% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -&gt; Double &#123;        var mergeArray = [Int](repeating: 0, count: nums1.count + nums2.count)        var i = 0        var j = 0        var index = 0        while index &lt; mergeArray.count &#123;            if j &gt;= nums2.count || (i &lt; nums1.count &amp;&amp; nums1[i] &lt;= nums2[j]) &#123;                mergeArray[index] = nums1[i]                i += 1            &#125; else &#123;                mergeArray[index] = nums2[j]                j += 1            &#125;            index += 1        &#125;        if mergeArray.count % 2 == 0 &#123;            return Double(mergeArray[mergeArray.count / 2 - 1] + mergeArray[mergeArray.count / 2]) / 2.0        &#125; else &#123;            return Double(mergeArray[mergeArray.count / 2])        &#125;    &#125;&#125;\n\n结果执行用时 : 72 ms, 击败 22.31% 使用 Swift 的用户\n内存消耗 : 15.58 MB, 击败 5.79% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double &#123;        val mergeArray = IntArray(nums1.size + nums2.size)        var i = 0        var j = 0        var index = 0        while (index &lt; mergeArray.size) &#123;            if (j &gt;= nums2.size || (i &lt; nums1.size &amp;&amp; nums1[i] &lt;= nums2[j])) &#123;                mergeArray[index] = nums1[i]                i++            &#125; else &#123;                mergeArray[index] = nums2[j]                j++            &#125;            index++        &#125;        return if (mergeArray.size % 2 == 0) &#123;            (mergeArray[mergeArray.size / 2 - 1] + mergeArray[mergeArray.size / 2]) / 2.0        &#125; else &#123;            mergeArray[mergeArray.size / 2].toDouble()        &#125;    &#125;&#125;\n\n结果执行用时 : 268 ms, 击败 63.00% 使用 Kotlin 的用户\n内存消耗 : 46.55 MB, 击败 56.00% 使用 Kotlin 的用户\n\nDartclass Solution &#123;    double findMedianSortedArrays(List&lt;int&gt; nums1, List&lt;int&gt; nums2) &#123;    int totalLength = nums1.length + nums2.length;    int mid = totalLength ~/ 2;    int i = 0, j = 0;    int prev = 0, current = 0;    while (i + j &lt;= mid) &#123;        prev = current;        if (i &lt; nums1.length &amp;&amp; (j &gt;= nums2.length || nums1[i] &lt;= nums2[j])) &#123;        current = nums1[i];        i++;        &#125; else &#123;        current = nums2[j];        j++;        &#125;    &#125;    if (totalLength.isOdd) &#123;        return current.toDouble();    &#125; else &#123;        return (prev + current) / 2.0;    &#125;    &#125;&#125;\n\n结果执行用时 : 396 ms, 击败 43.75% 使用 Dart 的用户\n内存消耗 : 148.22 MB, 击败 87.50% 使用 Dart 的用户\n\nGofunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 &#123;    totalLength := len(nums1) + len(nums2)    mid := totalLength / 2    i, j := 0, 0    prev, current := 0, 0    for i+j &lt;= mid &#123;        prev = current        if i &lt; len(nums1) &amp;&amp; (j &gt;= len(nums2) || nums1[i] &lt;= nums2[j]) &#123;            current = nums1[i]            i++        &#125; else &#123;            current = nums2[j]            j++        &#125;    &#125;    if totalLength%2 == 1 &#123;        return float64(current)    &#125;    return float64(prev+current) / 2.0&#125;\n\n结果执行用时 : 8 ms, 击败 90.78% 使用 Go 的用户\n内存消耗 : 4.59 MB, 击败 99.81% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums1# @param &#123;Integer[]&#125; nums2# @return &#123;Float&#125;def find_median_sorted_arrays(nums1, nums2)  total_length = nums1.length + nums2.length  mid = total_length / 2  i = 0  j = 0  prev = 0  current = 0  while i + j &lt;= mid    prev = current    if i &lt; nums1.length &amp;&amp; (j &gt;= nums2.length || nums1[i] &lt;= nums2[j])      current = nums1[i]      i += 1    else      current = nums2[j]      j += 1    end  end  if total_length % 2 == 1    return current.to_f  else    return (prev + current) / 2.0  endend\n\n结果执行用时 : 88 ms, 击败 50.00% 使用 Ruby 的用户\n内存消耗 : 208.75 MB, 击败 16.67% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def findMedianSortedArrays(nums1: Array[Int], nums2: Array[Int]): Double = &#123;    val totalLength = nums1.length + nums2.length    val mid = totalLength / 2    var i = 0    var j = 0    var prev = 0    var current = 0    while (i + j &lt;= mid) &#123;      prev = current      if (i &lt; nums1.length &amp;&amp; (j &gt;= nums2.length || nums1(i) &lt;= nums2(j))) &#123;        current = nums1(i)        i += 1      &#125; else &#123;        current = nums2(j)        j += 1      &#125;    &#125;    if (totalLength % 2 == 1) &#123;      current.toDouble    &#125; else &#123;      (prev + current) / 2.0    &#125;  &#125;&#125;\n\n结果执行用时 : 680 ms, 击败 40.00% 使用 Scala 的用户\n内存消耗 : 56.56 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn find_median_sorted_arrays(nums1: Vec&lt;i32&gt;, nums2: Vec&lt;i32&gt;) -&gt; f64 &#123;        let total_length = nums1.len() + nums2.len();        let mid = total_length / 2;        let mut i = 0;        let mut j = 0;        let mut prev = 0;        let mut current = 0;        while i + j &lt;= mid &#123;            prev = current;            if i &lt; nums1.len() &amp;&amp; (j &gt;= nums2.len() || nums1[i] &lt;= nums2[j]) &#123;                current = nums1[i];                i += 1;            &#125; else &#123;                current = nums2[j];                j += 1;            &#125;        &#125;        if total_length % 2 == 1 &#123;            current as f64        &#125; else &#123;            (prev + current) as f64 / 2.0        &#125;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.05 MB, 击败 48.63% 使用 Rust 的用户\n\nRacket(define/contract (find-median-sorted-arrays nums1 nums2)  (-&gt; (listof exact-integer?) (listof exact-integer?) flonum?)    (string-&gt;number        (real-&gt;decimal-string            (find-midian-num-general nums1 nums2)            5))  )(define (find-midian-num-general nums1 nums2)    (let* ((nums (get-median-list nums1 nums2))            (len (length nums)))        (if (odd? len)            (if (= len 1)                (list-ref nums (- len 1))                (let ((id (/ (- len 1) 2)))                    (list-ref nums id)))            (let ((id (/ len 2)))                (/ (+ (list-ref nums (- id 1))                      (list-ref nums id))                    2)))))(define (get-median-list nums1 nums2)    (sort (append nums1 nums2) &lt;))\n\n结果执行用时 : 236 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 122.28 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang-spec find_median_sorted_arrays(Nums1 :: [integer()], Nums2 :: [integer()]) -&gt; float().find_median_sorted_arrays(Nums1, Nums2) -&gt;    Merged = lists:sort(Nums1 ++ Nums2),    Length = length(Merged),    Mid = Length div 2,    case Length rem 2 of        0 -&gt; (lists:nth(Mid, Merged) + lists:nth(Mid + 1, Merged)) / 2.0;        _ -&gt; lists:nth(Mid + 1, Merged)    end.\n\n结果执行用时 : 464 ms, 击败 -% 使用 Erlang 的用户\n内存消耗 : 61.45 MB, 击败 -% 使用 Erlang 的用户\n\nElixirdefmodule Solution do  @spec find_median_sorted_arrays(nums1 :: [integer], nums2 :: [integer]) :: float  def find_median_sorted_arrays(nums1, nums2) do    merged = Enum.sort(nums1 ++ nums2)    length = length(merged)    mid = div(length, 2)    case rem(length, 2) do      0 -&gt; (Enum.at(merged, mid - 1) + Enum.at(merged, mid)) / 2.0      _ -&gt; Enum.at(merged, mid)    end  endend\n\n结果执行用时 : 520 ms, 击败 -% 使用 Elixir 的用户\n内存消耗 : 69.50 MB, 击败 -% 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"孤独的美食家 第八季 第九集 东京千代田区御茶之水的南印度咖喱套餐和蒜味奶酪多萨","url":"/zh-CN/6f0478b3e57c/","content":"\n剧情介绍　　井之头五郎（松重丰饰）应客户要求“想修理坏掉的小提琴”，前往御茶水下仓（近藤公园）的小提琴店。但是，工作室里的马尾看上去像干燥的春雨，五郎饿了…。在没有土地直觉的小巷里寻找店铺的时候，出现了写着“南印度料理”的招牌。被菜单排列的「套餐·小吃」的词吸引进入【三灯舍】！在为数不多的菜单烦恼的同时，点了「santoushamilus」「蒜泥奶酪dosa(混血)」「浓厚rashi」。3种「チャツネ」附着的「蒜香奶酪ドーサ」，根据附着的「チャツネ」味道变化，快乐也绝妙的美味！作为“南印度套餐”的“圣淘沙米尔斯”有丰富的“肉咖喱”、“鱼咖喱”、“巴托拉”、“托伦”、“圣巴鲁”、“拉萨姆”、“米饭”、“沙拉沙拉”等，最后全部混合在一起享受“南印度套餐的最后一系”！被不知道的南印度菜的世界感动了的五郎追加订购「虾咖喱香蕉的叶包」。五郎因为其浓厚的美味一直到最后都非常满足。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"看见 第一季 第七集 薰衣草之路","url":"/zh-CN/af0585fa7424/","content":"\n剧情介绍　　猎巫人带着玛格拉和布茨一起寻找他的女王。哈尼瓦、科芬和其他人正接近杰拉马雷尔。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"曼达洛人 第一季 第四集 避难所","url":"/zh-CN/e57719e3725b/","content":"\n剧情介绍　　曼达洛人与一名退役士兵联手，保护一个村庄免受劫匪的侵害。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"力扣00005.最长回文子串","url":"/zh-CN/6aaf7c1d87d8/","content":"\n题目描述给你一个字符串 s，找到 s 中最长的回文子串。\n如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n示例 1：\n输入：s &#x3D; “babad”输出：”bab”解释：”aba” 同样是符合题意的答案。\n\n示例 2：\n输入：s &#x3D; “cbbd”输出：”bb”\n\n提示：\n1 &lt;&#x3D; s.length &lt;&#x3D; 1000\ns 仅由数字和英文字母组成\n\n\n解决方法C++class Solution &#123;public:    string longestPalindrome(string s) &#123;        if (s.empty()) &#123;            return &quot;&quot;;        &#125;        int n = s.length();        int start = 0, max_length = 1;        vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false));        for (int i = 0; i &lt; n; ++i) &#123;            dp[i][i] = true;        &#125;        for (int i = 0; i &lt; n - 1; ++i) &#123;            if (s[i] == s[i + 1]) &#123;                dp[i][i + 1] = true;                start = i;                max_length = 2;            &#125;        &#125;        for (int length = 3; length &lt;= n; ++length) &#123;            for (int i = 0; i &lt;= n - length; ++i) &#123;                int j = i + length - 1;                if (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]) &#123;                    dp[i][j] = true;                    start = i;                    max_length = length;                &#125;            &#125;        &#125;        return s.substr(start, max_length);    &#125;&#125;;\n\n结果执行用时 : 188 ms, 击败 50.83% 使用 C++ 的用户\n内存消耗 : 22.71 MB, 击败 52.86% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public String longestPalindrome(String s) &#123;        if (s == null || s.length() &lt; 1) &#123;            return &quot;&quot;;        &#125;        int start = 0, end = 0;        for (int i = 0; i &lt; s.length(); i++) &#123;            int len1 = expandAroundCenter(s, i, i);            int len2 = expandAroundCenter(s, i, i + 1);            int len = Math.max(len1, len2);            if (len &gt; end - start) &#123;                start = i - (len - 1) / 2;                end = i + len / 2;            &#125;        &#125;        return s.substring(start, end + 1);    &#125;    private int expandAroundCenter(String s, int left, int right) &#123;        while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;            left--;            right++;        &#125;        return right - left - 1;    &#125;&#125;\n\n结果执行用时 : 16 ms, 击败 87.41% 使用 Java 的用户\n内存消耗 : 41.15 MB, 击败 71.32% 使用 Java 的用户\n\nPythonclass Solution(object):    def longestPalindrome(self, s):        if not s:            return &quot;&quot;        n = len(s)        start, max_length = 0, 1        dp = [[False] * n for _ in range(n)]        for i in range(n):            dp[i][i] = True        for i in range(n - 1):            if s[i] == s[i + 1]:                dp[i][i + 1] = True                start = i                max_length = 2        for length in range(3, n + 1):            for i in range(n - length + 1):                j = i + length - 1                if s[i] == s[j] and dp[i + 1][j - 1]:                    dp[i][j] = True                    start = i                    max_length = length        return s[start:start + max_length]\n\n结果执行用时 : 2744 ms, 击败 50.76% 使用 Python 的用户\n内存消耗 : 20.48 MB, 击败 33.90% 使用 Python 的用户\n\nPython3class Solution:    def longestPalindrome(self, s: str) -&gt; str:        if not s:            return &quot;&quot;        n = len(s)        start, max_length = 0, 1        dp = [[False] * n for _ in range(n)]        for i in range(n):            dp[i][i] = True        for i in range(n - 1):            if s[i] == s[i + 1]:                dp[i][i + 1] = True                start = i                max_length = 2        for length in range(3, n + 1):            for i in range(n - length + 1):                j = i + length - 1                if s[i] == s[j] and dp[i + 1][j - 1]:                    dp[i][j] = True                    start = i                    max_length = length        return s[start:start + max_length]\n\n结果执行用时 : 1988 ms, 击败 58.06% 使用 Python3 的用户\n内存消耗 : 25.75 MB, 击败 5.00% 使用 Python3 的用户\n\nCchar* longestPalindrome(char* s) &#123;    if (s == NULL || *s == &#x27;\\0&#x27;) &#123;        return &quot;&quot;;    &#125;    int n = strlen(s);    int start = 0, max_length = 1;    int dp[n][n];    memset(dp, 0, sizeof(dp));    for (int i = 0; i &lt; n; ++i) &#123;        dp[i][i] = 1;    &#125;    for (int i = 0; i &lt; n - 1; ++i) &#123;        if (s[i] == s[i + 1]) &#123;            dp[i][i + 1] = 1;            start = i;            max_length = 2;        &#125;    &#125;    for (int length = 3; length &lt;= n; ++length) &#123;        for (int i = 0; i &lt;= n - length; ++i) &#123;            int j = i + length - 1;            if (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]) &#123;                dp[i][j] = 1;                start = i;                max_length = length;            &#125;        &#125;    &#125;    char* result = (char*)malloc((max_length + 1) * sizeof(char));    strncpy(result, s + start, max_length);    result[max_length] = &#x27;\\0&#x27;;    return result;&#125;\n\n结果执行用时 : 112 ms, 击败 35.91% 使用 C 的用户\n内存消耗 : 11.07 MB, 击败 8.11% 使用 C 的用户\n\nC#public class Solution &#123;    public string LongestPalindrome(string s) &#123;        if (string.IsNullOrEmpty(s)) &#123;            return &quot;&quot;;        &#125;        int n = s.Length;        int start = 0, maxLength = 1;        bool[,] dp = new bool[n, n];        for (int i = 0; i &lt; n; i++) &#123;            dp[i, i] = true;        &#125;        for (int i = 0; i &lt; n - 1; i++) &#123;            if (s[i] == s[i + 1]) &#123;                dp[i, i + 1] = true;                start = i;                maxLength = 2;            &#125;        &#125;        for (int length = 3; length &lt;= n; length++) &#123;            for (int i = 0; i &lt;= n - length; i++) &#123;                int j = i + length - 1;                if (s[i] == s[j] &amp;&amp; dp[i + 1, j - 1]) &#123;                    dp[i, j] = true;                    start = i;                    maxLength = length;                &#125;            &#125;        &#125;        return s.Substring(start, maxLength);    &#125;&#125;\n\n结果执行用时 : 104 ms, 击败 62.37% 使用 C# 的用户\n内存消耗 : 42.81 MB, 击败 39.55% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; s * @return &#123;string&#125; */var longestPalindrome = function(s) &#123;    if (!s || s.length === 0) &#123;        return &quot;&quot;;    &#125;    let n = s.length;    let start = 0;    let maxLength = 1;    let dp = Array.from(Array(n), () =&gt; new Array(n).fill(false));    for (let i = 0; i &lt; n; i++) &#123;        dp[i][i] = true;    &#125;    for (let i = 0; i &lt; n - 1; i++) &#123;        if (s[i] === s[i + 1]) &#123;            dp[i][i + 1] = true;            start = i;            maxLength = 2;        &#125;    &#125;    for (let length = 3; length &lt;= n; length++) &#123;        for (let i = 0; i &lt;= n - length; i++) &#123;            let j = i + length - 1;            if (s[i] === s[j] &amp;&amp; dp[i + 1][j - 1]) &#123;                dp[i][j] = true;                start = i;                maxLength = length;            &#125;        &#125;    &#125;    return s.substring(start, start + maxLength);&#125;;\n\n结果执行用时 : 608 ms, 击败 25.61% 使用 JavaScript 的用户\n内存消耗 : 70.17 MB, 击败 14.82% 使用 JavaScript 的用户\n\nTypeScriptfunction longestPalindrome(s: string): string &#123;    if (!s || s.length === 0) &#123;        return &quot;&quot;;    &#125;    const n = s.length;    let start = 0;    let maxLength = 1;    const dp: boolean[][] = Array.from(Array(n), () =&gt; new Array(n).fill(false));    for (let i = 0; i &lt; n; i++) &#123;        dp[i][i] = true;    &#125;    for (let i = 0; i &lt; n - 1; i++) &#123;        if (s[i] === s[i + 1]) &#123;            dp[i][i + 1] = true;            start = i;            maxLength = 2;        &#125;    &#125;    for (let length = 3; length &lt;= n; length++) &#123;        for (let i = 0; i &lt;= n - length; i++) &#123;            const j = i + length - 1;            if (s[i] === s[j] &amp;&amp; dp[i + 1][j - 1]) &#123;                dp[i][j] = true;                start = i;                maxLength = length;            &#125;        &#125;    &#125;    return s.substring(start, start + maxLength);&#125;\n\n结果执行用时 : 676 ms, 击败 24.04% 使用 TypeScript 的用户\n内存消耗 : 71.98 MB, 击败 17.54% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String $s     * @return String     */    function longestPalindrome($s) &#123;        if (empty($s)) &#123;            return &quot;&quot;;        &#125;        $n = strlen($s);        $start = 0;        $maxLength = 1;        $dp = array_fill(0, $n, array_fill(0, $n, false));        for ($i = 0; $i &lt; $n; $i++) &#123;            $dp[$i][$i] = true;        &#125;        for ($i = 0; $i &lt; $n - 1; $i++) &#123;            if ($s[$i] == $s[$i + 1]) &#123;                $dp[$i][$i + 1] = true;                $start = $i;                $maxLength = 2;            &#125;        &#125;        for ($length = 3; $length &lt;= $n; $length++) &#123;            for ($i = 0; $i &lt;= $n - $length; $i++) &#123;                $j = $i + $length - 1;                if ($s[$i] == $s[$j] &amp;&amp; $dp[$i + 1][$j - 1]) &#123;                    $dp[$i][$j] = true;                    $start = $i;                    $maxLength = $length;                &#125;            &#125;        &#125;        return substr($s, $start, $maxLength);    &#125;&#125;\n\n结果执行用时 : 1048 ms, 击败 36.36% 使用 PHP 的用户\n内存消耗 : 37.88 MB, 击败 36.36% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func longestPalindrome(_ s: String) -&gt; String &#123;        if s.isEmpty &#123;            return &quot;&quot;        &#125;        let chars = Array(s)        var start = 0, end = 0        for i in 0..&lt;chars.count &#123;            let len1 = expandAroundCenter(chars, i, i)            let len2 = expandAroundCenter(chars, i, i + 1)            let len = max(len1, len2)            if len &gt; end - start &#123;                start = i - (len - 1) / 2                end = i + len / 2            &#125;        &#125;        return String(chars[start...end])    &#125;    func expandAroundCenter(_ chars: [Character], _ left: Int, _ right: Int) -&gt; Int &#123;        var left = left, right = right        while left &gt;= 0 &amp;&amp; right &lt; chars.count &amp;&amp; chars[left] == chars[right] &#123;            left -= 1            right += 1        &#125;        return right - left - 1    &#125;&#125;\n\n结果执行用时 : 24 ms, 击败 76.19% 使用 Swift 的用户\n内存消耗 : 15.47 MB, 击败 5.71% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun longestPalindrome(s: String): String &#123;        if (s.isEmpty()) &#123;            return &quot;&quot;        &#125;        val n = s.length        var start = 0        var maxLength = 1        val dp = Array(n) &#123; BooleanArray(n) &#125;        for (i in 0 until n) &#123;            dp[i][i] = true        &#125;        for (i in 0 until n - 1) &#123;            if (s[i] == s[i + 1]) &#123;                dp[i][i + 1] = true                start = i                maxLength = 2            &#125;        &#125;        for (length in 3..n) &#123;            for (i in 0 until n - length + 1) &#123;                val j = i + length - 1                if (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]) &#123;                    dp[i][j] = true                    start = i                    maxLength = length                &#125;            &#125;        &#125;        return s.substring(start, start + maxLength)    &#125;&#125;\n\n结果执行用时 : 268 ms, 击败 59.81% 使用 Kotlin 的用户\n内存消耗 : 37.95 MB, 击败 23.36% 使用 Kotlin 的用户\n\nDartimport &#x27;dart:math&#x27;;class Solution &#123;  String longestPalindrome(String s) &#123;    if (s.isEmpty) &#123;      return &quot;&quot;;    &#125;    int start = 0;    int maxLen = 1;    for (int i = 0; i &lt; s.length; i++) &#123;      int len1 = expandAroundCenter(s, i, i);      int len2 = expandAroundCenter(s, i, i + 1);      int len = max(len1, len2);      if (len &gt; maxLen) &#123;        maxLen = len;        start = i - (maxLen - 1) ~/ 2;      &#125;    &#125;    return s.substring(start, start + maxLen);  &#125;  int expandAroundCenter(String s, int left, int right) &#123;    while (left &gt;= 0 &amp;&amp; right &lt; s.length &amp;&amp; s[left] == s[right]) &#123;      left--;      right++;    &#125;    return right - left - 1;  &#125;&#125;\n\n结果执行用时 : 280 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 141.77 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc longestPalindrome(s string) string &#123;    if len(s) == 0 &#123;        return &quot;&quot;    &#125;    var start, end int    for i := 0; i &lt; len(s); i++ &#123;        len1 := expandAroundCenter(s, i, i)        len2 := expandAroundCenter(s, i, i+1)        length := max(len1, len2)        if length &gt; end-start &#123;            start = i - (length-1)/2            end = i + length/2        &#125;    &#125;    return s[start : end+1]&#125;func expandAroundCenter(s string, left, right int) int &#123;    for left &gt;= 0 &amp;&amp; right &lt; len(s) &amp;&amp; s[left] == s[right] &#123;        left--        right++    &#125;    return right - left - 1&#125;func max(x, y int) int &#123;    if x &gt; y &#123;        return x    &#125;    return y&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.34 MB, 击败 65.18% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; s# @return &#123;String&#125;def longest_palindrome(s)    return &quot;&quot; if s.nil? || s.empty?    start = 0    max_len = 1    (0...s.length).each do |i|        len1 = expand_around_center(s, i, i)        len2 = expand_around_center(s, i, i + 1)        len = [len1, len2].max        if len &gt; max_len            max_len = len            start = i - (max_len - 1) / 2        end    end    s[start...(start + max_len)]enddef expand_around_center(s, left, right)    while left &gt;= 0 &amp;&amp; right &lt; s.length &amp;&amp; s[left] == s[right]        left -= 1        right += 1    end    right - left - 1end\n\n结果执行用时 : 620 ms, 击败 83.33% 使用 Ruby 的用户\n内存消耗 : 206.72 MB, 击败 16.67% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def longestPalindrome(s: String): String = &#123;    if (s.isEmpty) return &quot;&quot;    var start = 0    var end = 0    def expandAroundCenter(left: Int, right: Int): Int = &#123;      var l = left      var r = right      while (l &gt;= 0 &amp;&amp; r &lt; s.length &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;        l -= 1        r += 1      &#125;      r - l - 1    &#125;    for (i &lt;- 0 until s.length) &#123;      val len1 = expandAroundCenter(i, i)      val len2 = expandAroundCenter(i, i + 1)      val len = Math.max(len1, len2)      if (len &gt; end - start) &#123;        start = i - (len - 1) / 2        end = i + len / 2      &#125;    &#125;    s.substring(start, end + 1)  &#125;&#125;\n\n结果执行用时 : 600 ms, 击败 76.92% 使用 Scala 的用户\n内存消耗 : 54.00 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn longest_palindrome(s: String) -&gt; String &#123;        let n = s.len();        let s: Vec&lt;char&gt; = s.chars().collect();        let mut dp = vec![vec![false; n]; n];        let mut start = 0;        let mut max_len = 1;        for i in 0..n &#123;            dp[i][i] = true;        &#125;        for i in 0..n - 1 &#123;            if s[i] == s[i + 1] &#123;                dp[i][i + 1] = true;                start = i;                max_len = 2;            &#125;        &#125;        for k in 3..=n &#123;            for i in 0..=n - k &#123;                let j = i + k - 1;                if s[i] == s[j] &amp;&amp; dp[i + 1][j - 1] &#123;                    dp[i][j] = true;                    if k &gt; max_len &#123;                        start = i;                        max_len = k;                    &#125;                &#125;            &#125;        &#125;        s[start..start + max_len].iter().collect::&lt;String&gt;()    &#125;&#125;\n\n结果执行用时 : 52 ms, 击败 58.62% 使用 Rust 的用户\n内存消耗 : 3.30 MB, 击败 5.17% 使用 Rust 的用户\n\nRacket(define/contract (longest-palindrome s)  (-&gt; string? string?)    (longest-palindrome/center-better s)  )(define (longest-palindrome/center-better s)  (define (palindrome/in s n/begin n/end)    (if (and (&gt;= n/begin 0) (&lt; n/end (string-length s)))        (if (char=? (string-ref s n/begin) (string-ref s n/end))            (palindrome/in s (sub1 n/begin) (add1 n/end))            (list (add1 n/begin) (sub1 n/end)))        (list (add1 n/begin) (sub1 n/end))))  (define (palindrome/center s n/begin n/end n)    (if (&gt;= n (string-length s))        (substring s n/begin (add1 n/end))        (match-let ([(list begin1 end1) (palindrome/in s n n)]                    [(list begin2 end2) (palindrome/in s n (add1 n))])          (cond             [(&gt; (- end2 begin2) (- n/end n/begin)) (palindrome/center s begin2 end2 (add1 n))]            [(&gt; (- end1 begin1) (- n/end n/begin)) (palindrome/center s begin1 end1 (add1 n))]            [else (palindrome/center s n/begin n/end (add1 n))]))))  (palindrome/center s 0 0 0))\n\n结果执行用时 : 236 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 99.04 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang-spec longest_palindrome(S :: unicode:unicode_binary()) -&gt; unicode:unicode_binary().longest_palindrome(S) -&gt;    list_to_binary(main(binary_to_list(S))).main(S) -&gt;    &#123;FromZeroString, FromZeroLength&#125; = loop(S, get_zero_list(S), 0),    &#123;FromOneString, FromOneLength&#125; = loop(S, get_one_list(S), 1),    Longer = FromZeroLength &gt; FromOneLength,    if        Longer -&gt;            substr(FromZeroString, FromZeroLength);        true -&gt;            substr(FromOneString, FromOneLength)    end.loop(S, [ResultHead|ResultTail], N) -&gt;    NextList = next_list(S, ResultTail),    CheckListResult = check_list(NextList),    if        CheckListResult -&gt;            loop(S, NextList, N + 2);        true -&gt;            &#123;find_first(S, [ResultHead|ResultTail]), N&#125;    end.substr(_, N) when N == 0 -&gt;    [];substr([Head|Tail], N) -&gt;    [Head|substr(Tail, N - 1)].get_zero_list([Head|Tail]) -&gt;    [&#123;true, [Head|Tail]&#125; | get_zero_list(Tail)];get_zero_list([]) -&gt;    [].get_one_list([_ | Tail]) -&gt;    [&#123;true, Tail&#125; | get_one_list(Tail)];get_one_list([]) -&gt;    [].next_list([Head1|Tail1], [&#123;IsPalindrome, [Head2|Tail2]&#125; | ResultTail]) -&gt;    [&#123;(Head1 == Head2) and IsPalindrome, Tail2&#125; | next_list(Tail1, ResultTail)];next_list(_, [&#123;_, []&#125;]) -&gt;    [];next_list(_, []) -&gt;    [].check_list(S) -&gt;    check_list(S, false).check_list([&#123;IsPalindrome, _&#125; | Tail], Result) -&gt;    check_list(Tail, IsPalindrome or Result);check_list([], Result) -&gt;    Result.find_first([Head1|Tail1], [&#123;IsPalindrome, _&#125; | Tail2]) -&gt;    if        IsPalindrome -&gt;            [Head1|Tail1];        true -&gt;            find_first(Tail1, Tail2)    end;find_first(_, []) -&gt;    &quot;&quot;.\n\n结果执行用时 : 516 ms, 击败 100.00% 使用 Erlang 的用户\n内存消耗 : 57.55 MB, 击败 100.00% 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"食戟之灵 第四季 神之皿 第八集 你的侧脸","url":"/zh-CN/acc5c49f8a69/","content":"\n剧情介绍　　薙切蓟突然出现在比赛场地，并宣布他将担任本轮比赛的评委！叛军对此愤怒不已，但即使是应该站在他们这边的薙切仙左卫门也同意了这一改变。在众人满腹疑惑之际，塔克米和小林龙胆的料理已经完成并准备上桌！\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"利刃出鞘","url":"/zh-CN/95f60a530a95/","content":"\n剧情介绍　　富豪小说家哈兰·斯隆比在自己85岁生日第二天，被发现在自家庄园离奇自杀，遗留了亿万遗产。久负盛名的大侦探布兰科（丹尼尔·克雷格饰）突然被匿名人士雇佣调查此案真相。同时，哈兰的孙子兰森（克里斯·埃文斯饰）也正在秘密调查此案。当布兰科和哈兰·斯隆比家族的其他人对谈时， 他发现事情并没有想象中那么简单。\n　　哈兰家族没有表面上那么和睦，每个人都有着不可告人的秘密，每个人都想得到遗产……究竟这起命案是自杀还是他杀？似乎每个人都有嫌疑。随着一位遗产继承人的意外亮相，真相谜底渐渐浮出水面……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"女超人 第五季 第八集 拉玛汗之怒","url":"/zh-CN/757717b02a05/","content":"\n剧情介绍　　女超人与利维坦的斗争达到了高潮，她与拉玛·汗展开了对决。与此同时，莉娜和霍普共同努力启动“非伤害计划”，而霍普证明自己成为了莉娜的重要得力助手。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第一季 第八集 疯狂茶会","url":"/zh-CN/07eae09654cc/","content":"\n剧情介绍　　凯特和爱丽丝继续她们既是姐妹又是宿敌的纠葛，而爱丽丝和鼠男策划了迄今为止最邪恶的计划。玛丽邀请凯特参加一个特别活动，以纪念凯瑟琳，而雅各布做出了一个让凯特困惑的决定。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"黑客军团 第四季 第九集 409 冲突","url":"/zh-CN/d7c2c780cc86/","content":"\n剧情介绍　　黑客军团与神之议会\n\n","categories":["剧集"],"tags":["日常","USA Network"]},{"title":"黑闪电 第三季 第八集 抵抗之书：第三章：富兰克林露台之战","url":"/zh-CN/31c15c36f1f8/","content":"\n剧情介绍　　黑闪电决定反击，当ASA威胁到他曾经的老邻里时。雷霆与杀痛者展开对决，而托拜厄斯则有一个计划，希望琳恩能阻止ASA将超能力者武器化。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00006.N字形变换","url":"/zh-CN/e6368f225a69/","content":"\n题目描述将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：\n\nP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NA&nbsp;P   &nbsp;L&nbsp;S   &nbsp;I&nbsp;I   &nbsp;GY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。\n请你实现这个将字符串进行指定行数变换的函数：\n\nstring convert(string s, int numRows);\n\n示例 1：\n输入：s &#x3D; “PAYPALISHIRING”, numRows &#x3D; 3输出：”PAHNAPLSIIGYIR”\n\n示例 2：\n输入：s &#x3D; “PAYPALISHIRING”, numRows &#x3D; 4输出：”PINALSIGYAHRPI”解释：P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I GY A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H RP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I\n\n示例 3：\n输入：s &#x3D; “A”, numRows &#x3D; 1输出：”A”\n\n提示：\n1 &lt;&#x3D; s.length &lt;&#x3D; 1000\ns 由英文字母（小写和大写）、’,’ 和 ‘.’ 组成\n1 &lt;&#x3D; numRows &lt;&#x3D; 1000\n\n\n解决方法C++class Solution &#123;public:    std::string convert(std::string s, int numRows) &#123;        if (numRows &lt;= 1 || s.length() &lt;= numRows) &#123;            return s;        &#125;        std::vector&lt;std::string&gt; rows(numRows);        int row = 0;        int step = 1;        for (char c : s) &#123;            rows[row].push_back(c);            if (row == 0) &#123;                step = 1; // 到达第一行，改变方向向下            &#125; else if (row == numRows - 1) &#123;                step = -1; // 到达最后一行，改变方向向上            &#125;            row += step;        &#125;        std::string result;        for (const std::string&amp; rowStr : rows) &#123;            result += rowStr;        &#125;        return result;    &#125;&#125;;\n\n结果执行用时 : 8 ms, 击败 91.30% 使用 C++ 的用户\n内存消耗 : 10.46 MB, 击败 58.69% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public String convert(String s, int numRows) &#123;        if (numRows &lt;= 1 || s.length() &lt;= numRows) &#123;            return s;        &#125;        StringBuilder[] rows = new StringBuilder[numRows];        for (int i = 0; i &lt; numRows; i++) &#123;            rows[i] = new StringBuilder();        &#125;        int row = 0;        int step = 1;        for (char c : s.toCharArray()) &#123;            rows[row].append(c);            if (row == 0) &#123;                step = 1; // 到达第一行，改变方向向下            &#125; else if (row == numRows - 1) &#123;                step = -1; // 到达最后一行，改变方向向上            &#125;            row += step;        &#125;        StringBuilder result = new StringBuilder();        for (StringBuilder rowStr : rows) &#123;            result.append(rowStr);        &#125;        return result.toString();    &#125;&#125;\n\n结果执行用时 : 4 ms, 击败 86.05% 使用 Java 的用户\n内存消耗 : 43.73 MB, 击败 20.70% 使用 Java 的用户\n\nPythonclass Solution(object):    def convert(self, s, numRows):        if numRows &lt;= 1 or len(s) &lt;= numRows:            return s        rows = [&#x27;&#x27;] * numRows        row = 0        step = 1        for char in s:            rows[row] += char            if row == 0:                step = 1            elif row == numRows - 1:                step = -1            row += step        return &#x27;&#x27;.join(rows)\n\n结果执行用时 : 76 ms, 击败 29.33% 使用 Python 的用户\n内存消耗 : 13.10 MB, 击败 75.91% 使用 Python 的用户\n\nPython3class Solution:    def convert(self, s: str, numRows: int) -&gt; str:        if numRows &lt;= 1 or len(s) &lt;= numRows:            return s        rows = [&#x27;&#x27;] * numRows        row = 0        step = 1        for char in s:            rows[row] += char            if row == 0:                step = 1            elif row == numRows - 1:                step = -1            row += step        return &#x27;&#x27;.join(rows)\n\n结果执行用时 : 48 ms, 击败 97.61% 使用 Python3 的用户\n内存消耗 : 17.09 MB, 击败 14.32% 使用 Python3 的用户\n\nCchar* convert(char* s, int numRows) &#123;    int n = strlen(s), r = numRows;    if (r == 1 || r &gt;= n) &#123;        return s;    &#125;    int t = r * 2 - 2;    int c = (n + t - 1) / t * (r - 1);    char** mat = (char**)malloc(sizeof(char*) * r);    for (int i = 0; i &lt; r; i++) &#123;        mat[i] = (char*)malloc(sizeof(char) * c);        memset(mat[i], 0, sizeof(char) * c);    &#125;    for (int i = 0, x = 0, y = 0; i &lt; n; ++i) &#123;        mat[x][y] = s[i];        if (i % t &lt; r - 1) &#123;            ++x;        &#125; else &#123;            --x;            ++y;        &#125;    &#125;    char* result = (char*)malloc(sizeof(char) * (n + 1));    int pos = 0;    for (int i = 0; i &lt; r; i++) &#123;        for (int j = 0; j &lt; c; j++) &#123;            if (mat[i][j]) &#123;                result[pos++] = mat[i][j];            &#125;        &#125;        free(mat[i]);    &#125;    free(mat);    result[n] = &#x27;\\0&#x27;;    strcpy(s, result);    free(result);    return s;&#125;\n\n结果执行用时 : 44 ms, 击败 24.86% 使用 C 的用户\n内存消耗 : 30.42 MB, 击败 13.58% 使用 C 的用户\n\nC#public class Solution &#123;    public string Convert(string s, int numRows) &#123;        if (numRows &lt;= 1 || s.Length &lt;= numRows) &#123;            return s;        &#125;        int n = s.Length;        int t = numRows * 2 - 2;        int c = (n + t - 1) / t * (numRows - 1);        char[,] mat = new char[numRows, c];        int x = 0, y = 0;        for (int i = 0; i &lt; n; ++i) &#123;            mat[x, y] = s[i];            if (i % t &lt; numRows - 1) &#123;                ++x;            &#125; else &#123;                --x;                ++y;            &#125;        &#125;        string result = &quot;&quot;;        for (int i = 0; i &lt; numRows; i++) &#123;            for (int j = 0; j &lt; c; j++) &#123;                if (mat[i, j] != &#x27;\\0&#x27;) &#123;                    result += mat[i, j];                &#125;            &#125;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 88 ms, 击败 49.10% 使用 C# 的用户\n内存消耗 : 58.23 MB, 击败 42.19% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; s * @param &#123;number&#125; numRows * @return &#123;string&#125; */var convert = function(s, numRows) &#123;    if (numRows &lt;= 1 || s.length &lt;= numRows) &#123;        return s;    &#125;    let n = s.length;    let t = numRows * 2 - 2;    let c = Math.ceil(n / t) * (numRows - 1);    let mat = new Array(numRows).fill().map(() =&gt; new Array(c).fill(&#x27;&#x27;));    let x = 0, y = 0;    for (let i = 0; i &lt; n; ++i) &#123;        mat[x][y] = s[i];        if (i % t &lt; numRows - 1) &#123;            ++x;        &#125; else &#123;            --x;            ++y;        &#125;    &#125;    let result = &#x27;&#x27;;    for (let i = 0; i &lt; numRows; i++) &#123;        for (let j = 0; j &lt; c; j++) &#123;            if (mat[i][j] !== &#x27;&#x27;) &#123;                result += mat[i][j];            &#125;        &#125;    &#125;    return result;&#125;;\n\n结果执行用时 : 156 ms, 击败 21.61% 使用 JavaScript 的用户\n内存消耗 : 64.30 MB, 击败 8.54% 使用 JavaScript 的用户\n\nTypeScriptfunction convert(s: string, numRows: number): string &#123;    if (numRows &lt;= 1 || s.length &lt;= numRows) &#123;        return s;    &#125;    const n: number = s.length;    const t: number = numRows * 2 - 2;    const c: number = Math.ceil(n / t) * (numRows - 1);    const mat: string[][] = Array.from(&#123; length: numRows &#125;, () =&gt; Array(c).fill(&#x27;&#x27;));    let x: number = 0,        y: number = 0;    for (let i = 0; i &lt; n; ++i) &#123;        mat[x][y] = s[i];        if (i % t &lt; numRows - 1) &#123;            ++x;        &#125; else &#123;            --x;            ++y;        &#125;    &#125;    let result: string = &#x27;&#x27;;    for (let i = 0; i &lt; numRows; i++) &#123;        for (let j = 0; j &lt; c; j++) &#123;            if (mat[i][j] !== &#x27;&#x27;) &#123;                result += mat[i][j];            &#125;        &#125;    &#125;    return result;&#125;\n\n结果执行用时 : 156 ms, 击败 11.05% 使用 TypeScript 的用户\n内存消耗 : 63.39 MB, 击败 5.23% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String $s     * @param Integer $numRows     * @return String     */    function convert($s, $numRows) &#123;        if ($numRows &lt;= 1 || strlen($s) &lt;= $numRows) &#123;            return $s;        &#125;        $n = strlen($s);        $t = $numRows * 2 - 2;        $c = ceil($n / $t) * ($numRows - 1);        $mat = array_fill(0, $numRows, array_fill(0, $c, &#x27;&#x27;));        $x = 0;        $y = 0;        for ($i = 0; $i &lt; $n; ++$i) &#123;            $mat[$x][$y] = $s[$i];            if ($i % $t &lt; $numRows - 1) &#123;                ++$x;            &#125; else &#123;                --$x;                ++$y;            &#125;        &#125;        $result = &#x27;&#x27;;        for ($i = 0; $i &lt; $numRows; $i++) &#123;            for ($j = 0; $j &lt; $c; $j++) &#123;                if ($mat[$i][$j] !== &#x27;&#x27;) &#123;                    $result .= $mat[$i][$j];                &#125;            &#125;        &#125;        return $result;    &#125;&#125;\n\n结果执行用时 : 276 ms, 击败 6.98% 使用 PHP 的用户\n内存消耗 : 35.56 MB, 击败 6.98% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func convert(_ s: String, _ numRows: Int) -&gt; String &#123;        if numRows &lt;= 1 || s.count &lt;= numRows &#123;            return s        &#125;        let n = s.count        let t = numRows * 2 - 2        let c = Int(ceil(Double(n) / Double(t)) * Double(numRows - 1))        var mat = Array(repeating: Array(repeating: Character(&quot; &quot;), count: c), count: numRows)        var x = 0        var y = 0        for (i, char) in s.enumerated() &#123;            mat[x][y] = char            if i % t &lt; numRows - 1 &#123;                x += 1            &#125; else &#123;                x -= 1                y += 1            &#125;        &#125;        var result = &quot;&quot;        for i in 0..&lt;numRows &#123;            for j in 0..&lt;c &#123;                if mat[i][j] != &quot; &quot; &#123;                    result.append(mat[i][j])                &#125;            &#125;        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 172 ms, 击败 16.22% 使用 Swift 的用户\n内存消耗 : 28.77 MB, 击败 5.40% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun convert(s: String, numRows: Int): String &#123;        if (numRows &lt;= 1 || s.length &lt;= numRows) &#123;            return s        &#125;        val n = s.length        val t = numRows * 2 - 2        val c = ((n + t - 1) / t) * (numRows - 1)        val mat = Array(numRows) &#123; CharArray(c) &#123; &#x27; &#x27; &#125; &#125;        var x = 0        var y = 0        for (i in s.indices) &#123;            mat[x][y] = s[i]            if (i % t &lt; numRows - 1) &#123;                ++x            &#125; else &#123;                --x                ++y            &#125;        &#125;        var result = &quot;&quot;        for (i in 0 until numRows) &#123;            for (j in 0 until c) &#123;                if (mat[i][j] != &#x27; &#x27;) &#123;                    result += mat[i][j]                &#125;            &#125;        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 276 ms, 击败 29.79% 使用 Kotlin 的用户\n内存消耗 : 39.07 MB, 击败 14.89% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  String convert(String s, int numRows) &#123;    if (s.length == 1 || numRows == 1 || s.length &lt; numRows) &#123;      return s;    &#125;    List&lt;String&gt; rows = List.filled(numRows, &#x27;&#x27;);    int index = 0;    int currentRow = 0;    int zigzagLength = 2 * numRows - 2;    while (index &lt; s.length) &#123;      rows[currentRow] += s[index];      if (index % zigzagLength &lt; numRows - 1) &#123;        currentRow++;      &#125; else &#123;        currentRow--;      &#125;      index++;    &#125;    return rows.join();  &#125;&#125;\n\n结果执行用时 : 368 ms, 击败 37.50% 使用 Dart 的用户\n内存消耗 : 149.43 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc convert(s string, numRows int) string &#123;    if numRows &lt;= 1 || len(s) &lt;= numRows &#123;        return s    &#125;    rows := make([]string, numRows)    index, step := 0, 1    for i := 0; i &lt; len(s); i++ &#123;        rows[index] += string(s[i])        if index == 0 &#123;            step = 1        &#125; else if index == numRows-1 &#123;            step = -1        &#125;        index += step    &#125;    result := &quot;&quot;    for _, row := range rows &#123;        result += row    &#125;    return result&#125;\n\n结果执行用时 : 8 ms, 击败 68.58% 使用 Go 的用户\n内存消耗 : 7.21 MB, 击败 27.36% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; s# @param &#123;Integer&#125; num_rows# @return &#123;String&#125;def convert(s, num_rows)    return s if num_rows &lt;= 1 || s.length &lt;= num_rows    rows = Array.new(num_rows, &quot;&quot;)    index, step = 0, 1    s.each_char do |char|        rows[index] += char        if index == 0            step = 1        elsif index == num_rows - 1            step = -1        end        index += step    end    rows.joinend\n\n结果执行用时 : 96 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.76 MB, 击败 -% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def convert(s: String, numRows: Int): String = &#123;    if (numRows &lt;= 1 || s.length &lt;= numRows) &#123;      return s    &#125;    val rows = Array.fill(numRows)(&quot;&quot;) // 创建一个包含 numRows 个空字符串的数组    var index = 0    var step = 1    for (char &lt;- s) &#123;      rows(index) += char.toString      if (index == 0) &#123;        step = 1      &#125; else if (index == numRows - 1) &#123;        step = -1      &#125;      index += step    &#125;    rows.mkString  &#125;&#125;\n\n结果执行用时 : 516 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 55.05 MB, 击败 87.50% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn convert(s: String, num_rows: i32) -&gt; String &#123;        if num_rows &lt;= 1 || s.len() as i32 &lt;= num_rows &#123;            return s;        &#125;        let mut rows: Vec&lt;String&gt; = vec![String::new(); num_rows as usize];        let mut index = 0;        let mut step = 1;        for ch in s.chars() &#123;            rows[index as usize].push(ch);            if index == 0 &#123;                step = 1;            &#125; else if index == num_rows - 1 &#123;                step = -1;            &#125;            index += step;        &#125;        rows.join(&quot;&quot;)    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.37 MB, 击败 9.00% 使用 Rust 的用户\n\nRacket(define (convert s num-rows)  (define (make-log char row)    `(log ,char ,row))  (define (log? log)    (symbol=? (car log) &#x27;log))  (define (log-char log)    (cadr log))  (define (log-row log)    (if (log? log)        (caddr log)        (error log)))  (define (construct-result log-list)    (define (iterator row)      (if (&gt;= row num-rows)          &quot;&quot;          (string-append           (foldl (lambda (current accumulator)                    (string-append accumulator                                   (string (log-char current))))                  &quot;&quot;                  (filter (lambda (current)                            (= row (log-row current)))                          log-list))           (iterator (+ row 1)))))    (iterator 0))  (define (construct-log-list rest-string state row col)    (if (null? rest-string)        &#x27;()        (if (symbol=? &#x27;down state)            (if (= (- num-rows 1) row)                `(,(make-log (car rest-string) row) .                  ,(construct-log-list (cdr rest-string) &#x27;up                                       (- row 1) (+ col 1)))                `(,(make-log (car rest-string) row) .                  ,(construct-log-list (cdr rest-string) &#x27;down                                       (+ row 1) col)))            (if (= 0 row)                `(,(make-log (car rest-string) row) .                  ,(construct-log-list (cdr rest-string) &#x27;down                                       (+ row 1) col))                `(,(make-log (car rest-string) row) .                  ,(construct-log-list (cdr rest-string) &#x27;up                                       (- row 1) (+ col 1)))))))  (if (or (= 1 num-rows) (&gt; num-rows (string-length s)))      s      (construct-result       (construct-log-list (string-&gt;list s) &#x27;down 0 0))))\n\n结果执行用时 : 368 ms, 击败 -% 使用 Racket 的用户\n内存消耗 : 12368 MB, 击败 -% 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixirdefmodule Solution do  @spec convert(s :: String.t(), num_rows :: integer) :: String.t()  def convert(s, 1) do    s  end  def convert(s, num_rows) when is_binary(s) and is_integer(num_rows) and num_rows &gt; 1 do    group_size = num_rows * 2 - 2    offset = gen_offset([], 0, 0, num_rows) |&gt; Enum.reverse() |&gt; List.to_tuple()    ss = String.split(s, &quot;&quot;, trim: true)    mp = gen_map(0, ss, offset, group_size, num_rows, %&#123;&#125;)    len = length(ss)    w = div(len, group_size)    w = w * (num_rows - 1)    r = rem(len, group_size)    w =      cond do        r == 0 -&gt; w        r &lt; num_rows -&gt; w + 1        true -&gt; w + (r - num_rows + 1)      end    gen_str_i(0, num_rows, &quot;&quot;, w, mp)  end  defp gen_offset(offset, x, y, num_rows) do    cond do      y &lt; num_rows - 1 &amp;&amp; x == 0 -&gt;        gen_offset([&#123;x, y&#125; | offset], x, y + 1, num_rows)      x &lt; num_rows - 1 -&gt;        gen_offset([&#123;x, y&#125; | offset], x + 1, y - 1, num_rows)      true -&gt;        offset    end  end  defp gen_map(_, [], _, _, _, mp), do: mp  defp gen_map(step, [head | tail], offset, group_size, num_rows, mp) do    r = div(step, group_size)    i = rem(step, group_size)    op = elem(offset, i)    gen_map(      step + 1,      tail,      offset,      group_size,      num_rows,      Map.put(mp, &#123;r * (num_rows - 1) + elem(op, 0), elem(op, 1)&#125;, head)    )  end  defp gen_str_i(step, num_rows, str, w, mp) do    if step &lt;= num_rows - 1 do      gen_str_i(step + 1, num_rows, gen_str_j(0, str, w, mp, step), w, mp)    else      str    end  end  defp gen_str_j(step, str, w, mp, i) do    j = step    if step &lt;= w do      if Map.has_key?(mp, &#123;j, i&#125;) do        nc = Map.get(mp, &#123;j, i&#125;)        gen_str_j(step + 1, str &lt;&gt; nc, w, mp, i)      else        gen_str_j(step + 1, str, w, mp, i)      end    else      str    end  endend\n\n结果执行用时 : 748 ms, 击败 100.00% 使用 Elixir 的用户\n内存消耗 : 70.40 MB, 击败 100.00% 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00007.整数反转","url":"/zh-CN/7dbe0ca6a88b/","content":"\n题目描述给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n如果反转后整数超过 32 位的有符号整数的范围 [$−2^{31},  2^{31} − 1$] ，就返回 0。\n假设环境不允许存储 64 位整数（有符号或无符号）。\n示例 1：\n输入：x &#x3D; 123输出：321\n\n示例 2：\n输入：x &#x3D; -123输出：-321\n\n示例 3：\n输入：x &#x3D; 120输出：21\n\n示例 4：\n输入：x &#x3D; 0输出：0\n\n提示：\n$-2^{31} &lt;&#x3D; x &lt;&#x3D; 2^{31} - 1$\n\n\n解决方法C++#include &lt;limits&gt;class Solution &#123;public:    int reverse(int x) &#123;        int maximum = std::numeric_limits&lt;int&gt;::max();        int minimum = std::numeric_limits&lt;int&gt;::min();        int sign = (x &lt; 0) ? -1 : 1;        x = abs(x);        long long reversed_num = 0;        while (x != 0) &#123;            int pop = x % 10;            x /= 10;            reversed_num = reversed_num * 10 + pop;            if (reversed_num &gt; maximum || reversed_num &lt; minimum) &#123;                return 0;            &#125;        &#125;        return sign * reversed_num;    &#125;&#125;;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C++ 的用户\n内存消耗 : 6.39 MB, 击败 23.92% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int reverse(int x) &#123;        int MAX_VALUE = Integer.MAX_VALUE;        int MIN_VALUE = Integer.MIN_VALUE;        int sign = (x &lt; 0) ? -1 : 1;        x = Math.abs(x);        long reversedNum = 0;        while (x != 0) &#123;            int pop = x % 10;            x /= 10;            reversedNum = reversedNum * 10 + pop;            if (reversedNum &gt; MAX_VALUE || reversedNum &lt; MIN_VALUE) &#123;                return 0;            &#125;        &#125;        return (int) (sign * reversedNum);    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 47.24% 使用 Java 的用户\n内存消耗 : 39.78 MB, 击败 5.22% 使用 Java 的用户\n\nPythonclass Solution(object):    def reverse(self, x):        INT_MAX = 2**31 - 1        INT_MIN = -2**31        sign = -1 if x &lt; 0 else 1        x = abs(x)        reversed_num = 0        while x != 0:            pop = x % 10            x //= 10            if reversed_num &gt; INT_MAX // 10 or (reversed_num == INT_MAX // 10 and pop &gt; 7):                return 0            if reversed_num &lt; INT_MIN // 10 or (reversed_num == INT_MIN // 10 and pop &lt; -8):                return 0            reversed_num = reversed_num * 10 + pop        return sign * reversed_num\n\n结果执行用时 : 28 ms, 击败 42.98% 使用 Python 的用户\n内存消耗 : 13.20 MB, 击败 5.80% 使用 Python 的用户\n\nPython3class Solution:    def reverse(self, x: int) -&gt; int:        INT_MAX = 2**31 - 1        INT_MIN = -2**31        sign = -1 if x &lt; 0 else 1        x = abs(x)        reversed_num = 0        while x != 0:            pop = x % 10            x //= 10            if reversed_num &gt; INT_MAX // 10 or (reversed_num == INT_MAX // 10 and pop &gt; 7):                return 0            if reversed_num &lt; INT_MIN // 10 or (reversed_num == INT_MIN // 10 and pop &lt; -8):                return 0            reversed_num = reversed_num * 10 + pop        return sign * reversed_num\n\n结果执行用时 : 32 ms, 击败 98.79% 使用 Python3 的用户\n内存消耗 : 16.86 MB, 击败 5.02% 使用 Python3 的用户\n\nCint reverse(int x) &#123;    int reversed = 0;    int upper_limit = INT_MAX / 10;    int lower_limit = INT_MIN / 10;    while (x != 0) &#123;        int digit = x % 10;        x /= 10;        if (reversed &gt; upper_limit || (reversed == upper_limit &amp;&amp; digit &gt; 7)) &#123;            return 0;        &#125;        if (reversed &lt; lower_limit || (reversed == lower_limit &amp;&amp; digit &lt; -8)) &#123;            return 0;        &#125;        reversed = reversed * 10 + digit;    &#125;    return reversed;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 6.21 MB, 击败 50.59% 使用 C 的用户\n\nC#public class Solution &#123;    public int Reverse(int x) &#123;        int reversed = 0;        while (x != 0) &#123;            int digit = x % 10;            x /= 10;            if (reversed &gt; int.MaxValue / 10 || (reversed == int.MaxValue / 10 &amp;&amp; digit &gt; 7)) &#123;                return 0;            &#125;            if (reversed &lt; int.MinValue / 10 || (reversed == int.MinValue / 10 &amp;&amp; digit &lt; -8)) &#123;                return 0;            &#125;            reversed = reversed * 10 + digit;        &#125;        return reversed;    &#125;&#125;\n\n结果执行用时 : 20 ms, 击败 89.43% 使用 C# 的用户\n内存消耗 : 25.87 MB, 击败 95.35% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function(x) &#123;    let reversed = 0;    const INT_MAX = Math.pow(2, 31) - 1;    const INT_MIN = -Math.pow(2, 31);    while (x !== 0) &#123;        const digit = x % 10;        x = Math.trunc(x / 10);        if (reversed &gt; INT_MAX / 10 || (reversed === INT_MAX / 10 &amp;&amp; digit &gt; 7)) &#123;            return 0;        &#125;        if (reversed &lt; INT_MIN / 10 || (reversed === INT_MIN / 10 &amp;&amp; digit &lt; -8)) &#123;            return 0;        &#125;        reversed = reversed * 10 + digit;    &#125;    return reversed;&#125;;\n\n结果执行用时 : 68 ms, 击败 77.92% 使用 JavaScript 的用户\n内存消耗 : 42.45 MB, 击败 75.56% 使用 JavaScript 的用户\n\nTypeScriptfunction reverse(x: number): number &#123;    let reversed = 0;    const INT_MAX = Math.pow(2, 31) - 1;    const INT_MIN = -Math.pow(2, 31);    while (x !== 0) &#123;        const digit = x % 10;        x = Math.trunc(x / 10);        if (reversed &gt; INT_MAX / 10 || (reversed === INT_MAX / 10 &amp;&amp; digit &gt; 7)) &#123;            return 0;        &#125;        if (reversed &lt; INT_MIN / 10 || (reversed === INT_MIN / 10 &amp;&amp; digit &lt; -8)) &#123;            return 0;        &#125;        reversed = reversed * 10 + digit;    &#125;    return reversed;&#125;\n\n结果执行用时 : 80 ms, 击败 35.94% 使用 TypeScript 的用户\n内存消耗 : 43.93 MB, 击败 75.78% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer $x     * @return Integer     */    function reverse($x) &#123;        $reversed = 0;        $INT_MAX = pow(2, 31) - 1;        $INT_MIN = -pow(2, 31);        while ($x != 0) &#123;            $digit = $x % 10;            $x = (int)($x / 10);            if ($reversed &gt; $INT_MAX / 10 || ($reversed == $INT_MAX / 10 &amp;&amp; $digit &gt; 7)) &#123;                return 0;            &#125;            if ($reversed &lt; $INT_MIN / 10 || ($reversed == $INT_MIN / 10 &amp;&amp; $digit &lt; -8)) &#123;                return 0;            &#125;            $reversed = $reversed * 10 + $digit;        &#125;        return $reversed;    &#125;&#125;\n\n结果执行用时 : 8 ms, 击败 68.57% 使用 PHP 的用户\n内存消耗 : 19.14 MB, 击败 5.72% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func reverse(_ x: Int) -&gt; Int &#123;        var reversed = 0        let INT_MAX = Int32.max        let INT_MIN = Int32.min        var mutableX = x        while mutableX != 0 &#123;            let digit = mutableX % 10            mutableX /= 10            if reversed &gt; INT_MAX / 10 || (reversed == INT_MAX / 10 &amp;&amp; digit &gt; 7) &#123;                return 0            &#125;            if reversed &lt; INT_MIN / 10 || (reversed == INT_MIN / 10 &amp;&amp; digit &lt; -8) &#123;                return 0            &#125;            reversed = reversed * 10 + digit        &#125;        return reversed    &#125;&#125;\n\n结果执行用时 : 8 ms, 击败 22.22% 使用 Swift 的用户\n内存消耗 : 14.84 MB, 击败 5.56% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun reverse(x: Int): Int &#123;        var reversed = 0        val INT_MAX = Int.MAX_VALUE        val INT_MIN = Int.MIN_VALUE        var mutableX = x        while (mutableX != 0) &#123;            val digit = mutableX % 10            mutableX /= 10            if (reversed &gt; INT_MAX / 10 || (reversed == INT_MAX / 10 &amp;&amp; digit &gt; 7)) &#123;                return 0            &#125;            if (reversed &lt; INT_MIN / 10 || (reversed == INT_MIN / 10 &amp;&amp; digit &lt; -8)) &#123;                return 0            &#125;            reversed = reversed * 10 + digit        &#125;        return reversed    &#125;&#125;\n\n结果执行用时 : 132 ms, 击败 93.18% 使用 Kotlin 的用户\n内存消耗 : 32.98 MB, 击败 70.45% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int reverse(int x) &#123;    if (x &gt; -10 &amp;&amp; x &lt; 10) &#123;      return x;    &#125;    int res = 0;    final minInt = -2147483648;    final maxInt = 2147483647;    int sign = 1;    if (x &lt; 0) &#123;      sign = -1;      x = -x;    &#125;    while (x != 0) &#123;      if (sign * res &lt; minInt ~/ 10 || sign * res &gt; maxInt ~/ 10) &#123;        return 0;      &#125;      res = res * 10 + x % 10;      x ~/= 10;    &#125;    return sign * res;  &#125;&#125;\n\n结果执行用时 : 312 ms, 击败 50.00% 使用 Dart 的用户\n内存消耗 : 148.46 MB, 击败 90.00% 使用 Dart 的用户\n\nGofunc reverse(x int) int &#123;    if x &gt; -10 &amp;&amp; x &lt; 10 &#123;        return x    &#125;    res := 0    minInt := -2147483648    maxInt := 2147483647    sign := 1    if x &lt; 0 &#123;        sign = -1        x = -x    &#125;    for x != 0 &#123;        if sign*res &lt; minInt/10 || sign*res &gt; maxInt/10 &#123;            return 0        &#125;        res = res*10 + x%10        x /= 10    &#125;    return sign * res&#125;\n\n结果执行用时 : 4 ms, 击败 26.89% 使用 Go 的用户\n内存消耗 : 2.02 MB, 击败 23.89% 使用 Go 的用户\n\nRuby# @param &#123;Integer&#125; x# @return &#123;Integer&#125;def reverse(x)    abs = 1    abs = -1 if x &lt; 0    reversed = x.abs.to_s.reverse.to_i * abs        if -2**31 &lt;= reversed &amp;&amp; reversed &lt; 2**31        return reversed    else        return 0    endend\n\n结果执行用时 : 52 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.73 MB, 击败 -% 使用 Ruby 的用户\n\nScalaobject Solution &#123;    def reverse(x: Int): Int = &#123;        if (x &gt; -10 &amp;&amp; x &lt; 10) &#123;            return x        &#125;        val minInt = -2147483648        val maxInt = 2147483647        var reversed = 0        var num = x        var sign = 1        if (x &lt; 0) &#123;            sign = -1            num = -x        &#125;        while (num != 0) &#123;            val digit = num % 10            num /= 10            if (sign * reversed &lt; minInt / 10 || sign * reversed &gt; maxInt / 10) &#123;                return 0            &#125;            reversed = reversed * 10 + digit        &#125;        sign * reversed    &#125;&#125;\n\n结果执行用时 : 424 ms, 击败 66.67% 使用 Scala 的用户\n内存消耗 : 51.57 MB, 击败 16.67% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn reverse(x: i32) -&gt; i32 &#123;        if x &gt; -10 &amp;&amp; x &lt; 10 &#123;            return x;        &#125;        let min_int = i32::MIN;        let max_int = i32::MAX;        let mut reversed = 0;        let mut num = x;        let mut sign = 1;        if x &lt; 0 &#123;            sign = -1;            num = -x;        &#125;        while num != 0 &#123;            let digit = num % 10;            num /= 10;            if sign * reversed &lt; min_int / 10 || sign * reversed &gt; max_int / 10 &#123;                return 0;            &#125;            reversed = reversed * 10 + digit;        &#125;        sign * reversed    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.16 MB, 击败 16.03% 使用 Rust 的用户\n\nRacket(define (reverse x)  (define _reverse    (lambda (ls)      (if (null? ls)          &#x27;()          (append (_reverse (cdr ls)) (list (car ls))))))  (let* ((to-list (string-&gt;list (number-&gt;string (abs x))))         (reversed-list (_reverse to-list))         (reversed-str (list-&gt;string reversed-list))         (reversed-num (string-&gt;number reversed-str))         (reversed (if (&lt; x 0) (- 0 reversed-num) reversed-num)))    (if (and (&gt;= reversed -2147483648) (&lt;= reversed 2147483647))        reversed        0)))\n\n结果执行用时 : 216 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 98.86 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang-export([reverse/1]).reverse(X) when X &gt;= -9, X =&lt; 9 -&gt;    X;reverse(X) -&gt;    Sign = if X &lt; 0 -&gt; -1; true -&gt; 1 end,    AbsX = abs(X),    Reversed = reverse_helper(AbsX, 0),    case Reversed * Sign of        Result when Result &gt;= -2147483648, Result =&lt; 2147483647 -&gt; Result;        _ -&gt; 0    end.reverse_helper(0, Acc) -&gt;    Acc;reverse_helper(X, Acc) -&gt;    Digit = X rem 10,    NewAcc = Acc * 10 + Digit,    NewX = X div 10,    reverse_helper(NewX, NewAcc).\n\n结果执行用时 : 256 ms, 击败 -% 使用 Erlang 的用户\n内存消耗 : 55.36 MB, 击败 -% 使用 Erlang 的用户\n\nElixirdefmodule Solution do  @spec reverse(x :: integer) :: integer  def reverse(x) when x in -9..9 do    x  end  def reverse(x) do    sign = if x &lt; 0, do: -1, else: 1    abs_x = abs(x)    reversed = reverse_helper(abs_x, 0)    case reversed * sign do      result when result &gt;= -2147483648 and result &lt;= 2147483647 -&gt; result      _ -&gt; 0    end  end  defp reverse_helper(0, acc), do: acc  defp reverse_helper(x, acc) do    digit = rem(x, 10)    new_acc = acc * 10 + digit    new_x = div(x, 10)    reverse_helper(new_x, new_acc)  endend\n\n结果执行用时 : 304 ms, 击败 100.00% 使用 Elixir 的用户\n内存消耗 : 68.14 MB, 击败 100.00% 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"闪电侠 第六季 第八集 巴里·艾伦的最后动摇 （2）","url":"/zh-CN/f1ba3e765fe0/","content":"\n剧情介绍　　雷·帕尔默（Ray Palmer）的“对角线探测器”（Paragondetector）将巴里（Barry），乔恩（J’onn J’onzz）和常春藤镇科学家瑞安·崔（Ryan Choi）确定为剩余的三人，因此拉尔夫（Ralph），艾里斯（Iris）和雷（Ray）离开招募崔。监控器恢复Cisco的权力后，Flash和Nash团队（现为Pariah）返回到后者找到的会议厅；他们在这里找到了反物质加农炮，并使用Earth-90的闪电侠为其供电。他们成功地释放了他，但是大炮开始变得至关重要，因此帕里亚（Pariah）从另一个地球招募了黑色闪电来帮助控制能量。当Barry准备牺牲自己时，Earth-90 Barry阻止了他，取而代之。摧毁大炮。在其他地方，约翰·康斯坦丁（John Constantine）米娅·斯莫克（Mia Smoak）和约翰·迪格（John Diggle）在666号地球上拜访了路西法，将奥利弗的灵魂重拾回来，他们在炼狱中找到了。在他们离开之前，吉姆·科里根（Jim Corrigan）出现了，因此他可以将幽灵的力量传递给奥利弗（Oliver）。他接受了，君士坦丁的团队被遣散，没有他。当英雄们重组时，反监视者派出洗脑的先驱者攻击他们并杀死监视者，这样他就可以摧毁多宇宙了。在他被杀之前，帕里亚将其传送到消失点。在这里学习Lex Luthor用《命运之书》代替Earth-96 Superman 与他自己。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"绿箭侠 第八季 第七集 炼狱","url":"/zh-CN/e744b741d402/","content":"\n剧情介绍　　奥利弗的任务将他带到了炼狱岛（Lian Yu），在这里，他试图忽视即将到来的危机所带来的后果，直到他得到一位老朋友的帮助。与此同时，团结一致的绿箭队（Team Arrow）则迎来了一个熟悉的敌人。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00008.字符串转换整数(atoi)","url":"/zh-CN/b9627de17441/","content":"\n题目描述请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 atoi 函数）。\n函数 myAtoi(string s) 的算法如下：\n\n读入字符串并丢弃无用的前导空格\n检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。\n读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。\n将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。\n如果整数数超过 32 位有符号整数范围 [$−2^{31},  2^{31} − 1$] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 $−2^{31}$ 的整数应该被固定为 $−2^{31}$ ，大于 $2^{31} − 1$ 的整数应该被固定为 $2^{31} − 1$ 。\n返回整数作为最终结果。\n\n注意：\n本题中的空白字符只包括空格字符 ‘ ‘ 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。\n\n示例 1：\n输入：s &#x3D; “42”输出：42解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。第 1 步：”42”（当前没有读入字符，因为没有前导空格）第 2 步：”42”（当前没有读入字符，因为这里不存在 ‘-‘ 或者 ‘+’）第 3 步：”42”（读入 “42”）解析得到整数 42 。由于 “42” 在范围 [$−2^{31}, 2^{31} − 1$] 内，最终结果为 42 。\n\n示例 2：\n输入：s &#x3D; “&nbsp;&nbsp;&nbsp;-42”输出：-42解释：第 1 步：”&nbsp;&nbsp;&nbsp;-42”（读入前导空格，但忽视掉）第 2 步：”&nbsp;&nbsp;&nbsp;-42”（读入 ‘-‘ 字符，所以结果应该是负数）第 3 步：”&nbsp;&nbsp;&nbsp;-42”（读入 “42”）解析得到整数 -42 。由于 “-42” 在范围 [$−2^{31}, 2^{31} − 1$] 内，最终结果为 -42 。\n\n示例 3：\n输入：s &#x3D; “4193 with words”输出：4193解释：第 1 步：”4193 with words”（当前没有读入字符，因为没有前导空格）第 2 步：”4193 with words”（当前没有读入字符，因为这里不存在 ‘-‘ 或者 ‘+’）第 3 步：”4193 with words”（读入 “4193”；由于下一个字符不是一个数字，所以读入停止）解析得到整数 4193 。由于 “4193” 在范围 [$−2^{31}, 2^{31} − 1$] 内，最终结果为 4193 。\n\n提示：\n0 &lt;&#x3D; s.length &lt;&#x3D; 200\ns 由英文字母（大写和小写）、数字（0-9）、’ ‘、’+’、’-‘ 和 ‘.’ 组成\n\n\n解决方法C++class Solution &#123;public:    int myAtoi(string s) &#123;        s.erase(0, s.find_first_not_of(&#x27; &#x27;));        if (s.empty())            return 0;        int sign = 1;        size_t i = 0;        if (s[i] == &#x27;+&#x27; || s[i] == &#x27;-&#x27;) &#123;            sign = (s[i++] == &#x27;-&#x27;) ? -1 : 1;        &#125;        long result = 0;        while (i &lt; s.length() &amp;&amp; isdigit(s[i])) &#123;            result = result * 10 + (s[i++] - &#x27;0&#x27;);            if (result * sign &gt;= INT_MAX)                return INT_MAX;            else if (result * sign &lt;= INT_MIN)                return INT_MIN;        &#125;        return result * sign;    &#125;&#125;;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C++ 的用户\n内存消耗 : 6.43 MB, 击败 68.82% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int myAtoi(String s) &#123;        s = s.trim();        if (s.isEmpty())            return 0;        int sign = 1;        int i = 0;        if (s.charAt(i) == &#x27;+&#x27; || s.charAt(i) == &#x27;-&#x27;) &#123;            sign = (s.charAt(i++) == &#x27;-&#x27;) ? -1 : 1;        &#125;        long result = 0;        while (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i))) &#123;            result = result * 10 + (s.charAt(i++) - &#x27;0&#x27;);            if (result * sign &gt;= Integer.MAX_VALUE)                return Integer.MAX_VALUE;            else if (result * sign &lt;= Integer.MIN_VALUE)                return Integer.MIN_VALUE;        &#125;        return (int) (result * sign);    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 41.44 MB, 击败 6.90% 使用 Java 的用户\n\nPythonclass Solution(object):    def myAtoi(self, s):        s = s.strip()        if not s:            return 0        sign = 1        i = 0        if s[i] == &#x27;+&#x27; or s[i] == &#x27;-&#x27;:            sign = -1 if s[i] == &#x27;-&#x27; else 1            i += 1        result = 0        while i &lt; len(s) and s[i].isdigit():            result = result * 10 + int(s[i])            i += 1            if result * sign &gt;= 2**31 - 1:                return 2**31 - 1            elif result * sign &lt;= -2**31:                return -2**31        return result * sign\n\n结果执行用时 : 24 ms, 击败 82.57% 使用 Python 的用户\n内存消耗 : 13.01 MB, 击败 77.81% 使用 Python 的用户\n\nPython3class Solution:    def myAtoi(self, s: str) -&gt; int:        s = s.strip()        if not s:            return 0        sign = 1        i = 0        if s[i] == &#x27;+&#x27; or s[i] == &#x27;-&#x27;:            sign = -1 if s[i] == &#x27;-&#x27; else 1            i += 1        result = 0        while i &lt; len(s) and s[i].isdigit():            result = result * 10 + int(s[i])            i += 1            if result * sign &gt;= 2**31 - 1:                return 2**31 - 1            elif result * sign &lt;= -2**31:                return -2**31        return result * sign\n\n结果执行用时 : 44 ms, 击败 76.98% 使用 Python3 的用户\n内存消耗 : 16.98 MB, 击败 5.10% 使用 Python3 的用户\n\nCint myAtoi(char* s) &#123;    if (s == NULL) return 0;    while (*s &amp;&amp; isspace(*s)) &#123;        s++;    &#125;    int sign = 1;    if (*s == &#x27;-&#x27; || *s == &#x27;+&#x27;) &#123;        sign = (*s == &#x27;-&#x27;) ? -1 : 1;        s++;    &#125;    long result = 0;    while (*s &amp;&amp; isdigit(*s)) &#123;        result = result * 10 + (*s - &#x27;0&#x27;);        if (result * sign &gt;= INT_MAX) &#123;            return INT_MAX;        &#125; else if (result * sign &lt;= INT_MIN) &#123;            return INT_MIN;        &#125;        s++;    &#125;    return (int)(result * sign);&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 6.07 MB, 击败 98.05% 使用 C 的用户\n\nC#public class Solution &#123;    public int MyAtoi(string s) &#123;        if (string.IsNullOrWhiteSpace(s))            return 0;        s = s.Trim();        int sign = 1;        int i = 0;        if (s[i] == &#x27;+&#x27; || s[i] == &#x27;-&#x27;) &#123;            sign = (s[i++] == &#x27;-&#x27;) ? -1 : 1;        &#125;        long result = 0;        while (i &lt; s.Length &amp;&amp; char.IsDigit(s[i])) &#123;            result = result * 10 + (s[i++] - &#x27;0&#x27;);            if (result * sign &gt;= int.MaxValue)                return int.MaxValue;            else if (result * sign &lt;= int.MinValue)                return int.MinValue;        &#125;        return (int)(result * sign);    &#125;&#125;\n\n结果执行用时 : 52 ms, 击败 93.48% 使用 C# 的用户\n内存消耗 : 38.67 MB, 击败 23.48% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; s * @return &#123;number&#125; */var myAtoi = function(s) &#123;    s = s.trim();    if (!s)        return 0;    let sign = 1;    let i = 0;    if (s[i] === &#x27;+&#x27; || s[i] === &#x27;-&#x27;) &#123;        sign = (s[i++] === &#x27;-&#x27;) ? -1 : 1;    &#125;    let result = 0;    while (i &lt; s.length &amp;&amp; !isNaN(parseInt(s[i]))) &#123;        result = result * 10 + parseInt(s[i++]);        if (result * sign &gt;= Math.pow(2, 31) - 1) &#123;            return Math.pow(2, 31) - 1;        &#125; else if (result * sign &lt;= -Math.pow(2, 31)) &#123;            return -Math.pow(2, 31);        &#125;    &#125;    return result * sign;&#125;;\n\n结果执行用时 : 76 ms, 击败 58.19% 使用 JavaScript 的用户\n内存消耗 : 43.27 MB, 击败 48.14% 使用 JavaScript 的用户\n\nTypeScriptfunction myAtoi(s: string): number &#123;    s = s.trim();    if (!s)        return 0;    let sign = 1;    let i = 0;    if (s[i] === &#x27;+&#x27; || s[i] === &#x27;-&#x27;) &#123;        sign = (s[i++] === &#x27;-&#x27;) ? -1 : 1;    &#125;    let result = 0;    while (i &lt; s.length &amp;&amp; !isNaN(parseInt(s[i]))) &#123;        result = result * 10 + parseInt(s[i++]);        if (result * sign &gt;= Math.pow(2, 31) - 1) &#123;            return Math.pow(2, 31) - 1;        &#125; else if (result * sign &lt;= -Math.pow(2, 31)) &#123;            return -Math.pow(2, 31);        &#125;    &#125;    return result * sign;&#125;\n\n结果执行用时 : 88 ms, 击败 24.75% 使用 TypeScript 的用户\n内存消耗 : 44.51 MB, 击败 64.64% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String $s     * @return Integer     */    function myAtoi($s) &#123;        $s = trim($s);        if ($s === &#x27;&#x27;)            return 0;        $sign = 1;        $i = 0;        if ($s[$i] === &#x27;+&#x27; || $s[$i] === &#x27;-&#x27;) &#123;            $sign = ($s[$i++] === &#x27;-&#x27;) ? -1 : 1;        &#125;        $result = 0;        while ($i &lt; strlen($s) &amp;&amp; is_numeric($s[$i])) &#123;            $result = $result * 10 + (int)($s[$i++]);            if ($result * $sign &gt;= pow(2, 31) - 1) &#123;                return pow(2, 31) - 1;            &#125; else if ($result * $sign &lt;= -pow(2, 31)) &#123;                return -pow(2, 31);            &#125;        &#125;        return $result * $sign;    &#125;&#125;\n\n结果执行用时 : 12 ms, 击败 26.09% 使用 PHP 的用户\n内存消耗 : 19.36 MB, 击败 8.70% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func myAtoi(_ s: String) -&gt; Int &#123;        let trimmed = s.trimmingCharacters(in: .whitespaces)        if trimmed.isEmpty &#123;            return 0        &#125;        var sign = 1        var i = trimmed.startIndex        if trimmed[i] == &quot;+&quot; || trimmed[i] == &quot;-&quot; &#123;            sign = trimmed[i] == &quot;-&quot; ? -1 : 1            i = trimmed.index(after: i)        &#125;        var result = 0        while i &lt; trimmed.endIndex &amp;&amp; trimmed[i].isNumber &#123;            if let digit = Int(String(trimmed[i])) &#123;                result = result * 10 + digit                if result * sign &gt;= Int32.max &#123;                    return Int(Int32.max)                &#125; else if result * sign &lt;= Int32.min &#123;                    return Int(Int32.min)                &#125;            &#125;            i = trimmed.index(after: i)        &#125;        return result * sign    &#125;&#125;\n\n结果执行用时 : 12 ms, 击败 27.50% 使用 Swift 的用户\n内存消耗 : 16.10 MB, 击败 5.00% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun myAtoi(s: String): Int &#123;        var trimmed = s.trim()        if (trimmed.isEmpty())            return 0        var sign = 1        var i = 0        if (trimmed[i] == &#x27;+&#x27; || trimmed[i] == &#x27;-&#x27;) &#123;            sign = if (trimmed[i] == &#x27;-&#x27;) -1 else 1            i++        &#125;        var result = 0L        while (i &lt; trimmed.length &amp;&amp; trimmed[i].isDigit()) &#123;            result = result * 10 + (trimmed[i] - &#x27;0&#x27;)            if (result * sign &gt;= Int.MAX_VALUE) &#123;                return Int.MAX_VALUE            &#125; else if (result * sign &lt;= Int.MIN_VALUE) &#123;                return Int.MIN_VALUE            &#125;            i++        &#125;        return (result * sign).toInt()    &#125;&#125;\n\n结果执行用时 : 208 ms, 击败 16.22% 使用 Kotlin 的用户\n内存消耗 : 36.90 MB, 击败 29.73% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int myAtoi(String s) &#123;    s = s.trim();    int sign = 1;    int result = 0;    final maxVal = (1 &lt;&lt; 31) - 1;    final minVal = -(1 &lt;&lt; 31);    if (s.isEmpty) return 0;    int i = 0;    if (s[i] == &#x27;-&#x27;) &#123;        sign = -1;        i++;    &#125; else if (s[i] == &#x27;+&#x27;) &#123;        i++;    &#125;    while (i &lt; s.length &amp;&amp; s[i].compareTo(&#x27;0&#x27;) &gt;= 0 &amp;&amp; s[i].compareTo(&#x27;9&#x27;) &lt;= 0) &#123;        int digit = s.codeUnitAt(i) - &#x27;0&#x27;.codeUnitAt(0);        if (result &gt; (maxVal - digit) ~/ 10) &#123;        return sign == 1 ? maxVal : minVal;        &#125;        result = result * 10 + digit;        i++;    &#125;    return result * sign;  &#125;&#125;\n\n结果执行用时 : 340 ms, 击败 50.00% 使用 Dart 的用户\n内存消耗 : 143.98 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc myAtoi(s string) int &#123;    s = strings.TrimSpace(s)    if s == &quot;&quot; &#123;        return 0    &#125;    sign := 1    result := 0    maxVal := int(math.Pow(2, 31)) - 1    minVal := -int(math.Pow(2, 31))    i := 0    if s[i] == &#x27;-&#x27; &#123;        sign = -1        i++    &#125; else if s[i] == &#x27;+&#x27; &#123;        i++    &#125;    for i &lt; len(s) &amp;&amp; unicode.IsDigit(rune(s[i])) &#123;        digit := int(s[i] - &#x27;0&#x27;)        if result &gt; (maxVal-digit)/10 &#123;            if sign == 1 &#123;                return maxVal            &#125;            return minVal        &#125;        result = result*10 + digit        i++    &#125;    return result * sign&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.02 MB, 击败 100.00% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; s# @return &#123;Integer&#125;def my_atoi(s)    s = s.strip    return 0 if s.empty?    sign = 1    result = 0    max_val = 2**31 - 1    min_val = -(2**31)    i = 0    if s[i] == &#x27;-&#x27;        sign = -1        i += 1    elsif s[i] == &#x27;+&#x27;        i += 1    end    while i &lt; s.length &amp;&amp; s[i].match?(/\\d/)        digit = s[i].to_i        if result &gt; (max_val - digit) / 10            return sign == 1 ? max_val : min_val        end        result = result * 10 + digit        i += 1    end    result * signend\n\n结果执行用时 : 68 ms, 击败 -% 使用 Ruby 的用户\n内存消耗 : 206.60 MB, 击败 33.33% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def myAtoi(s: String): Int = &#123;    val trimmed = s.trim    if (trimmed.isEmpty) return 0    var sign = 1    var result = 0    val maxVal = Int.MaxValue    val minVal = Int.MinValue    var i = 0    if (trimmed(i) == &#x27;-&#x27;) &#123;      sign = -1      i += 1    &#125; else if (trimmed(i) == &#x27;+&#x27;) &#123;      i += 1    &#125;    while (i &lt; trimmed.length &amp;&amp; trimmed(i).isDigit) &#123;      val digit = trimmed(i).asDigit      if (result &gt; (maxVal - digit) / 10) &#123;        return if (sign == 1) maxVal else minVal      &#125;      result = result * 10 + digit      i += 1    &#125;    result * sign  &#125;&#125;\n\n结果执行用时 : 480 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 54.23 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn my_atoi(s: String) -&gt; i32 &#123;        let trimmed = s.trim();        if trimmed.is_empty() &#123;            return 0;        &#125;        let mut sign = 1;        let mut result: i64 = 0;        let max_val = i32::MAX as i64;        let min_val = i32::MIN as i64;        let mut i = 0;        if trimmed.as_bytes()[i] as char == &#x27;-&#x27; &#123;            sign = -1;            i += 1;        &#125; else if trimmed.as_bytes()[i] as char == &#x27;+&#x27; &#123;            i += 1;        &#125;        while i &lt; trimmed.len() &amp;&amp; (trimmed.as_bytes()[i] as char).is_digit(10) &#123;            let digit = trimmed.as_bytes()[i] as char;            result = result * 10 + digit.to_digit(10).unwrap() as i64;            if result * sign &gt;= max_val &#123;                return i32::MAX;            &#125; else if result * sign &lt;= min_val &#123;                return i32::MIN;            &#125;            i += 1;        &#125;        result as i32 * sign as i32    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.01 MB, 击败 59.21% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang-spec my_atoi(S :: unicode:unicode_binary()) -&gt; integer().my_atoi(S) -&gt;    Str = unicode:characters_to_list(S),    Str2 = string:strip(Str),    case string:to_integer(Str2) of        &#123;Num, _&#125; when is_integer(Num) -&gt;            case &#123;Num &lt; -2147483648, Num &gt; 2147483647&#125; of                &#123;true, false&#125; -&gt; -2147483648;                &#123;false, true&#125; -&gt; 2147483647;                &#123;false, false&#125; -&gt; Num            end;        _ -&gt; 0    end.\n\n结果执行用时 : 288 ms, 击败 100.00% 使用 Erlang 的用户\n内存消耗 : 59.31 MB, 击败 100.00% 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00009.回文数","url":"/zh-CN/b80f588f5148/","content":"\n题目描述给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n例如，121 是回文，而 123 不是。\n示例 1：\n输入：x &#x3D; 121输出：true\n\n示例 2：\n输入：x &#x3D; -121输出：false解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n\n示例 3：\n输入：x &#x3D; 10输出：false解释：从右向左读, 为 01 。因此它不是一个回文数。\n\n提示：\n$-2^{31} &lt;&#x3D; x &lt;&#x3D; 2^{31} - 1$\n\n进阶：你能不将整数转为字符串来解决这个问题吗？\n\n解决方法C++class Solution &#123;public:    bool isPalindrome(int x) &#123;        if (x &lt; 0) &#123;            return false;        &#125;        std::string strX = std::to_string(x);        int left = 0;        int right = strX.length() - 1;        while (left &lt; right) &#123;            if (strX[left] != strX[right]) &#123;                return false;            &#125;            left++;            right--;        &#125;        return true;    &#125;&#125;;\n\n结果执行用时 : 12 ms, 击败 52.12% 使用 C++ 的用户\n内存消耗 : 6.23 MB, 击败 43.77% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public boolean isPalindrome(int x) &#123;        if (x &lt; 0) &#123;            return false;        &#125;        String strX = String.valueOf(x);        int left = 0;        int right = strX.length() - 1;        while (left &lt; right) &#123;            if (strX.charAt(left) != strX.charAt(right)) &#123;                return false;            &#125;            left++;            right--;        &#125;        return true;    &#125;&#125;\n\n结果执行用时 : 6 ms, 击败 55.42% 使用 Java 的用户\n内存消耗 : 42.70 MB, 击败 9.49% 使用 Java 的用户\n\nPythonclass Solution(object):    def isPalindrome(self, x):        if x &lt; 0:            return False        str_x = str(x)        left = 0        right = len(str_x) - 1        while left &lt; right:            if str_x[left] != str_x[right]:                return False            left += 1            right -= 1        return True\n\n结果执行用时 : 82 ms, 击败 81.38% 使用 Python 的用户\n内存消耗 : 12.87 MB, 击败 85.78% 使用 Python 的用户\n\nPython3class Solution:    def isPalindrome(self, x: int) -&gt; bool:        if x &lt; 0:            return False        str_x = str(x)        left = 0        right = len(str_x) - 1        while left &lt; right:            if str_x[left] != str_x[right]:                return False            left += 1            right -= 1        return True\n\n结果执行用时 : 56 ms, 击败 92.88% 使用 Python3 的用户\n内存消耗 : 17.05 MB, 击败 5.11% 使用 Python3 的用户\n\nC#include &lt;stdbool.h&gt;bool isPalindrome(int x) &#123;    if (x &lt; 0) &#123;        return false;    &#125;    long long reversed = 0;    int original = x;    while (x &gt; 0) &#123;        int digit = x % 10;        reversed = reversed * 10LL + digit;        x /= 10;    &#125;    return original == reversed;&#125;\n\n结果执行用时 : 8 ms, 击败 77.34% 使用 C 的用户\n内存消耗 : 6.36 MB, 击败 88.88% 使用 C 的用户\n\nC#public class Solution &#123;    public bool IsPalindrome(int x) &#123;        if (x &lt; 0) &#123;            return false;        &#125;        int original = x;        int reversed = 0;        while (x != 0) &#123;            int digit = x % 10;            reversed = reversed * 10 + digit;            x /= 10;        &#125;        return original == reversed;    &#125;&#125;\n\n结果执行用时 : 44 ms, 击败 51.96% 使用 C# 的用户\n内存消耗 : 30.38 MB, 击败 32.71% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number&#125; x * @return &#123;boolean&#125; */var isPalindrome = function(x) &#123;    if (x &lt; 0) &#123;        return false;    &#125;    let original = x;    let reversed = 0;    while (x &gt; 0) &#123;        let digit = x % 10;        reversed = reversed * 10 + digit;        x = Math.floor(x / 10);    &#125;    return original === reversed;&#125;;\n\n结果执行用时 : 172 ms, 击败 25.28% 使用 JavaScript 的用户\n内存消耗 : 55.16 MB, 击败 6.23% 使用 JavaScript 的用户\n\nTypeScriptfunction isPalindrome(x: number): boolean &#123;    if (x &lt; 0) &#123;        return false;    &#125;    let original = x;    let reversed = 0;    while (x &gt; 0) &#123;        const digit = x % 10;        reversed = reversed * 10 + digit;        x = Math.floor(x / 10);    &#125;    return original === reversed;&#125;\n\n结果执行用时 : 144 ms, 击败 78.49% 使用 TypeScript 的用户\n内存消耗 : 55.14 MB, 击败 7.92% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer $x     * @return Boolean     */    function isPalindrome($x) &#123;        if ($x &lt; 0) &#123;            return false;        &#125;        $original = $x;        $reversed = 0;        while ($x &gt; 0) &#123;            $digit = $x % 10;            $reversed = $reversed * 10 + $digit;            $x = intval($x / 10);        &#125;        return $original === $reversed;    &#125;&#125;\n\n结果执行用时 : 28 ms, 击败 68.75% 使用 PHP 的用户\n内存消耗 : 19.27 MB, 击败 9.38% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func isPalindrome(_ x: Int) -&gt; Bool &#123;        if x &lt; 0 &#123;            return false        &#125;        var original = x        var reversed = 0        var num = x        while num &gt; 0 &#123;            let digit = num % 10            reversed = reversed * 10 + digit            num /= 10        &#125;        return original == reversed    &#125;&#125;\n\n结果执行用时 : 28 ms, 击败 79.49% 使用 Swift 的用户\n内存消耗 : 15.09 MB, 击败 5.13% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun isPalindrome(x: Int): Boolean &#123;        if (x &lt; 0) &#123;            return false        &#125;        var original = x        var reversed = 0        var num = x        while (num &gt; 0) &#123;            val digit = num % 10            reversed = reversed * 10 + digit            num /= 10        &#125;        return original == reversed    &#125;&#125;\n\n结果执行用时 : 200 ms, 击败 85.11% 使用 Kotlin 的用户\n内存消耗 : 35.91 MB, 击败 45.75% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  bool isPalindrome(int x) &#123;    if (x &lt; 0) &#123;      return false;    &#125;    String strX = x.toString();    int left = 0;    int right = strX.length - 1;    while (left &lt; right) &#123;      if (strX[left] != strX[right]) &#123;        return false;      &#125;      left++;      right--;    &#125;    return true;  &#125;&#125;\n\n结果执行用时 : 496 ms, 击败 11.76% 使用 Dart 的用户\n内存消耗 : 146.45 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc isPalindrome(x int) bool &#123;    if x &lt; 0 &#123;        return false    &#125;    strX := strconv.Itoa(x)    left, right := 0, len(strX)-1    for left &lt; right &#123;        if strX[left] != strX[right] &#123;            return false        &#125;        left++        right--    &#125;    return true&#125;\n\n结果执行用时 : 12 ms, 击败 66.98% 使用 Go 的用户\n内存消耗 : 4.36 MB, 击败 22.27% 使用 Go 的用户\n\nRuby# @param &#123;Integer&#125; x# @return &#123;Boolean&#125;def is_palindrome(x)    return false if x &lt; 0    str_x = x.to_s    left = 0    right = str_x.length - 1    while left &lt; right        return false if str_x[left] != str_x[right]        left += 1        right -= 1    end    trueend\n\n结果执行用时 : 88 ms, 击败 69.23% 使用 Ruby 的用户\n内存消耗 : 206.53 MB, 击败 7.69% 使用 Ruby 的用户\n\nScalaobject Solution &#123;    def isPalindrome(x: Int): Boolean = &#123;        if (x &lt; 0) &#123;            false        &#125; else &#123;            val strX = x.toString            val len = strX.length            var left = 0            var right = len - 1            while (left &lt; right) &#123;                if (strX(left) != strX(right)) &#123;                    return false                &#125;                left += 1                right -= 1            &#125;            true        &#125;    &#125;&#125;\n\n结果执行用时 : 504 ms, 击败 66.67% 使用 Scala 的用户\n内存消耗 : 52.84 MB, 击败 79.17% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn is_palindrome(x: i32) -&gt; bool &#123;        if x &lt; 0 &#123;            return false;        &#125;        let mut num = x;        let mut reversed = 0;        let original = x;        while num != 0 &#123;            let digit = num % 10;            reversed = reversed * 10 + digit;            num /= 10;        &#125;        original == reversed    &#125;&#125;\n\n结果执行用时 : 4 ms, 击败 76.59% 使用 Rust 的用户\n内存消耗 : 2.08 MB, 击败 38.68% 使用 Rust 的用户\n\nRacket(define (is-palindrome x)  (define (reverse-number n)    (let loop ((num n) (reversed 0))      (if (= num 0)          reversed          (loop (quotient num 10) (+ (* reversed 10) (remainder num 10))))))  (if (&lt; x 0)      #f      (= x (reverse-number x))))\n\n结果执行用时 : 300 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 121.48 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang-export([is_palindrome/1]).is_palindrome(X) when X &lt; 0 -&gt;    false;is_palindrome(X) -&gt;    is_palindrome(X, 0, X).is_palindrome(0, Rev, Original) -&gt;    Original =:= Rev;is_palindrome(Num, Rev, Original) -&gt;    Digit = Num rem 10,    NewRev = Rev * 10 + Digit,    NewNum = Num div 10,    is_palindrome(NewNum, NewRev, Original).\n\n结果执行用时 : 1144 ms, 击败 -% 使用 Erlang 的用户\n内存消耗 : 55.36 MB, 击败 -% 使用 Erlang 的用户\n\nElixirdefmodule Solution do  @spec is_palindrome(x :: integer) :: boolean  def is_palindrome(x) when x &lt; 0, do: false  def is_palindrome(x) do    is_palindrome(x, 0, x)  end  defp is_palindrome(0, rev, original), do: original == rev  defp is_palindrome(num, rev, original) do    digit = rem(num, 10)    new_rev = rev * 10 + digit    new_num = div(num, 10)    is_palindrome(new_num, new_rev, original)  endend\n\n结果执行用时 : 1056 ms, 击败 100.00% 使用 Elixir 的用户\n内存消耗 : 67.73 MB, 击败 100.00% 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"孤独的美食家 第八季 第十集 东京都世田谷区豪德寺的照烧套餐和奶油炸肉饼","url":"/zh-CN/b28d85d78018/","content":"\n剧情介绍　　井之头五郎（松重丰）为了和商谈对象内田良夫见面，去了豪德寺。五郎结束了和内田的某些麻烦的交流，累了，决定吃完晚饭回家。不久发现了「吃饭处」的旗帜。鱼和西餐菜单被写，是日还是西洋”不能读”「应时彩鱼稻na」试着进入的事！被店内各处贴的多种多样的菜单一边夺人眼球，订购「隔了好久的照烧套餐」「赏月粘稠」「奶油可乐饼」。“照烧套餐”除了甜辣绝妙的“照烧海带”之外，还有配角美味的“海带佃煮”、温柔口味的“每日更换煮物”、让人感受到店家担心的“菠菜芝麻拌菜”等丰富多彩的套餐。“奶油炸肉饼”配有塔塔酱汁，其组合意外的美味让白饭不断进展，再来一碗米饭，点上“生鱼片”、“自家制梅干”。最后，把剩下的“赏月山药”和“生鱼片”放在饭上，用“海鲜赏月山药泥盖浇饭”结束，五郎非常满足。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"曼达洛人 第一季 第五集 神枪手","url":"/zh-CN/3ba59b29b778/","content":"\n剧情介绍　　曼达洛人帮助一名陷入困境的新手赏金猎人。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"食戟之灵 第四季 神之皿 第九集 第一席与第二席","url":"/zh-CN/ba9d4fd80915/","content":"\n剧情介绍　　中央和叛军各得一胜！一色慧与司瑛士的食戟对决进入了高潮！这一回合的主题是经典的法式食材——兔肉。一色慧的料理成功打动了评委，但司瑛士似乎毫无动摇。他能否超越一色慧那极具攻击性的料理？\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"力扣00010.正则表达式匹配","url":"/zh-CN/3b504d42a3b9/","content":"\n题目描述给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。\n\n‘.’ 匹配任意单个字符\n‘*’ 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n\n示例 1：\n输入：s &#x3D; “aa”, p &#x3D; “a”输出：false解释：”a” 无法匹配 “aa” 整个字符串。\n\n示例 2：\n输入：s &#x3D; “aa”, p &#x3D; “a*”输出：true解释：因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。\n\n示例 3：\n输入：s &#x3D; “ab”, p &#x3D; “.“输出：true解释：”.“ 表示可匹配零个或多个（’*’）任意字符（’.’）。\n\n提示：\n1 &lt;&#x3D; s.length &lt;&#x3D; 20\n1 &lt;&#x3D; p.length &lt;&#x3D; 20\ns 只包含从 a-z 的小写字母。\np 只包含从 a-z 的小写字母，以及字符 . 和 *。\n保证每次出现字符 * 时，前面都匹配到有效的字符\n\n\n解决方法C++class Solution &#123;public:    bool isMatch(string s, string p) &#123;        int m = s.length();        int n = p.length();        vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false));        dp[0][0] = true;        for (int j = 1; j &lt;= n; ++j) &#123;            if (p[j - 1] == &#x27;*&#x27;) &#123;                dp[0][j] = dp[0][j - 2];            &#125;        &#125;        for (int i = 1; i &lt;= m; ++i) &#123;            for (int j = 1; j &lt;= n; ++j) &#123;                if (p[j - 1] == &#x27;.&#x27; || p[j - 1] == s[i - 1]) &#123;                    dp[i][j] = dp[i - 1][j - 1];                &#125; else if (p[j - 1] == &#x27;*&#x27;) &#123;                    dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &#x27;.&#x27;));                &#125;            &#125;        &#125;        return dp[m][n];    &#125;&#125;;\n\n结果执行用时 : 4 ms, 击败 88.69% 使用 C++ 的用户\n内存消耗 : 6.96 MB, 击败 71.57% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public boolean isMatch(String s, String p) &#123;        int m = s.length();        int n = p.length();        boolean[][] dp = new boolean[m + 1][n + 1];        dp[0][0] = true;        for (int j = 1; j &lt;= n; ++j) &#123;            if (p.charAt(j - 1) == &#x27;*&#x27;) &#123;                dp[0][j] = dp[0][j - 2];            &#125;        &#125;        for (int i = 1; i &lt;= m; ++i) &#123;            for (int j = 1; j &lt;= n; ++j) &#123;                if (p.charAt(j - 1) == &#x27;.&#x27; || p.charAt(j - 1) == s.charAt(i - 1)) &#123;                    dp[i][j] = dp[i - 1][j - 1];                &#125; else if (p.charAt(j - 1) == &#x27;*&#x27;) &#123;                    dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] &amp;&amp; (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == &#x27;.&#x27;));                &#125;            &#125;        &#125;        return dp[m][n];    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 40.96 MB, 击败 14.24% 使用 Java 的用户\n\nPythonclass Solution(object):    def isMatch(self, s, p):        m, n = len(s), len(p)        dp = [[False] * (n + 1) for _ in range(m + 1)]        dp[0][0] = True        for i in range(2, n + 1):            if p[i - 1] == &#x27;*&#x27;:                dp[0][i] = dp[0][i - 2]        for i in range(1, m + 1):            for j in range(1, n + 1):                if p[j - 1] == &#x27;.&#x27; or p[j - 1] == s[i - 1]:                    dp[i][j] = dp[i - 1][j - 1]                elif p[j - 1] == &#x27;*&#x27;:                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == &#x27;.&#x27;))        return dp[m][n]\n\n结果执行用时 : 40 ms, 击败 48.50% 使用 Python 的用户\n内存消耗 : 12.98 MB, 击败 65.87% 使用 Python 的用户\n\nPython3class Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        m, n = len(s), len(p)        dp = [[False] * (n + 1) for _ in range(m + 1)]        dp[0][0] = True        for i in range(2, n + 1):            if p[i - 1] == &#x27;*&#x27;:                dp[0][i] = dp[0][i - 2]        for i in range(1, m + 1):            for j in range(1, n + 1):                if p[j - 1] == &#x27;.&#x27; or p[j - 1] == s[i - 1]:                    dp[i][j] = dp[i - 1][j - 1]                elif p[j - 1] == &#x27;*&#x27;:                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == &#x27;.&#x27;))        return dp[m][n]\n\n结果执行用时 : 48 ms, 击败 90.66% 使用 Python3 的用户\n内存消耗 : 17.07 MB, 击败 5.29% 使用 Python3 的用户\n\nCbool isMatch(char* s, char* p) &#123;    int m = strlen(s);    int n = strlen(p);    bool dp[m + 1][n + 1];    memset(dp, false, sizeof(dp));    dp[0][0] = true;    for (int j = 2; j &lt;= n; ++j) &#123;        if (p[j - 1] == &#x27;*&#x27;) &#123;            dp[0][j] = dp[0][j - 2];        &#125;    &#125;    for (int i = 1; i &lt;= m; ++i) &#123;        for (int j = 1; j &lt;= n; ++j) &#123;            if (p[j - 1] == &#x27;.&#x27; || p[j - 1] == s[i - 1]) &#123;                dp[i][j] = dp[i - 1][j - 1];            &#125; else if (p[j - 1] == &#x27;*&#x27;) &#123;                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &#x27;.&#x27;));            &#125;        &#125;    &#125;    return dp[m][n];&#125;\n\n结果执行用时 : 4 ms, 击败 85.05% 使用 C 的用户\n内存消耗 : 6.22 MB, 击败 51.22% 使用 C 的用户\n\nC#public class Solution &#123;    public bool IsMatch(string s, string p) &#123;        int m = s.Length;        int n = p.Length;        bool[,] dp = new bool[m + 1, n + 1];        dp[0, 0] = true;        for (int j = 2; j &lt;= n; ++j) &#123;            if (p[j - 1] == &#x27;*&#x27;) &#123;                dp[0, j] = dp[0, j - 2];            &#125;        &#125;        for (int i = 1; i &lt;= m; ++i) &#123;            for (int j = 1; j &lt;= n; ++j) &#123;                if (p[j - 1] == &#x27;.&#x27; || p[j - 1] == s[i - 1]) &#123;                    dp[i, j] = dp[i - 1, j - 1];                &#125; else if (p[j - 1] == &#x27;*&#x27;) &#123;                    dp[i, j] = dp[i, j - 2] || (dp[i - 1, j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &#x27;.&#x27;));                &#125;            &#125;        &#125;        return dp[m, n];    &#125;&#125;\n\n结果执行用时 : 56 ms, 击败 98.17% 使用 C# 的用户\n内存消耗 : 39.55 MB, 击败 38.53% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; s * @param &#123;string&#125; p * @return &#123;boolean&#125; */var isMatch = function(s, p) &#123;    const m = s.length;    const n = p.length;    const dp = Array.from(Array(m + 1), () =&gt; Array(n + 1).fill(false));    dp[0][0] = true;    for (let j = 2; j &lt;= n; ++j) &#123;        if (p[j - 1] === &#x27;*&#x27;) &#123;            dp[0][j] = dp[0][j - 2];        &#125;    &#125;    for (let i = 1; i &lt;= m; ++i) &#123;        for (let j = 1; j &lt;= n; ++j) &#123;            if (p[j - 1] === &#x27;.&#x27; || p[j - 1] === s[i - 1]) &#123;                dp[i][j] = dp[i - 1][j - 1];            &#125; else if (p[j - 1] === &#x27;*&#x27;) &#123;                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] &amp;&amp; (s[i - 1] === p[j - 2] || p[j - 2] === &#x27;.&#x27;));            &#125;        &#125;    &#125;    return dp[m][n];&#125;;\n\n结果执行用时 : 64 ms, 击败 95.81% 使用 JavaScript 的用户\n内存消耗 : 51.29 MB, 击败 6.59% 使用 JavaScript 的用户\n\nTypeScriptfunction isMatch(s: string, p: string): boolean &#123;    const m: number = s.length;    const n: number = p.length;    const dp: boolean[][] = Array.from(Array(m + 1), () =&gt; Array(n + 1).fill(false));    dp[0][0] = true;    for (let j = 2; j &lt;= n; ++j) &#123;        if (p[j - 1] === &#x27;*&#x27;) &#123;            dp[0][j] = dp[0][j - 2];        &#125;    &#125;    for (let i = 1; i &lt;= m; ++i) &#123;        for (let j = 1; j &lt;= n; ++j) &#123;            if (p[j - 1] === &#x27;.&#x27; || p[j - 1] === s[i - 1]) &#123;                dp[i][j] = dp[i - 1][j - 1];            &#125; else if (p[j - 1] === &#x27;*&#x27;) &#123;                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] &amp;&amp; (s[i - 1] === p[j - 2] || p[j - 2] === &#x27;.&#x27;));            &#125;        &#125;    &#125;    return dp[m][n];&#125;\n\n结果执行用时 : 72 ms, 击败 83.00% 使用 TypeScript 的用户\n内存消耗 : 51.92 MB, 击败 5.00% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String $s     * @param String $p     * @return Boolean     */    function isMatch($s, $p) &#123;        $m = strlen($s);        $n = strlen($p);        $dp = array_fill(0, $m + 1, array_fill(0, $n + 1, false));        $dp[0][0] = true;        for ($j = 2; $j &lt;= $n; ++$j) &#123;            if ($p[$j - 1] == &#x27;*&#x27;) &#123;                $dp[0][$j] = $dp[0][$j - 2];            &#125;        &#125;        for ($i = 1; $i &lt;= $m; ++$i) &#123;            for ($j = 1; $j &lt;= $n; ++$j) &#123;                if ($p[$j - 1] == &#x27;.&#x27; || $p[$j - 1] == $s[$i - 1]) &#123;                    $dp[$i][$j] = $dp[$i - 1][$j - 1];                &#125; else if ($p[$j - 1] == &#x27;*&#x27;) &#123;                    $dp[$i][$j] = $dp[$i][$j - 2] || ($dp[$i - 1][$j] &amp;&amp; ($s[$i - 1] == $p[$j - 2] || $p[$j - 2] == &#x27;.&#x27;));                &#125;            &#125;        &#125;        return $dp[$m][$n];    &#125;&#125;\n\n结果执行用时 : 12 ms, 击败 100.00% 使用 PHP 的用户\n内存消耗 : 19.39 MB, 击败 7.69% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func isMatch(_ s: String, _ p: String) -&gt; Bool &#123;        let m = s.count        let n = p.count        var dp = Array(repeating: Array(repeating: false, count: n + 1), count: m + 1)        dp[0][0] = true        let sArr = Array(s)        let pArr = Array(p)        for j in stride(from: 2, through: n, by: 1) &#123;            if pArr[j - 1] == &quot;*&quot; &#123;                dp[0][j] = dp[0][j - 2]            &#125;        &#125;        for i in stride(from: 1, through: m, by: 1) &#123;            for j in stride(from: 1, through: n, by: 1) &#123;                if pArr[j - 1] == &quot;.&quot; || pArr[j - 1] == sArr[i - 1] &#123;                    dp[i][j] = dp[i - 1][j - 1]                &#125; else if pArr[j - 1] == &quot;*&quot; &#123;                    dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] &amp;&amp; (sArr[i - 1] == pArr[j - 2] || pArr[j - 2] == &quot;.&quot;))                &#125;            &#125;        &#125;        return dp[m][n]    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Swift 的用户\n内存消耗 : 15.19 MB, 击败 7.14% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun isMatch(s: String, p: String): Boolean &#123;        val m = s.length        val n = p.length        val dp = Array(m + 1) &#123; BooleanArray(n + 1) &#125;        dp[0][0] = true        for (j in 2..n) &#123;            if (p[j - 1] == &#x27;*&#x27;) &#123;                dp[0][j] = dp[0][j - 2]            &#125;        &#125;        for (i in 1..m) &#123;            for (j in 1..n) &#123;                if (p[j - 1] == &#x27;.&#x27; || p[j - 1] == s[i - 1]) &#123;                    dp[i][j] = dp[i - 1][j - 1]                &#125; else if (p[j - 1] == &#x27;*&#x27;) &#123;                    dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &#x27;.&#x27;))                &#125;            &#125;        &#125;        return dp[m][n]    &#125;&#125;\n\n结果执行用时 : 164 ms, 击败 70.83% 使用 Kotlin 的用户\n内存消耗 : 34.23 MB, 击败 70.83% 使用 Kotlin 的用户\n\nDartclass Solution &#123;    bool isMatch(String s, String p) &#123;    int m = s.length;    int n = p.length;    List&lt;List&lt;bool&gt;&gt; dp = List.generate(m + 1, (_) =&gt; List.filled(n + 1, false));    dp[0][0] = true;    for (int j = 2; j &lt;= n; ++j) &#123;        if (p[j - 1] == &#x27;*&#x27;) &#123;        dp[0][j] = dp[0][j - 2];        &#125;    &#125;    for (int i = 1; i &lt;= m; ++i) &#123;        for (int j = 1; j &lt;= n; ++j) &#123;        if (p[j - 1] == &#x27;.&#x27; || p[j - 1] == s[i - 1]) &#123;            dp[i][j] = dp[i - 1][j - 1];        &#125; else if (p[j - 1] == &#x27;*&#x27;) &#123;            dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &#x27;.&#x27;));        &#125;        &#125;    &#125;    return dp[m][n];    &#125;&#125;\n\n结果执行用时 : 332 ms, 击败 50.00% 使用 Dart 的用户\n内存消耗 : 147.81 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc isMatch(s string, p string) bool &#123;    m := len(s)    n := len(p)    dp := make([][]bool, m+1)    for i := range dp &#123;        dp[i] = make([]bool, n+1)    &#125;    dp[0][0] = true    for j := 2; j &lt;= n; j++ &#123;        if p[j-1] == &#x27;*&#x27; &#123;            dp[0][j] = dp[0][j-2]        &#125;    &#125;    for i := 1; i &lt;= m; i++ &#123;        for j := 1; j &lt;= n; j++ &#123;            if p[j-1] == &#x27;.&#x27; || p[j-1] == s[i-1] &#123;                dp[i][j] = dp[i-1][j-1]            &#125; else if p[j-1] == &#x27;*&#x27; &#123;                dp[i][j] = dp[i][j-2] || (dp[i-1][j] &amp;&amp; (s[i-1] == p[j-2] || p[j-2] == &#x27;.&#x27;))            &#125;        &#125;    &#125;    return dp[m][n]&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.16 MB, 击败 46.23% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; s# @param &#123;String&#125; p# @return &#123;Boolean&#125;def is_match(s, p)    m = s.length    n = p.length    dp = Array.new(m + 1) &#123; Array.new(n + 1, false) &#125;    dp[0][0] = true    (2..n).each do |j|        dp[0][j] = dp[0][j - 2] if p[j - 1] == &#x27;*&#x27;    end    (1..m).each do |i|        (1..n).each do |j|            if p[j - 1] == &#x27;.&#x27; || p[j - 1] == s[i - 1]                dp[i][j] = dp[i - 1][j - 1]            elsif p[j - 1] == &#x27;*&#x27;                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &#x27;.&#x27;))            end        end    end    dp[m][n]end\n\n结果执行用时 : 80 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.64 MB, 击败 100.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;    def isMatch(s: String, p: String): Boolean = &#123;        val m = s.length        val n = p.length        val dp = Array.ofDim[Boolean](m + 1, n + 1)        dp(0)(0) = true        for (j &lt;- 2 to n) &#123;            if (p(j - 1) == &#x27;*&#x27;) &#123;                dp(0)(j) = dp(0)(j - 2)            &#125;        &#125;        for (i &lt;- 1 to m) &#123;            for (j &lt;- 1 to n) &#123;                if (p(j - 1) == &#x27;.&#x27; || p(j - 1) == s(i - 1)) &#123;                    dp(i)(j) = dp(i - 1)(j - 1)                &#125; else if (p(j - 1) == &#x27;*&#x27;) &#123;                    dp(i)(j) = dp(i)(j - 2) || (dp(i - 1)(j) &amp;&amp; (s(i - 1) == p(j - 2) || p(j - 2) == &#x27;.&#x27;))                &#125;            &#125;        &#125;        dp(m)(n)    &#125;&#125;\n\n结果执行用时 : 516 ms, 击败 -% 使用 Scala 的用户\n内存消耗 : 54.05 MB, 击败 -% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn is_match(s: String, p: String) -&gt; bool &#123;        let s_chars: Vec&lt;char&gt; = s.chars().collect();        let p_chars: Vec&lt;char&gt; = p.chars().collect();        let m = s_chars.len();        let n = p_chars.len();        let mut dp = vec![vec![false; n + 1]; m + 1];        dp[0][0] = true;        for j in 2..=n &#123;            if p_chars[j - 1] == &#x27;*&#x27; &#123;                dp[0][j] = dp[0][j - 2];            &#125;        &#125;        for i in 1..=m &#123;            for j in 1..=n &#123;                if p_chars[j - 1] == &#x27;.&#x27; || p_chars[j - 1] == s_chars[i - 1] &#123;                    dp[i][j] = dp[i - 1][j - 1];                &#125; else if p_chars[j - 1] == &#x27;*&#x27; &#123;                    dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] &amp;&amp; (s_chars[i - 1] == p_chars[j - 2] || p_chars[j - 2] == &#x27;.&#x27;));                &#125;            &#125;        &#125;        dp[m][n]    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.30 MB, 击败 6.35% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"看见 第一季 第八集 启蒙之屋","url":"/zh-CN/6d2566cd3a83/","content":"\n剧情介绍　　双胞胎见到了杰拉马雷尔，终于揭开了真相。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"罪恶黑名单 第七季 第九集 猎户星迁移服务","url":"/zh-CN/aca2b9d76e42/","content":"\n剧情介绍　　雷德和莉兹调查了奥赖恩迁徙服务公司，这是一家暗中帮助罪犯消失并重新安置的组织。同时，卡塔莉娜深入挖掘一位老朋友的记忆，以获取更多关于汤森指令的信息。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"大雪","url":"/zh-CN/3dc074bb3cc0/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大雪\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大雪"]},{"title":"女超人 第五季 第九集 无限地球危机：第一部分（一）","url":"/zh-CN/08bfd139c809/","content":"\n剧情介绍　　监视者派遣先驱者（Harbinger）召集各大英雄——女超人、闪电侠、绿箭侠、蝙蝠女、白金翅膀、原子侠和超人——为即将来临的“危机”做准备。在他们的世界面临迫在眉睫的危险时，超级英雄们穿上战斗服准备迎接挑战，而琼恩和亚历克斯则联手莉娜，试图找到拯救地球-38人民的办法。\n　　这一跨界故事继续展开，涉及《蝙蝠女侠》第1季第9集、《闪电侠》第6季第9集、《绿箭侠》第8季第8集以及《明日传奇》第5季第1集。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00011.盛最多水的容器","url":"/zh-CN/04eddde1909a/","content":"\n题目描述给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。\n说明：你不能倾斜容器。\n示例 1：\n\n\n输入：[1,8,6,2,5,4,8,3,7]输出：49解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n\n示例 2：\n输入：height &#x3D; [1,1]输出：1\n\n提示：\n$n &#x3D;&#x3D; height.length$\n$2 &lt;&#x3D; n &lt;&#x3D; 10^5$\n$0 &lt;&#x3D; height[i] &lt;&#x3D; 10^4$\n\n\n解决方法C++class Solution &#123;public:    int maxArea(std::vector&lt;int&gt;&amp; height) &#123;        int max_area = 0;        int left = 0;        int right = height.size() - 1;        while (left &lt; right) &#123;            int current_area = std::min(height[left], height[right]) * (right - left);            max_area = std::max(max_area, current_area);            if (height[left] &lt; height[right]) &#123;                left++;            &#125; else &#123;                right--;            &#125;        &#125;        return max_area;    &#125;&#125;;\n\n结果执行用时 : 72 ms, 击败 73.27% 使用 C++ 的用户\n内存消耗 : 58.09 MB, 击败 17.81% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public int maxArea(int[] height) &#123;        int maxArea = 0;        int left = 0;        int right = height.length - 1;        while (left &lt; right) &#123;            int currentArea = Math.min(height[left], height[right]) * (right - left);            maxArea = Math.max(maxArea, currentArea);            if (height[left] &lt; height[right]) &#123;                left++;            &#125; else &#123;                right--;            &#125;        &#125;        return maxArea;    &#125;&#125;\n\n结果执行用时 : 4 ms, 击败 60.64% 使用 Java 的用户\n内存消耗 : 56.42 MB, 击败 5.85% 使用 Java 的用户\n\nPythonclass Solution(object):    def maxArea(self, height):        max_area = 0        left = 0        right = len(height) - 1        while left &lt; right:            current_area = min(height[left], height[right]) * (right - left)            max_area = max(max_area, current_area)            if height[left] &lt; height[right]:                left += 1            else:                right -= 1        return max_area\n\n结果执行用时 : 148 ms, 击败 13.12% 使用 Python 的用户\n内存消耗 : 21.30 MB, 击败 5.26% 使用 Python 的用户\n\nPython3class Solution:    def maxArea(self, height: List[int]) -&gt; int:        max_area = 0        left = 0        right = len(height) - 1        while left &lt; right:            current_area = min(height[left], height[right]) * (right - left)            max_area = max(max_area, current_area)            if height[left] &lt; height[right]:                left += 1            else:                right -= 1        return max_area\n\n结果执行用时 : 156 ms, 击败 72.12% 使用 Python3 的用户\n内存消耗 : 27.78 MB, 击败 5.13% 使用 Python3 的用户\n\nCint maxArea(int* height, int heightSize) &#123;    int max_area = 0;    int left = 0;    int right = heightSize - 1;    while (left &lt; right) &#123;        int current_area = (height[left] &lt; height[right]) ? height[left] * (right - left) : height[right] * (right - left);        max_area = (current_area &gt; max_area) ? current_area : max_area;        if (height[left] &lt; height[right]) &#123;            left++;        &#125; else &#123;            right--;        &#125;    &#125;    return max_area;&#125;\n\n结果执行用时 : 76 ms, 击败 42.07% 使用 C 的用户\n内存消耗 : 12.04 MB, 击败 80.31% 使用 C 的用户\n\nC#public class Solution &#123;    public int MaxArea(int[] height) &#123;        int maxArea = 0;        int left = 0;        int right = height.Length - 1;        while (left &lt; right) &#123;            int currentArea = Math.Min(height[left], height[right]) * (right - left);            maxArea = Math.Max(maxArea, currentArea);            if (height[left] &lt; height[right]) &#123;                left++;            &#125; else &#123;                right--;            &#125;        &#125;        return maxArea;    &#125;&#125;\n\n结果执行用时 : 292 ms, 击败 5.03% 使用 C# 的用户\n内存消耗 : 60.38 MB, 击败 6.09% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; height * @return &#123;number&#125; */var maxArea = function(height) &#123;    let maxArea = 0;    let left = 0;    let right = height.length - 1;    while (left &lt; right) &#123;        const currentArea = Math.min(height[left], height[right]) * (right - left);        maxArea = Math.max(maxArea, currentArea);        if (height[left] &lt; height[right]) &#123;            left++;        &#125; else &#123;            right--;        &#125;    &#125;    return maxArea;&#125;;\n\n结果执行用时 : 68 ms, 击败 86.66% 使用 JavaScript 的用户\n内存消耗 : 55.49 MB, 击败 5.07% 使用 JavaScript 的用户\n\nTypeScriptfunction maxArea(height: number[]): number &#123;    let maxArea: number = 0;    let left: number = 0;    let right: number = height.length - 1;    while (left &lt; right) &#123;        const currentArea: number = Math.min(height[left], height[right]) * (right - left);        maxArea = Math.max(maxArea, currentArea);        if (height[left] &lt; height[right]) &#123;            left++;        &#125; else &#123;            right--;        &#125;    &#125;    return maxArea;&#125;\n\n结果执行用时 : 76 ms, 击败 71.65% 使用 TypeScript 的用户\n内存消耗 : 57.73 MB, 击败 5.08% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $height     * @return Integer     */    function maxArea($height) &#123;        $maxArea = 0;        $left = 0;        $right = count($height) - 1;        while ($left &lt; $right) &#123;            $currentArea = min($height[$left], $height[$right]) * ($right - $left);            $maxArea = max($maxArea, $currentArea);            if ($height[$left] &lt; $height[$right]) &#123;                $left++;            &#125; else &#123;                $right--;            &#125;        &#125;        return $maxArea;    &#125;&#125;\n\n结果执行用时 : 180 ms, 击败 80.25% 使用 PHP 的用户\n内存消耗 : 25.96 MB, 击败 96.30% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func maxArea(_ height: [Int]) -&gt; Int &#123;        var maxArea = 0        var left = 0        var right = height.count - 1        while left &lt; right &#123;            let currentArea = min(height[left], height[right]) * (right - left)            maxArea = max(maxArea, currentArea)            if height[left] &lt; height[right] &#123;                left += 1            &#125; else &#123;                right -= 1            &#125;        &#125;        return maxArea    &#125;&#125;\n\n结果执行用时 : 628 ms, 击败 5.38% 使用 Swift 的用户\n内存消耗 : 19.45 MB, 击败 5.38% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun maxArea(height: IntArray): Int &#123;        var maxArea = 0        var left = 0        var right = height.size - 1        while (left &lt; right) &#123;            val currentArea = minOf(height[left], height[right]) * (right - left)            maxArea = maxOf(maxArea, currentArea)            if (height[left] &lt; height[right]) &#123;                left++            &#125; else &#123;                right--            &#125;        &#125;        return maxArea    &#125;&#125;\n\n结果执行用时 : 400 ms, 击败 45.71% 使用 Kotlin 的用户\n内存消耗 : 51.34 MB, 击败 68.57% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int maxArea(List&lt;int&gt; height) &#123;    int maxArea = 0;    int left = 0;    int right = height.length - 1;    while (left &lt; right) &#123;      int currentArea = height[left] &lt; height[right]          ? height[left] * (right - left)          : height[right] * (right - left);      maxArea = currentArea &gt; maxArea ? currentArea : maxArea;      if (height[left] &lt; height[right]) &#123;        left++;      &#125; else &#123;        right--;      &#125;    &#125;    return maxArea;  &#125;&#125;\n\n结果执行用时 : 332 ms, 击败 22.22% 使用 Dart 的用户\n内存消耗 : 167.73 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc maxArea(height []int) int &#123;    maxArea := 0    left := 0    right := len(height) - 1    for left &lt; right &#123;        currentArea := min(height[left], height[right]) * (right - left)        if currentArea &gt; maxArea &#123;            maxArea = currentArea        &#125;        if height[left] &lt; height[right] &#123;            left++        &#125; else &#123;            right--        &#125;    &#125;    return maxArea&#125;\n\n结果执行用时 : 76 ms, 击败 20.43% 使用 Go 的用户\n内存消耗 : 8.11 MB, 击败 48.25% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; height# @return &#123;Integer&#125;def max_area(height)  max_area = 0  left = 0  right = height.length - 1  while left &lt; right    current_area = [height[left], height[right]].min * (right - left)    max_area = [max_area, current_area].max    if height[left] &lt; height[right]      left += 1    else      right -= 1    end  end  max_areaend\n\n结果执行用时 : 128 ms, 击败 85.71% 使用 Ruby 的用户\n内存消耗 : 213.06 MB, 击败 14.29% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def maxArea(height: Array[Int]): Int = &#123;    var maxArea = 0    var left = 0    var right = height.length - 1    while (left &lt; right) &#123;      val currentArea = math.min(height(left), height(right)) * (right - left)      maxArea = math.max(maxArea, currentArea)      if (height(left) &lt; height(right)) &#123;        left += 1      &#125; else &#123;        right -= 1      &#125;    &#125;    maxArea  &#125;&#125;\n\n结果执行用时 : 706 ms, 击败 28.57% 使用 Scala 的用户\n内存消耗 : 75.38 MB, 击败 76.19% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn max_area(height: Vec&lt;i32&gt;) -&gt; i32 &#123;        let mut max_area = 0;        let mut left = 0;        let mut right = height.len() - 1;        while left &lt; right &#123;            let current_area = std::cmp::min(height[left], height[right]) * (right - left) as i32;            max_area = std::cmp::max(max_area, current_area);            if height[left] &lt; height[right] &#123;                left += 1;            &#125; else &#123;                right -= 1;            &#125;        &#125;        max_area    &#125;&#125;\n\n结果执行用时 : 4 ms, 击败 98.87% 使用 Rust 的用户\n内存消耗 : 3.07 MB, 击败 6.02% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"黑闪电 第三季 第九集 抵抗之书：第四章：地球危机","url":"/zh-CN/440646260435/","content":"\n剧情介绍　　随着红色天空的到来，珍妮弗发现自己在两个世界之间感到撕裂和矛盾。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第一季 第九集 无限地球危机：第二部分（二）","url":"/zh-CN/df47861dedb8/","content":"\n剧情介绍　　团队利用雷的发明追踪新的盟友，以拯救宇宙。监视者派遣艾瑞斯、克拉克和洛伊丝寻找一位神秘的氪星人，而凯特和卡拉则前往寻找布鲁斯·韦恩。此外，米娅向萨拉发起挑战，罗瑞发现了隐藏的天赋，而莱克斯·卢瑟回归。\n　　这次跨界剧情从《女超人》第五季第九集开始，接续于《闪电侠》第六季第九集、《绿箭侠》第八季第八集，以及《明日传奇》第五季第一集。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"腾讯引进Nintendo Switch上市","url":"/zh-CN/852d26238694/","content":"\n主机介绍Nintendo Switch是一部可结合不同场合切换形态的游戏机，集电视模式、掌上模式、桌面模式于一身，用户可以随时随地畅玩任天堂出品的高品质游戏。\nNintendo Switch的桌面模式，可以让你与家人朋友随时分享画面缩短距离。即使外出在没有电视的地方，你也可将主机背面的支架拉出，和朋友分享手柄和画面即可进行对战和合作游玩。\nNintendo Switch的掌上模式，则让用户可以携带Nintendo Switch外出。无需担心场地，随时随地一个人轻松享受Nintendo Switch的高品质游戏内容。或是和三五知己通过邻近的主机联机一起玩。\n此外，Nintendo Switch附有手柄Joy-Con左右各一个，可竖握、横握来操作， 也有左右握持控制器的玩法。 用户还可“分享”其中一个Joy-Con给別人， 进行2人对战或合作游玩。其内置的“高精振动”将为游玩过程带来无法通过画面和声音表现的临场感；“动作感应红外摄像头”会读取照相机捕捉的物件形状、动作和距离，通过辨识猜拳之类的手势，展现出独特输入操作。\n展示\n\n\n","categories":["游戏"],"tags":["主机","国行","Nintendo","Switch"]},{"title":"黑客军团 第四季 第十集 410 丢失","url":"/zh-CN/6454bb2d8675/","content":"\n剧情介绍　　我们支持Domlene。\n\n","categories":["剧集"],"tags":["日常","USA Network"]},{"title":"新 超级马力欧兄弟U 豪华版","url":"/zh-CN/a6cffba691f9/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"闪电侠 第六季 第九集 无限地球危机：第三部分（三）","url":"/zh-CN/6f3feefae5b9/","content":"\n剧情介绍　　帕里亚邀请黑色闪电帮助阻止反监视器，Flash-90分享了他在“Elseworlds”战斗中学到的东西。在黑色闪电的帮助下，巴里、西斯科和杀手弗罗斯特想出了一个可以拯救他们所有人的计划。与此同时，艾瑞斯与瑞恩·崔心连心，而奥利弗和迪格尔则回到了熟悉的老地方。\n　　这个跨剧集事件从《女超人》第五季第九集、《蝙蝠女侠》第五季第九集以及《绿箭侠》第8季第8集，最终在《明日传奇》第五季第一集中落下帷幕。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"Mac Pro（Intel，2019年）","url":"/zh-CN/6d94f958ada8/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Mac Pro\n  这台 Mac，在众多方面再一次超越\n  自我。Mac Pro 拥有强悍的性能和\n  卓越的配置潜能，可助你一往无前，\n  挑战不可能。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"Pro Display XDR（2019年）","url":"/zh-CN/7acba7977b91/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Pro Display XDR\n  Apple 的首款\n  32 英寸 6K 视网膜显示器。\n  峰值亮度可达 1600 尼特;\n  对比度高达 1000000:1,\n  可呈现超过十亿色彩;\n  极致动态范围，\n  可让专业工作流程焕然一新。\n  而且，在整个制作过程中，\n  每位专业用户看到的影像都能\n  保持一致的鲜活出色。\n  这就是 Pro Display XDR，\n  专业显示器的巅峰之作。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Display"]},{"title":"力扣00012.整数转罗马数字","url":"/zh-CN/5b2e4ebdebbf/","content":"\n题目描述罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n\n\n\n字符\n数值\n\n\n\nI\n1\n\n\nV\n5\n\n\nX\n10\n\n\nL\n50\n\n\nC\n100\n\n\nD\n500\n\n\nM\n1000\n\n\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n\n给你一个整数，将其转为罗马数字。\n示例 1：\n输入: num &#x3D; 3输出: “III”\n\n示例 2：\n输入: num &#x3D; 4输出: “IV”\n\n示例 3：\n输入: num &#x3D; 9输出: “IX”\n\n示例 4：\n输入: num &#x3D; 58输出: “LVIII”解释: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.\n\n示例 5：\n输入: num &#x3D; 1994输出: “MCMXCIV”解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.\n\n提示：\n1 &lt;&#x3D; num &lt;&#x3D; 3999\n\n\n解决方法C++class Solution &#123;public:    string intToRoman(int num) &#123;        int val[] = &#123; 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;;        string syms[] = &#123; &quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot; &#125;;        string romanNum = &quot;&quot;;        for (int i = 0; i &lt; 13; i++) &#123;            while (num &gt;= val[i]) &#123;                num -= val[i];                romanNum += syms[i];            &#125;        &#125;        return romanNum;    &#125;&#125;;\n\n结果执行用时 : 4 ms, 击败 85.27% 使用 C++ 的用户\n内存消耗 : 6.16 MB, 击败 84.14% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public String intToRoman(int num) &#123;        int[] val = &#123; 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;;        String[] syms = &#123; &quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot; &#125;;        StringBuilder romanNum = new StringBuilder();        for (int i = 0; i &lt; 13; i++) &#123;            while (num &gt;= val[i]) &#123;                num -= val[i];                romanNum.append(syms[i]);            &#125;        &#125;        return romanNum.toString();    &#125;&#125;\n\n结果执行用时 : 3 ms, 击败 98.23% 使用 Java 的用户\n内存消耗 : 43.08 MB, 击败 12.68% 使用 Java 的用户\n\nPythonclass Solution(object):    def intToRoman(self, num):        val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]        syms = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]        roman_num = &#x27;&#x27;        i = 0        while num &gt; 0:            for _ in range(num // val[i]):                roman_num += syms[i]                num -= val[i]            i += 1        return roman_num\n\n结果执行用时 : 52 ms, 击败 34.85% 使用 Python 的用户\n内存消耗 : 13.04 MB, 击败 32.88% 使用 Python 的用户\n\nPython3class Solution:    def intToRoman(self, num: int) -&gt; str:        val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]        syms = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]        roman_num = &#x27;&#x27;        i = 0        while num &gt; 0:            for _ in range(num // val[i]):                roman_num += syms[i]                num -= val[i]            i += 1        return roman_num\n\n结果执行用时 : 76 ms, 击败 5.82% 使用 Python3 的用户\n内存消耗 : 16.88 MB, 击败 10.91% 使用 Python3 的用户\n\nCchar* intToRoman(int num) &#123;    int values[] = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;    const char* symbols[] = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;    char* result = (char*)malloc(20 * sizeof(char));    result[0] = &#x27;\\0&#x27;;    for (int i = 0; i &lt; 13; i++) &#123;        while (num &gt;= values[i]) &#123;            strcat(result, symbols[i]);            num -= values[i];        &#125;    &#125;    return result;&#125;\n\n结果执行用时 : 4 ms, 击败 85.58% 使用 C 的用户\n内存消耗 : 6.68 MB, 击败 25.77% 使用 C 的用户\n\nC#public class Solution &#123;    public string IntToRoman(int num) &#123;        int[] values = &#123; 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;;        string[] symbols = &#123; &quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot; &#125;;        StringBuilder romanNum = new StringBuilder();        for (int i = 0; i &lt; 13; i++) &#123;            while (num &gt;= values[i]) &#123;                romanNum.Append(symbols[i]);                num -= values[i];            &#125;        &#125;        return romanNum.ToString();    &#125;&#125;\n\n结果执行用时 : 60 ms, 击败 95.39% 使用 C# 的用户\n内存消耗 : 44.50 MB, 击败 27.31% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number&#125; num * @return &#123;string&#125; */var intToRoman = function(num) &#123;    const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];    const symbols = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;];    let romanNum = &#x27;&#x27;;    for (let i = 0; i &lt; 13; i++) &#123;        while (num &gt;= values[i]) &#123;            romanNum += symbols[i];            num -= values[i];        &#125;    &#125;    return romanNum;&#125;;\n\n结果执行用时 : 120 ms, 击败 48.51% 使用 JavaScript 的用户\n内存消耗 : 52.22 MB, 击败 6.03% 使用 JavaScript 的用户\n\nTypeScriptfunction intToRoman(num: number): string &#123;    const values: number[] = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];    const symbols: string[] = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;];    let romanNum: string = &#x27;&#x27;;    for (let i = 0; i &lt; 13; i++) &#123;        while (num &gt;= values[i]) &#123;            romanNum += symbols[i];            num -= values[i];        &#125;    &#125;    return romanNum;&#125;\n\n结果执行用时 : 120 ms, 击败 52.74% 使用 TypeScript 的用户\n内存消耗 : 53.53 MB, 击败 5.47% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer $num     * @return String     */    function intToRoman($num) &#123;        $values = array(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1);        $symbols = array(&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;);        $romanNum = &#x27;&#x27;;        for ($i = 0; $i &lt; 13; $i++) &#123;            while ($num &gt;= $values[$i]) &#123;                $romanNum .= $symbols[$i];                $num -= $values[$i];            &#125;        &#125;        return $romanNum;    &#125;&#125;\n\n结果执行用时 : 24 ms, 击败 25.00% 使用 PHP 的用户\n内存消耗 : 19.44 MB, 击败 6.25% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func intToRoman(_ num: Int) -&gt; String &#123;        let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]        let symbols = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]        var romanNum = &quot;&quot;        var number = num        var i = 0        while number &gt; 0 &#123;            while number &gt;= values[i] &#123;                romanNum += symbols[i]                number -= values[i]            &#125;            i += 1        &#125;        return romanNum    &#125;&#125;\n\n结果执行用时 : 16 ms, 击败 87.88% 使用 Swift 的用户\n内存消耗 : 14.98 MB, 击败 6.06% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun intToRoman(num: Int): String &#123;        val values = listOf(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)        val symbols = listOf(&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;)        var romanNum = &quot;&quot;        var number = num        var i = 0        while (number &gt; 0) &#123;            while (number &gt;= values[i]) &#123;                romanNum += symbols[i]                number -= values[i]            &#125;            i++        &#125;        return romanNum    &#125;&#125;\n\n结果执行用时 : 212 ms, 击败 55.56% 使用 Kotlin 的用户\n内存消耗 : 38.36 MB, 击败 27.78% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  String intToRoman(int num) &#123;    List&lt;int&gt; values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];    List&lt;String&gt; symbols = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;];    String romanNum = &#x27;&#x27;;    for (int i = 0; i &lt; 13; i++) &#123;      while (num &gt;= values[i]) &#123;        romanNum += symbols[i];        num -= values[i];      &#125;    &#125;    return romanNum;  &#125;&#125;\n\n结果执行用时 : 440 ms, 击败 50.00% 使用 Dart 的用户\n内存消耗 : 149.71 MB, 击败 50.00% 使用 Dart 的用户\n\nGofunc intToRoman(num int) string &#123;    values := []int&#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;    symbols := []string&#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;    var romanNum strings.Builder    for i := 0; i &lt; 13; i++ &#123;        for num &gt;= values[i] &#123;            romanNum.WriteString(symbols[i])            num -= values[i]        &#125;    &#125;    return romanNum.String()&#125;\n\n结果执行用时 : 4 ms, 击败 88.52% 使用 Go 的用户\n内存消耗 : 2.93 MB, 击败 89.29% 使用 Go 的用户\n\nRuby# @param &#123;Integer&#125; num# @return &#123;String&#125;def int_to_roman(num)    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]    symbols = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]    roman_num = &#x27;&#x27;    (0...13).each do |i|        while num &gt;= values[i]            roman_num += symbols[i]            num -= values[i]        end    end    roman_numend\n\n结果执行用时 : 88 ms, 击败 50.00% 使用 Ruby 的用户\n内存消耗 : 206.59 MB, 击败 -% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def intToRoman(num: Int): String = &#123;    val values = List(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)    val symbols = List(&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;)    var romanNum = &quot;&quot;    var number = num    var i = 0    while (i &lt; 13) &#123;      while (number &gt;= values(i)) &#123;        romanNum += symbols(i)        number -= values(i)      &#125;      i += 1    &#125;    romanNum  &#125;&#125;\n\n结果执行用时 : 500 ms, 击败 66.67% 使用 Scala 的用户\n内存消耗 : 53.13 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn int_to_roman(num: i32) -&gt; String &#123;        let values = vec![1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];        let symbols = vec![&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;];        let mut roman_num = String::new();        let mut number = num;        for i in 0..13 &#123;            while number &gt;= values[i] &#123;                roman_num += symbols[i];                number -= values[i];            &#125;        &#125;        roman_num    &#125;&#125;\n\n结果执行用时 : 4 ms, 击败 63.10% 使用 Rust 的用户\n内存消耗 : 2.11 MB, 击败 25.00% 使用 Rust 的用户\n\nRacket(define (int-to-roman num)  (define values &#x27;(1000 900 500 400 100 90 50 40 10 9 5 4 1))  (define symbols &#x27;(&quot;M&quot; &quot;CM&quot; &quot;D&quot; &quot;CD&quot; &quot;C&quot; &quot;XC&quot; &quot;L&quot; &quot;XL&quot; &quot;X&quot; &quot;IX&quot; &quot;V&quot; &quot;IV&quot; &quot;I&quot;))  (define (convert num values symbols)    (let loop ((num num) (values values) (symbols symbols) (result &#x27;()))      (cond        ((= num 0) (apply string-append (reverse result)))        ((&gt;= num (car values))         (loop (- num (car values)) values symbols (cons (car symbols) result)))        (else (loop num (cdr values) (cdr symbols) result)))))  (convert num values symbols))\n\n结果执行用时 : 240 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 99.15 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixirdefmodule Solution do  @spec int_to_roman(num :: integer) :: String.t  def int_to_roman(num) do    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]    symbols = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]    int_to_roman(num, values, symbols, &quot;&quot;)  end  defp int_to_roman(_, [], _, acc), do: acc  defp int_to_roman(num, [value | rest_values], [symbol | rest_symbols], acc) when num &gt;= value do    int_to_roman(num - value, [value | rest_values], [symbol | rest_symbols], acc &lt;&gt; symbol)  end  defp int_to_roman(num, [_ | rest_values], [_ | rest_symbols], acc) do    int_to_roman(num, rest_values, rest_symbols, acc)  endend\n\n结果执行用时 : 556 ms, 击败 100.00% 使用 Elixir 的用户\n内存消耗 : 68.21 MB, 击败 100.00% 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"孤独的美食家 第八季 第十一集 神奈川县川崎市武藏小杉一人成吉思汗","url":"/zh-CN/8c726a133549/","content":"\n剧情介绍　　井之头五郎（松重丰饰）到刚搬到武藏小杉的塔级公寓的村井美咲（水野真纪饰）那里，进行了客厅装修的商谈。但是，由于村井优柔寡断的性格，谈判完全没有进展，谈判结束时已经是吃晚饭的时候了。五郎空着肚子为了寻找店铺而四处奔走，像是被从换气口飘来的气味所吸入似的【成吉思汗どう～】！看菜单，好像是能享用网烤和铁锅二等级的店。按照菜单，五郎决定首先挑战烤网，点了“盐烤鱼卷”、“米饭（中）”、“火腿”。“チャックロール葱盐烧”是“将羔羊肉放在网烤+葱上”的第一种吃法，它非常美味，被全新的成吉思汗世界所感动。更加骨附着的「火腿」，多汁的脂肪登载绝品！食欲旺盛的五郎决定冲进第二轮的铁锅。点了「成吉思汗套餐」的话，笨蛋胡萝卜级好吃的「momo肉」，咬的那样肉汁溢出的「shoulder」，与刚才的网烤再划一条线的「chack卷儿」的美味筷子变得不停止的五郎。五郎十分满足于最后一张照片，非常满足地踏上了归途。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"曼达洛人 第一季 第六集 囚犯","url":"/zh-CN/7bdd4daa2cc9/","content":"\n剧情介绍　　曼达洛人加入一支雇佣兵队伍，执行一项危险任务。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"力扣00013.罗马数字转整数","url":"/zh-CN/854ee8d5e69b/","content":"\n题目描述罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n\n\n\n字符\n数值\n\n\n\nI\n1\n\n\nV\n5\n\n\nX\n10\n\n\nL\n50\n\n\nC\n100\n\n\nD\n500\n\n\nM\n1000\n\n\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。\n示例 1：\n输入: s &#x3D; “III”输出: 3\n\n示例 2：\n输入: s &#x3D; “IV”输出: 4\n\n示例 3:\n输入: s &#x3D; “IX”输出: 9\n\n示例 4:\n输入: s &#x3D; “LVIII”输出: 58解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.\n\n示例 5:\n输入: s &#x3D; “MCMXCIV”输出: 1994解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.\n\n提示：\n1 &lt;&#x3D; s.length &lt;&#x3D; 15\ns 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’)\n题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内\n题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。\nIL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。\n\n\n解决方法C++class Solution &#123;public:    int romanToInt(string s) &#123;        unordered_map&lt;char, int&gt; roman_values = &#123;            &#123;&#x27;I&#x27;, 1&#125;, &#123;&#x27;V&#x27;, 5&#125;, &#123;&#x27;X&#x27;, 10&#125;, &#123;&#x27;L&#x27;, 50&#125;,            &#123;&#x27;C&#x27;, 100&#125;, &#123;&#x27;D&#x27;, 500&#125;, &#123;&#x27;M&#x27;, 1000&#125;        &#125;;        int total = 0;        for (int i = 0; i &lt; s.length(); ++i) &#123;            if (i + 1 &lt; s.length() &amp;&amp; roman_values[s[i]] &lt; roman_values[s[i + 1]]) &#123;                total += roman_values[s[i + 1]] - roman_values[s[i]];                ++i;            &#125; else &#123;                total += roman_values[s[i]];            &#125;        &#125;        return total;    &#125;&#125;;\n\n结果执行用时 : 12 ms, 击败 63.8% 使用 C++ 的用户\n内存消耗 : 8.18 MB, 击败 62.73% 使用 C++ 的用户\n\nJavaimport java.util.HashMap;class Solution &#123;    public int romanToInt(String s) &#123;        HashMap&lt;Character, Integer&gt; romanValues = new HashMap&lt;&gt;();        romanValues.put(&#x27;I&#x27;, 1);        romanValues.put(&#x27;V&#x27;, 5);        romanValues.put(&#x27;X&#x27;, 10);        romanValues.put(&#x27;L&#x27;, 50);        romanValues.put(&#x27;C&#x27;, 100);        romanValues.put(&#x27;D&#x27;, 500);        romanValues.put(&#x27;M&#x27;, 1000);        int total = 0;        for (int i = 0; i &lt; s.length(); ++i) &#123;            if (i + 1 &lt; s.length() &amp;&amp; romanValues.get(s.charAt(i)) &lt; romanValues.get(s.charAt(i + 1))) &#123;                total += romanValues.get(s.charAt(i + 1)) - romanValues.get(s.charAt(i));                ++i;            &#125; else &#123;                total += romanValues.get(s.charAt(i));            &#125;        &#125;        return total;    &#125;&#125;\n\n结果执行用时 : 6 ms, 击败 18.77% 使用 Java 的用户\n内存消耗 : 43.35 MB, 击败 17.83% 使用 Java 的用户\n\nPythonclass Solution(object):    def romanToInt(self, s):        roman_values = &#123;            &#x27;I&#x27;: 1, &#x27;V&#x27;: 5, &#x27;X&#x27;: 10, &#x27;L&#x27;: 50,            &#x27;C&#x27;: 100, &#x27;D&#x27;: 500, &#x27;M&#x27;: 1000        &#125;        total = 0        i = 0        while i &lt; len(s):            if i + 1 &lt; len(s) and roman_values[s[i]] &lt; roman_values[s[i + 1]]:                total += roman_values[s[i + 1]] - roman_values[s[i]]                i += 2            else:                total += roman_values[s[i]]                i += 1        return total\n\n结果执行用时 : 44 ms, 击败 91.49% 使用 Python 的用户\n内存消耗 : 12.98 MB, 击败 60.24% 使用 Python 的用户\n\nPython3class Solution:    def romanToInt(self, s: str) -&gt; int:        roman_values = &#123;            &#x27;I&#x27;: 1, &#x27;V&#x27;: 5, &#x27;X&#x27;: 10, &#x27;L&#x27;: 50,            &#x27;C&#x27;: 100, &#x27;D&#x27;: 500, &#x27;M&#x27;: 1000        &#125;        total = 0        i = 0        while i &lt; len(s):            if i + 1 &lt; len(s) and roman_values[s[i]] &lt; roman_values[s[i + 1]]:                total += roman_values[s[i + 1]] - roman_values[s[i]]                i += 2            else:                total += roman_values[s[i]]                i += 1        return total\n\n结果执行用时 : 56 ms, 击败 60.20% 使用 Python3 的用户\n内存消耗 : 17.10 MB, 击败 5.04% 使用 Python3 的用户\n\nCint value(char c) &#123;    switch(c) &#123;        case &#x27;I&#x27;: return 1;        case &#x27;V&#x27;: return 5;        case &#x27;X&#x27;: return 10;        case &#x27;L&#x27;: return 50;        case &#x27;C&#x27;: return 100;        case &#x27;D&#x27;: return 500;        case &#x27;M&#x27;: return 1000;        default: return 0;    &#125;&#125;int romanToInt(char* s) &#123;    int result = 0;    for (int i = 0; s[i] != &#x27;\\0&#x27;; i++) &#123;        int current = value(s[i]);        int next = value(s[i + 1]);        if (current &lt; next) &#123;            result += (next - current);            i++;        &#125; else &#123;            result += current;        &#125;    &#125;    return result;&#125;\n\n结果执行用时 : 8 ms, 击败 58.83% 使用 C 的用户\n内存消耗 : 6.36 MB, 击败 87.77% 使用 C 的用户\n\nC#public class Solution &#123;    public int RomanToInt(string s) &#123;        Dictionary&lt;char, int&gt; romanValues = new Dictionary&lt;char, int&gt;() &#123;            &#123;&#x27;I&#x27;, 1&#125;, &#123;&#x27;V&#x27;, 5&#125;, &#123;&#x27;X&#x27;, 10&#125;, &#123;&#x27;L&#x27;, 50&#125;,            &#123;&#x27;C&#x27;, 100&#125;, &#123;&#x27;D&#x27;, 500&#125;, &#123;&#x27;M&#x27;, 1000&#125;        &#125;;        int total = 0;        for (int i = 0; i &lt; s.Length; i++) &#123;            if (i + 1 &lt; s.Length &amp;&amp; romanValues[s[i]] &lt; romanValues[s[i + 1]]) &#123;                total += romanValues[s[i + 1]] - romanValues[s[i]];                i++;            &#125; else &#123;                total += romanValues[s[i]];            &#125;        &#125;        return total;    &#125;&#125;\n\n结果执行用时 : 60 ms, 击败 85.78% 使用 C# 的用户\n内存消耗 : 47.64 MB, 击败 18.79% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; s * @return &#123;number&#125; */var romanToInt = function(s) &#123;    const romanValues = &#123;        &#x27;I&#x27;: 1, &#x27;V&#x27;: 5, &#x27;X&#x27;: 10, &#x27;L&#x27;: 50,        &#x27;C&#x27;: 100, &#x27;D&#x27;: 500, &#x27;M&#x27;: 1000    &#125;;    let total = 0;    for (let i = 0; i &lt; s.length; i++) &#123;        if (i + 1 &lt; s.length &amp;&amp; romanValues[s[i]] &lt; romanValues[s[i + 1]]) &#123;            total += romanValues[s[i + 1]] - romanValues[s[i]];            i++;        &#125; else &#123;            total += romanValues[s[i]];        &#125;    &#125;    return total;&#125;;\n\n结果执行用时 : 116 ms, 击败 63.20% 使用 JavaScript 的用户\n内存消耗 : 53.13 MB, 击败 7.86% 使用 JavaScript 的用户\n\nTypeScriptfunction romanToInt(s: string): number &#123;    const romanValues: &#123; [key: string]: number &#125; = &#123;        &#x27;I&#x27;: 1, &#x27;V&#x27;: 5, &#x27;X&#x27;: 10, &#x27;L&#x27;: 50,        &#x27;C&#x27;: 100, &#x27;D&#x27;: 500, &#x27;M&#x27;: 1000    &#125;;    let total = 0;    for (let i = 0; i &lt; s.length; i++) &#123;        if (i + 1 &lt; s.length &amp;&amp; romanValues[s[i]] &lt; romanValues[s[i + 1]]) &#123;            total += romanValues[s[i + 1]] - romanValues[s[i]];            i++;        &#125; else &#123;            total += romanValues[s[i]];        &#125;    &#125;    return total;&#125;\n\n结果执行用时 : 124 ms, 击败 44.44% 使用 TypeScript 的用户\n内存消耗 : 53.39 MB, 击败 11.57% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String $s     * @return Integer     */    function romanToInt($s) &#123;        $romanValues = [            &#x27;I&#x27; =&gt; 1, &#x27;V&#x27; =&gt; 5, &#x27;X&#x27; =&gt; 10, &#x27;L&#x27; =&gt; 50,            &#x27;C&#x27; =&gt; 100, &#x27;D&#x27; =&gt; 500, &#x27;M&#x27; =&gt; 1000        ];        $total = 0;        for ($i = 0; $i &lt; strlen($s); $i++) &#123;            if ($i + 1 &lt; strlen($s) &amp;&amp; $romanValues[$s[$i]] &lt; $romanValues[$s[$i + 1]]) &#123;                $total += $romanValues[$s[$i + 1]] - $romanValues[$s[$i]];                $i++;            &#125; else &#123;                $total += $romanValues[$s[$i]];            &#125;        &#125;        return $total;    &#125;&#125;\n\n结果执行用时 : 16 ms, 击败 72.29% 使用 PHP 的用户\n内存消耗 : 19.67 MB, 击败 6.03% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func romanToInt(_ s: String) -&gt; Int &#123;        let romanValues: [Character: Int] = [            &quot;I&quot;: 1, &quot;V&quot;: 5, &quot;X&quot;: 10, &quot;L&quot;: 50,            &quot;C&quot;: 100, &quot;D&quot;: 500, &quot;M&quot;: 1000        ]        var total = 0        var i = s.startIndex        while i &lt; s.endIndex &#123;            let current = s[i]            let nextIndex = s.index(after: i)            if nextIndex &lt; s.endIndex &#123;                let next = s[nextIndex]                if romanValues[current]! &lt; romanValues[next]! &#123;                    total += romanValues[next]! - romanValues[current]!                    i = s.index(after: nextIndex)                    continue                &#125;            &#125;            total += romanValues[current]!            i = s.index(after: i)        &#125;        return total    &#125;&#125;\n\n结果执行用时 : 24 ms, 击败 32.26% 使用 Swift 的用户\n内存消耗 : 15.66 MB, 击败 6.45% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun romanToInt(s: String): Int &#123;        val romanValues = hashMapOf(            &#x27;I&#x27; to 1, &#x27;V&#x27; to 5, &#x27;X&#x27; to 10, &#x27;L&#x27; to 50,            &#x27;C&#x27; to 100, &#x27;D&#x27; to 500, &#x27;M&#x27; to 1000        )        var total = 0        var i = 0        while (i &lt; s.length) &#123;            if (i + 1 &lt; s.length &amp;&amp; romanValues[s[i]]!! &lt; romanValues[s[i + 1]]!!) &#123;                total += romanValues[s[i + 1]]!! - romanValues[s[i]]!!                i += 2            &#125; else &#123;                total += romanValues[s[i]]!!                i++            &#125;        &#125;        return total    &#125;&#125;\n\n结果执行用时 : 224 ms, 击败 40.00% 使用 Kotlin 的用户\n内存消耗 : 36.78 MB, 击败 40.00% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int romanToInt(String s) &#123;    Map&lt;String, int&gt; romanValues = &#123;      &#x27;I&#x27;: 1, &#x27;V&#x27;: 5, &#x27;X&#x27;: 10, &#x27;L&#x27;: 50,      &#x27;C&#x27;: 100, &#x27;D&#x27;: 500, &#x27;M&#x27;: 1000    &#125;;    int total = 0;    for (int i = 0; i &lt; s.length; i++) &#123;      if (i + 1 &lt; s.length &amp;&amp;          romanValues[s[i]]! &lt; romanValues[s[i + 1]]!) &#123;        total += romanValues[s[i + 1]]! - romanValues[s[i]]!;        i++;      &#125; else &#123;        total += romanValues[s[i]]!;      &#125;    &#125;    return total;  &#125;&#125;\n\n结果执行用时 : 380 ms, 击败 20.00% 使用 Dart 的用户\n内存消耗 : 148.83 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc romanToInt(s string) int &#123;    romanValues := map[byte]int&#123;        &#x27;I&#x27;: 1, &#x27;V&#x27;: 5, &#x27;X&#x27;: 10, &#x27;L&#x27;: 50,        &#x27;C&#x27;: 100, &#x27;D&#x27;: 500, &#x27;M&#x27;: 1000,    &#125;    total := 0    for i := 0; i &lt; len(s); i++ &#123;        if i+1 &lt; len(s) &amp;&amp; romanValues[s[i]] &lt; romanValues[s[i+1]] &#123;            total += romanValues[s[i+1]] - romanValues[s[i]]            i++        &#125; else &#123;            total += romanValues[s[i]]        &#125;    &#125;    return total&#125;\n\n结果执行用时 : 8 ms, 击败 52.05% 使用 Go 的用户\n内存消耗 : 2.64 MB, 击败 78.89% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; s# @return &#123;Integer&#125;def roman_to_int(s)    roman_values = &#123;        &#x27;I&#x27; =&gt; 1, &#x27;V&#x27; =&gt; 5, &#x27;X&#x27; =&gt; 10, &#x27;L&#x27; =&gt; 50,        &#x27;C&#x27; =&gt; 100, &#x27;D&#x27; =&gt; 500, &#x27;M&#x27; =&gt; 1000    &#125;    total = 0    i = 0    while i &lt; s.length        if i + 1 &lt; s.length &amp;&amp; roman_values[s[i]] &lt; roman_values[s[i + 1]]            total += roman_values[s[i + 1]] - roman_values[s[i]]            i += 2        else            total += roman_values[s[i]]            i += 1        end    end    return totalend\n\n结果执行用时 : 68 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.81 MB, 击败 16.67% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def romanToInt(s: String): Int = &#123;    val romanValues = Map(      &#x27;I&#x27; -&gt; 1, &#x27;V&#x27; -&gt; 5, &#x27;X&#x27; -&gt; 10, &#x27;L&#x27; -&gt; 50,      &#x27;C&#x27; -&gt; 100, &#x27;D&#x27; -&gt; 500, &#x27;M&#x27; -&gt; 1000    )    var total = 0    var i = 0    while (i &lt; s.length) &#123;      if (i + 1 &lt; s.length &amp;&amp; romanValues(s(i)) &lt; romanValues(s(i + 1))) &#123;        total += romanValues(s(i + 1)) - romanValues(s(i))        i += 2      &#125; else &#123;        total += romanValues(s(i))        i += 1      &#125;    &#125;    total  &#125;&#125;\n\n结果执行用时 : 540 ms, 击败 87.50% 使用 Scala 的用户\n内存消耗 : 54.98 MB, 击败 62.50% 使用 Scala 的用户\n\nRustuse std::collections::HashMap;impl Solution &#123;    pub fn roman_to_int(s: String) -&gt; i32 &#123;        let mut roman_values: HashMap&lt;char, i32&gt; = HashMap::new();        roman_values.insert(&#x27;I&#x27;, 1);        roman_values.insert(&#x27;V&#x27;, 5);        roman_values.insert(&#x27;X&#x27;, 10);        roman_values.insert(&#x27;L&#x27;, 50);        roman_values.insert(&#x27;C&#x27;, 100);        roman_values.insert(&#x27;D&#x27;, 500);        roman_values.insert(&#x27;M&#x27;, 1000);        let mut total = 0;        let mut prev = 0;        for c in s.chars() &#123;            let curr = roman_values[&amp;c];            total += curr;            if curr &gt; prev &#123;                total -= 2 * prev;            &#125;            prev = curr;        &#125;        total    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.20 MB, 击败 17.91% 使用 Rust 的用户\n\nRacket(define (roman-to-int s)  (define roman-values    &#x27;((#\\I . 1) (#\\V . 5) (#\\X . 10) (#\\L . 50)      (#\\C . 100) (#\\D . 500) (#\\M . 1000)))  (define (get-value c)    (cdr (assoc c roman-values)))  (let loop ((chars (string-&gt;list s))             (result 0))    (cond      ((null? chars) result)      ((= (length chars) 1) (+ result (get-value (car chars))))      (else       (let ((current (get-value (car chars)))             (next (get-value (cadr chars))))         (if (&lt; current next)             (loop (cddr chars) (+ result (- next current)))             (loop (cdr chars) (+ result current))))))))\n\n结果执行用时 : 216 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 97.95 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"食戟之灵 第四季 神之皿 第十集 必杀料理的制作方法","url":"/zh-CN/63b7294d5e78/","content":"\n剧情介绍　　最后的Régiment du Cuisine开始了！在最终回合中，每位队员都必须完成一道前菜和一道主菜，组成一套完整的套餐。尽管团队合作在这场战斗中至关重要，但创真和绘里奈却仍在争吵不休。另一方面，无敌组合司瑛士和小林龙胆已经准备好呈上他们的料理……！\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"罪恶黑名单 第七季 第十集 卡特琳娜·罗斯托娃","url":"/zh-CN/a467e64000e9/","content":"\n剧情介绍　　雷德和特工小组拜访了一名曾经的黑名单人物，一场激烈的对峙让莉兹做出了一个关键的选择。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"黑客军团 第四季 第十一集 退出","url":"/zh-CN/2496cffc94b7/","content":"\n剧情介绍　　够了，忍无可忍。艾略特前往华盛顿镇电力厂。\n\n","categories":["剧集"],"tags":["日常","USA Network"]},{"title":"力扣00014.最长公共前缀","url":"/zh-CN/674a8ae5c290/","content":"\n题目描述编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 “”。\n示例 1：\n输入：strs &#x3D; [“flower”,”flow”,”flight”]输出：”fl”\n\n示例 2：\n输入：strs &#x3D; [“dog”,”racecar”,”car”]输出：””解释：输入不存在公共前缀。\n\n提示：\n1 &lt;&#x3D; strs.length &lt;&#x3D; 200\n0 &lt;&#x3D; strs[i].length &lt;&#x3D; 200\nstrs[i] 仅由小写英文字母组成\n\n\n解决方法C++class Solution &#123;public:    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;        if (strs.empty()) &#123;            return &quot;&quot;;        &#125;        string prefix = strs[0];        for (int i = 1; i &lt; strs.size(); ++i) &#123;            while (strs[i].find(prefix) != 0) &#123;                prefix = prefix.substr(0, prefix.length() - 1);                if (prefix.empty()) &#123;                    return &quot;&quot;;                &#125;            &#125;        &#125;        return prefix;    &#125;&#125;;\n\n结果执行用时 : 4 ms, 击败 74.94% 使用 C++ 的用户\n内存消耗 : 9.45 MB, 击败 36.89% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public String longestCommonPrefix(String[] strs) &#123;        if (strs == null || strs.length == 0) &#123;            return &quot;&quot;;        &#125;        String prefix = strs[0];        for (int i = 1; i &lt; strs.length; i++) &#123;            while (strs[i].indexOf(prefix) != 0) &#123;                prefix = prefix.substring(0, prefix.length() - 1);                if (prefix.isEmpty()) &#123;                    return &quot;&quot;;                &#125;            &#125;        &#125;        return prefix;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 40.09 MB, 击败 23.36% 使用 Java 的用户\n\nPythonclass Solution(object):    def longestCommonPrefix(self, strs):        if not strs:            return &quot;&quot;        prefix = strs[0]        for string in strs[1:]:            while string.find(prefix) != 0:                prefix = prefix[:-1]                if not prefix:                    return &quot;&quot;        return prefix\n\n结果执行用时 : 16 ms, 击败 86.01% 使用 Python 的用户\n内存消耗 : 13.26 MB, 击败 17.29% 使用 Python 的用户\n\nPython3class Solution:    def longestCommonPrefix(self, strs: List[str]) -&gt; str:        if not strs:            return &quot;&quot;        prefix = &quot;&quot;        min_length = min(len(s) for s in strs)        for i in range(min_length):            char = strs[0][i]            if all(s[i] == char for s in strs):                prefix += char            else:                break        return prefix\n\n结果执行用时 : 44 ms, 击败 64.70% 使用 Python3 的用户\n内存消耗 : 17.16 MB, 击败 5.01% 使用 Python3 的用户\n\nCchar* longestCommonPrefix(char** strs, int strsSize) &#123;    if (strsSize == 0) &#123;        return &quot;&quot;;    &#125;    int i, j;    for (i = 0; i &lt; strlen(strs[0]); ++i) &#123;        for (j = 1; j &lt; strsSize; ++j) &#123;            if (strs[j][i] != strs[0][i] || strs[j][i] == &#x27;\\0&#x27;) &#123;                char* result = (char*)malloc(sizeof(char) * (i + 1));                strncpy(result, strs[0], i);                result[i] = &#x27;\\0&#x27;;                return result;            &#125;        &#125;    &#125;    char* result = (char*)malloc(sizeof(char) * (i + 1));    strncpy(result, strs[0], i);    result[i] = &#x27;\\0&#x27;;    return result;&#125;\n\n结果执行用时 : 4 ms, 击败 53.70% 使用 C 的用户\n内存消耗 : 6.52 MB, 击败 47.21% 使用 C 的用户\n\nC#public class Solution &#123;    public string LongestCommonPrefix(string[] strs) &#123;        if (strs == null || strs.Length == 0) &#123;            return &quot;&quot;;        &#125;        string prefix = strs[0];        for (int i = 1; i &lt; strs.Length; i++) &#123;            while (strs[i].IndexOf(prefix) != 0) &#123;                prefix = prefix.Substring(0, prefix.Length - 1);                if (prefix.Length == 0) &#123;                    return &quot;&quot;;                &#125;            &#125;        &#125;        return prefix;    &#125;&#125;\n\n结果执行用时 : 72 ms, 击败 90.59% 使用 C# 的用户\n内存消耗 : 42.74 MB, 击败 5.02% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string[]&#125; strs * @return &#123;string&#125; */var longestCommonPrefix = function(strs) &#123;    if (strs === null || strs.length === 0) &#123;        return &#x27;&#x27;;    &#125;    let prefix = strs[0];    for (let i = 1; i &lt; strs.length; i++) &#123;        while (strs[i].indexOf(prefix) !== 0) &#123;            prefix = prefix.substring(0, prefix.length - 1);            if (prefix.length === 0) &#123;                return &#x27;&#x27;;            &#125;        &#125;    &#125;    return prefix;&#125;;\n\n结果执行用时 : 68 ms, 击败 55.60% 使用 JavaScript 的用户\n内存消耗 : 47.75 MB, 击败 12.44% 使用 JavaScript 的用户\n\nTypeScriptfunction longestCommonPrefix(strs: string[]): string &#123;    if (strs === null || strs.length === 0) &#123;        return &#x27;&#x27;;    &#125;    let prefix: string = strs[0];    for (let i = 1; i &lt; strs.length; i++) &#123;        while (strs[i].indexOf(prefix) !== 0) &#123;            prefix = prefix.substring(0, prefix.length - 1);            if (prefix.length === 0) &#123;                return &#x27;&#x27;;            &#125;        &#125;    &#125;    return prefix;&#125;\n\n结果执行用时 : 56 ms, 击败 97.39% 使用 TypeScript 的用户\n内存消耗 : 50.28 MB, 击败 8.64% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String[] $strs     * @return String     */    function longestCommonPrefix($strs) &#123;        if (empty($strs)) &#123;            return &#x27;&#x27;;        &#125;        $prefix = $strs[0];        for ($i = 1; $i &lt; count($strs); $i++) &#123;            while (strpos($strs[$i], $prefix) !== 0) &#123;                $prefix = substr($prefix, 0, strlen($prefix) - 1);                if (empty($prefix)) &#123;                    return &#x27;&#x27;;                &#125;            &#125;        &#125;        return $prefix;    &#125;&#125;\n\n结果执行用时 : 8 ms, 击败 77.67% 使用 PHP 的用户\n内存消耗 : 19.42 MB, 击败 5.82% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func longestCommonPrefix(_ strs: [String]) -&gt; String &#123;        guard !strs.isEmpty else &#123; return &quot;&quot; &#125;        var prefix = strs[0]        for i in 1..&lt;strs.count &#123;            while !strs[i].hasPrefix(prefix) &#123;                prefix = String(prefix.dropLast())                if prefix.isEmpty &#123; return &quot;&quot; &#125;            &#125;        &#125;        return prefix    &#125;&#125;\n\n结果执行用时 : 8 ms, 击败 93.33% 使用 Swift 的用户\n内存消耗 : 15.48 MB, 击败 14.08% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun longestCommonPrefix(strs: Array&lt;String&gt;): String &#123;        if (strs.isEmpty()) &#123;            return &quot;&quot;        &#125;        var prefix = strs[0]        for (i in 1 until strs.size) &#123;            while (!strs[i].startsWith(prefix)) &#123;                prefix = prefix.dropLast(1)                if (prefix.isEmpty()) &#123;                    return &quot;&quot;                &#125;            &#125;        &#125;        return prefix    &#125;&#125;\n\n结果执行用时 : 180 ms, 击败 51.52% 使用 Kotlin 的用户\n内存消耗 : 36.44 MB, 击败 40.40% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  String longestCommonPrefix(List&lt;String&gt; strs) &#123;    if (strs.isEmpty) &#123;      return &#x27;&#x27;;    &#125;    String prefix = strs[0];    for (int i = 1; i &lt; strs.length; i++) &#123;      while (!strs[i].startsWith(prefix)) &#123;        prefix = prefix.substring(0, prefix.length - 1);        if (prefix.isEmpty) &#123;          return &#x27;&#x27;;        &#125;      &#125;    &#125;    return prefix;  &#125;&#125;\n\n结果执行用时 : 284 ms, 击败 0.00% 使用 Dart 的用户\n内存消耗 : 146.90 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc longestCommonPrefix(strs []string) string &#123;    if len(strs) == 0 &#123;        return &quot;&quot;    &#125;    prefix := strs[0]    for i := 1; i &lt; len(strs); i++ &#123;        for !strings.HasPrefix(strs[i], prefix) &#123;            prefix = prefix[:len(prefix)-1]            if prefix == &quot;&quot; &#123;                return &quot;&quot;            &#125;        &#125;    &#125;    return prefix&#125;\n\n结果执行用时 : 4 ms, 击败 19.36% 使用 Go 的用户\n内存消耗 : 2.21 MB, 击败 36.25% 使用 Go 的用户\n\nRuby# @param &#123;String[]&#125; strs# @return &#123;String&#125;def longest_common_prefix(strs)  return &quot;&quot; if strs.empty?  prefix = strs[0]  (1...strs.length).each do |i|    while strs[i].index(prefix) != 0      prefix = prefix.chop      return &quot;&quot; if prefix.empty?    end  end  prefixend\n\n结果执行用时 : 48 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.80 MB, 击败 10.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def longestCommonPrefix(strs: Array[String]): String = &#123;    if (strs.isEmpty) &#123;      return &quot;&quot;    &#125;    var prefix = strs(0)    for (i &lt;- 1 until strs.length) &#123;      while (!strs(i).startsWith(prefix)) &#123;        prefix = prefix.dropRight(1)        if (prefix.isEmpty) &#123;          return &quot;&quot;        &#125;      &#125;    &#125;    prefix  &#125;&#125;\n\n结果执行用时 : 488 ms, 击败 73.33% 使用 Scala 的用户\n内存消耗 : 54.09 MB, 击败 86.67% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn longest_common_prefix(strs: Vec&lt;String&gt;) -&gt; String &#123;        if strs.is_empty() &#123;            return String::new();        &#125;        let mut prefix = strs[0].clone();        for i in 1..strs.len() &#123;            while !strs[i].starts_with(&amp;prefix) &#123;                prefix.pop();                if prefix.is_empty() &#123;                    return String::new();                &#125;            &#125;        &#125;        prefix    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.12 MB, 击败 35.11% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"张韶涵 ？","url":"/zh-CN/f14a50142869/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","张韶涵"]},{"title":"力扣00015.三数之和","url":"/zh-CN/e8fd96f06a8e/","content":"\n题目描述给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请\n你返回所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n示例 1：\n输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。\n\n示例 2：\n输入：nums &#x3D; [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。\n\n示例 3：\n输入：nums &#x3D; [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。\n\n提示：\n$3 &lt;&#x3D; nums.length &lt;&#x3D; 3000$\n$-10^5 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5$\n\n\n解决方法C++class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        int length = nums.size();        if (length &lt; 3) &#123;            return result;        &#125;        sort(nums.begin(), nums.end());        for (int i = 0; i &lt; length - 2; ++i) &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;                continue;            &#125;            int left = i + 1;            int right = length - 1;            while (left &lt; right) &#123;                int total = nums[i] + nums[left] + nums[right];                if (total &lt; 0) &#123;                    left++;                &#125; else if (total &gt; 0) &#123;                    right--;                &#125; else &#123;                    result.push_back(&#123;nums[i], nums[left], nums[right]&#125;);                    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;                        left++;                    &#125;                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;                        right--;                    &#125;                    left++;                    right--;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;\n\n结果执行用时 : 124 ms, 击败 58.25% 使用 C++ 的用户\n内存消耗 : 23.80 MB, 击败 64.63% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        int length = nums.length;        if (length &lt; 3) &#123;            return result;        &#125;        Arrays.sort(nums);        for (int i = 0; i &lt; length - 2; i++) &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;                continue;            &#125;            int left = i + 1;            int right = length - 1;            while (left &lt; right) &#123;                int total = nums[i] + nums[left] + nums[right];                if (total &lt; 0) &#123;                    left++;                &#125; else if (total &gt; 0) &#123;                    right--;                &#125; else &#123;                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));                    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;                        left++;                    &#125;                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;                        right--;                    &#125;                    left++;                    right--;                &#125;            &#125;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 32 ms, 击败 59.30% 使用 Java 的用户\n内存消耗 : 49.95 MB, 击败 50.66% 使用 Java 的用户\n\nPythonclass Solution(object):    def threeSum(self, nums):        nums.sort()        result = []        length = len(nums)        for i in range(length - 2):            if i &gt; 0 and nums[i] == nums[i - 1]:                continue            left, right = i + 1, length - 1            while left &lt; right:                total = nums[i] + nums[left] + nums[right]                if total &lt; 0:                    left += 1                elif total &gt; 0:                    right -= 1                else:                    result.append([nums[i], nums[left], nums[right]])                    while left &lt; right and nums[left] == nums[left + 1]:                        left += 1                    while left &lt; right and nums[right] == nums[right - 1]:                        right -= 1                    left += 1                    right -= 1        return result\n\n结果执行用时 : 716 ms, 击败 71.67% 使用 Python 的用户\n内存消耗 : 18.73 MB, 击败 63.92% 使用 Python 的用户\n\nPython3class Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        nums.sort()        result = []        length = len(nums)        for i in range(length - 2):            if i &gt; 0 and nums[i] == nums[i - 1]:                continue            left, right = i + 1, length - 1            while left &lt; right:                total = nums[i] + nums[left] + nums[right]                if total &lt; 0:                    left += 1                elif total &gt; 0:                    right -= 1                else:                    result.append([nums[i], nums[left], nums[right]])                    while left &lt; right and nums[left] == nums[left + 1]:                        left += 1                    while left &lt; right and nums[right] == nums[right - 1]:                        right -= 1                    left += 1                    right -= 1        return result\n\n结果执行用时 : 612 ms, 击败 92.99% 使用 Python3 的用户\n内存消耗 : 20.02 MB, 击败 15.62% 使用 Python3 的用户\n\nCint cmp(const void* pa, const void* pb)&#123;    int a = *(int*)pa;    int b = *(int*)pb;    return a &gt; b ? 1 : -1;&#125;int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)&#123;    int initialSize = 100;    int** result = (int**)malloc(sizeof(int*) * initialSize);    *returnColumnSizes = (int*)malloc(sizeof(int) * initialSize);    *returnSize = 0;    qsort(nums, numsSize, sizeof(int), cmp);    for (int i = 0; i &lt; numsSize - 2; i++) &#123;        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])            continue;        int left = i + 1;        int right = numsSize - 1;        while (left &lt; right) &#123;            int sum = nums[i] + nums[left] + nums[right];            if (sum == 0) &#123;                result[*returnSize] = (int*)malloc(sizeof(int) * 3);                (*returnColumnSizes)[*returnSize] = 3;                result[*returnSize][0] = nums[i];                result[*returnSize][1] = nums[left];                result[*returnSize][2] = nums[right];                (*returnSize)++;                if (*returnSize == initialSize) &#123;                    initialSize *= 2;                    result = (int**)realloc(result, sizeof(int*) * initialSize);                    *returnColumnSizes = (int*)realloc(*returnColumnSizes, sizeof(int) * initialSize);                &#125;                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1])                    left++;                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1])                    right--;                left++;                right--;            &#125; else if (sum &lt; 0) &#123;                left++;            &#125; else &#123;                right--;            &#125;        &#125;    &#125;    return result;&#125;\n\n结果执行用时 : 276 ms, 击败 16.27% 使用 C 的用户\n内存消耗 : 31.54 MB, 击败 68.67% 使用 C 的用户\n\nC#public class Solution &#123;    public IList&lt;IList&lt;int&gt;&gt; ThreeSum(int[] nums) &#123;        Array.Sort(nums);        IList&lt;IList&lt;int&gt;&gt; result = new List&lt;IList&lt;int&gt;&gt;();        int length = nums.Length;        for (int i = 0; i &lt; length - 2; i++) &#123;            if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])) &#123;                int left = i + 1, right = length - 1, target = -nums[i];                while (left &lt; right) &#123;                    int sum = nums[left] + nums[right];                    if (sum == target) &#123;                        result.Add(new List&lt;int&gt; &#123; nums[i], nums[left], nums[right] &#125;);                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;                        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;                        left++;                        right--;                    &#125;                    else if (sum &lt; target) &#123;                        left++;                    &#125;                    else &#123;                        right--;                    &#125;                &#125;            &#125;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 180 ms, 击败 86.80% 使用 C# 的用户\n内存消耗 : 73.13 MB, 击败 5.19% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var threeSum = function(nums) &#123;    nums.sort((a, b) =&gt; a - b);    const result = [];    const length = nums.length;    for (let i = 0; i &lt; length - 2; i++) &#123;        if (i === 0 || (i &gt; 0 &amp;&amp; nums[i] !== nums[i - 1])) &#123;            let left = i + 1, right = length - 1, target = -nums[i];            while (left &lt; right) &#123;                const sum = nums[left] + nums[right];                if (sum === target) &#123;                    result.push([nums[i], nums[left], nums[right]]);                    while (left &lt; right &amp;&amp; nums[left] === nums[left + 1]) left++;                    while (left &lt; right &amp;&amp; nums[right] === nums[right - 1]) right--;                    left++;                    right--;                &#125; else if (sum &lt; target) &#123;                    left++;                &#125; else &#123;                    right--;                &#125;            &#125;        &#125;    &#125;    return result;&#125;;\n\n结果执行用时 : 152 ms, 击败 77.73% 使用 JavaScript 的用户\n内存消耗 : 63.00 MB, 击败 6.25% 使用 JavaScript 的用户\n\nTypeScriptfunction threeSum(nums: number[]): number[][] &#123;    nums.sort((a, b) =&gt; a - b);    const result: number[][] = [];    const length = nums.length;    for (let i = 0; i &lt; length - 2; i++) &#123;        if (i === 0 || (i &gt; 0 &amp;&amp; nums[i] !== nums[i - 1])) &#123;            let left = i + 1, right = length - 1, target = -nums[i];            while (left &lt; right) &#123;                const sum = nums[left] + nums[right];                if (sum === target) &#123;                    result.push([nums[i], nums[left], nums[right]]);                    while (left &lt; right &amp;&amp; nums[left] === nums[left + 1]) left++;                    while (left &lt; right &amp;&amp; nums[right] === nums[right - 1]) right--;                    left++;                    right--;                &#125; else if (sum &lt; target) &#123;                    left++;                &#125; else &#123;                    right--;                &#125;            &#125;        &#125;    &#125;    return result;&#125;\n\n结果执行用时 : 172 ms, 击败 45.17% 使用 TypeScript 的用户\n内存消耗 : 63.81 MB, 击败 10.84% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @return Integer[][]     */    function threeSum($nums) &#123;        $result = [];        $length = count($nums);        sort($nums);        for ($i = 0; $i &lt; $length - 2; $i++) &#123;            if ($i === 0 || ($i &gt; 0 &amp;&amp; $nums[$i] !== $nums[$i - 1])) &#123;                $left = $i + 1;                $right = $length - 1;                $target = -$nums[$i];                while ($left &lt; $right) &#123;                    $sum = $nums[$left] + $nums[$right];                    if ($sum === $target) &#123;                        $result[] = [$nums[$i], $nums[$left], $nums[$right]];                        while ($left &lt; $right &amp;&amp; $nums[$left] === $nums[$left + 1]) $left++;                        while ($left &lt; $right &amp;&amp; $nums[$right] === $nums[$right - 1]) $right--;                        $left++;                        $right--;                    &#125; elseif ($sum &lt; $target) &#123;                        $left++;                    &#125; else &#123;                        $right--;                    &#125;                &#125;            &#125;        &#125;        return $result;    &#125;&#125;\n\n结果执行用时 : 236 ms, 击败 72.28% 使用 PHP 的用户\n内存消耗 : 26.17 MB, 击败 94.06% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func threeSum(_ nums: [Int]) -&gt; [[Int]] &#123;        var result = [[Int]]()        let length = nums.count        let sortedNums = nums.sorted()        for i in 0..&lt;length - 2 &#123;            if i == 0 || (i &gt; 0 &amp;&amp; sortedNums[i] != sortedNums[i - 1]) &#123;                var left = i + 1                var right = length - 1                let target = -sortedNums[i]                while left &lt; right &#123;                    let sum = sortedNums[left] + sortedNums[right]                    if sum == target &#123;                        result.append([sortedNums[i], sortedNums[left], sortedNums[right]])                        while left &lt; right &amp;&amp; sortedNums[left] == sortedNums[left + 1] &#123;                            left += 1                        &#125;                        while left &lt; right &amp;&amp; sortedNums[right] == sortedNums[right - 1] &#123;                            right -= 1                        &#125;                        left += 1                        right -= 1                    &#125; else if sum &lt; target &#123;                        left += 1                    &#125; else &#123;                        right -= 1                    &#125;                &#125;            &#125;        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 184 ms, 击败 37.55% 使用 Swift 的用户\n内存消耗 : 19.67 MB, 击败 9.30% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun threeSum(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;        val result: MutableList&lt;List&lt;Int&gt;&gt; = mutableListOf()        val length = nums.size        val sortedNums = nums.sorted()        for (i in 0 until length - 2) &#123;            if (i == 0 || (i &gt; 0 &amp;&amp; sortedNums[i] != sortedNums[i - 1])) &#123;                var left = i + 1                var right = length - 1                val target = -sortedNums[i]                while (left &lt; right) &#123;                    val sum = sortedNums[left] + sortedNums[right]                    when &#123;                        sum == target -&gt; &#123;                            result.add(listOf(sortedNums[i], sortedNums[left], sortedNums[right]))                            while (left &lt; right &amp;&amp; sortedNums[left] == sortedNums[left + 1]) left++                            while (left &lt; right &amp;&amp; sortedNums[right] == sortedNums[right - 1]) right--                            left++                            right--                        &#125;                        sum &lt; target -&gt; left++                        else -&gt; right--                    &#125;                &#125;            &#125;        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 528 ms, 击败 42.86% 使用 Kotlin 的用户\n内存消耗 : 54.28 MB, 击败 45.00% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;List&lt;int&gt;&gt; threeSum(List&lt;int&gt; nums) &#123;    List&lt;List&lt;int&gt;&gt; result = [];    nums.sort();    for (int i = 0; i &lt; nums.length - 2; i++) &#123;      if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])) &#123;        int left = i + 1, right = nums.length - 1, target = -nums[i];        while (left &lt; right) &#123;          int sum = nums[left] + nums[right];          if (sum == target) &#123;            result.add([nums[i], nums[left], nums[right]]);            while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;            while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;            left++;            right--;          &#125; else if (sum &lt; target) &#123;            left++;          &#125; else &#123;            right--;          &#125;        &#125;      &#125;    &#125;    return result;  &#125;&#125;\n\n结果执行用时 : 396 ms, 击败 58.33% 使用 Dart 的用户\n内存消耗 : 157.53 MB, 击败 75.00% 使用 Dart 的用户\n\nGofunc threeSum(nums []int) [][]int &#123;    var result [][]int    sort.Ints(nums)    length := len(nums)    for i := 0; i &lt; length-2; i++ &#123;        if i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i-1]) &#123;            left, right := i+1, length-1            target := -nums[i]            for left &lt; right &#123;                sum := nums[left] + nums[right]                if sum == target &#123;                    result = append(result, []int&#123;nums[i], nums[left], nums[right]&#125;)                    for left &lt; right &amp;&amp; nums[left] == nums[left+1] &#123;                        left++                    &#125;                    for left &lt; right &amp;&amp; nums[right] == nums[right-1] &#123;                        right--                    &#125;                    left++                    right--                &#125; else if sum &lt; target &#123;                    left++                &#125; else &#123;                    right--                &#125;            &#125;        &#125;    &#125;    return result&#125;\n\n结果执行用时 : 40 ms, 击败 90.27% 使用 Go 的用户\n内存消耗 : 8.68 MB, 击败 35.24% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @return &#123;Integer[][]&#125;def three_sum(nums)    nums.sort!    result = []    (0..nums.length - 2).each do |i|        if i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])            left = i + 1            right = nums.length - 1            target = -nums[i]            while left &lt; right                sum = nums[left] + nums[right]                if sum == target                    result &lt;&lt; [nums[i], nums[left], nums[right]]                    left += 1 while left &lt; right &amp;&amp; nums[left] == nums[left + 1]                    right -= 1 while left &lt; right &amp;&amp; nums[right] == nums[right - 1]                    left += 1                    right -= 1                elsif sum &lt; target                    left += 1                else                    right -= 1                end            end        end    end    resultend\n\n结果执行用时 : 620 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 211.62 MB, 击败 16.67% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def threeSum(nums: Array[Int]): List[List[Int]] = &#123;    val sortedNums = nums.sorted    val result = scala.collection.mutable.ListBuffer[List[Int]]()    for (i &lt;- 0 until sortedNums.length - 2) &#123;      if (i == 0 || (i &gt; 0 &amp;&amp; sortedNums(i) != sortedNums(i - 1))) &#123;        var left = i + 1        var right = sortedNums.length - 1        val target = -sortedNums(i)        while (left &lt; right) &#123;          val sum = sortedNums(left) + sortedNums(right)          if (sum == target) &#123;            result += List(sortedNums(i), sortedNums(left), sortedNums(right))            while (left &lt; right &amp;&amp; sortedNums(left) == sortedNums(left + 1)) left += 1            while (left &lt; right &amp;&amp; sortedNums(right) == sortedNums(right - 1)) right -= 1            left += 1            right -= 1          &#125; else if (sum &lt; target) &#123;            left += 1          &#125; else &#123;            right -= 1          &#125;        &#125;      &#125;    &#125;    result.toList  &#125;&#125;\n\n结果执行用时 : 748 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 66.24 MB, 击败 85.71% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn three_sum(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; &#123;        let mut result = Vec::new();        let mut nums = nums;        nums.sort();        for i in 0..nums.len() - 2 &#123;            if i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1]) &#123;                let mut left = i + 1;                let mut right = nums.len() - 1;                let target = -nums[i];                while left &lt; right &#123;                    let sum = nums[left] + nums[right];                    if sum == target &#123;                        result.push(vec![nums[i], nums[left], nums[right]]);                        while left &lt; right &amp;&amp; nums[left] == nums[left + 1] &#123;                            left += 1;                        &#125;                        while left &lt; right &amp;&amp; nums[right] == nums[right - 1] &#123;                            right -= 1;                        &#125;                        left += 1;                        right -= 1;                    &#125; else if sum &lt; target &#123;                        left += 1;                    &#125; else &#123;                        right -= 1;                    &#125;                &#125;            &#125;        &#125;        result    &#125;&#125;\n\n结果执行用时 : 32 ms, 击败 85.36% 使用 Rust 的用户\n内存消耗 : 3.91 MB, 击败 67.78% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"曼达洛人 第一季 第七集 清算","url":"/zh-CN/c0934a20c9b9/","content":"\n剧情介绍　　一位旧日对手邀请曼达洛人前来和解。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"力扣00016.最接近的三数之和","url":"/zh-CN/a4f1727f21ed/","content":"\n题目描述给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。\n返回这三个数的和。\n假定每组输入只存在恰好一个解。\n示例 1：\n输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。\n\n示例 2：\n输入：nums &#x3D; [0,0,0], target &#x3D; 1输出：0\n\n提示：\n$3 &lt;&#x3D; nums.length &lt;&#x3D; 1000$\n$-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000$\n$-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4$\n\n\n解决方法C++class Solution &#123;public:    int threeSumClosest(std::vector&lt;int&gt;&amp; nums, int target) &#123;        int closest_sum = INT_MAX; // 设置初始最接近值为最大整数值        int min_diff = INT_MAX; // 设置初始最小差值为最大整数值        std::sort(nums.begin(), nums.end()); // 对数组进行排序        for (int i = 0; i &lt; nums.size() - 2; ++i) &#123;            int left = i + 1, right = nums.size() - 1;            while (left &lt; right) &#123;                int current_sum = nums[i] + nums[left] + nums[right];                int diff = abs(target - current_sum);                if (diff &lt; min_diff) &#123;                    min_diff = diff;                    closest_sum = current_sum;                &#125;                if (current_sum &lt; target) &#123;                    ++left;                &#125; else if (current_sum &gt; target) &#123;                    --right;                &#125; else &#123;                    return current_sum;                &#125;            &#125;        &#125;        return closest_sum;    &#125;&#125;;\n\n结果执行用时 : 44 ms, 击败 55.31% 使用 C++ 的用户\n内存消耗 : 10.40 MB, 击败 27.05% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int threeSumClosest(int[] nums, int target) &#123;        int closestSum = Integer.MAX_VALUE;        int minDiff = Integer.MAX_VALUE;        Arrays.sort(nums);        for (int i = 0; i &lt; nums.length - 2; i++) &#123;            int left = i + 1, right = nums.length - 1;            while (left &lt; right) &#123;                int currentSum = nums[i] + nums[left] + nums[right];                int diff = Math.abs(target - currentSum);                if (diff &lt; minDiff) &#123;                    minDiff = diff;                    closestSum = currentSum;                &#125;                if (currentSum &lt; target) &#123;                    left++;                &#125; else if (currentSum &gt; target) &#123;                    right--;                &#125; else &#123;                    return currentSum;                &#125;            &#125;        &#125;        return closestSum;    &#125;&#125;\n\n结果执行用时 : 12 ms, 击败 77.58% 使用 Java 的用户\n内存消耗 : 41.82 MB, 击败 71.00% 使用 Java 的用户\n\nPythonclass Solution(object):    def threeSumClosest(self, nums, target):        nums.sort()        closest_sum = float(&#x27;inf&#x27;)        for i in range(len(nums) - 2):            left, right = i + 1, len(nums) - 1            while left &lt; right:                current_sum = nums[i] + nums[left] + nums[right]                if abs(target - current_sum) &lt; abs(target - closest_sum):                    closest_sum = current_sum                if current_sum &lt; target:                    left += 1                elif current_sum &gt; target:                    right -= 1                else:                    return current_sum        return closest_sum\n\n结果执行用时 : 440 ms, 击败 68.17% 使用 Python 的用户\n内存消耗 : 12.94 MB, 击败 84.08% 使用 Python 的用户\n\nPython3class Solution:    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:        nums.sort()        closest_sum = float(&#x27;inf&#x27;)        for i in range(len(nums) - 2):            left, right = i + 1, len(nums) - 1            while left &lt; right:                current_sum = nums[i] + nums[left] + nums[right]                if abs(target - current_sum) &lt; abs(target - closest_sum):                    closest_sum = current_sum                if current_sum &lt; target:                    left += 1                elif current_sum &gt; target:                    right -= 1                else:                    return current_sum        return closest_sum\n\n结果执行用时 : 376 ms, 击败 80.23% 使用 Python3 的用户\n内存消耗 : 16.85 MB, 击败 14.26% 使用 Python3 的用户\n\nCint compare(const void *a, const void *b) &#123;    return (*(int *)a - *(int *)b);&#125;int threeSumClosest(int* nums, int numsSize, int target) &#123;    qsort(nums, numsSize, sizeof(int), compare);    int closestSum = INT_MAX;    int minDiff = INT_MAX;    for (int i = 0; i &lt; numsSize - 2; i++) &#123;        int left = i + 1, right = numsSize - 1;        while (left &lt; right) &#123;            int currentSum = nums[i] + nums[left] + nums[right];            int diff = abs(target - currentSum);            if (diff &lt; minDiff) &#123;                minDiff = diff;                closestSum = currentSum;            &#125;            if (currentSum &lt; target) &#123;                left++;            &#125; else if (currentSum &gt; target) &#123;                right--;            &#125; else &#123;                return currentSum;            &#125;        &#125;    &#125;    return closestSum;&#125;\n\n结果执行用时 : 28 ms, 击败 65.84% 使用 C 的用户\n内存消耗 : 6.64 MB, 击败 27.88% 使用 C 的用户\n\nC#public class Solution &#123;    public int ThreeSumClosest(int[] nums, int target) &#123;        Array.Sort(nums);        int closestSum = int.MaxValue;        for (int i = 0; i &lt; nums.Length - 2; i++) &#123;            int left = i + 1, right = nums.Length - 1;            while (left &lt; right) &#123;                int currentSum = nums[i] + nums[left] + nums[right];                if (Math.Abs(target - currentSum) &lt; Math.Abs(target - closestSum)) &#123;                    closestSum = currentSum;                &#125;                if (currentSum &lt; target) &#123;                    left++;                &#125; else if (currentSum &gt; target) &#123;                    right--;                &#125; else &#123;                    return currentSum;                &#125;            &#125;        &#125;        return closestSum;    &#125;&#125;\n\n结果执行用时 : 92 ms, 击败 58.71% 使用 C# 的用户\n内存消耗 : 41.35 MB, 击败 5.80% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var threeSumClosest = function(nums, target) &#123;    nums.sort((a, b) =&gt; a - b);    let closestSum = Infinity;    for (let i = 0; i &lt; nums.length - 2; i++) &#123;        let left = i + 1, right = nums.length - 1;        while (left &lt; right) &#123;            const currentSum = nums[i] + nums[left] + nums[right];            if (Math.abs(target - currentSum) &lt; Math.abs(target - closestSum)) &#123;                closestSum = currentSum;            &#125;            if (currentSum &lt; target) &#123;                left++;            &#125; else if (currentSum &gt; target) &#123;                right--;            &#125; else &#123;                return currentSum;            &#125;        &#125;    &#125;    return closestSum;&#125;;\n\n结果执行用时 : 60 ms, 击败 99.54% 使用 JavaScript 的用户\n内存消耗 : 49.55 MB, 击败 5.43% 使用 JavaScript 的用户\n\nTypeScriptfunction threeSumClosest(nums: number[], target: number): number &#123;    nums.sort((a, b) =&gt; a - b);    let closestSum: number = Infinity;    for (let i = 0; i &lt; nums.length - 2; i++) &#123;        let left: number = i + 1, right: number = nums.length - 1;        while (left &lt; right) &#123;            const currentSum: number = nums[i] + nums[left] + nums[right];            if (Math.abs(target - currentSum) &lt; Math.abs(target - closestSum)) &#123;                closestSum = currentSum;            &#125;            if (currentSum &lt; target) &#123;                left++;            &#125; else if (currentSum &gt; target) &#123;                right--;            &#125; else &#123;                return currentSum;            &#125;        &#125;    &#125;    return closestSum;&#125;\n\n结果执行用时 : 76 ms, 击败 88.81% 使用 TypeScript 的用户\n内存消耗 : 51.18 MB, 击败 5.59% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @param Integer $target     * @return Integer     */    function threeSumClosest($nums, $target) &#123;        sort($nums);        $closestSum = PHP_INT_MAX;        $length = count($nums);        for ($i = 0; $i &lt; $length - 2; $i++) &#123;            $left = $i + 1;            $right = $length - 1;            while ($left &lt; $right) &#123;                $currentSum = $nums[$i] + $nums[$left] + $nums[$right];                if (abs($target - $currentSum) &lt; abs($target - $closestSum)) &#123;                    $closestSum = $currentSum;                &#125;                if ($currentSum &lt; $target) &#123;                    $left++;                &#125; elseif ($currentSum &gt; $target) &#123;                    $right--;                &#125; else &#123;                    return $currentSum;                &#125;            &#125;        &#125;        return $closestSum;    &#125;&#125;\n\n结果执行用时 : 208 ms, 击败 26.67% 使用 PHP 的用户\n内存消耗 : 19.53 MB, 击败 6.67%用 PHP 的用户\n\nSwiftclass Solution &#123;    func threeSumClosest(_ nums: [Int], _ target: Int) -&gt; Int &#123;        let sorted = nums.sorted()        var gap = Int.max        var finalSum = 0        for i in 0 ..&lt; sorted.count - 2 &#123;            var left = i + 1            var right = sorted.count - 1            while(left &lt; right) &#123;                let sum = sorted[i] + sorted[left] + sorted[right]                let tmp = abs(sum - target)                if(tmp &lt; gap) &#123;                    gap = tmp                    finalSum = sum                &#125;                if(sum &lt; target) &#123;                    left += 1                &#125; else if(sum &gt; target) &#123;                    right -= 1                &#125; else &#123;                    return sum                &#125;            &#125;        &#125;        return finalSum    &#125;&#125;\n\n结果执行用时 : 36 ms, 击败 61.70% 使用 Swift 的用户\n内存消耗 : 15.40 MB, 击败 6.38% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun threeSumClosest(nums: IntArray, target: Int): Int &#123;        nums.sort()        var closestSum = Int.MAX_VALUE        for (i in 0 until nums.size - 2) &#123;            var left = i + 1            var right = nums.size - 1            while (left &lt; right) &#123;                val currentSum = nums[i] + nums[left] + nums[right]                if (Math.abs(target - currentSum) &lt; Math.abs(target - closestSum)) &#123;                    closestSum = currentSum                &#125;                if (currentSum &lt; target) &#123;                    left++                &#125; else if (currentSum &gt; target) &#123;                    right--                &#125; else &#123;                    return currentSum // 如果等于目标值，直接返回                &#125;            &#125;        &#125;        return closestSum    &#125;&#125;\n\n结果执行用时 : 208 ms, 击败 84.00% 使用 Kotlin 的用户\n内存消耗 : 38.36 MB, 击败 40.00% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int threeSumClosest(List&lt;int&gt; nums, int target) &#123;    nums.sort();    int closestSum = nums[0] + nums[1] + nums[2];    for (int i = 0; i &lt; nums.length - 2; i++) &#123;      int left = i + 1;      int right = nums.length - 1;      while (left &lt; right) &#123;        int currentSum = nums[i] + nums[left] + nums[right];        if ((target - currentSum).abs() &lt; (target - closestSum).abs()) &#123;          closestSum = currentSum;        &#125;        if (currentSum &lt; target) &#123;          left++;        &#125; else if (currentSum &gt; target) &#123;          right--;        &#125; else &#123;          return currentSum;        &#125;      &#125;    &#125;    return closestSum;  &#125;&#125;\n\n结果执行用时 : 348 ms, 击败 50.00% 使用 Dart 的用户\n内存消耗 : 152.27 MB, 击败 50.00% 使用 Dart 的用户\n\nGoimport &quot;sort&quot;func threeSumClosest(nums []int, target int) int &#123;    sort.Ints(nums)    closestSum := nums[0] + nums[1] + nums[2]    for i := 0; i &lt; len(nums)-2; i++ &#123;        left := i + 1        right := len(nums) - 1        for left &lt; right &#123;            currentSum := nums[i] + nums[left] + nums[right]            if abs(target-currentSum) &lt; abs(target-closestSum) &#123;                closestSum = currentSum            &#125;            if currentSum &lt; target &#123;                left++            &#125; else if currentSum &gt; target &#123;                right--            &#125; else &#123;                return currentSum            &#125;        &#125;    &#125;    return closestSum&#125;func abs(a int) int &#123;    if a &lt; 0 &#123;        return -a    &#125;    return a&#125;\n\n结果执行用时 : 8 ms, 击败 95.37% 使用 Go 的用户\n内存消耗 : 2.74 MB, 击败 97.61% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @param &#123;Integer&#125; target# @return &#123;Integer&#125;def three_sum_closest(nums, target)    nums.sort!    closest_sum = nums[0] + nums[1] + nums[2]    (0..nums.size-2).each do |i|        left = i + 1        right = nums.size - 1        while left &lt; right            current_sum = nums[i] + nums[left] + nums[right]            if (target - current_sum).abs &lt; (target - closest_sum).abs                closest_sum = current_sum            end            if current_sum &lt; target                left += 1            elsif current_sum &gt; target                right -= 1            else                return current_sum            end        end    end    closest_sumend\n\n结果执行用时 : 344 ms, 击败 50.00% 使用 Ruby 的用户\n内存消耗 : 206.89 MB, 击败 -% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def threeSumClosest(nums: Array[Int], target: Int): Int = &#123;    val sorted = nums.sorted    var closestSum = sorted(0) + sorted(1) + sorted(2)    for (i &lt;- 0 until sorted.length - 2) &#123;      var left = i + 1      var right = sorted.length - 1      while (left &lt; right) &#123;        val currentSum = sorted(i) + sorted(left) + sorted(right)        if (math.abs(target - currentSum) &lt; math.abs(target - closestSum)) &#123;          closestSum = currentSum        &#125;        if (currentSum &lt; target) &#123;          left += 1        &#125; else if (currentSum &gt; target) &#123;          right -= 1        &#125; else &#123;          return currentSum        &#125;      &#125;    &#125;    closestSum  &#125;&#125;\n\n结果执行用时 : 548 ms, 击败 -% 使用 Scala 的用户\n内存消耗 : 54.30 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn three_sum_closest(nums: Vec&lt;i32&gt;, target: i32) -&gt; i32 &#123;        let mut sorted = nums;        sorted.sort();        let mut closest_sum = sorted[0] + sorted[1] + sorted[2];        for i in 0..sorted.len() - 2 &#123;            let mut left = i + 1;            let mut right = sorted.len() - 1;            while left &lt; right &#123;                let current_sum = sorted[i] + sorted[left] + sorted[right];                if (target - current_sum).abs() &lt; (target - closest_sum).abs() &#123;                    closest_sum = current_sum;                &#125;                if current_sum &lt; target &#123;                    left += 1;                &#125; else if current_sum &gt; target &#123;                    right -= 1;                &#125; else &#123;                    return current_sum;                &#125;            &#125;        &#125;        closest_sum    &#125;&#125;\n\n结果执行用时 : 8 ms, 击败 86.75% 使用 Rust 的用户\n内存消耗 : 2.05 MB, 击败 51.81% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00017.电话号码的字母组合","url":"/zh-CN/4b6f5fbc1f12/","content":"\n题目描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n\n示例 1：\n输入：digits &#x3D; “23”输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]\n\n示例 2：\n输入：digits &#x3D; “”输出：[]\n\n示例 3：\n输入：digits &#x3D; “2”输出：[“a”,”b”,”c”]\n\n提示：\n0 &lt;&#x3D; digits.length &lt;&#x3D; 4\ndigits[i] 是范围 [‘2’, ‘9’] 的一个数字。\n\n\n解决方法C++class Solution &#123;public:    vector&lt;string&gt; letterCombinations(string digits) &#123;        if (digits.empty()) &#123;            return &#123;&#125;;        &#125;        vector&lt;string&gt; phone = &#123;            &quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;        &#125;;        vector&lt;string&gt; combinations;        backtrack(digits, 0, &quot;&quot;, combinations, phone);        return combinations;    &#125;private:    void backtrack(const string&amp; digits, int index, string current, vector&lt;string&gt;&amp; combinations, const vector&lt;string&gt;&amp; phone) &#123;        if (index == digits.length()) &#123;            combinations.push_back(current);            return;        &#125;        string letters = phone[digits[index] - &#x27;0&#x27;];        for (char letter : letters) &#123;            current.push_back(letter);            backtrack(digits, index + 1, current, combinations, phone);            current.pop_back();        &#125;    &#125;&#125;;\n\n结果执行用时 : 4 ms, 击败 31.65% 使用 C++ 的用户\n内存消耗 : 6.75 MB, 击败 75.08% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public List&lt;String&gt; letterCombinations(String digits) &#123;        List&lt;String&gt; combinations = new ArrayList&lt;&gt;();        if (digits == null || digits.length() == 0) &#123;            return combinations;        &#125;        String[] phone = &#123;            &quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;        &#125;;        backtrack(digits, 0, new StringBuilder(), combinations, phone);        return combinations;    &#125;    private void backtrack(String digits, int index, StringBuilder current, List&lt;String&gt; combinations, String[] phone) &#123;        if (index == digits.length()) &#123;            combinations.add(current.toString());            return;        &#125;        String letters = phone[digits.charAt(index) - &#x27;0&#x27;];        for (char letter : letters.toCharArray()) &#123;            current.append(letter);            backtrack(digits, index + 1, current, combinations, phone);            current.deleteCharAt(current.length() - 1);        &#125;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 40.78 MB, 击败 15.89% 使用 Java 的用户\n\nPythonclass Solution(object):    def letterCombinations(self, digits):        if not digits:            return []        phone = &#123;            &#x27;2&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;],            &#x27;3&#x27;: [&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;],            &#x27;4&#x27;: [&#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;],            &#x27;5&#x27;: [&#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;],            &#x27;6&#x27;: [&#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;],            &#x27;7&#x27;: [&#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;],            &#x27;8&#x27;: [&#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;],            &#x27;9&#x27;: [&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]        &#125;        def backtrack(index, path):            if index == len(digits):                combinations.append(&#x27;&#x27;.join(path))                return            for letter in phone[digits[index]]:                path.append(letter)                backtrack(index + 1, path)                path.pop()        combinations = []        backtrack(0, [])        return combinations\n\n结果执行用时 : 20 ms, 击败 40.96% 使用 Python 的用户\n内存消耗 : 13.01 MB, 击败 69.30% 使用 Python 的用户\n\nPython3class Solution:    def letterCombinations(self, digits: str) -&gt; List[str]:        if not digits:            return []        phone = &#123;            &#x27;2&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;],            &#x27;3&#x27;: [&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;],            &#x27;4&#x27;: [&#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;],            &#x27;5&#x27;: [&#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;],            &#x27;6&#x27;: [&#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;],            &#x27;7&#x27;: [&#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;],            &#x27;8&#x27;: [&#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;],            &#x27;9&#x27;: [&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]        &#125;        def backtrack(index, path):            if index == len(digits):                combinations.append(&#x27;&#x27;.join(path))                return            for letter in phone[digits[index]]:                path.append(letter)                backtrack(index + 1, path)                path.pop()        combinations = []        backtrack(0, [])        return combinations\n\n结果执行用时 : 36 ms, 击败 89.86% 使用 Python3 的用户\n内存消耗 : 16.86 MB, 击败 16.18% 使用 Python3 的用户\n\nC/** * Note: The returned array must be malloced, assume caller calls free(). */char* phone[] = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;void backtrack(char* digits, int index, char* path, char** combinations, int* count) &#123;    if (digits[index] == &#x27;\\0&#x27;) &#123;        combinations[*count] = strdup(path);        (*count)++;        return;    &#125;    int digit = digits[index] - &#x27;0&#x27;;    char* letters = phone[digit];    for (int i = 0; i &lt; strlen(letters); i++) &#123;        path[index] = letters[i];        backtrack(digits, index + 1, path, combinations, count);    &#125;&#125;char** letterCombinations(char* digits, int* returnSize) &#123;    if (digits == NULL || *digits == &#x27;\\0&#x27;) &#123;        *returnSize = 0;        return NULL;    &#125;    int len = strlen(digits);    int total_combinations = 1;    for (int i = 0; i &lt; len; i++) &#123;        int digit = digits[i] - &#x27;0&#x27;;        total_combinations *= strlen(phone[digit]);    &#125;    char** combinations = (char**)malloc(total_combinations * sizeof(char*));    char* path = (char*)malloc((len + 1) * sizeof(char));    path[len] = &#x27;\\0&#x27;;    int count = 0;    backtrack(digits, 0, path, combinations, &amp;count);    free(path);    *returnSize = count;    return combinations;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 6.61 MB, 击败 31.77% 使用 C 的用户\n\nC#public class Solution &#123;    private readonly string[] phone = &#123;        &quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;    &#125;;    public IList&lt;string&gt; LetterCombinations(string digits) &#123;        IList&lt;string&gt; combinations = new List&lt;string&gt;();        if (string.IsNullOrEmpty(digits)) &#123;            return combinations;        &#125;        Backtrack(digits, 0, new List&lt;char&gt;(), combinations);        return combinations;    &#125;    private void Backtrack(string digits, int index, List&lt;char&gt; path, IList&lt;string&gt; combinations) &#123;        if (index == digits.Length) &#123;            combinations.Add(new string(path.ToArray()));            return;        &#125;        int digit = digits[index] - &#x27;0&#x27;;        string letters = phone[digit];        foreach (char letter in letters) &#123;            path.Add(letter);            Backtrack(digits, index + 1, path, combinations);            path.RemoveAt(path.Count - 1);        &#125;    &#125;&#125;\n\n结果执行用时 : 108 ms, 击败 87.74% 使用 C# 的用户\n内存消耗 : 46.07 MB, 击败 5.37% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; digits * @return &#123;string[]&#125; */var letterCombinations = function(digits) &#123;    if (digits === null || digits.length === 0) &#123;        return [];    &#125;    const phone = &#123;        &#x27;2&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;],        &#x27;3&#x27;: [&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;],        &#x27;4&#x27;: [&#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;],        &#x27;5&#x27;: [&#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;],        &#x27;6&#x27;: [&#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;],        &#x27;7&#x27;: [&#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;],        &#x27;8&#x27;: [&#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;],        &#x27;9&#x27;: [&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]    &#125;;    const combinations = [];    const backtrack = (index, path) =&gt; &#123;        if (index === digits.length) &#123;            combinations.push(path.join(&#x27;&#x27;));            return;        &#125;        const letters = phone[digits[index]];        for (let letter of letters) &#123;            path.push(letter);            backtrack(index + 1, path);            path.pop();        &#125;    &#125;;    backtrack(0, []);    return combinations;&#125;;\n\n结果执行用时 : 56 ms, 击败 84.24% 使用 JavaScript 的用户\n内存消耗 : 47.66 MB, 击败 8.30% 使用 JavaScript 的用户\n\nTypeScriptfunction letterCombinations(digits: string): string[] &#123;    if (!digits || digits.length === 0) &#123;        return [];    &#125;    const phone: &#123; [key: string]: string[] &#125; = &#123;        &#x27;2&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;],        &#x27;3&#x27;: [&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;],        &#x27;4&#x27;: [&#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;],        &#x27;5&#x27;: [&#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;],        &#x27;6&#x27;: [&#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;],        &#x27;7&#x27;: [&#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;],        &#x27;8&#x27;: [&#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;],        &#x27;9&#x27;: [&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]    &#125;;    const combinations: string[] = [];    const backtrack = (index: number, path: string[]) =&gt; &#123;        if (index === digits.length) &#123;            combinations.push(path.join(&#x27;&#x27;));            return;        &#125;        const letters = phone[digits.charAt(index)];        for (let letter of letters) &#123;            path.push(letter);            backtrack(index + 1, path);            path.pop();        &#125;    &#125;;    backtrack(0, []);    return combinations;&#125;\n\n结果执行用时 : 76 ms, 击败 7.96% 使用 TypeScript 的用户\n内存消耗 : 50.34 MB, 击败 5.09% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String $digits     * @return String[]     */    function letterCombinations($digits) &#123;        if ($digits === &quot;&quot;) &#123;            return [];        &#125;        $phone = [            &#x27;2&#x27; =&gt; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;],            &#x27;3&#x27; =&gt; [&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;],            &#x27;4&#x27; =&gt; [&#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;],            &#x27;5&#x27; =&gt; [&#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;],            &#x27;6&#x27; =&gt; [&#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;],            &#x27;7&#x27; =&gt; [&#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;],            &#x27;8&#x27; =&gt; [&#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;],            &#x27;9&#x27; =&gt; [&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]        ];        $combinations = [];        $this-&gt;backtrack($digits, 0, &#x27;&#x27;, $combinations, $phone);        return $combinations;    &#125;    function backtrack($digits, $index, $path, &amp;$combinations, $phone) &#123;        if ($index === strlen($digits)) &#123;            $combinations[] = $path;            return;        &#125;        $letters = $phone[$digits[$index]];        foreach ($letters as $letter) &#123;            $this-&gt;backtrack($digits, $index + 1, $path . $letter, $combinations, $phone);        &#125;    &#125;&#125;\n\n结果执行用时 : 12 ms, 击败 18.52% 使用 PHP 的用户\n内存消耗 : 19.43 MB, 击败 11.11% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    let phone: [Character: [Character]] = [        &quot;2&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;],        &quot;3&quot;: [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;],        &quot;4&quot;: [&quot;g&quot;, &quot;h&quot;, &quot;i&quot;],        &quot;5&quot;: [&quot;j&quot;, &quot;k&quot;, &quot;l&quot;],        &quot;6&quot;: [&quot;m&quot;, &quot;n&quot;, &quot;o&quot;],        &quot;7&quot;: [&quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;],        &quot;8&quot;: [&quot;t&quot;, &quot;u&quot;, &quot;v&quot;],        &quot;9&quot;: [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]    ]    func letterCombinations(_ digits: String) -&gt; [String] &#123;        guard !digits.isEmpty else &#123; return [] &#125;        var combinations = [String]()        backtrack(Array(digits), 0, &quot;&quot;, &amp;combinations)        return combinations    &#125;    func backtrack(_ digits: [Character], _ index: Int, _ path: String, _ combinations: inout [String]) &#123;        if index == digits.count &#123;            combinations.append(path)            return        &#125;        let currentDigit = digits[index]        guard let letters = phone[currentDigit] else &#123; return &#125;        for letter in letters &#123;            backtrack(digits, index + 1, path + String(letter), &amp;combinations)        &#125;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Swift 的用户\n内存消耗 : 15.64 MB, 击败 15.04% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    val phone = mapOf(        &#x27;2&#x27; to listOf(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;),        &#x27;3&#x27; to listOf(&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;),        &#x27;4&#x27; to listOf(&#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;),        &#x27;5&#x27; to listOf(&#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;),        &#x27;6&#x27; to listOf(&#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;),        &#x27;7&#x27; to listOf(&#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;),        &#x27;8&#x27; to listOf(&#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;),        &#x27;9&#x27; to listOf(&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;)    )    fun letterCombinations(digits: String): List&lt;String&gt; &#123;        if (digits.isEmpty()) &#123;            return emptyList()        &#125;        val combinations = mutableListOf&lt;String&gt;()        backtrack(digits.toCharArray(), 0, StringBuilder(), combinations)        return combinations    &#125;    private fun backtrack(digits: CharArray, index: Int, path: StringBuilder, combinations: MutableList&lt;String&gt;) &#123;        if (index == digits.size) &#123;            combinations.add(path.toString())            return        &#125;        val letters = phone[digits[index]] ?: return        for (letter in letters) &#123;            path.append(letter)            backtrack(digits, index + 1, path, combinations)            path.deleteCharAt(path.length - 1)        &#125;    &#125;&#125;\n\n结果执行用时 : 216 ms, 击败 5.45% 使用 Kotlin 的用户\n内存消耗 : 37.51 MB, 击败 10.91% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  Map&lt;String, List&lt;String&gt;&gt; phone = &#123;    &#x27;2&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;],    &#x27;3&#x27;: [&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;],    &#x27;4&#x27;: [&#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;],    &#x27;5&#x27;: [&#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;],    &#x27;6&#x27;: [&#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;],    &#x27;7&#x27;: [&#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;],    &#x27;8&#x27;: [&#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;],    &#x27;9&#x27;: [&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]  &#125;;  List&lt;String&gt; letterCombinations(String digits) &#123;    List&lt;String&gt; combinations = [];    if (digits.isEmpty) &#123;      return combinations;    &#125;    _backtrack(digits, 0, &#x27;&#x27;, combinations);    return combinations;  &#125;  void _backtrack(String digits, int index, String current, List&lt;String&gt; combinations) &#123;    if (index == digits.length) &#123;      combinations.add(current);      return;    &#125;    List&lt;String&gt; letters = phone[digits[index]]!;    for (var letter in letters) &#123;      _backtrack(digits, index + 1, current + letter, combinations);    &#125;  &#125;&#125;\n\n结果执行用时 : 296 ms, 击败 -% 使用 Dart 的用户\n内存消耗 : 147.34 MB, 击败 100.00% 使用 Dart 的用户\n\nGovar phone = map[string][]string&#123;\t&quot;2&quot;: []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;,\t&quot;3&quot;: []string&#123;&quot;d&quot;, &quot;e&quot;, &quot;f&quot;&#125;,\t&quot;4&quot;: []string&#123;&quot;g&quot;, &quot;h&quot;, &quot;i&quot;&#125;,\t&quot;5&quot;: []string&#123;&quot;j&quot;, &quot;k&quot;, &quot;l&quot;&#125;,\t&quot;6&quot;: []string&#123;&quot;m&quot;, &quot;n&quot;, &quot;o&quot;&#125;,\t&quot;7&quot;: []string&#123;&quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;&#125;,\t&quot;8&quot;: []string&#123;&quot;t&quot;, &quot;u&quot;, &quot;v&quot;&#125;,\t&quot;9&quot;: []string&#123;&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;&#125;,&#125;func letterCombinations(digits string) []string &#123;\tvar combinations []string\tif digits == &quot;&quot; &#123;\t\treturn combinations\t&#125;\tvar backtrack func(index int, path string)\tbacktrack = func(index int, path string) &#123;\t\tif index == len(digits) &#123;\t\t\tcombinations = append(combinations, path)\t\t\treturn\t\t&#125;\t\tletters := phone[string(digits[index])]\t\tfor _, letter := range letters &#123;\t\t\tbacktrack(index+1, path+letter)\t\t&#125;\t&#125;\tbacktrack(0, &quot;&quot;)\treturn combinations&#125;\n\n结果执行用时 : 4 ms, 击败 9.81% 使用 Go 的用户\n内存消耗 : 1.94 MB, 击败 39.95% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; digits# @return &#123;String[]&#125;PHONE = &#123;  &#x27;2&#x27; =&gt; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;],  &#x27;3&#x27; =&gt; [&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;],  &#x27;4&#x27; =&gt; [&#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;],  &#x27;5&#x27; =&gt; [&#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;],  &#x27;6&#x27; =&gt; [&#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;],  &#x27;7&#x27; =&gt; [&#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;],  &#x27;8&#x27; =&gt; [&#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;],  &#x27;9&#x27; =&gt; [&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]&#125;def letter_combinations(digits)  return [] if digits.empty?  combinations = []  backtrack(digits, 0, &#x27;&#x27;, combinations)  combinationsenddef backtrack(digits, index, path, combinations)  if index == digits.length    combinations &lt;&lt; path    return  end  letters = PHONE[digits[index]]  letters.each do |letter|    backtrack(digits, index + 1, path + letter, combinations)  endend\n\n结果执行用时 : 76 ms, 击败 25.00% 使用 Ruby 的用户\n内存消耗 : 206.65 MB, 击败 25.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  val phone = Map(    &#x27;2&#x27; -&gt; List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;),    &#x27;3&#x27; -&gt; List(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;),    &#x27;4&#x27; -&gt; List(&quot;g&quot;, &quot;h&quot;, &quot;i&quot;),    &#x27;5&#x27; -&gt; List(&quot;j&quot;, &quot;k&quot;, &quot;l&quot;),    &#x27;6&#x27; -&gt; List(&quot;m&quot;, &quot;n&quot;, &quot;o&quot;),    &#x27;7&#x27; -&gt; List(&quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;),    &#x27;8&#x27; -&gt; List(&quot;t&quot;, &quot;u&quot;, &quot;v&quot;),    &#x27;9&#x27; -&gt; List(&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;)  )  def letterCombinations(digits: String): List[String] = &#123;    if (digits.isEmpty) &#123;      return List()    &#125;    var combinations = List[String]()    def backtrack(index: Int, path: String): Unit = &#123;      if (index == digits.length) &#123;        combinations = path :: combinations        return      &#125;      val letters = phone(digits(index))      letters.foreach(letter =&gt; backtrack(index + 1, path + letter))    &#125;    backtrack(0, &quot;&quot;)    combinations.reverse  &#125;&#125;\n\n结果执行用时 : 452 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 53.96 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn letter_combinations(digits: String) -&gt; Vec&lt;String&gt; &#123;        let phone = [            (&#x27;2&#x27;, &quot;abc&quot;),            (&#x27;3&#x27;, &quot;def&quot;),            (&#x27;4&#x27;, &quot;ghi&quot;),            (&#x27;5&#x27;, &quot;jkl&quot;),            (&#x27;6&#x27;, &quot;mno&quot;),            (&#x27;7&#x27;, &quot;pqrs&quot;),            (&#x27;8&#x27;, &quot;tuv&quot;),            (&#x27;9&#x27;, &quot;wxyz&quot;),        ]        .iter()        .cloned()        .collect::&lt;std::collections::HashMap&lt;_, _&gt;&gt;();        if digits.is_empty() &#123;            return vec![];        &#125;        let mut result = vec![&quot;&quot;.to_string()];        for digit in digits.chars() &#123;            if let Some(letters) = phone.get(&amp;digit) &#123;                let mut temp = Vec::new();                for letter in letters.chars() &#123;                    for item in &amp;result &#123;                        temp.push(item.clone() + &amp;letter.to_string());                    &#125;                &#125;                result = temp;            &#125;        &#125;        result    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.14 MB, 击败 26.85% 使用 Rust 的用户\n\nRacket(define letter-map  #hash((#\\2 . (#\\a #\\b #\\c))        (#\\3 . (#\\d #\\e #\\f))        (#\\4 . (#\\g #\\h #\\i))        (#\\5 . (#\\j #\\k #\\l))        (#\\6 . (#\\m #\\n #\\o))        (#\\7 . (#\\p #\\q #\\r #\\s))        (#\\8 . (#\\t #\\u #\\v))        (#\\9 . (#\\w #\\x #\\y #\\z))))(define (get-letters n)  (hash-ref letter-map n))(define/contract (letter-combinations digits)  (-&gt; string? (listof string?))  (if (= 0 (string-length digits))      &#x27;()      (map list-&gt;string           (char-combinations (string-&gt;list digits)))))(define/contract (char-combinations ns)  (-&gt; (listof char?) (listof (listof char?)))  (if (null? ns)      &#x27;(())      (for*/list ([rest-combinations (char-combinations (cdr ns))]                  [current-letter (get-letters (car ns))])        (cons current-letter rest-combinations))))\n\n结果执行用时 : 184 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 98.10 MB, 击败 -% 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"孤独的美食家 第八季 第十二集 东京都台东区三之轮的炸猪排盖饭与麻婆冷面","url":"/zh-CN/d4a0b49e3818/","content":"\n剧情介绍　　五郎托在三之轮经营水晶玻璃店的广濑省吾帮忙举办活动。广濑爽快地答应了，不过，他也有个不情之请，托五郎替他去做一项工作，为此五郎要付出很大代价。虽然因此而头疼，但五郎还是饿了。他找了一圈小饭店，终于发现了一家定食屋。他被招牌上写的“请品尝用最棒的酥脆油炸里脊肉排套餐”诱惑，走进店一年，菜牌上从中华料理到西餐有各种让五郎纠结的菜名。从一大堆菜中，五郎选了猪排饭。好久没吃过猪排饭的五郎被美味搞得乐不可支，还把酱汁拌进饭里一起吃。胃口大开的他又追加了麻婆豆腐冷面和饺子。麻婆豆腐冷面兼具中华风冷豆腐的爽滑和肉酱的辛辣，是一种滋味绝妙的组合。会联想到古典中华料理风味的饺子那令人怀念的味道给五郎带来的治愈感。他给麻婆豆腐冷面加上醋和辣油后，味道变得古怪，但又更加令人开心。不一会儿，五郎就吃完了。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"食戟之灵 第四季 神之皿 第十一集 希望之歌","url":"/zh-CN/eb97ee0b7dad/","content":"\n剧情介绍　　在最终回合中，创真向绘里奈发起了一场食戟挑战。这背后隐藏着一个目的：创真希望绘里奈能全力以赴，做出她的“杀手之作”……随着时间限制逐渐逼近，绘里奈接受了创真的挑战，并开始准备一份全新的料理！绘里奈最终会呈现出怎样的“杀手之作”？\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"力扣00018.四数之和","url":"/zh-CN/ebb20949ccd5/","content":"\n题目描述给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：\n\n0 &lt;&#x3D; a, b, c, d &lt; n\na、b、c 和 d 互不相同\nnums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target\n\n你可以按 任意顺序 返回答案 。\n示例 1：\n输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n示例 2：\n输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8输出：[[2,2,2,2]]\n\n提示：\n$1 &lt;&#x3D; nums.length &lt;&#x3D; 200$\n$-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9$\n$-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9$\n\n\n解决方法C++class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        int n = nums.size();        if (n &lt; 4) &#123;            return result;        &#125;        sort(nums.begin(), nums.end());        for (int i = 0; i &lt; n - 3; ++i) &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;                continue;            &#125;            for (int j = i + 1; j &lt; n - 2; ++j) &#123;                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;                    continue;                &#125;                int left = j + 1;                int right = n - 1;                while (left &lt; right) &#123;                    long long sum = static_cast&lt;long long&gt;(nums[i]) + static_cast&lt;long long&gt;(nums[j]) + static_cast&lt;long long&gt;(nums[left]) + static_cast&lt;long long&gt;(nums[right]);                    if (sum == target) &#123;                        result.push_back(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;                            left++;                        &#125;                        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;                            right--;                        &#125;                        left++;                        right--;                    &#125; else if (sum &lt; target) &#123;                        left++;                    &#125; else &#123;                        right--;                    &#125;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;\n\n结果执行用时 : 72 ms, 击败 56.26% 使用 C++ 的用户\n内存消耗 : 13.43 MB, 击败 19.12% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;        List&lt;List&lt;Integer&gt;&gt; quadruplets = new ArrayList&lt;&gt;();        if (nums == null || nums.length &lt; 4) &#123;            return quadruplets;        &#125;        Arrays.sort(nums);        int length = nums.length;        for (int i = 0; i &lt; length - 3; i++) &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;                continue;            &#125;            if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) &#123;                break;            &#125;            if ((long) nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target) &#123;                continue;            &#125;            for (int j = i + 1; j &lt; length - 2; j++) &#123;                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;                    continue;                &#125;                if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) &#123;                    break;                &#125;                if ((long) nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target) &#123;                    continue;                &#125;                int left = j + 1, right = length - 1;                while (left &lt; right) &#123;                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];                    if (sum == target) &#123;                        quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;                            left++;                        &#125;                        left++;                        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;                            right--;                        &#125;                        right--;                    &#125; else if (sum &lt; target) &#123;                        left++;                    &#125; else &#123;                        right--;                    &#125;                &#125;            &#125;        &#125;        return quadruplets;    &#125;&#125;\n\n结果执行用时 : 2 ms, 击败 99.83% 使用 Java 的用户\n内存消耗 : 42.84 MB, 击败 46.30% 使用 Java 的用户\n\nPythonclass Solution(object):    def fourSum(self, nums, target):        quadruplets = []        nums.sort()        length = len(nums)        for i in range(length - 3):            if i &gt; 0 and nums[i] == nums[i - 1]:                continue            if nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target:                break            if nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target:                continue            for j in range(i + 1, length - 2):                if j &gt; i + 1 and nums[j] == nums[j - 1]:                    continue                if nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target:                    break                if nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target:                    continue                left = j + 1                right = length - 1                while left &lt; right:                    total = nums[i] + nums[j] + nums[left] + nums[right]                    if total == target:                        quadruplets.append([nums[i], nums[j], nums[left], nums[right]])                        while left &lt; right and nums[left] == nums[left + 1]:                            left += 1                        left += 1                        while left &lt; right and nums[right] == nums[right - 1]:                            right -= 1                        right -= 1                    elif total &lt; target:                        left += 1                    else:                        right -= 1        return quadruplets\n\n结果执行用时 : 40 ms, 击败 96.53% 使用 Python 的用户\n内存消耗 : 12.91 MB, 击败 85.86% 使用 Python 的用户\n\nPython3class Solution:    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:        nums.sort()        length = len(nums)        quadruplets = []        for i in range(length - 3):            if i &gt; 0 and nums[i] == nums[i - 1]:                continue            if nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target:                break            if nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target:                continue            for j in range(i + 1, length - 2):                if j &gt; i + 1 and nums[j] == nums[j - 1]:                    continue                if nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target:                    break                if nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target:                    continue                left = j + 1                right = length - 1                while left &lt; right:                    total = nums[i] + nums[j] + nums[left] + nums[right]                    if total == target:                        quadruplets.append([nums[i], nums[j], nums[left], nums[right]])                        while left &lt; right and nums[left] == nums[left + 1]:                            left += 1                        left += 1                        while left &lt; right and nums[right] == nums[right - 1]:                            right -= 1                        right -= 1                    elif total &lt; target:                        left += 1                    else:                        right -= 1        return quadruplets\n\n结果执行用时 : 56 ms, 击败 98.70% 使用 Python3 的用户\n内存消耗 : 17.07 MB, 击败 12.39% 使用 Python3 的用户\n\nC/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int compare(const void* a, const void* b) &#123;    return (*(int*)a - *(int*)b);&#125;int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) &#123;    qsort(nums, numsSize, sizeof(int), compare);    int capacity = 16;    int** result = (int**)malloc(capacity * sizeof(int*));    *returnColumnSizes = (int*)malloc(capacity * sizeof(int));    *returnSize = 0;    for (int i = 0; i &lt; numsSize - 3; i++) &#123;        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;            continue;        &#125;        for (int j = i + 1; j &lt; numsSize - 2; j++) &#123;            if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;                continue;            &#125;            int left = j + 1;            int right = numsSize - 1;            while (left &lt; right) &#123;                long long sum = (long long)nums[i] + nums[j] + nums[left] + nums[right];                if (sum == target) &#123;                    if (*returnSize == capacity) &#123;                        capacity *= 2;                        result = (int**)realloc(result, capacity * sizeof(int*));                        *returnColumnSizes = (int*)realloc(*returnColumnSizes, capacity * sizeof(int));                    &#125;                    result[*returnSize] = (int*)malloc(4 * sizeof(int));                    result[*returnSize][0] = nums[i];                    result[*returnSize][1] = nums[j];                    result[*returnSize][2] = nums[left];                    result[*returnSize][3] = nums[right];                    (*returnColumnSizes)[*returnSize] = 4;                    (*returnSize)++;                    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;                        left++;                    &#125;                    left++;                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;                        right--;                    &#125;                    right--;                &#125; else if (sum &lt; target) &#123;                    left++;                &#125; else &#123;                    right--;                &#125;            &#125;        &#125;    &#125;    return result;&#125;\n\n结果执行用时 : 36 ms, 击败 25.54% 使用 C 的用户\n内存消耗 : 7.29 MB, 击败 94.96% 使用 C 的用户\n\nC#public class Solution&#123;    public IList&lt;IList&lt;int&gt;&gt; FourSum(int[] nums, int target)    &#123;        Array.Sort(nums);        IList&lt;IList&lt;int&gt;&gt; result = new List&lt;IList&lt;int&gt;&gt;();        for (int i = 0; i &lt; nums.Length - 3; i++)        &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])                continue;            for (int j = i + 1; j &lt; nums.Length - 2; j++)            &#123;                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1])                    continue;                int left = j + 1;                int right = nums.Length - 1;                while (left &lt; right)                &#123;                    long sum = (long)nums[i] + nums[j] + nums[left] + nums[right];                    if (sum == target)                    &#123;                        result.Add(new List&lt;int&gt; &#123; nums[i], nums[j], nums[left], nums[right] &#125;);                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1])                            left++;                        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1])                            right--;                        left++;                        right--;                    &#125;                    else if (sum &lt; target)                    &#123;                        left++;                    &#125;                    else                    &#123;                        right--;                    &#125;                &#125;            &#125;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 124 ms, 击败 97.50% 使用 C# 的用户\n内存消耗 : 46.96 MB, 击败 9.38% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[][]&#125; */var fourSum = function(nums, target) &#123;    nums.sort((a, b) =&gt; a - b);    const result = [];    for (let i = 0; i &lt; nums.length - 3; i++) &#123;        if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) &#123;            continue;        &#125;        for (let j = i + 1; j &lt; nums.length - 2; j++) &#123;            if (j &gt; i + 1 &amp;&amp; nums[j] === nums[j - 1]) &#123;                continue;            &#125;            let left = j + 1;            let right = nums.length - 1;            while (left &lt; right) &#123;                const sum = nums[i] + nums[j] + nums[left] + nums[right];                if (sum === target) &#123;                    result.push([nums[i], nums[j], nums[left], nums[right]]);                    while (left &lt; right &amp;&amp; nums[left] === nums[left + 1]) &#123;                        left++;                    &#125;                    left++;                    while (left &lt; right &amp;&amp; nums[right] === nums[right - 1]) &#123;                        right--;                    &#125;                    right--;                &#125; else if (sum &lt; target) &#123;                    left++;                &#125; else &#123;                    right--;                &#125;            &#125;        &#125;    &#125;    return result;&#125;;\n\n结果执行用时 : 96 ms, 击败 34.66% 使用 JavaScript 的用户\n内存消耗 : 52.09 MB, 击败 12.46% 使用 JavaScript 的用户\n\nTypeScriptfunction fourSum(nums: number[], target: number): number[][] &#123;    nums.sort((a, b) =&gt; a - b);    const result: number[][] = [];    for (let i = 0; i &lt; nums.length - 3; i++) &#123;        if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) &#123;            continue;        &#125;        for (let j = i + 1; j &lt; nums.length - 2; j++) &#123;            if (j &gt; i + 1 &amp;&amp; nums[j] === nums[j - 1]) &#123;                continue;            &#125;            let left = j + 1;            let right = nums.length - 1;            while (left &lt; right) &#123;                const sum = nums[i] + nums[j] + nums[left] + nums[right];                if (sum === target) &#123;                    result.push([nums[i], nums[j], nums[left], nums[right]]);                    while (left &lt; right &amp;&amp; nums[left] === nums[left + 1]) &#123;                        left++;                    &#125;                    left++;                    while (left &lt; right &amp;&amp; nums[right] === nums[right - 1]) &#123;                        right--;                    &#125;                    right--;                &#125; else if (sum &lt; target) &#123;                    left++;                &#125; else &#123;                    right--;                &#125;            &#125;        &#125;    &#125;    return result;&#125;\n\n结果执行用时 : 108 ms, 击败 21.46% 使用 TypeScript 的用户\n内存消耗 : 53.43 MB, 击败 7.32% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @param Integer $target     * @return Integer[][]     */    function fourSum($nums, $target) &#123;        sort($nums);        $result = [];        $length = count($nums);        for ($i = 0; $i &lt; $length - 3; $i++) &#123;            if ($i &gt; 0 &amp;&amp; $nums[$i] == $nums[$i - 1]) &#123;                continue;            &#125;            for ($j = $i + 1; $j &lt; $length - 2; $j++) &#123;                if ($j &gt; $i + 1 &amp;&amp; $nums[$j] == $nums[$j - 1]) &#123;                    continue;                &#125;                $left = $j + 1;                $right = $length - 1;                while ($left &lt; $right) &#123;                    $sum = $nums[$i] + $nums[$j] + $nums[$left] + $nums[$right];                    if ($sum == $target) &#123;                        $result[] = [$nums[$i], $nums[$j], $nums[$left], $nums[$right]];                        while ($left &lt; $right &amp;&amp; $nums[$left] == $nums[$left + 1]) &#123;                            $left++;                        &#125;                        $left++;                        while ($left &lt; $right &amp;&amp; $nums[$right] == $nums[$right - 1]) &#123;                            $right--;                        &#125;                        $right--;                    &#125; elseif ($sum &lt; $target) &#123;                        $left++;                    &#125; else &#123;                        $right--;                    &#125;                &#125;            &#125;        &#125;        return $result;    &#125;&#125;\n\n结果执行用时 : 188 ms, 击败 25.00% 使用 PHP 的用户\n内存消耗 : 19.44 MB, 击败 12.50% 使用 PHP 的用户\n\nSwiftclass Solution &#123;  func fourSum(_ nums: [Int], _ target: Int) -&gt; [[Int]] &#123;      var result = [[Int]]()      let sortedNums = nums.sorted()      for k in 0..&lt;sortedNums.count &#123;          if k &gt; 0 &amp;&amp; sortedNums[k] == sortedNums[k - 1] &#123;              continue          &#125;          for i in (k + 1)..&lt;sortedNums.count &#123;              if i &gt; k + 1 &amp;&amp; sortedNums[i] == sortedNums[i - 1] &#123;                  continue              &#125;              var left = i + 1              var right = sortedNums.count - 1              while left &lt; right &#123;                  let sum = sortedNums[k] + sortedNums[i] + sortedNums[left] + sortedNums[right]                  if sum &lt; target &#123;                      left += 1                  &#125; else if sum &gt; target &#123;                      right -= 1                  &#125; else &#123;                      result.append([sortedNums[k], sortedNums[i], sortedNums[left], sortedNums[right]])                      while left &lt; right &amp;&amp; sortedNums[left] == sortedNums[left + 1] &#123;                          left += 1                      &#125;                      while left &lt; right &amp;&amp; sortedNums[right] == sortedNums[right - 1] &#123;                          right -= 1                      &#125;                      left += 1                      right -= 1                  &#125;              &#125;          &#125;      &#125;      return result  &#125;&#125;\n\n结果执行用时 : 24 ms, 击败 62.86% 使用 Swift 的用户\n内存消耗 : 15.23 MB, 击败 22.86% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun fourSum(nums: IntArray, target: Int): List&lt;List&lt;Int&gt;&gt; &#123;        val result = mutableListOf&lt;List&lt;Int&gt;&gt;()        val sortedNums = nums.sorted()        for (k in 0 until sortedNums.size) &#123;            if (k &gt; 0 &amp;&amp; sortedNums[k] == sortedNums[k - 1]) &#123;                continue            &#125;            for (i in k + 1 until sortedNums.size) &#123;                if (i &gt; k + 1 &amp;&amp; sortedNums[i] == sortedNums[i - 1]) &#123;                    continue                &#125;                var left = i + 1                var right = sortedNums.size - 1                while (left &lt; right) &#123;                    val sum = sortedNums[k].toLong() + sortedNums[i].toLong() + sortedNums[left].toLong() + sortedNums[right].toLong()                    when &#123;                        sum &lt; target -&gt; left++                        sum &gt; target -&gt; right--                        else -&gt; &#123;                            result.add(listOf(sortedNums[k], sortedNums[i], sortedNums[left], sortedNums[right]))                            while (left &lt; right &amp;&amp; sortedNums[left] == sortedNums[left + 1]) &#123;                                left++                            &#125;                            while (left &lt; right &amp;&amp; sortedNums[right] == sortedNums[right - 1]) &#123;                                right--                            &#125;                            left++                            right--                        &#125;                    &#125;                &#125;            &#125;        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 336 ms, 击败 11.11% 使用 Kotlin 的用户\n内存消耗 : 41.36 MB, 击败 11.11% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;List&lt;int&gt;&gt; fourSum(List&lt;int&gt; nums, int target) &#123;    List&lt;List&lt;int&gt;&gt; result = [];    if (nums == null || nums.length &lt; 4) &#123;      return result;    &#125;    nums.sort();    for (int i = 0; i &lt; nums.length - 3; i++) &#123;      if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;        continue;      &#125;      for (int j = i + 1; j &lt; nums.length - 2; j++) &#123;        if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;          continue;        &#125;        int left = j + 1;        int right = nums.length - 1;        while (left &lt; right) &#123;          int sum = nums[i] + nums[j] + nums[left] + nums[right];          if (sum == target) &#123;            result.add([nums[i], nums[j], nums[left], nums[right]]);            while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;              left++;            &#125;            left++;            while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;              right--;            &#125;            right--;          &#125; else if (sum &lt; target) &#123;            left++;          &#125; else &#123;            right--;          &#125;        &#125;      &#125;    &#125;    return result;  &#125;&#125;\n\n结果执行用时 : 448 ms, 击败 -% 使用 Dart 的用户\n内存消耗 : 153.90 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc fourSum(nums []int, target int) [][]int &#123;    var result [][]int    if len(nums) &lt; 4 &#123;        return result    &#125;    sort.Ints(nums)    for i := 0; i &lt; len(nums)-3; i++ &#123;        if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &#123;            continue        &#125;        for j := i + 1; j &lt; len(nums)-2; j++ &#123;            if j &gt; i+1 &amp;&amp; nums[j] == nums[j-1] &#123;                continue            &#125;            left, right := j+1, len(nums)-1            for left &lt; right &#123;                sum := nums[i] + nums[j] + nums[left] + nums[right]                if sum == target &#123;                    result = append(result, []int&#123;nums[i], nums[j], nums[left], nums[right]&#125;)                    for left &lt; right &amp;&amp; nums[left] == nums[left+1] &#123;                        left++                    &#125;                    left++                    for left &lt; right &amp;&amp; nums[right] == nums[right-1] &#123;                        right--                    &#125;                    right--                &#125; else if sum &lt; target &#123;                    left++                &#125; else &#123;                    right--                &#125;            &#125;        &#125;    &#125;    return result&#125;\n\n结果执行用时 : 12 ms, 击败 45.41% 使用 Go 的用户\n内存消耗 : 2.56 MB, 击败 96.90% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @param &#123;Integer&#125; target# @return &#123;Integer[][]&#125;def four_sum(nums, target)    result = []    return result if nums.length &lt; 4    nums.sort!    (0...nums.length-3).each do |i|        next if i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]        (i+1...nums.length-2).each do |j|            next if j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]            left = j + 1            right = nums.length - 1            while left &lt; right                sum = nums[i] + nums[j] + nums[left] + nums[right]                if sum == target                    result.push([nums[i], nums[j], nums[left], nums[right]])                    while left &lt; right &amp;&amp; nums[left] == nums[left + 1]                        left += 1                    end                    left += 1                    while left &lt; right &amp;&amp; nums[right] == nums[right - 1]                        right -= 1                    end                    right -= 1                elsif sum &lt; target                    left += 1                else                    right -= 1                end            end        end    end    return resultend\n\n结果执行用时 : 416 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.90 MB, 击败 20.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def fourSum(nums: Array[Int], target: Int): List[List[Int]] = &#123;    var result: List[List[Int]] = List()    if (nums.length &lt; 4) &#123;      return result    &#125;    val sortedNums = nums.sorted    for (i &lt;- 0 until sortedNums.length - 3) &#123;      if (i &gt; 0 &amp;&amp; sortedNums(i) == sortedNums(i - 1)) &#123;        ()      &#125; else &#123;        for (j &lt;- i + 1 until sortedNums.length - 2) &#123;          if (j &gt; i + 1 &amp;&amp; sortedNums(j) == sortedNums(j - 1)) &#123;            ()          &#125; else &#123;            var left = j + 1            var right = sortedNums.length - 1            while (left &lt; right) &#123;              val sum = sortedNums(i).toLong + sortedNums(j).toLong + sortedNums(left).toLong + sortedNums(right).toLong              if (sum == target) &#123;                result = result :+ List(sortedNums(i), sortedNums(j), sortedNums(left), sortedNums(right))                do &#123;                  left += 1                &#125; while (left &lt; right &amp;&amp; sortedNums(left) == sortedNums(left - 1))                do &#123;                  right -= 1                &#125; while (left &lt; right &amp;&amp; sortedNums(right) == sortedNums(right + 1))              &#125; else if (sum &lt; target) &#123;                left += 1              &#125; else &#123;                right -= 1              &#125;            &#125;          &#125;        &#125;      &#125;    &#125;    result  &#125;&#125;\n\n结果执行用时 : 604 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 55.20 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn four_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; &#123;        let mut result: Vec&lt;Vec&lt;i32&gt;&gt; = Vec::new();        if nums.len() &lt; 4 &#123;            return result;        &#125;        let mut sorted_nums = nums;        sorted_nums.sort();        for i in 0..sorted_nums.len() - 3 &#123;            if i &gt; 0 &amp;&amp; sorted_nums[i] == sorted_nums[i - 1] &#123;                continue;            &#125;            for j in i + 1..sorted_nums.len() - 2 &#123;                if j &gt; i + 1 &amp;&amp; sorted_nums[j] == sorted_nums[j - 1] &#123;                    continue;                &#125;                let mut left = j + 1;                let mut right = sorted_nums.len() - 1;                while left &lt; right &#123;                    let sum = sorted_nums[i] as i64 + sorted_nums[j] as i64 + sorted_nums[left] as i64 + sorted_nums[right] as i64;                    if sum == target as i64 &#123;                        result.push(vec![sorted_nums[i], sorted_nums[j], sorted_nums[left], sorted_nums[right]]);                        while left &lt; right &amp;&amp; sorted_nums[left] == sorted_nums[left + 1] &#123;                            left += 1;                        &#125;                        left += 1;                        while left &lt; right &amp;&amp; sorted_nums[right] == sorted_nums[right - 1] &#123;                            right -= 1;                        &#125;                        right -= 1;                    &#125; else if sum &lt; target as i64 &#123;                        left += 1;                    &#125; else &#123;                        right -= 1;                    &#125;                &#125;            &#125;        &#125;        result    &#125;&#125;\n\n结果执行用时 : 8 ms, 击败 67.74% 使用 Rust 的用户\n内存消耗 : 2.17 MB, 击败 32.26% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"冬至","url":"/zh-CN/39c7a7159eb2/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  冬至\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","冬至"]},{"title":"黑客军团 第四季 第十二集 指令","url":"/zh-CN/b105d665c113/","content":"\n剧情介绍　　向艾略特问好。\n\n","categories":["剧集"],"tags":["日常","USA Network"]},{"title":"力扣00019.删除链表的倒数第 N 个结点","url":"/zh-CN/1baff17c8f20/","content":"\n题目描述给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n示例 1：\n\n\n输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2输出：[1,2,3,5]\n\n示例 2：\n输入：head &#x3D; [1], n &#x3D; 1输出：[]\n\n示例 3：\n输入：head &#x3D; [1,2], n &#x3D; 1输出：[1]\n\n提示：\n链表中结点的数目为 sz\n1 &lt;&#x3D; sz &lt;&#x3D; 30\n0 &lt;&#x3D; Node.val &lt;&#x3D; 100\n1 &lt;&#x3D; n &lt;&#x3D; sz\n\n进阶：你能尝试使用一趟扫描实现吗？\n\n解决方法C++/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* dummy = new ListNode(0);        dummy-&gt;next = head;        ListNode* fast = dummy;        ListNode* slow = dummy;        for (int i = 0; i &lt;= n; ++i) &#123;            fast = fast-&gt;next;        &#125;        while (fast != nullptr) &#123;            slow = slow-&gt;next;            fast = fast-&gt;next;        &#125;        ListNode* toDelete = slow-&gt;next;        slow-&gt;next = slow-&gt;next-&gt;next;        delete toDelete;        return dummy-&gt;next;    &#125;&#125;;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C++ 的用户\n内存消耗 : 10.97 MB, 击败 11.94% 使用 C++ 的用户\n\nJava/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode dummy = new ListNode(0);        dummy.next = head;        ListNode fast = dummy;        ListNode slow = dummy;        for (int i = 0; i &lt;= n; i++) &#123;            fast = fast.next;        &#125;        while (fast != null) &#123;            slow = slow.next;            fast = fast.next;        &#125;        slow.next = slow.next.next;        return dummy.next;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 40.65 MB, 击败 7.23% 使用 Java 的用户\n\nPython# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution(object):    def removeNthFromEnd(self, head, n):        dummy = ListNode(0)        dummy.next = head        fast = slow = dummy        for i in range(n + 1):            fast = fast.next        while fast != None:            slow = slow.next            fast = fast.next        slow.next = slow.next.next        return dummy.next\n\n结果执行用时 : 24 ms, 击败 29.15% 使用 Python 的用户\n内存消耗 : 13.18 MB, 击败 7.92% 使用 Python 的用户\n\nPython3# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        dummy = ListNode(0)        dummy.next = head        fast = slow = dummy        for i in range(n + 1):            fast = fast.next        while fast:            slow = slow.next            fast = fast.next        slow.next = slow.next.next        return dummy.next\n\n结果执行用时 : 40 ms, 击败 81.53% 使用 Python3 的用户\n内存消耗 : 16.98 MB, 击败 8.12% 使用 Python3 的用户\n\nC/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     struct ListNode *next; * &#125;; */struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123;    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));    dummy-&gt;next = head;    struct ListNode* fast = dummy;    struct ListNode* slow = dummy;    for (int i = 0; i &lt;= n; ++i) &#123;        fast = fast-&gt;next;    &#125;    while (fast != NULL) &#123;        slow = slow-&gt;next;        fast = fast-&gt;next;    &#125;    struct ListNode* toDelete = slow-&gt;next;    slow-&gt;next = slow-&gt;next-&gt;next;    free(toDelete);    return dummy-&gt;next;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 6.30 MB, 击败 82.47% 使用 C 的用户\n\nC#/** * Definition for singly-linked list. * public class ListNode &#123; *     public int val; *     public ListNode next; *     public ListNode(int val=0, ListNode next=null) &#123; *         this.val = val; *         this.next = next; *     &#125; * &#125; */public class Solution &#123;    public ListNode RemoveNthFromEnd(ListNode head, int n) &#123;        ListNode dummy = new ListNode(0);        dummy.next = head;        ListNode fast = dummy;        ListNode slow = dummy;        for (int i = 0; i &lt;= n; i++) &#123;            fast = fast.next;        &#125;        while (fast != null) &#123;            slow = slow.next;            fast = fast.next;        &#125;        slow.next = slow.next.next;        return dummy.next;    &#125;&#125;\n\n结果执行用时 : 68 ms, 击败 85.59% 使用 C# 的用户\n内存消耗 : 40.11 MB, 击败 10.36% 使用 C# 的用户\n\nJavaScript/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; n * @return &#123;ListNode&#125; */var removeNthFromEnd = function(head, n) &#123;    let dummy = new ListNode(0);    dummy.next = head;    let fast = dummy;    let slow = dummy;    for (let i = 0; i &lt;= n; i++) &#123;        fast = fast.next;    &#125;    while (fast !== null) &#123;        slow = slow.next;        fast = fast.next;    &#125;    slow.next = slow.next.next;    return dummy.next;&#125;;\n\n结果执行用时 : 68 ms, 击败 40.96% 使用 JavaScript 的用户\n内存消耗 : 49.12 MB, 击败 7.04% 使用 JavaScript 的用户\n\nTypeScript/** * Definition for singly-linked list. * class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null &#123;    const dummy = new ListNode(0);    dummy.next = head;    let fast: ListNode | null = dummy;    let slow: ListNode | null = dummy;    for (let i = 0; i &lt;= n; i++) &#123;        if (fast !== null) &#123;            fast = fast.next;        &#125;    &#125;    while (fast !== null) &#123;        slow = slow.next;        fast = fast.next;    &#125;    if (slow !== null &amp;&amp; slow.next !== null) &#123;        slow.next = slow.next.next;    &#125;    return dummy.next;&#125;\n\n结果执行用时 : 72 ms, 击败 43.59% 使用 TypeScript 的用户\n内存消耗 : 50.61 MB, 击败 8.16% 使用 TypeScript 的用户\n\nPHP/** * Definition for a singly-linked list. * class ListNode &#123; *     public $val = 0; *     public $next = null; *     function __construct($val = 0, $next = null) &#123; *         $this-&gt;val = $val; *         $this-&gt;next = $next; *     &#125; * &#125; */class Solution &#123;    /**     * @param ListNode $head     * @param Integer $n     * @return ListNode     */    function removeNthFromEnd($head, $n) &#123;        $dummy = new ListNode(0);        $dummy-&gt;next = $head;        $fast = $dummy;        $slow = $dummy;        for ($i = 0; $i &lt;= $n; $i++) &#123;            $fast = $fast-&gt;next;        &#125;        while ($fast != null) &#123;            $slow = $slow-&gt;next;            $fast = $fast-&gt;next;        &#125;        $slow-&gt;next = $slow-&gt;next-&gt;next;        return $dummy-&gt;next;    &#125;&#125;\n\n结果执行用时 : 8 ms, 击败 58.70% 使用 PHP 的用户\n内存消耗 : 19.46 MB, 击败 6.52% 使用 PHP 的用户\n\nSwift/** * Definition for singly-linked list. * public class ListNode &#123; *     public var val: Int *     public var next: ListNode? *     public init() &#123; self.val = 0; self.next = nil; &#125; *     public init(_ val: Int) &#123; self.val = val; self.next = nil; &#125; *     public init(_ val: Int, _ next: ListNode?) &#123; self.val = val; self.next = next; &#125; * &#125; */class Solution &#123;    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -&gt; ListNode? &#123;        let dummy = ListNode(0)        dummy.next = head        var fast: ListNode? = dummy        var slow: ListNode? = dummy        for _ in 0...n &#123;            fast = fast?.next        &#125;        while fast != nil &#123;            slow = slow?.next            fast = fast?.next        &#125;        slow?.next = slow?.next?.next        return dummy.next    &#125;&#125;\n\n结果执行用时 : 4 ms, 击败 97.71% 使用 Swift 的用户\n内存消耗 : 15.30 MB, 击败 6.29% 使用 Swift 的用户\n\nKotlin/** * Example: * var li = ListNode(5) * var v = li.`val` * Definition for singly-linked list. * class ListNode(var `val`: Int) &#123; *     var next: ListNode? = null * &#125; */class Solution &#123;    fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? &#123;        val dummy = ListNode(0)        dummy.next = head        var fast: ListNode? = dummy        var slow: ListNode? = dummy        for (i in 0..n) &#123;            fast = fast?.next        &#125;        while (fast != null) &#123;            slow = slow?.next            fast = fast?.next        &#125;        slow?.next = slow?.next?.next        return dummy.next    &#125;&#125;\n\n结果执行用时 : 156 ms, 击败 88.00% 使用 Kotlin 的用户\n内存消耗 : 33.89 MB, 击败 51.00% 使用 Kotlin 的用户\n\nDart/** * Definition for singly-linked list. * class ListNode &#123; *   int val; *   ListNode? next; *   ListNode([this.val = 0, this.next]); * &#125; */class Solution &#123;  ListNode? removeNthFromEnd(ListNode? head, int n) &#123;    ListNode? dummy = ListNode(0);    dummy.next = head;    ListNode? fast = dummy;    ListNode? slow = dummy;    for (int i = 0; i &lt;= n; i++) &#123;      fast = fast!.next;    &#125;    while (fast != null) &#123;      slow = slow!.next;      fast = fast.next;    &#125;    slow!.next = slow.next!.next;    return dummy.next;  &#125;&#125;\n\n结果执行用时 : 388 ms, 击败 0.00% 使用 Dart 的用户\n内存消耗 : 148.34 MB, 击败 85.71% 使用 Dart 的用户\n\nGo/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func removeNthFromEnd(head *ListNode, n int) *ListNode &#123;\tdummy := &amp;ListNode&#123;Val: 0, Next: head&#125;\tfast, slow := dummy, dummy\tfor i := 0; i &lt;= n; i++ &#123;\t\tfast = fast.Next\t&#125;\tfor fast != nil &#123;\t\tfast = fast.Next\t\tslow = slow.Next\t&#125;\tslow.Next = slow.Next.Next\treturn dummy.Next&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.07 MB, 击败 83.45% 使用 Go 的用户\n\nRuby# Definition for singly-linked list.# class ListNode#     attr_accessor :val, :next#     def initialize(val = 0, _next = nil)#         @val = val#         @next = _next#     end# end# @param &#123;ListNode&#125; head# @param &#123;Integer&#125; n# @return &#123;ListNode&#125;def remove_nth_from_end(head, n)  dummy = ListNode.new(0)  dummy.next = head  fast = dummy  slow = dummy  (n + 1).times &#123; fast = fast.next &#125;  while fast != nil    slow = slow.next    fast = fast.next  end  slow.next = slow.next.next  return dummy.nextend\n\n结果执行用时 : 56 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.75 MB, 击败 16.67% 使用 Ruby 的用户\n\nScala/** * Definition for singly-linked list. * class ListNode(_x: Int = 0, _next: ListNode = null) &#123; *   var next: ListNode = _next *   var x: Int = _x * &#125; */object Solution &#123;  def removeNthFromEnd(head: ListNode, n: Int): ListNode = &#123;    val dummy = new ListNode()    dummy.next = head    var fast = dummy    var slow = dummy    for (i &lt;- 0 to n) &#123;      fast = fast.next    &#125;    while (fast != null) &#123;      slow = slow.next      fast = fast.next    &#125;    slow.next = slow.next.next    dummy.next  &#125;&#125;\n\n结果执行用时 : 556 ms, 击败 12.50% 使用 Scala 的用户\n内存消耗 : 56.24 MB, 击败 62.50% 使用 Scala 的用户\n\nRust// Definition for singly-linked list.// #[derive(PartialEq, Eq, Clone, Debug)]// pub struct ListNode &#123;//   pub val: i32,//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;// &#125;//// impl ListNode &#123;//   #[inline]//   fn new(val: i32) -&gt; Self &#123;//     ListNode &#123;//       next: None,//       val//     &#125;//   &#125;// &#125;impl Solution &#123;    pub fn remove_nth_from_end(head: Option&lt;Box&lt;ListNode&gt;&gt;, n: i32) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; &#123;        let mut dummy = Box::new(ListNode &#123; val: 0, next: head &#125;);        unsafe &#123;            let mut slow = &amp;mut dummy as *mut Box&lt;ListNode&gt;;            let mut fast = &amp;mut dummy as *mut Box&lt;ListNode&gt;;            for _ in 0..n &#123;                fast = (*fast).next.as_mut().unwrap();            &#125;            while (*fast).next.is_some() &#123;                fast = (*fast).next.as_mut().unwrap();                slow = (*slow).next.as_mut().unwrap();            &#125;            (*slow).next = (*slow).next.take().unwrap().next;        &#125;        dummy.next    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.14 MB, 击败 16.30% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"黑客军团 第四季 第十三集 你好，艾略特","url":"/zh-CN/34921a1d2dfb/","content":"\n剧情介绍　　再见，朋友。\n\n","categories":["剧集"],"tags":["日常","USA Network"]},{"title":"力扣00020.有效的括号","url":"/zh-CN/f6fa43793369/","content":"\n题目描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n每个右括号都有一个对应的相同类型的左括号。\n\n示例 1：\n输入：s &#x3D; “()”输出：true\n\n示例 2：\n输入：s &#x3D; “()[]{}”输出：true\n\n示例 3：\n输入：s &#x3D; “(]”输出：false\n\n提示：\n$1 &lt;&#x3D; s.length &lt;&#x3D; 10^4$\ns 仅由括号 ‘()[]{}’ 组成\n\n\n解决方法C++class Solution &#123;public:    bool isValid(string s) &#123;        stack&lt;char&gt; stack;        unordered_map&lt;char, char&gt; mapping = &#123;            &#123;&#x27;)&#x27;, &#x27;(&#x27;&#125;,            &#123;&#x27;]&#x27;, &#x27;[&#x27;&#125;,            &#123;&#x27;&#125;&#x27;, &#x27;&#123;&#x27;&#125;        &#125;;        for (char&amp; c : s) &#123;            if (mapping.find(c) != mapping.end()) &#123;                char top_element = stack.empty() ? &#x27;#&#x27; : stack.top();                stack.pop();                if (top_element != mapping[c]) &#123;                    return false;                &#125;            &#125; else &#123;                stack.push(c);            &#125;        &#125;        return stack.empty();    &#125;&#125;;\n\n结果执行用时 : 4 ms, 击败 34.94% 使用 C++ 的用户\n内存消耗 : 6.66 MB, 击败 20.29% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public boolean isValid(String s) &#123;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        HashMap&lt;Character, Character&gt; mapping = new HashMap&lt;&gt;();        mapping.put(&#x27;)&#x27;, &#x27;(&#x27;);        mapping.put(&#x27;]&#x27;, &#x27;[&#x27;);        mapping.put(&#x27;&#125;&#x27;, &#x27;&#123;&#x27;);        for (char c : s.toCharArray()) &#123;            if (mapping.containsKey(c)) &#123;                char topElement = stack.isEmpty() ? &#x27;#&#x27; : stack.pop();                if (topElement != mapping.get(c)) &#123;                    return false;                &#125;            &#125; else &#123;                stack.push(c);            &#125;        &#125;        return stack.isEmpty();    &#125;&#125;\n\n结果执行用时 : 2 ms, 击败 51.90% 使用 Java 的用户\n内存消耗 : 40.38 MB, 击败 15.69% 使用 Java 的用户\n\nPythonclass Solution(object):    def isValid(self, s):        stack = []        mapping = &#123;&#x27;)&#x27;: &#x27;(&#x27;, &#x27;&#125;&#x27;: &#x27;&#123;&#x27;, &#x27;]&#x27;: &#x27;[&#x27;&#125;        for char in s:            if char in mapping:                top_element = stack.pop() if stack else &#x27;#&#x27;                if mapping[char] != top_element:                    return False            else:                stack.append(char)        return not stack\n\n结果执行用时 : 24 ms, 击败 28.80% 使用 Python 的用户\n内存消耗 : 13.06 MB, 击败 58.31% 使用 Python 的用户\n\nPython3class Solution:    def isValid(self, s: str) -&gt; bool:        stack = []        mapping = &#123;&#x27;)&#x27;: &#x27;(&#x27;, &#x27;&#125;&#x27;: &#x27;&#123;&#x27;, &#x27;]&#x27;: &#x27;[&#x27;&#125;        for char in s:            if char in mapping:                top_element = stack.pop() if stack else &#x27;#&#x27;                if mapping[char] != top_element:                    return False            else:                stack.append(char)        return not stack\n\n结果执行用时 : 32 ms, 击败 97.63% 使用 Python3 的用户\n内存消耗 : 16.83 MB, 击败 16.72% 使用 Python3 的用户\n\nCbool isValid(char* s) &#123;    int len = strlen(s);    char stack[len];    int top = -1;    for (int i = 0; i &lt; len; i++) &#123;        if (s[i] == &#x27;(&#x27; || s[i] == &#x27;[&#x27; || s[i] == &#x27;&#123;&#x27;) &#123;            stack[++top] = s[i];        &#125; else &#123;            if (top == -1) &#123;                return false;            &#125;            char temp = stack[top--];            if ((s[i] == &#x27;)&#x27; &amp;&amp; temp != &#x27;(&#x27;) || (s[i] == &#x27;]&#x27; &amp;&amp; temp != &#x27;[&#x27;) || (s[i] == &#x27;&#125;&#x27; &amp;&amp; temp != &#x27;&#123;&#x27;)) &#123;                return false;            &#125;        &#125;    &#125;    return top == -1;&#125;\n\n结果执行用时 : 4 ms, 击败 41.72% 使用 C 的用户\n内存消耗 : 6.13 MB, 击败 89.19% 使用 C 的用户\n\nC#public class Solution &#123;    public bool IsValid(string s) &#123;        if (string.IsNullOrEmpty(s)) return true;        Stack&lt;char&gt; stack = new Stack&lt;char&gt;();        Dictionary&lt;char, char&gt; mapping = new Dictionary&lt;char, char&gt; &#123;&#123;&#x27;)&#x27;, &#x27;(&#x27;&#125;, &#123;&#x27;]&#x27;, &#x27;[&#x27;&#125;, &#123;&#x27;&#125;&#x27;, &#x27;&#123;&#x27;&#125;&#125;;        foreach (char c in s) &#123;            if (mapping.ContainsValue(c)) &#123;                stack.Push(c);            &#125; else if (mapping.TryGetValue(c, out char value)) &#123;                if (stack.Count == 0 || stack.Pop() != value) &#123;                    return false;                &#125;            &#125;        &#125;        return stack.Count == 0;    &#125;&#125;\n\n结果执行用时 : 56 ms, 击败 95.95% 使用 C# 的用户\n内存消耗 : 38.44 MB, 击败 12.55% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123;    if (s.length === 0) return true;    const stack = [];    const mapping = &#123;&#x27;)&#x27;: &#x27;(&#x27;, &#x27;]&#x27;: &#x27;[&#x27;, &#x27;&#125;&#x27;: &#x27;&#123;&#x27;&#125;;    for (let i = 0; i &lt; s.length; i++) &#123;        const char = s[i];        if (mapping[char] !== undefined) &#123;            const topElement = stack.length === 0 ? &#x27;#&#x27; : stack.pop();            if (mapping[char] !== topElement) &#123;                return false;            &#125;        &#125; else &#123;            stack.push(char);        &#125;    &#125;    return stack.length === 0;&#125;;\n\n结果执行用时 : 64 ms, 击败 71.45% 使用 JavaScript 的用户\n内存消耗 : 48.31 MB, 击败 12.49% 使用 JavaScript 的用户\n\nTypeScriptfunction isValid(s: string): boolean &#123;    if (s.length === 0) return true;    const stack: string[] = [];    const mapping: &#123; [key: string]: string &#125; = &#123;&#x27;)&#x27;: &#x27;(&#x27;, &#x27;]&#x27;: &#x27;[&#x27;, &#x27;&#125;&#x27;: &#x27;&#123;&#x27;&#125;;    for (let i = 0; i &lt; s.length; i++) &#123;        const char = s[i];        if (mapping[char] !== undefined) &#123;            const topElement = stack.length === 0 ? &#x27;#&#x27; : stack.pop()!;            if (mapping[char] !== topElement) &#123;                return false;            &#125;        &#125; else &#123;            stack.push(char);        &#125;    &#125;    return stack.length === 0;&#125;\n\n结果执行用时 : 68 ms, 击败 64.87% 使用 TypeScript 的用户\n内存消耗 : 51.40 MB, 击败 6.85% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;        /**     * @param String $s     * @return Boolean     */    function isValid($s) &#123;        if (empty($s)) return true;        $stack = [];        $mapping = [&#x27;)&#x27; =&gt; &#x27;(&#x27;, &#x27;]&#x27; =&gt; &#x27;[&#x27;, &#x27;&#125;&#x27; =&gt; &#x27;&#123;&#x27;];        for ($i = 0; $i &lt; strlen($s); $i++) &#123;            $char = $s[$i];            if (array_key_exists($char, $mapping)) &#123;                $topElement = empty($stack) ? &#x27;#&#x27; : array_pop($stack);                if ($mapping[$char] !== $topElement) &#123;                    return false;                &#125;            &#125; else &#123;                array_push($stack, $char);            &#125;        &#125;        return empty($stack);    &#125;&#125;\n\n结果执行用时 : 8 ms, 击败 63.54% 使用 PHP 的用户\n内存消耗 : 19.52 MB, 击败 6.25% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func isValid(_ s: String) -&gt; Bool &#123;        if s.isEmpty &#123;            return true        &#125;        var stack = [Character]()        let mapping: [Character: Character] = [&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;&#125;&quot;: &quot;&#123;&quot;]        for char in s &#123;            if let leftBracket = mapping[char] &#123;                if stack.isEmpty || stack.popLast() != leftBracket &#123;                    return false                &#125;            &#125; else &#123;                stack.append(char)            &#125;        &#125;        return stack.isEmpty    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Swift 的用户\n内存消耗 : 15.52 MB, 击败 5.91% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun isValid(s: String): Boolean &#123;        if (s.isEmpty()) &#123;            return true        &#125;        val stack = Stack&lt;Char&gt;()        val mapping = mapOf(&#x27;)&#x27; to &#x27;(&#x27;, &#x27;]&#x27; to &#x27;[&#x27;, &#x27;&#125;&#x27; to &#x27;&#123;&#x27;)        for (char in s) &#123;            if (mapping.containsKey(char)) &#123;                val topElement = if (stack.isEmpty()) &#x27;#&#x27; else stack.pop()                if (mapping[char] != topElement) &#123;                    return false                &#125;            &#125; else &#123;                stack.push(char)            &#125;        &#125;        return stack.isEmpty()    &#125;&#125;\n\n结果执行用时 : 148 ms, 击败 66.67% 使用 Kotlin 的用户\n内存消耗 : 33.78 MB, 击败 44.17% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  bool isValid(String s) &#123;    if (s.isEmpty) return true;    final Map&lt;String, String&gt; mapping = &#123;&#x27;)&#x27;: &#x27;(&#x27;, &#x27;]&#x27;: &#x27;[&#x27;, &#x27;&#125;&#x27;: &#x27;&#123;&#x27;&#125;;    final List&lt;String&gt; stack = [];    for (int i = 0; i &lt; s.length; i++) &#123;      String char = s[i];      if (mapping.containsKey(char)) &#123;        String topElement = stack.isEmpty ? &#x27;#&#x27; : stack.removeLast();        if (mapping[char] != topElement) &#123;          return false;        &#125;      &#125; else &#123;        stack.add(char);      &#125;    &#125;    return stack.isEmpty;  &#125;&#125;\n\n结果执行用时 : 256 ms, 击败 85.71% 使用 Dart 的用户\n内存消耗 : 147.11 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc isValid(s string) bool &#123;    if len(s) == 0 &#123;        return true    &#125;    mapping := map[rune]rune&#123;        &#x27;)&#x27;: &#x27;(&#x27;,        &#x27;]&#x27;: &#x27;[&#x27;,        &#x27;&#125;&#x27;: &#x27;&#123;&#x27;,    &#125;    stack := []rune&#123;&#125;    for _, char := range s &#123;        if val, ok := mapping[char]; ok &#123;            var topElement rune            if len(stack) == 0 &#123;                topElement = &#x27;#&#x27;            &#125; else &#123;                topElement, stack = stack[len(stack)-1], stack[:len(stack)-1]            &#125;            if val != topElement &#123;                return false            &#125;        &#125; else &#123;            stack = append(stack, char)        &#125;    &#125;    return len(stack) == 0&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 1.93 MB, 击败 16.11% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; s# @return &#123;Boolean&#125;def is_valid(s)    return true if s.empty?    mapping = &#123; &#x27;)&#x27; =&gt; &#x27;(&#x27;, &#x27;]&#x27; =&gt; &#x27;[&#x27;, &#x27;&#125;&#x27; =&gt; &#x27;&#123;&#x27; &#125;    stack = []    s.each_char do |char|        if mapping.key?(char)            top_element = stack.empty? ? &#x27;#&#x27; : stack.pop            return false if mapping[char] != top_element        else            stack.push(char)        end    end    stack.empty?end\n\n结果执行用时 : 80 ms, 击败 16.67% 使用 Ruby 的用户\n内存消耗 : 206.79 MB, 击败 8.33% 使用 Ruby 的用户\n\nScalaimport scala.collection.mutable.Stackobject Solution &#123;  def isValid(s: String): Boolean = &#123;    if (s.isEmpty) return true    val mapping = Map(&#x27;)&#x27; -&gt; &#x27;(&#x27;, &#x27;]&#x27; -&gt; &#x27;[&#x27;, &#x27;&#125;&#x27; -&gt; &#x27;&#123;&#x27;)    val stack = Stack[Char]()    for (char &lt;- s) &#123;      if (mapping.contains(char)) &#123;        val topElement = if (stack.isEmpty) &#x27;#&#x27; else stack.pop()        if (mapping(char) != topElement) &#123;          return false        &#125;      &#125; else &#123;        stack.push(char)      &#125;    &#125;    stack.isEmpty  &#125;&#125;\n\n结果执行用时 : 492 ms, 击败 28.00% 使用 Scala 的用户\n内存消耗 : 55.64 MB, 击败 84.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn is_valid(s: String) -&gt; bool &#123;        if s.is_empty() &#123;            return true;        &#125;        let mut stack = Vec::new();        let mapping: Vec&lt;(char, char)&gt; = vec![(&#x27;(&#x27;, &#x27;)&#x27;), (&#x27;[&#x27;, &#x27;]&#x27;), (&#x27;&#123;&#x27;, &#x27;&#125;&#x27;)];        for c in s.chars() &#123;            match c &#123;                &#x27;(&#x27; | &#x27;[&#x27; | &#x27;&#123;&#x27; =&gt; stack.push(c),                _ =&gt; &#123;                    if let Some(&amp;top) = stack.last() &#123;                        if let Some(&amp;(_, close)) = mapping.iter().find(|&amp;&amp;(open, _)| open == top) &#123;                            if close == c &#123;                                stack.pop();                            &#125; else &#123;                                return false;                            &#125;                        &#125; else &#123;                            return false;                        &#125;                    &#125; else &#123;                        return false;                    &#125;                &#125;            &#125;        &#125;        stack.is_empty()    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.03 MB, 击败 65.16% 使用 Rust 的用户\n\nRacket(define/contract (is-valid s)  (-&gt; string? boolean?)  (if (string=? s &quot;&quot;) #t      (let loop ((s (string-&gt;list s)) (stack &#x27;()))        (cond          ((null? s) (null? stack))          ((member (car s) &#x27;(#\\( #\\[ #\\&#123;)) (loop (cdr s) (cons (car s) stack)))          ((and (member (car s) &#x27;(#\\) #\\] #\\&#125;)) (not (null? stack)) (char=? (car s)                                                                               (cond ((char=? (car stack) #\\() #\\))                                                                                     ((char=? (car stack) #\\[) #\\])                                                                                     ((char=? (car stack) #\\&#123;) #\\&#125;)))                                                 (loop (cdr s) (cdr stack))))          (else #f)))))\n\n结果执行用时 : 188 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 98.05 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00021.合并两个有序链表","url":"/zh-CN/87f52842f77d/","content":"\n题目描述将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n示例 1：\n\n\n输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]输出：[1,1,2,3,4,4]\n\n示例 2：\n输入：l1 &#x3D; [], l2 &#x3D; []输出：[]\n\n示例 3：\n输入：l1 &#x3D; [], l2 &#x3D; [0]输出：[0]\n\n提示：\n两个链表的节点数目范围是 [0, 50]\n-100 &lt;&#x3D; Node.val &lt;&#x3D; 100\nl1 和 l2 均按 非递减顺序 排列\n\n\n解决方法C++/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;        ListNode* dummy = new ListNode(-1);        ListNode* current = dummy;        while (list1 &amp;&amp; list2) &#123;            if (list1-&gt;val &lt;= list2-&gt;val) &#123;                current-&gt;next = list1;                list1 = list1-&gt;next;            &#125; else &#123;                current-&gt;next = list2;                list2 = list2-&gt;next;            &#125;            current = current-&gt;next;        &#125;        current-&gt;next = list1 ? list1 : list2;        return dummy-&gt;next;    &#125;&#125;;\n\n结果执行用时 : 8 ms, 击败 55.64% 使用 C++ 的用户\n内存消耗 : 14.73 MB, 击败 77.93% 使用 C++ 的用户\n\nJava/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */public class Solution &#123;    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode dummy = new ListNode(-1);        ListNode current = dummy;        while (list1 != null &amp;&amp; list2 != null) &#123;            if (list1.val &lt;= list2.val) &#123;                current.next = list1;                list1 = list1.next;            &#125; else &#123;                current.next = list2;                list2 = list2.next;            &#125;            current = current.next;        &#125;        current.next = (list1 != null) ? list1 : list2;        return dummy.next;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 41.36 MB, 击败 9.94% 使用 Java 的用户\n\nPython# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution(object):    def mergeTwoLists(self, list1, list2):        dummy = ListNode(-1)        current = dummy        while list1 and list2:            if list1.val &lt;= list2.val:                current.next = list1                list1 = list1.next            else:                current.next = list2                list2 = list2.next            current = current.next        current.next = list1 if list1 else list2        return dummy.next\n\n结果执行用时 : 16 ms, 击败 94.38% 使用 Python 的用户\n内存消耗 : 12.98 MB, 击败 77.98% 使用 Python 的用户\n\nPython3# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        if not list1:            return list2        if not list2:            return list1        if list1.val &lt;= list2.val:            list1.next = self.mergeTwoLists(list1.next, list2)            return list1        else:            list2.next = self.mergeTwoLists(list1, list2.next)            return list2\n\n结果执行用时 : 48 ms, 击败 47.07% 使用 Python3 的用户\n内存消耗 : 16.86 MB, 击败 15.63% 使用 Python3 的用户\n\nC/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     struct ListNode *next; * &#125;; */struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) &#123;    struct ListNode dummy;    struct ListNode* current = &amp;dummy;    dummy.next = NULL;    while (list1 &amp;&amp; list2) &#123;        if (list1-&gt;val &lt;= list2-&gt;val) &#123;            current-&gt;next = list1;            list1 = list1-&gt;next;        &#125; else &#123;            current-&gt;next = list2;            list2 = list2-&gt;next;        &#125;        current = current-&gt;next;    &#125;    current-&gt;next = (list1 != NULL) ? list1 : list2;    return dummy.next;&#125;\n\n结果执行用时 : 4 ms, 击败 70.71% 使用 C 的用户\n内存消耗 : 6.79 MB, 击败 33.43% 使用 C 的用户\n\nC#/** * Definition for singly-linked list. * public class ListNode &#123; *     public int val; *     public ListNode next; *     public ListNode(int val=0, ListNode next=null) &#123; *         this.val = val; *         this.next = next; *     &#125; * &#125; */public class Solution &#123;    public ListNode MergeTwoLists(ListNode list1, ListNode list2) &#123;        ListNode dummy = new ListNode(-1);        ListNode current = dummy;        while (list1 != null &amp;&amp; list2 != null) &#123;            if (list1.val &lt;= list2.val) &#123;                current.next = list1;                list1 = list1.next;            &#125; else &#123;                current.next = list2;                list2 = list2.next;            &#125;            current = current.next;        &#125;        current.next = (list1 != null) ? list1 : list2;        return dummy.next;    &#125;&#125;\n\n结果执行用时 : 68 ms, 击败 87.27% 使用 C# 的用户\n内存消耗 : 40.66 MB, 击败 15.22% 使用 C# 的用户\n\nJavaScript/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; list1 * @param &#123;ListNode&#125; list2 * @return &#123;ListNode&#125; */var mergeTwoLists = function(list1, list2) &#123;    let dummy = new ListNode(-1);    let current = dummy;    while (list1 !== null &amp;&amp; list2 !== null) &#123;        if (list1.val &lt;= list2.val) &#123;            current.next = list1;            list1 = list1.next;        &#125; else &#123;            current.next = list2;            list2 = list2.next;        &#125;        current = current.next;    &#125;    current.next = list1 !== null ? list1 : list2;    return dummy.next;&#125;;\n\n结果执行用时 : 80 ms, 击败 16.68% 使用 JavaScript 的用户\n内存消耗 : 49.72 MB, 击败 13.06% 使用 JavaScript 的用户\n\nTypeScript/** * Definition for singly-linked list. * class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null &#123;    if (list1 === null) &#123;        return list2;    &#125;    if (list2 === null) &#123;        return list1;    &#125;    if (list1.val &lt;= list2.val) &#123;        list1.next = mergeTwoLists(list1.next, list2);        return list1;    &#125; else &#123;        list2.next = mergeTwoLists(list1, list2.next);        return list2;    &#125;&#125;\n\n结果执行用时 : 80 ms, 击败 28.31% 使用 TypeScript 的用户\n内存消耗 : 50.95 MB, 击败 8.20% 使用 TypeScript 的用户\n\nPHP/** * Definition for a singly-linked list. * class ListNode &#123; *     public $val = 0; *     public $next = null; *     function __construct($val = 0, $next = null) &#123; *         $this-&gt;val = $val; *         $this-&gt;next = $next; *     &#125; * &#125; */class Solution &#123;    /**     * @param ListNode $list1     * @param ListNode $list2     * @return ListNode     */    function mergeTwoLists($list1, $list2) &#123;        $dummy = new ListNode(-1);        $current = $dummy;        while ($list1 !== null &amp;&amp; $list2 !== null) &#123;            if ($list1-&gt;val &lt;= $list2-&gt;val) &#123;                $current-&gt;next = $list1;                $list1 = $list1-&gt;next;            &#125; else &#123;                $current-&gt;next = $list2;                $list2 = $list2-&gt;next;            &#125;            $current = $current-&gt;next;        &#125;        $current-&gt;next = ($list1 !== null) ? $list1 : $list2;        return $dummy-&gt;next;    &#125;&#125;\n\n结果执行用时 : 8 ms, 击败 73.13% 使用 PHP 的用户\n内存消耗 : 19.55 MB, 击败 5.97% 使用 PHP 的用户\n\nSwift/** * Definition for singly-linked list. * public class ListNode &#123; *     public var val: Int *     public var next: ListNode? *     public init() &#123; self.val = 0; self.next = nil; &#125; *     public init(_ val: Int) &#123; self.val = val; self.next = nil; &#125; *     public init(_ val: Int, _ next: ListNode?) &#123; self.val = val; self.next = next; &#125; * &#125; */class Solution &#123;    func mergeTwoLists(_ list1: ListNode?, _ list2: ListNode?) -&gt; ListNode? &#123;        guard let l1 = list1 else &#123; return list2 &#125;        guard let l2 = list2 else &#123; return list1 &#125;        if l1.val &lt; l2.val &#123;            l1.next = mergeTwoLists(l1.next, l2)            return l1        &#125; else &#123;            l2.next = mergeTwoLists(l1, l2.next)            return l2        &#125;    &#125;&#125;\n\n结果执行用时 : 16 ms, 击败 14.80% 使用 Swift 的用户\n内存消耗 : 15.41 MB, 击败 5.06% 使用 Swift 的用户\n\nKotlin/** * Example: * var li = ListNode(5) * var v = li.`val` * Definition for singly-linked list. * class ListNode(var `val`: Int) &#123; *     var next: ListNode? = null * &#125; */class Solution &#123;    fun mergeTwoLists(list1: ListNode?, list2: ListNode?): ListNode? &#123;        if (list1 == null) &#123;            return list2        &#125;        if (list2 == null) &#123;            return list1        &#125;        if (list1.`val` &lt;= list2.`val`) &#123;            list1.next = mergeTwoLists(list1.next, list2)            return list1        &#125; else &#123;            list2.next = mergeTwoLists(list1, list2.next)            return list2        &#125;    &#125;&#125;\n\n结果执行用时 : 200 ms, 击败 6.76% 使用 Kotlin 的用户\n内存消耗 : 34.70 MB, 击败 52.03% 使用 Kotlin 的用户\n\nDart/** * Definition for singly-linked list. * class ListNode &#123; *   int val; *   ListNode? next; *   ListNode([this.val = 0, this.next]); * &#125; */class Solution &#123;  ListNode? mergeTwoLists(ListNode? l1, ListNode? l2) &#123;    ListNode dummy = ListNode(0);    ListNode? current = dummy;    while (l1 != null &amp;&amp; l2 != null) &#123;      if (l1.val &lt; l2.val) &#123;        current!.next = l1;        l1 = l1.next;      &#125; else &#123;        current!.next = l2;        l2 = l2.next;      &#125;      current = current.next;    &#125;    current!.next = l1 ?? l2;    return dummy.next;  &#125;&#125;\n\n结果执行用时 : 372 ms, 击败 6.67% 使用 Dart 的用户\n内存消耗 : 147.40 MB, 击败 93.33% 使用 Dart 的用户\n\nGo/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode &#123;\tdummy := &amp;ListNode&#123;&#125;\tcurrent := dummy\tfor list1 != nil &amp;&amp; list2 != nil &#123;\t\tif list1.Val &lt;= list2.Val &#123;\t\t\tcurrent.Next = list1\t\t\tlist1 = list1.Next\t\t&#125; else &#123;\t\t\tcurrent.Next = list2\t\t\tlist2 = list2.Next\t\t&#125;\t\tcurrent = current.Next\t&#125;\tif list1 != nil &#123;\t\tcurrent.Next = list1\t&#125; else &#123;\t\tcurrent.Next = list2\t&#125;\treturn dummy.Next&#125;\n\n结果执行用时 : 4 ms, 击败 36.50% 使用 Go 的用户\n内存消耗 : 2.35 MB, 击败 60.06% 使用 Go 的用户\n\nRuby# Definition for singly-linked list.# class ListNode#     attr_accessor :val, :next#     def initialize(val = 0, _next = nil)#         @val = val#         @next = _next#     end# end# @param &#123;ListNode&#125; list1# @param &#123;ListNode&#125; list2# @return &#123;ListNode&#125;def merge_two_lists(list1, list2)  dummy = ListNode.new(-1)  current = dummy  while list1 &amp;&amp; list2    if list1.val &lt;= list2.val      current.next = list1      list1 = list1.next    else      current.next = list2      list2 = list2.next    end    current = current.next  end  current.next = list1 || list2  dummy.nextend\n\n结果执行用时 : 56 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.81 MB, 击败 22.22% 使用 Ruby 的用户\n\nScala/** * Definition for singly-linked list. * class ListNode(_x: Int = 0, _next: ListNode = null) &#123; *   var next: ListNode = _next *   var x: Int = _x * &#125; */object Solution &#123;  def mergeTwoLists(list1: ListNode, list2: ListNode): ListNode = &#123;    if (list1 == null) &#123;      return list2    &#125;    if (list2 == null) &#123;      return list1    &#125;    if (list1.x &lt;= list2.x) &#123;      list1.next = mergeTwoLists(list1.next, list2)      return list1    &#125; else &#123;      list2.next = mergeTwoLists(list1, list2.next)      return list2    &#125;  &#125;&#125;\n\n结果执行用时 : 488 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 56.16 MB, 击败 94.12% 使用 Scala 的用户\n\nRust// Definition for singly-linked list.// #[derive(PartialEq, Eq, Clone, Debug)]// pub struct ListNode &#123;//   pub val: i32,//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;// &#125;//// impl ListNode &#123;//   #[inline]//   fn new(val: i32) -&gt; Self &#123;//     ListNode &#123;//       next: None,//       val//     &#125;//   &#125;// &#125;impl Solution &#123;    pub fn merge_two_lists(mut list1: Option&lt;Box&lt;ListNode&gt;&gt;, mut list2: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; &#123;        let mut dummy = Some(Box::new(ListNode &#123; val: 0, next: None &#125;));        let mut current = &amp;mut dummy;        while let (Some(node1), Some(node2)) = (list1.as_deref_mut(), list2.as_deref_mut()) &#123;            if node1.val &lt;= node2.val &#123;                current.as_mut().unwrap().next = list1.take();                list1 = current.as_mut().unwrap().next.as_deref_mut().unwrap().next.take();            &#125; else &#123;                current.as_mut().unwrap().next = list2.take();                list2 = current.as_mut().unwrap().next.as_deref_mut().unwrap().next.take();            &#125;            current = &amp;mut current.as_mut().unwrap().next;        &#125;        current.as_mut().unwrap().next = list1.or(list2);        dummy.unwrap().next    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.04 MB, 击败 56.83% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang%% Definition for singly-linked list.%%%% -record(list_node, &#123;val = 0 :: integer(),%%                     next = null :: &#x27;null&#x27; | #list_node&#123;&#125;&#125;).merge_two_lists(List1, List2) -&gt;    case &#123;List1, List2&#125; of        &#123;null, List2&#125; -&gt; List2;        &#123;List1, null&#125; -&gt; List1;        &#123;Node1 = #list_node&#123;val = Val1, next = Next1&#125;, Node2 = #list_node&#123;val = Val2, next = Next2&#125;&#125; -&gt;            if Val1 =&lt; Val2 -&gt;                Node1#list_node&#123;next = merge_two_lists(Next1, Node2)&#125;;            true -&gt;                Node2#list_node&#123;next = merge_two_lists(Node1, Next2)&#125;            end    end.\n\n结果执行用时 : 268 ms, 击败 -% 使用 Erlang 的用户\n内存消耗 : 59.08 MB, 击败 -% 使用 Erlang 的用户\n\nElixir# Definition for singly-linked list.## defmodule ListNode do#   @type t :: %__MODULE__&#123;#           val: integer,#           next: ListNode.t() | nil#         &#125;#   defstruct val: 0, next: nil# enddefmodule Solution do  @spec merge_two_lists(list1 :: ListNode.t | nil, list2 :: ListNode.t | nil) :: ListNode.t | nil  def merge_two_lists(nil, list2), do: list2  def merge_two_lists(list1, nil), do: list1  def merge_two_lists(%ListNode&#123;val: val1, next: next1&#125; = list1, %ListNode&#123;val: val2, next: next2&#125; = list2) do    if val1 &lt;= val2 do      %ListNode&#123;val: val1, next: merge_two_lists(next1, list2)&#125;    else      %ListNode&#123;val: val2, next: merge_two_lists(list1, next2)&#125;    end  endend\n\n结果执行用时 : 344 ms, 击败 -% 使用 Elixir 的用户\n内存消耗 : 67.86 MB, 击败 -% 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00022.括号生成","url":"/zh-CN/5455ee7e9622/","content":"\n题目描述数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n示例 1：\n输入：n &#x3D; 3输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]\n\n示例 2：\n输入：n &#x3D; 1输出：[“()”]\n\n提示：\n1 &lt;&#x3D; n &lt;&#x3D; 8\n\n\n解决方法C++class Solution &#123;public:    vector&lt;std::string&gt; generateParenthesis(int n) &#123;        vector&lt;string&gt; result;        generate(&quot;&quot;, n, n, result);        return result;    &#125;private:    void generate(string current, int left, int right, vector&lt;string&gt;&amp; result) &#123;        if (left == 0 &amp;&amp; right == 0) &#123;            result.push_back(current);            return;        &#125;        if (left &gt; 0) &#123;            generate(current + &#x27;(&#x27;, left - 1, right, result);        &#125;        if (right &gt; left) &#123;            generate(current + &#x27;)&#x27;, left, right - 1, result);        &#125;    &#125;&#125;;\n\n结果执行用时 : 4 ms, 击败 70.78% 使用 C++ 的用户\n内存消耗 : 15.12 MB, 击败 31.77% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public List&lt;String&gt; generateParenthesis(int n) &#123;        List&lt;String&gt; result = new ArrayList&lt;&gt;();        generate(&quot;&quot;, n, n, result);        return result;    &#125;    private void generate(String current, int left, int right, List&lt;String&gt; result) &#123;        if (left == 0 &amp;&amp; right == 0) &#123;            result.add(current);            return;        &#125;        if (left &gt; 0) &#123;            generate(current + &#x27;(&#x27;, left - 1, right, result);        &#125;        if (right &gt; left) &#123;            generate(current + &#x27;)&#x27;, left, right - 1, result);        &#125;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 71.45% 使用 Java 的用户\n内存消耗 : 42.19 MB, 击败 31.97% 使用 Java 的用户\n\nPythonclass Solution(object):    def generateParenthesis(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: List[str]        &quot;&quot;&quot;        def generate(current, left, right, result):            if left == 0 and right == 0:                result.append(current)                return            if left &gt; 0:                generate(current + &#x27;(&#x27;, left - 1, right, result)            if right &gt; left:                generate(current + &#x27;)&#x27;, left, right - 1, result)        result = []        generate(&quot;&quot;, n, n, result)        return result\n\n结果执行用时 : 20 ms, 击败 61.89% 使用 Python 的用户\n内存消耗 : 13.23 MB, 击败 66.19% 使用 Python 的用户\n\nPython3class Solution:    def generateParenthesis(self, n: int) -&gt; List[str]:        def generate(current, left, right, result):            if left == 0 and right == 0:                result.append(current)                return            if left &gt; 0:                generate(current + &#x27;(&#x27;, left - 1, right, result)            if right &gt; left:                generate(current + &#x27;)&#x27;, left, right - 1, result)        result = []        generate(&quot;&quot;, n, n, result)        return result\n\n结果执行用时 : 24 ms, 击败 99.93% 使用 Python3 的用户\n内存消耗 : 17.18 MB, 击败 13.63% 使用 Python3 的用户\n\nC/** * Note: The returned array must be malloced, assume caller calls free(). */void backTarck(int n, int *returnSize, char **returnStr, int leftNum, int rightNum, char *stack, int top) &#123;    if ((rightNum + leftNum) &gt;= 2 * n) &#123;         // 当前长度已达2n        stack[top] = &#x27;\\0&#x27;;        returnStr[*returnSize] = (char*)malloc(sizeof(char) * (top + 1));        strcpy(returnStr[*returnSize], stack);        (*returnSize)++;        return;    &#125;    if (leftNum &lt; n) &#123;        stack[top] = &#x27;(&#x27;;        backTarck(n, returnSize, returnStr, leftNum + 1, rightNum, stack, top + 1);    &#125;    if (rightNum &lt; leftNum) &#123;        stack[top] = &#x27;)&#x27;;        backTarck(n, returnSize, returnStr, leftNum, rightNum + 1, stack, top + 1);    &#125;&#125;char** generateParenthesis(int n, int *returnSize) &#123;    char **returnStr = (char **)malloc(sizeof(char *) * 2000);    char *stack = (char *)malloc(sizeof(char) * (n * 2 + 1));    *returnSize = 0;    backTarck(n, returnSize, returnStr, 0, 0, stack, 0);    return returnStr;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 7.05 MB, 击败 72.42% 使用 C 的用户\n\nC#public class Solution &#123;    public IList&lt;string&gt; GenerateParenthesis(int n) &#123;        IList&lt;string&gt; result = new List&lt;string&gt;();        Generate(result, &quot;&quot;, 0, 0, n);        return result;    &#125;    private void Generate(IList&lt;string&gt; result, string current, int left, int right, int n) &#123;        if (current.Length == 2 * n) &#123;            result.Add(current);            return;        &#125;        if (left &lt; n) &#123;            Generate(result, current + &#x27;(&#x27;, left + 1, right, n);        &#125;        if (right &lt; left) &#123;            Generate(result, current + &#x27;)&#x27;, left, right + 1, n);        &#125;    &#125;&#125;\n\n结果执行用时 : 84 ms, 击败 98.27% 使用 C# 的用户\n内存消耗 : 48.10 MB, 击败 12.14% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number&#125; n * @return &#123;string[]&#125; */var generateParenthesis = function(n) &#123;    let result = [];    function generate(current, left, right) &#123;        if (current.length === 2 * n) &#123;            result.push(current);            return;        &#125;        if (left &lt; n) &#123;            generate(current + &#x27;(&#x27;, left + 1, right);        &#125;        if (right &lt; left) &#123;            generate(current + &#x27;)&#x27;, left, right + 1);        &#125;    &#125;    generate(&#x27;&#x27;, 0, 0);    return result;&#125;;\n\n结果执行用时 : 68 ms, 击败 33.89% 使用 JavaScript 的用户\n内存消耗 : 49.30 MB, 击败 9.30% 使用 JavaScript 的用户\n\nTypeScriptfunction generateParenthesis(n: number): string[] &#123;    const result: string[] = [];    function generate(current: string, left: number, right: number): void &#123;        if (current.length === 2 * n) &#123;            result.push(current);            return;        &#125;        if (left &lt; n) &#123;            generate(current + &#x27;(&#x27;, left + 1, right);        &#125;        if (right &lt; left) &#123;            generate(current + &#x27;)&#x27;, left, right + 1);        &#125;    &#125;    generate(&#x27;&#x27;, 0, 0);    return result;&#125;\n\n结果执行用时 : 84 ms, 击败 13.04% 使用 TypeScript 的用户\n内存消耗 : 50.48 MB, 击败 9.88% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer $n     * @return String[]     */    function generateParenthesis($n) &#123;        $result = [];        $this-&gt;backtrack(&#x27;&#x27;, 0, 0, $n, $result);        return $result;    &#125;    function backtrack($current, $left, $right, $n, &amp;$result) &#123;        if (strlen($current) === 2 * $n) &#123;            array_push($result, $current);            return;        &#125;        if ($left &lt; $n) &#123;            $this-&gt;backtrack($current . &#x27;(&#x27;, $left + 1, $right, $n, $result);        &#125;        if ($right &lt; $left) &#123;            $this-&gt;backtrack($current . &#x27;)&#x27;, $left, $right + 1, $n, $result);        &#125;    &#125;&#125;\n\n结果执行用时 : 12 ms, 击败 25.00% 使用 PHP 的用户\n内存消耗 : 19.68 MB, 击败 18.75% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func generateParenthesis(_ n: Int) -&gt; [String] &#123;        var result: [String] = []        backtrack(&quot;&quot;, 0, 0, n, &amp;result)        return result    &#125;    func backtrack(_ current: String, _ left: Int, _ right: Int, _ n: Int, _ result: inout [String]) &#123;        if current.count == 2 * n &#123;            result.append(current)            return        &#125;        if left &lt; n &#123;            backtrack(current + &quot;(&quot;, left + 1, right, n, &amp;result)        &#125;        if right &lt; left &#123;            backtrack(current + &quot;)&quot;, left, right + 1, n, &amp;result)        &#125;    &#125;&#125;\n\n结果执行用时 : 24 ms, 击败 8.82% 使用 Swift 的用户\n内存消耗 : 15.61 MB, 击败 7.84% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun generateParenthesis(n: Int): List&lt;String&gt; &#123;        val result: MutableList&lt;String&gt; = mutableListOf()        backtrack(&quot;&quot;, 0, 0, n, result)        return result    &#125;    private fun backtrack(current: String, left: Int, right: Int, n: Int, result: MutableList&lt;String&gt;) &#123;        if (current.length == 2 * n) &#123;            result.add(current)            return        &#125;        if (left &lt; n) &#123;            backtrack(&quot;$current(&quot;, left + 1, right, n, result)        &#125;        if (right &lt; left) &#123;            backtrack(&quot;$current)&quot;, left, right + 1, n, result)        &#125;    &#125;&#125;\n\n结果执行用时 : 204 ms, 击败 15.38% 使用 Kotlin 的用户\n内存消耗 : 36.29 MB, 击败 75.38% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;String&gt; generateParenthesis(int n) &#123;    List&lt;String&gt; result = [];    _backtrack(&#x27;&#x27;, 0, 0, n, result);    return result;  &#125;  void _backtrack(String current, int left, int right, int n, List&lt;String&gt; result) &#123;    if (current.length == 2 * n) &#123;      result.add(current);      return;    &#125;    if (left &lt; n) &#123;      _backtrack(&#x27;$current(&#x27;, left + 1, right, n, result);    &#125;    if (right &lt; left) &#123;      _backtrack(&#x27;$current)&#x27;, left, right + 1, n, result);    &#125;  &#125;&#125;\n\n结果执行用时 : 288 ms, 击败 50.00% 使用 Dart 的用户\n内存消耗 : 147.64 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc generateParenthesis(n int) []string &#123;\tvar result []string\tbacktrack(&quot;&quot;, 0, 0, n, &amp;result)\treturn result&#125;func backtrack(current string, left int, right int, n int, result *[]string) &#123;\tif len(current) == 2*n &#123;\t\t*result = append(*result, current)\t\treturn\t&#125;\tif left &lt; n &#123;\t\tbacktrack(current+&quot;(&quot;, left+1, right, n, result)\t&#125;\tif right &lt; left &#123;\t\tbacktrack(current+&quot;)&quot;, left, right+1, n, result)\t&#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.61 MB, 击败 62.59% 使用 Go 的用户\n\nRuby# @param &#123;Integer&#125; n# @return &#123;String[]&#125;def generate_parenthesis(n)  result = []  backtrack(&#x27;&#x27;, 0, 0, n, result)  resultenddef backtrack(current, left, right, n, result)  if current.length == 2 * n    result &lt;&lt; current    return  end  if left &lt; n    backtrack(current + &#x27;(&#x27;, left + 1, right, n, result)  end  if right &lt; left    backtrack(current + &#x27;)&#x27;, left, right + 1, n, result)  endend\n\n结果执行用时 : 48 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.92 MB, 击败 12.50% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def generateParenthesis(n: Int): List[String] = &#123;    var result: List[String] = List()    def backtrack(current: String, left: Int, right: Int): Unit = &#123;      if (current.length == 2 * n) &#123;        result = current :: result        return      &#125;      if (left &lt; n) &#123;        backtrack(current + &quot;(&quot;, left + 1, right)      &#125;      if (right &lt; left) &#123;        backtrack(current + &quot;)&quot;, left, right + 1)      &#125;    &#125;    backtrack(&quot;&quot;, 0, 0)    result  &#125;&#125;\n\n结果执行用时 : 452 ms, 击败 -% 使用 Scala 的用户\n内存消耗 : 52.77 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn generate_parenthesis(n: i32) -&gt; Vec&lt;String&gt; &#123;        let mut result = Vec::new();        Self::backtrack(String::new(), 0, 0, n, &amp;mut result);        result    &#125;    fn backtrack(current: String, left: i32, right: i32, n: i32, result: &amp;mut Vec&lt;String&gt;) &#123;        if current.len() as i32 == 2 * n &#123;            result.push(current);            return;        &#125;        if left &lt; n &#123;            let mut new_current = current.clone();            new_current.push(&#x27;(&#x27;);            Self::backtrack(new_current, left + 1, right, n, result);        &#125;        if right &lt; left &#123;            let mut new_current = current.clone();            new_current.push(&#x27;)&#x27;);            Self::backtrack(new_current, left, right + 1, n, result);        &#125;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.31 MB, 击败 18.09% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"曼达洛人 第一季 第八集 救赎","url":"/zh-CN/5abd1f2b862c/","content":"\n剧情介绍　　曼达洛人意外面对一名出乎意料的敌人。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"力扣00023.合并 K 个升序链表","url":"/zh-CN/3c6e9a69b6fb/","content":"\n题目描述给你一个链表数组，每个链表都已经按升序排列。\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n示例 1：\n输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n\n示例 2：\n输入：lists &#x3D; []输出：[]\n\n示例 3：\n输入：lists &#x3D; [[]]输出：[]\n\n提示：\nk &#x3D;&#x3D; lists.length\n$0 &lt;&#x3D; k &lt;&#x3D; 10^4$\n0 &lt;&#x3D; lists[i].length &lt;&#x3D; 500\n$-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4$\nlists[i] 按 升序 排列\n$lists[i].length 的总和不超过 10^4$\n\n\n解决方法C++/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* mergeKLists(std::vector&lt;ListNode*&gt;&amp; lists) &#123;        if (lists.empty()) &#123;            return nullptr;        &#125;        return mergeLists(lists, 0, lists.size() - 1);    &#125;private:    ListNode* mergeLists(std::vector&lt;ListNode*&gt;&amp; lists, int left, int right) &#123;        if (left == right) &#123;            return lists[left];        &#125;        int mid = left + (right - left) / 2;        ListNode* l1 = mergeLists(lists, left, mid);        ListNode* l2 = mergeLists(lists, mid + 1, right);        return mergeTwoLists(l1, l2);    &#125;    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        if (!l1) &#123;            return l2;        &#125;        if (!l2) &#123;            return l1;        &#125;        if (l1-&gt;val &lt; l2-&gt;val) &#123;            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);            return l1;        &#125; else &#123;            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);            return l2;        &#125;    &#125;&#125;;\n\n结果执行用时 : 14 ms, 击败 89.11% 使用 C++ 的用户\n内存消耗 : 16.66 MB, 击败 14.97% 使用 C++ 的用户\n\nJava/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */public class Solution &#123;    public ListNode mergeKLists(ListNode[] lists) &#123;        if (lists == null || lists.length == 0) &#123;            return null;        &#125;        return mergeLists(lists, 0, lists.length - 1);    &#125;    private ListNode mergeLists(ListNode[] lists, int left, int right) &#123;        if (left == right) &#123;            return lists[left];        &#125;        int mid = left + (right - left) / 2;        ListNode l1 = mergeLists(lists, left, mid);        ListNode l2 = mergeLists(lists, mid + 1, right);        return mergeTwoLists(l1, l2);    &#125;    private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;        if (l1 == null) &#123;            return l2;        &#125;        if (l2 == null) &#123;            return l1;        &#125;        if (l1.val &lt; l2.val) &#123;            l1.next = mergeTwoLists(l1.next, l2);            return l1;        &#125; else &#123;            l2.next = mergeTwoLists(l1, l2.next);            return l2;        &#125;    &#125;&#125;\n\n结果执行用时 : 2 ms, 击败 79.3% 使用 Java 的用户\n内存消耗 : 43.41 MB, 击败 14.48% 使用 Java 的用户\n\nPython# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def mergeKLists(self, lists):        if not lists:            return None        return self.merge_lists(lists, 0, len(lists) - 1)    def merge_lists(self, lists, left, right):        if left == right:            return lists[left]        mid = left + (right - left) // 2        l1 = self.merge_lists(lists, left, mid)        l2 = self.merge_lists(lists, mid + 1, right)        return self.merge_two_lists(l1, l2)    def merge_two_lists(self, l1, l2):        if not l1:            return l2        if not l2:            return l1        if l1.val &lt; l2.val:            l1.next = self.merge_two_lists(l1.next, l2)            return l1        else:            l2.next = self.merge_two_lists(l1, l2.next)            return l2\n\n结果执行用时 : 98 ms, 击败 35.65% 使用 Python 的用户\n内存消耗 : 23.25 MB, 击败 12.82% 使用 Python 的用户\n\nPython3# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def mergeKLists(self, lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:        if not lists:            return None        return self.merge_lists(lists, 0, len(lists) - 1)    def merge_lists(self, lists: List[Optional[ListNode]], left: int, right: int) -&gt; Optional[ListNode]:        if left == right:            return lists[left]        mid = left + (right - left) // 2        l1 = self.merge_lists(lists, left, mid)        l2 = self.merge_lists(lists, mid + 1, right)        return self.merge_two_lists(l1, l2)    def merge_two_lists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:        if not l1:            return l2        if not l2:            return l1        if l1.val &lt; l2.val:            l1.next = self.merge_two_lists(l1.next, l2)            return l1        else:            l2.next = self.merge_two_lists(l1, l2.next)            return l2\n\n结果执行用时 : 65 ms, 击败 76.55% 使用 Python3 的用户\n内存消耗 : 20.19 MB, 击败 17.06% 使用 Python3 的用户\n\nC/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     struct ListNode *next; * &#125;; */struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;    if (!l1) &#123;        return l2;    &#125;    if (!l2) &#123;        return l1;    &#125;    if (l1-&gt;val &lt; l2-&gt;val) &#123;        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);        return l1;    &#125; else &#123;        l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);        return l2;    &#125;&#125;struct ListNode* mergeKLists(struct ListNode** lists, int listsSize) &#123;    if (listsSize == 0) &#123;        return NULL;    &#125;    if (listsSize == 1) &#123;        return lists[0];    &#125;    int mid = listsSize / 2;    struct ListNode* l1 = mergeKLists(lists, mid);    struct ListNode* l2 = mergeKLists(lists + mid, listsSize - mid);    return mergeTwoLists(l1, l2);&#125;\n\n结果执行用时 : 10 ms, 击败 97.55% 使用 C 的用户\n内存消耗 : 8.04 MB, 击败 98.02% 使用 C 的用户\n\nC#/** * Definition for singly-linked list. * public class ListNode &#123; *     public int val; *     public ListNode next; *     public ListNode(int val=0, ListNode next=null) &#123; *         this.val = val; *         this.next = next; *     &#125; * &#125; */public class Solution &#123;    public ListNode MergeKLists(ListNode[] lists) &#123;        if (lists == null || lists.Length == 0) &#123;            return null;        &#125;        return MergeLists(lists, 0, lists.Length - 1);    &#125;    private ListNode MergeLists(ListNode[] lists, int left, int right) &#123;        if (left == right) &#123;            return lists[left];        &#125;        int mid = left + (right - left) / 2;        ListNode l1 = MergeLists(lists, left, mid);        ListNode l2 = MergeLists(lists, mid + 1, right);        return MergeTwoLists(l1, l2);    &#125;    private ListNode MergeTwoLists(ListNode l1, ListNode l2) &#123;        if (l1 == null) &#123;            return l2;        &#125;        if (l2 == null) &#123;            return l1;        &#125;        if (l1.val &lt; l2.val) &#123;            l1.next = MergeTwoLists(l1.next, l2);            return l1;        &#125; else &#123;            l2.next = MergeTwoLists(l1, l2.next);            return l2;        &#125;    &#125;&#125;\n\n结果执行用时 : 73 ms, 击败 98.76% 使用 C# 的用户\n内存消耗 : 46.32 MB, 击败 7.46% 使用 C# 的用户\n\nJavaScript/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode[]&#125; lists * @return &#123;ListNode&#125; */var mergeKLists = function(lists) &#123;    if (!lists || lists.length === 0) &#123;        return null;    &#125;    return mergeLists(lists, 0, lists.length - 1);&#125;;var mergeLists = function(lists, left, right) &#123;    if (left === right) &#123;        return lists[left];    &#125;    var mid = left + Math.floor((right - left) / 2);    var l1 = mergeLists(lists, left, mid);    var l2 = mergeLists(lists, mid + 1, right);    return mergeTwoLists(l1, l2);&#125;;var mergeTwoLists = function(l1, l2) &#123;    if (!l1) &#123;        return l2;    &#125;    if (!l2) &#123;        return l1;    &#125;    if (l1.val &lt; l2.val) &#123;        l1.next = mergeTwoLists(l1.next, l2);        return l1;    &#125; else &#123;        l2.next = mergeTwoLists(l1, l2.next);        return l2;    &#125;&#125;;\n\n结果执行用时 : 77 ms, 击败 92.51% 使用 JavaScript 的用户\n内存消耗 : 55.14 MB, 击败 11.95% 使用 JavaScript 的用户\n\nTypeScript/** * Definition for singly-linked list. * class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */function mergeKLists(lists: Array&lt;ListNode | null&gt;): ListNode | null &#123;    if (!lists || lists.length === 0) &#123;        return null;    &#125;    return mergeLists(lists, 0, lists.length - 1);&#125;function mergeLists(lists: Array&lt;ListNode | null&gt;, left: number, right: number): ListNode | null &#123;    if (left === right) &#123;        return lists[left];    &#125;    const mid = left + Math.floor((right - left) / 2);    const l1 = mergeLists(lists, left, mid);    const l2 = mergeLists(lists, mid + 1, right);    return mergeTwoLists(l1, l2);&#125;function mergeTwoLists(l1: ListNode | null, l2: ListNode | null): ListNode | null &#123;    if (!l1) &#123;        return l2;    &#125;    if (!l2) &#123;        return l1;    &#125;    if (l1.val &lt; l2.val) &#123;        l1.next = mergeTwoLists(l1.next, l2);        return l1;    &#125; else &#123;        l2.next = mergeTwoLists(l1, l2.next);        return l2;    &#125;&#125;\n\n结果执行用时 : 84 ms, 击败 95.94% 使用 TypeScript 的用户\n内存消耗 : 56.80 MB, 击败 10.66% 使用 TypeScript 的用户\n\nPHP/** * Definition for a singly-linked list. * class ListNode &#123; *     public $val = 0; *     public $next = null; *     function __construct($val = 0, $next = null) &#123; *         $this-&gt;val = $val; *         $this-&gt;next = $next; *     &#125; * &#125; */class Solution &#123;    /**     * @param ListNode[] $lists     * @return ListNode     */    function mergeKLists($lists) &#123;        if (empty($lists)) &#123;            return null;        &#125;        return $this-&gt;mergeLists($lists, 0, count($lists) - 1);    &#125;    private function mergeLists($lists, $left, $right) &#123;        if ($left == $right) &#123;            return $lists[$left];        &#125;        $mid = $left + intdiv($right - $left, 2);        $l1 = $this-&gt;mergeLists($lists, $left, $mid);        $l2 = $this-&gt;mergeLists($lists, $mid + 1, $right);        return $this-&gt;mergeTwoLists($l1, $l2);    &#125;    private function mergeTwoLists($l1, $l2) &#123;        if (!$l1) &#123;            return $l2;        &#125;        if (!$l2) &#123;            return $l1;        &#125;        if ($l1-&gt;val &lt; $l2-&gt;val) &#123;            $l1-&gt;next = $this-&gt;mergeTwoLists($l1-&gt;next, $l2);            return $l1;        &#125; else &#123;            $l2-&gt;next = $this-&gt;mergeTwoLists($l1, $l2-&gt;next);            return $l2;        &#125;    &#125;&#125;\n\n结果执行用时 : 21 ms, 击败 100.00% 使用 PHP 的用户\n内存消耗 : 26.56 MB, 击败 27.27% 使用 PHP 的用户\n\nSwift/** * Definition for singly-linked list. * public class ListNode &#123; *     public var val: Int *     public var next: ListNode? *     public init() &#123; self.val = 0; self.next = nil; &#125; *     public init(_ val: Int) &#123; self.val = val; self.next = nil; &#125; *     public init(_ val: Int, _ next: ListNode?) &#123; self.val = val; self.next = next; &#125; * &#125; */class Solution &#123;    func mergeKLists(_ lists: [ListNode?]) -&gt; ListNode? &#123;        if lists.isEmpty &#123;            return nil        &#125;        return mergeLists(lists, 0, lists.count - 1)    &#125;    private func mergeLists(_ lists: [ListNode?], _ left: Int, _ right: Int) -&gt; ListNode? &#123;        if left == right &#123;            return lists[left]        &#125;        let mid = left + (right - left) / 2        let l1 = mergeLists(lists, left, mid)        let l2 = mergeLists(lists, mid + 1, right)        return mergeTwoLists(l1, l2)    &#125;    private func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;        guard let l1 = l1 else &#123;            return l2        &#125;        guard let l2 = l2 else &#123;            return l1        &#125;        if l1.val &lt; l2.val &#123;            l1.next = mergeTwoLists(l1.next, l2)            return l1        &#125; else &#123;            l2.next = mergeTwoLists(l1, l2.next)            return l2        &#125;    &#125;&#125;\n\n结果执行用时 : 65 ms, 击败 77.22% 使用 Swift 的用户\n内存消耗 : 16.79 MB, 击败 5.06% 使用 Swift 的用户\n\nKotlin/** * Example: * var li = ListNode(5) * var v = li.`val` * Definition for singly-linked list. * class ListNode(var `val`: Int) &#123; *     var next: ListNode? = null * &#125; */class Solution &#123;    fun mergeKLists(lists: Array&lt;ListNode?&gt;): ListNode? &#123;        if (lists.isEmpty()) &#123;            return null        &#125;        return mergeLists(lists, 0, lists.size - 1)    &#125;    private fun mergeLists(lists: Array&lt;ListNode?&gt;, left: Int, right: Int): ListNode? &#123;        if (left == right) &#123;            return lists[left]        &#125;        val mid = left + (right - left) / 2        val l1 = mergeLists(lists, left, mid)        val l2 = mergeLists(lists, mid + 1, right)        return mergeTwoLists(l1, l2)    &#125;    private fun mergeTwoLists(l1: ListNode?, l2: ListNode?): ListNode? &#123;        if (l1 == null) &#123;            return l2        &#125;        if (l2 == null) &#123;            return l1        &#125;        return if (l1.`val` &lt; l2.`val`) &#123;            l1.next = mergeTwoLists(l1.next, l2)            l1        &#125; else &#123;            l2.next = mergeTwoLists(l1, l2.next)            l2        &#125;    &#125;&#125;\n\n结果执行用时 : 191 ms, 击败 98.00% 使用 Kotlin 的用户\n内存消耗 : 37.37 MB, 击败 98.00% 使用 Kotlin 的用户\n\nDart/** * Definition for singly-linked list. * class ListNode &#123; *   int val; *   ListNode? next; *   ListNode([this.val = 0, this.next]); * &#125; */class Solution &#123;  ListNode? mergeKLists(List&lt;ListNode?&gt; lists) &#123;    if (lists.isEmpty) &#123;      return null;    &#125;    return mergeLists(lists, 0, lists.length - 1);  &#125;  ListNode? mergeLists(List&lt;ListNode?&gt; lists, int left, int right) &#123;    if (left == right) &#123;      return lists[left];    &#125;    int mid = left + ((right - left) ~/ 2);    ListNode? l1 = mergeLists(lists, left, mid);    ListNode? l2 = mergeLists(lists, mid + 1, right);    return mergeTwoLists(l1, l2);  &#125;  ListNode? mergeTwoLists(ListNode? l1, ListNode? l2) &#123;    if (l1 == null) &#123;      return l2;    &#125;    if (l2 == null) &#123;      return l1;    &#125;    if (l1.val &lt; l2.val) &#123;      l1.next = mergeTwoLists(l1.next, l2);      return l1;    &#125; else &#123;      l2.next = mergeTwoLists(l1, l2.next);      return l2;    &#125;  &#125;&#125;\n\n结果执行用时 : 341 ms, 击败 71.43% 使用 Dart 的用户\n内存消耗 : 149.57 MB, 击败 57.14% 使用 Dart 的用户\n\nGo/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func mergeKLists(lists []*ListNode) *ListNode &#123;    if len(lists) == 0 &#123;        return nil    &#125;    return mergeLists(lists, 0, len(lists)-1)&#125;func mergeLists(lists []*ListNode, left int, right int) *ListNode &#123;    if left == right &#123;        return lists[left]    &#125;    mid := left + (right-left)/2    l1 := mergeLists(lists, left, mid)    l2 := mergeLists(lists, mid+1, right)    return mergeTwoLists(l1, l2)&#125;func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123;    if l1 == nil &#123;        return l2    &#125;    if l2 == nil &#123;        return l1    &#125;    if l1.Val &lt; l2.Val &#123;        l1.Next = mergeTwoLists(l1.Next, l2)        return l1    &#125; else &#123;        l2.Next = mergeTwoLists(l1, l2.Next)        return l2    &#125;&#125;\n\n结果执行用时 : 8 ms, 击败 70.42% 使用 Go 的用户\n内存消耗 : 5.17 MB, 击败 22.50% 使用 Go 的用户\n\nRuby# Definition for singly-linked list.# class ListNode#     attr_accessor :val, :next#     def initialize(val = 0, _next = nil)#         @val = val#         @next = _next#     end# end# @param &#123;ListNode[]&#125; lists# @return &#123;ListNode&#125;def merge_k_lists(lists)  return nil if lists.nil? || lists.empty?  merge_lists(lists, 0, lists.length - 1)enddef merge_lists(lists, left, right)  return lists[left] if left == right  mid = left + (right - left) / 2  l1 = merge_lists(lists, left, mid)  l2 = merge_lists(lists, mid + 1, right)  merge_two_lists(l1, l2)enddef merge_two_lists(l1, l2)  return l2 if l1.nil?  return l1 if l2.nil?  if l1.val &lt; l2.val    l1.next = merge_two_lists(l1.next, l2)    l1  else    l2.next = merge_two_lists(l1, l2.next)    l2  endend\n\n结果执行用时 : 74 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 208.77 MB, 击败 -% 使用 Ruby 的用户\n\nScala/** * Definition for singly-linked list. * class ListNode(_x: Int = 0, _next: ListNode = null) &#123; *   var next: ListNode = _next *   var x: Int = _x * &#125; */object Solution &#123;  def mergeKLists(lists: Array[precompiled.ListNode]): precompiled.ListNode = &#123;    if (lists == null || lists.isEmpty) &#123;      return null    &#125;    mergeLists(lists, 0, lists.length - 1)  &#125;  def mergeLists(lists: Array[precompiled.ListNode], left: Int, right: Int): precompiled.ListNode = &#123;    if (left == right) &#123;      return lists(left)    &#125;    val mid = left + (right - left) / 2    val l1 = mergeLists(lists, left, mid)    val l2 = mergeLists(lists, mid + 1, right)    mergeTwoLists(l1, l2)  &#125;  def mergeTwoLists(l1: precompiled.ListNode, l2: precompiled.ListNode): precompiled.ListNode = &#123;    if (l1 == null) &#123;      return l2    &#125;    if (l2 == null) &#123;      return l1    &#125;    if (l1.x &lt; l2.x) &#123; // assuming x is the field for value      l1.next = mergeTwoLists(l1.next, l2)      l1    &#125; else &#123;      l2.next = mergeTwoLists(l1, l2.next)      l2    &#125;  &#125;&#125;\n\n结果执行用时 : 594 ms, 击败 75.00% 使用 Scala 的用户\n内存消耗 : 58.96 MB, 击败 37.50% 使用 Scala 的用户\n\nRust暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"食戟之灵 第四季 神之皿 第十二集 新生『远月十杰』","url":"/zh-CN/1d5801d3fbb8/","content":"\n剧情介绍　　决定最终回合胜负的时刻到了！最终，叛军队赢得了这场战斗！薙切蓟承认中央的失败，默默地离开了会场。然而，他被老朋友才波城一郎和堂岛银拦住了。同时，创真等人聚在一起，商讨谁将入选新的远月十杰席位……\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"力扣00024.两两交换链表中的节点","url":"/zh-CN/9623394395b7/","content":"\n题目描述给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n示例 1：\n\n\n输入：head &#x3D; [1,2,3,4]输出：[2,1,4,3]\n\n示例 2：\n输入：head &#x3D; []输出：[]\n\n示例 3：\n输入：head &#x3D; [1]输出：[1]\n\n提示：\n链表中节点的数目在范围 [0, 100] 内\n0 &lt;&#x3D; Node.val &lt;&#x3D; 100\n\n\n解决方法C++/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        ListNode* dummy = new ListNode(0);        dummy-&gt;next = head;        ListNode* current = dummy;        while (current-&gt;next &amp;&amp; current-&gt;next-&gt;next) &#123;            ListNode* node1 = current-&gt;next;            ListNode* node2 = current-&gt;next-&gt;next;            current-&gt;next = node2;            node1-&gt;next = node2-&gt;next;            node2-&gt;next = node1;            current = node1;        &#125;        return dummy-&gt;next;    &#125;&#125;;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C++ 的用户\n内存消耗 : 9.32 MB, 击败 5.03% 使用 C++ 的用户\n\nJava/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */public class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        ListNode dummy = new ListNode(0);        dummy.next = head;        ListNode current = dummy;        while (current.next != null &amp;&amp; current.next.next != null) &#123;            ListNode node1 = current.next;            ListNode node2 = current.next.next;            current.next = node2;            node1.next = node2.next;            node2.next = node1;            current = node1;        &#125;        return dummy.next;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 40.38 MB, 击败 5.18% 使用 Java 的用户\n\nPython# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution(object):    def swapPairs(self, head):        dummy = ListNode(0)        dummy.next = head        current = dummy        while current.next and current.next.next:            node1 = current.next            node2 = current.next.next            current.next = node2            node1.next = node2.next            node2.next = node1            current = node1        return dummy.next\n\n结果执行用时 : 14 ms, 击败 75.45% 使用 Python 的用户\n内存消耗 : 11.44 MB, 击败 97.48% 使用 Python 的用户\n\nPython3# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        dummy = ListNode(0)        dummy.next = head        current = dummy        while current.next and current.next.next:            node1 = current.next            node2 = current.next.next            current.next = node2            node1.next = node2.next            node2.next = node1            current = node1        return dummy.next\n\n结果执行用时 : 33 ms, 击败 90.27% 使用 Python3 的用户\n内存消耗 : 16.45 MB, 击败 30.15% 使用 Python3 的用户\n\nC/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     struct ListNode *next; * &#125;; */struct ListNode* swapPairs(struct ListNode* head) &#123;    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));    dummy-&gt;next = head;    struct ListNode* current = dummy;    while (current-&gt;next &amp;&amp; current-&gt;next-&gt;next) &#123;        struct ListNode* node1 = current-&gt;next;        struct ListNode* node2 = current-&gt;next-&gt;next;        current-&gt;next = node2;        node1-&gt;next = node2-&gt;next;        node2-&gt;next = node1;        current = node1;    &#125;    return dummy-&gt;next;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 5.71 MB, 击败 95.91% 使用 C 的用户\n\nC#/** * Definition for singly-linked list. * public class ListNode &#123; *     public int val; *     public ListNode next; *     public ListNode(int val=0, ListNode next=null) &#123; *         this.val = val; *         this.next = next; *     &#125; * &#125; */public class Solution &#123;    public ListNode SwapPairs(ListNode head) &#123;        ListNode dummy = new ListNode(0);        dummy.next = head;        ListNode current = dummy;        while (current.next != null &amp;&amp; current.next.next != null) &#123;            ListNode node1 = current.next;            ListNode node2 = current.next.next;            current.next = node2;            node1.next = node2.next;            node2.next = node1;            current = node1;        &#125;        return dummy.next;    &#125;&#125;\n\n结果执行用时 : 57 ms, 击败 88.57% 使用 C# 的用户\n内存消耗 : 39.66 MB, 击败 5.71% 使用 C# 的用户\n\nJavaScript/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var swapPairs = function(head) &#123;    let dummy = new ListNode(0);    dummy.next = head;    let current = dummy;    while (current.next &amp;&amp; current.next.next) &#123;        let node1 = current.next;        let node2 = current.next.next;        current.next = node2;        node1.next = node2.next;        node2.next = node1;        current = node1;    &#125;    return dummy.next;&#125;;\n\n结果执行用时 : 37 ms, 击败 100.00% 使用 JavaScript 的用户\n内存消耗 : 49.33 MB, 击败 5.29% 使用 JavaScript 的用户\n\nTypeScript/** * Definition for singly-linked list. * class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */function swapPairs(head: ListNode | null): ListNode | null &#123;    let dummy: ListNode = new ListNode(0);    dummy.next = head;    let current: ListNode | null = dummy;    while (current?.next &amp;&amp; current?.next?.next) &#123;        let node1: ListNode | null = current.next;        let node2: ListNode | null = current.next.next;        if (node1 &amp;&amp; node2) &#123;            current.next = node2;            node1.next = node2.next;            node2.next = node1;            current = node1;        &#125;    &#125;    return dummy.next;&#125;\n\n结果执行用时 : 60 ms, 击败 86.10% 使用 TypeScript 的用户\n内存消耗 : 51.79 MB, 击败 5.02% 使用 TypeScript 的用户\n\nPHP/** * Definition for a singly-linked list. * class ListNode &#123; *     public $val = 0; *     public $next = null; *     function __construct($val = 0, $next = null) &#123; *         $this-&gt;val = $val; *         $this-&gt;next = $next; *     &#125; * &#125; */class Solution &#123;    /**     * @param ListNode $head     * @return ListNode     */    function swapPairs($head) &#123;        $dummy = new ListNode(0);        $dummy-&gt;next = $head;        $current = $dummy;        while ($current-&gt;next &amp;&amp; $current-&gt;next-&gt;next) &#123;            $node1 = $current-&gt;next;            $node2 = $current-&gt;next-&gt;next;            $current-&gt;next = $node2;            $node1-&gt;next = $node2-&gt;next;            $node2-&gt;next = $node1;            $current = $node1;        &#125;        return $dummy-&gt;next;    &#125;&#125;\n\n结果执行用时 : 11 ms, 击败 16.67% 使用 PHP 的用户\n内存消耗 : 19.93 MB, 击败 5.55% 使用 PHP 的用户\n\nSwift/** * Definition for singly-linked list. * public class ListNode &#123; *     public var val: Int *     public var next: ListNode? *     public init() &#123; self.val = 0; self.next = nil; &#125; *     public init(_ val: Int) &#123; self.val = val; self.next = nil; &#125; *     public init(_ val: Int, _ next: ListNode?) &#123; self.val = val; self.next = next; &#125; * &#125; */class Solution &#123;    func swapPairs(_ head: ListNode?) -&gt; ListNode? &#123;        let dummy = ListNode(0)        dummy.next = head        var current: ListNode? = dummy        while current?.next != nil &amp;&amp; current?.next?.next != nil &#123;            let node1 = current?.next            let node2 = current?.next?.next            current?.next = node2            node1?.next = node2?.next            node2?.next = node1            current = node1        &#125;        return dummy.next    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Swift 的用户\n内存消耗 : 15.22 MB, 击败 20.67% 使用 Swift 的用户\n\nKotlin/** * Example: * var li = ListNode(5) * var v = li.`val` * Definition for singly-linked list. * class ListNode(var `val`: Int) &#123; *     var next: ListNode? = null * &#125; */class Solution &#123;    fun swapPairs(head: ListNode?): ListNode? &#123;        val dummy = ListNode(0)        dummy.next = head        var current: ListNode? = dummy        while (current?.next != null &amp;&amp; current.next?.next != null) &#123;            val node1 = current.next            val node2 = current.next?.next            current.next = node2            node1?.next = node2?.next            node2?.next = node1            current = node1        &#125;        return dummy.next    &#125;&#125;\n\n结果执行用时 : 138 ms, 击败 81.08% 使用 Kotlin 的用户\n内存消耗 : 33.44 MB, 击败 32.43% 使用 Kotlin 的用户\n\nDart/** * Definition for singly-linked list. * class ListNode &#123; *   int val; *   ListNode? next; *   ListNode([this.val = 0, this.next]); * &#125; */class Solution &#123;  ListNode? swapPairs(ListNode? head) &#123;    ListNode? tail = head;    for (int i = 0; i &lt; 2; i++) &#123;      if (tail == null) &#123;        return head;      &#125;      tail = tail.next;    &#125;    ListNode? pre;    ListNode? cur = head;    while (cur != tail) &#123;      ListNode? temp = cur?.next;      cur?.next = pre;      pre = cur;      cur = temp;    &#125;    head?.next = swapPairs(tail);    return pre;  &#125;&#125;\n\n结果执行用时 : 302 ms, 击败 22.22% 使用 Dart 的用户\n内存消耗 : 147.56 MB, 击败 55.56% 使用 Dart 的用户\n\nGo/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func swapPairs(head *ListNode) *ListNode &#123;\tdummy := &amp;ListNode&#123;Val: 0, Next: head&#125;\tcurrent := dummy\tfor current.Next != nil &amp;&amp; current.Next.Next != nil &#123;\t\tnode1 := current.Next\t\tnode2 := current.Next.Next\t\tcurrent.Next = node2\t\tnode1.Next = node2.Next\t\tnode2.Next = node1\t\tcurrent = node1\t&#125;\treturn dummy.Next&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 1.97 MB, 击败 26.06% 使用 Go 的用户\n\nRuby# Definition for singly-linked list.# class ListNode#     attr_accessor :val, :next#     def initialize(val = 0, _next = nil)#         @val = val#         @next = _next#     end# end# @param &#123;ListNode&#125; head# @return &#123;ListNode&#125;def swap_pairs(head)  dummy = ListNode.new(0)  dummy.next = head  current = dummy  while current.next &amp;&amp; current.next.next    node1 = current.next    node2 = current.next.next    current.next = node2    node1.next = node2.next    node2.next = node1    current = node1  end  dummy.nextend\n\n结果执行用时 : 47 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.64 MB, 击败 -% 使用 Ruby 的用户\n\nScala/** * Definition for singly-linked list. * class ListNode(_x: Int = 0, _next: ListNode = null) &#123; *   var next: ListNode = _next *   var x: Int = _x * &#125; */object Solution &#123;  def swapPairs(head: ListNode): ListNode = &#123;    if (head == null || head.next == null) &#123;      return head    &#125;    val t1 = head.next    val t2 = head.next.next    t1.next = head    head.next = swapPairs(t2)    t1  &#125;&#125;\n\n结果执行用时 : 460 ms, 击败 85.71% 使用 Scala 的用户\n内存消耗 : 56.41 MB, 击败 14.29% 使用 Scala 的用户\n\nRust// Definition for singly-linked list.// #[derive(PartialEq, Eq, Clone, Debug)]// pub struct ListNode &#123;//   pub val: i32,//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;// &#125;//// impl ListNode &#123;//   #[inline]//   fn new(val: i32) -&gt; Self &#123;//     ListNode &#123;//       next: None,//       val//     &#125;//   &#125;// &#125;impl Solution &#123;    pub fn swap_pairs(head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; &#123;        if let Some(mut node) = head &#123;            if let Some(mut next) = node.next.take() &#123;                node.next = Self::swap_pairs(next.next.take());                next.next = Some(node);                Some(next)            &#125; else &#123;                Some(node)            &#125;        &#125; else &#123;            None        &#125;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.15 MB, 击败 21.54% 使用 Rust 的用户\n\nRacket; Definition for singly-linked list:#|; val : integer?; next : (or/c list-node? #f)(struct list-node  (val next) #:mutable #:transparent); constructor(define (make-list-node [val 0])  (list-node val #f))|#(define (swap-pairs head)  (cond    ((or (not head) (not (list-node? head)) (not (list-node? (list-node-next head))))     head)    (else     (let ((node1 head)           (node2 (list-node-next head))           (rest (list-node-next (list-node-next head))))       (set-list-node-next! node1 (swap-pairs rest))       (set-list-node-next! node2 node1)       node2))))\n\n结果执行用时 : 175 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 98.80 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang%% Definition for singly-linked list.%%%% -record(list_node, &#123;val = 0 :: integer(),%%                     next = null :: &#x27;null&#x27; | #list_node&#123;&#125;&#125;).-spec swap_pairs(Head :: #list_node&#123;&#125; | null) -&gt; #list_node&#123;&#125; | null.swap_pairs(Head) when Head =:= null -&gt; null;swap_pairs(Head) when is_record(Head, list_node) -&gt;     case Head#list_node.next of        null -&gt; Head;        Next -&gt;             NewNext = swap_pairs(Next#list_node.next),            NewHead = Head#list_node&#123;next = NewNext&#125;,            Next#list_node&#123;next = NewHead&#125;    end.\n\n结果执行用时 : 222 ms, 击败 -% 使用 Erlang 的用户\n内存消耗 : 59.48 MB, 击败 -% 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00025.K 个一组翻转链表","url":"/zh-CN/55d70033c857/","content":"\n题目描述给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。\nk 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n示例 1：\n\n\n输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2输出：[2,1,4,3,5]\n\n示例 2：\n\n\n输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3输出：[3,2,1,4,5]\n\n提示：\n链表中的节点数目为 n\n1 &lt;&#x3D; k &lt;&#x3D; n &lt;&#x3D; 5000\n0 &lt;&#x3D; Node.val &lt;&#x3D; 1000\n\n进阶：你可以设计一个只用 O(1) 额外内存空间的算法解决此问题吗？\n\n解决方法C++/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* reverseKGroup(ListNode* head, int k) &#123;        ListNode* dummy = new ListNode(0);        dummy-&gt;next = head;        ListNode* prev_group_end = dummy;        while (true) &#123;            ListNode* group_start = prev_group_end-&gt;next;            ListNode* group_end = getGroupEnd(group_start, k);            if (!group_end) &#123;                break;            &#125;            ListNode* next_group_start = group_end-&gt;next;            group_end-&gt;next = nullptr;            prev_group_end-&gt;next = reverseList(group_start);            group_start-&gt;next = next_group_start;            prev_group_end = group_start;        &#125;        return dummy-&gt;next;    &#125;private:    ListNode* getGroupEnd(ListNode* start, int k) &#123;        for (int i = 1; i &lt; k &amp;&amp; start; ++i) &#123;            start = start-&gt;next;        &#125;        return start;    &#125;    ListNode* reverseList(ListNode* head) &#123;        ListNode* prev = nullptr;        ListNode* curr = head;        while (curr) &#123;            ListNode* next_node = curr-&gt;next;            curr-&gt;next = prev;            prev = curr;            curr = next_node;        &#125;        return prev;    &#125;&#125;;\n\n结果执行用时 : 14 ms, 击败 29.79% 使用 C++ 的用户\n内存消耗 : 14.58 MB, 击败 7.15% 使用 C++ 的用户\n\nJava/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode reverseKGroup(ListNode head, int k) &#123;        ListNode dummy = new ListNode(0);        dummy.next = head;        ListNode prevGroupEnd = dummy;        while (true) &#123;            ListNode groupStart = prevGroupEnd.next;            ListNode groupEnd = getGroupEnd(groupStart, k);            if (groupEnd == null) &#123;                break;            &#125;            ListNode nextGroupStart = groupEnd.next;            groupEnd.next = null;            prevGroupEnd.next = reverseList(groupStart);            groupStart.next = nextGroupStart;            prevGroupEnd = groupStart;        &#125;        return dummy.next;    &#125;    private ListNode getGroupEnd(ListNode start, int k) &#123;        for (int i = 1; i &lt; k &amp;&amp; start != null; ++i) &#123;            start = start.next;        &#125;        return start;    &#125;    private ListNode reverseList(ListNode head) &#123;        ListNode prev = null;        ListNode curr = head;        while (curr != null) &#123;            ListNode nextNode = curr.next;            curr.next = prev;            prev = curr;            curr = nextNode;        &#125;        return prev;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 43.32 MB, 击败 5.99% 使用 Java 的用户\n\nPython# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution(object):    def reverseKGroup(self, head, k):        dummy = ListNode(0)        dummy.next = head        prev_group_end = dummy        while True:            group_start = prev_group_end.next            group_end = self.get_group_end(group_start, k)            if not group_end:                break            next_group_start = group_end.next            group_end.next = None            prev_group_end.next = self.reverse_list(group_start)            group_start.next = next_group_start            prev_group_end = group_start        return dummy.next    def get_group_end(self, start, k):        for i in range(1, k):            if start:                start = start.next        return start    def reverse_list(self, head):        prev = None        curr = head        while curr:            next_node = curr.next            curr.next = prev            prev, curr = curr, next_node        return prev\n\n结果执行用时 : 32 ms, 击败 67.63% 使用 Python 的用户\n内存消耗 : 13.03 MB, 击败 97.28% 使用 Python 的用户\n\nPython3# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def reverseKGroup(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:        dummy = ListNode(0)        dummy.next = head        prev_group_end = dummy        while True:            group_start = prev_group_end.next            group_end = self.get_group_end(group_start, k)            if not group_end:                break            next_group_start = group_end.next            group_end.next = None            prev_group_end.next = self.reverse_list(group_start)            group_start.next = next_group_start            prev_group_end = group_start        return dummy.next    def get_group_end(self, start, k):        for i in range(1, k):            if start:                start = start.next        return start    def reverse_list(self, head):        prev = None        curr = head        while curr:            next_node = curr.next            curr.next = prev            prev, curr = curr, next_node        return prev\n\n结果执行用时 : 44 ms, 击败 87.58% 使用 Python3 的用户\n内存消耗 : 17.23 MB, 击败 40.79% 使用 Python3 的用户\n\nC/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     struct ListNode *next; * &#125;; */struct ListNode* getGroupEnd(struct ListNode* start, int k);struct ListNode* reverseList(struct ListNode* head);struct ListNode* reverseKGroup(struct ListNode* head, int k) &#123;    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));    dummy-&gt;next = head;    struct ListNode* prev_group_end = dummy;    while (1) &#123;        struct ListNode* group_start = prev_group_end-&gt;next;        struct ListNode* group_end = getGroupEnd(group_start, k);        if (!group_end) &#123;            break;        &#125;        struct ListNode* next_group_start = group_end-&gt;next;        group_end-&gt;next = NULL;        prev_group_end-&gt;next = reverseList(group_start);        group_start-&gt;next = next_group_start;        prev_group_end = group_start;    &#125;    return dummy-&gt;next;&#125;struct ListNode* getGroupEnd(struct ListNode* start, int k) &#123;    for (int i = 1; i &lt; k &amp;&amp; start; ++i) &#123;        start = start-&gt;next;    &#125;    return start;&#125;struct ListNode* reverseList(struct ListNode* head) &#123;    struct ListNode* prev = NULL;    struct ListNode* curr = head;    while (curr) &#123;        struct ListNode* next_node = curr-&gt;next;        curr-&gt;next = prev;        prev = curr;        curr = next_node;    &#125;    return prev;&#125;\n\n结果执行用时 : 5 ms, 击败 60.44% 使用 C 的用户\n内存消耗 : 6.59 MB, 击败 99.47% 使用 C 的用户\n\nC#/** * Definition for singly-linked list. * public class ListNode &#123; *     public int val; *     public ListNode next; *     public ListNode(int val=0, ListNode next=null) &#123; *         this.val = val; *         this.next = next; *     &#125; * &#125; */public class Solution &#123;    public ListNode ReverseKGroup(ListNode head, int k) &#123;        ListNode dummy = new ListNode(0);        dummy.next = head;        ListNode prevGroupEnd = dummy;        while (true) &#123;            ListNode groupStart = prevGroupEnd.next;            ListNode groupEnd = GetGroupEnd(groupStart, k);            if (groupEnd == null) &#123;                break;            &#125;            ListNode nextGroupStart = groupEnd.next;            groupEnd.next = null;            prevGroupEnd.next = ReverseList(groupStart);            groupStart.next = nextGroupStart;            prevGroupEnd = groupStart;        &#125;        return dummy.next;    &#125;    private ListNode GetGroupEnd(ListNode start, int k) &#123;        for (int i = 1; i &lt; k &amp;&amp; start != null; ++i) &#123;            start = start.next;        &#125;        return start;    &#125;    private ListNode ReverseList(ListNode head) &#123;        ListNode prev = null;        ListNode curr = head;        while (curr != null) &#123;            ListNode nextNode = curr.next;            curr.next = prev;            prev = curr;            curr = nextNode;        &#125;        return prev;    &#125;&#125;\n\n结果执行用时 : 81 ms, 击败 50.00% 使用 C# 的用户\n内存消耗 : 43.74 MB, 击败 5.55% 使用 C# 的用户\n\nJavaScript/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; k * @return &#123;ListNode&#125; */var reverseKGroup = function(head, k) &#123;    let dummy = new ListNode(0);    dummy.next = head;    let prevGroupEnd = dummy;    while (true) &#123;        let groupStart = prevGroupEnd.next;        let groupEnd = getGroupEnd(groupStart, k);        if (!groupEnd) &#123;            break;        &#125;        let nextGroupStart = groupEnd.next;        groupEnd.next = null;        prevGroupEnd.next = reverseList(groupStart);        groupStart.next = nextGroupStart;        prevGroupEnd = groupStart;    &#125;    return dummy.next;    function getGroupEnd(start, k) &#123;        for (let i = 1; i &lt; k &amp;&amp; start; ++i) &#123;            start = start.next;        &#125;        return start;    &#125;    function reverseList(head) &#123;        let prev = null;        let curr = head;        while (curr) &#123;            let nextNode = curr.next;            curr.next = prev;            prev = curr;            curr = nextNode;        &#125;        return prev;    &#125;&#125;;\n\n结果执行用时 : 84 ms, 击败 34.35% 使用 JavaScript 的用户\n内存消耗 : 52.97 MB, 击败 10.36% 使用 JavaScript 的用户\n\nTypeScript/** * Definition for singly-linked list. * class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */function reverseKGroup(head: ListNode | null, k: number): ListNode | null &#123;    let dummy: ListNode = new ListNode(0);    dummy.next = head;    let prevGroupEnd: ListNode = dummy;    while (true) &#123;        let groupStart: ListNode | null = prevGroupEnd.next;        let groupEnd: ListNode | null = getGroupEnd(groupStart, k);        if (!groupEnd) &#123;            break;        &#125;        let nextGroupStart: ListNode | null = groupEnd.next;        groupEnd.next = null;        prevGroupEnd.next = reverseList(groupStart);        groupStart.next = nextGroupStart;        prevGroupEnd = groupStart;    &#125;    return dummy.next;    function getGroupEnd(start: ListNode | null, k: number): ListNode | null &#123;        for (let i = 1; i &lt; k &amp;&amp; start; ++i) &#123;            start = start.next;        &#125;        return start;    &#125;    function reverseList(head: ListNode | null): ListNode | null &#123;        let prev: ListNode | null = null;        let curr: ListNode | null = head;        while (curr) &#123;            let nextNode: ListNode | null = curr.next;            curr.next = prev;            prev = curr;            curr = nextNode;        &#125;        return prev;    &#125;&#125;\n\n结果执行用时 : 79 ms, 击败 79.55% 使用 TypeScript 的用户\n内存消耗 : 54.74 MB, 击败 10.46% 使用 TypeScript 的用户\n\nPHP/** * Definition for a singly-linked list. * class ListNode &#123; *     public $val = 0; *     public $next = null; *     function __construct($val = 0, $next = null) &#123; *         $this-&gt;val = $val; *         $this-&gt;next = $next; *     &#125; * &#125; */class Solution &#123;    /**     * @param ListNode $head     * @param int $k     * @return ListNode     */    function reverseKGroup($head, $k) &#123;        $dummy = new ListNode(0);        $dummy-&gt;next = $head;        $prevGroupEnd = $dummy;        while (true) &#123;            $groupStart = $prevGroupEnd-&gt;next;            $groupEnd = $this-&gt;getGroupEnd($groupStart, $k);            if (!$groupEnd) &#123;                break;            &#125;            $nextGroupStart = $groupEnd-&gt;next;            $groupEnd-&gt;next = null;            $prevGroupEnd-&gt;next = $this-&gt;reverseList($groupStart);            $groupStart-&gt;next = $nextGroupStart;            $prevGroupEnd = $groupStart;        &#125;        return $dummy-&gt;next;    &#125;    private function getGroupEnd($start, $k) &#123;        for ($i = 1; $i &lt; $k &amp;&amp; $start; ++$i) &#123;            $start = $start-&gt;next;        &#125;        return $start;    &#125;    private function reverseList($head) &#123;        $prev = null;        $curr = $head;        while ($curr) &#123;            $nextNode = $curr-&gt;next;            $curr-&gt;next = $prev;            $prev = $curr;            $curr = $nextNode;        &#125;        return $prev;    &#125;&#125;\n\n结果执行用时 : 13 ms, 击败 35.71% 使用 PHP 的用户\n内存消耗 : 21.41 MB, 击败 7.14% 使用 PHP 的用户\n\nSwift/** * Definition for singly-linked list. * public class ListNode &#123; *     public var val: Int *     public var next: ListNode? *     public init() &#123; self.val = 0; self.next = nil; &#125; *     public init(_ val: Int) &#123; self.val = val; self.next = nil; &#125; *     public init(_ val: Int, _ next: ListNode?) &#123; self.val = val; self.next = next; &#125; * &#125; */class Solution &#123;    func reverseKGroup(_ head: ListNode?, _ k: Int) -&gt; ListNode? &#123;        let dummy = ListNode(0)        dummy.next = head        var prevGroupEnd: ListNode? = dummy        while true &#123;            let groupStart: ListNode? = prevGroupEnd?.next            let groupEnd: ListNode? = getGroupEnd(groupStart, k)            if groupEnd == nil &#123;                break            &#125;            let nextGroupStart: ListNode? = groupEnd?.next            groupEnd?.next = nil            prevGroupEnd?.next = reverseList(groupStart)            groupStart?.next = nextGroupStart            prevGroupEnd = groupStart        &#125;        return dummy.next    &#125;    private func getGroupEnd(_ start: ListNode?, _ k: Int) -&gt; ListNode? &#123;        var start = start        for _ in 1..&lt;k where start != nil &#123;            start = start?.next        &#125;        return start    &#125;    private func reverseList(_ head: ListNode?) -&gt; ListNode? &#123;        var prev: ListNode? = nil        var curr: ListNode? = head        while curr != nil &#123;            let nextNode: ListNode? = curr?.next            curr?.next = prev            prev = curr            curr = nextNode        &#125;        return prev    &#125;&#125;\n\n结果执行用时 : 36 ms, 击败 18.75% 使用 Swift 的用户\n内存消耗 : 15.75 MB, 击败 6.25% 使用 Swift 的用户\n\nKotlin/** * Example: * var li = ListNode(5) * var v = li.`val` * Definition for singly-linked list. * class ListNode(var `val`: Int) &#123; *     var next: ListNode? = null * &#125; */class Solution &#123;    fun reverseKGroup(head: ListNode?, k: Int): ListNode? &#123;        val dummy = ListNode(0)        dummy.next = head        var prevGroupEnd: ListNode? = dummy        while (true) &#123;            val groupStart: ListNode? = prevGroupEnd?.next            val groupEnd: ListNode? = getGroupEnd(groupStart, k)            if (groupEnd == null) &#123;                break            &#125;            val nextGroupStart: ListNode? = groupEnd?.next            groupEnd?.next = null            prevGroupEnd?.next = reverseList(groupStart)            groupStart?.next = nextGroupStart            prevGroupEnd = groupStart        &#125;        return dummy.next    &#125;    private fun getGroupEnd(start: ListNode?, k: Int): ListNode? &#123;        var start = start        for (i in 1 until k) &#123;            if (start == null) &#123;                break            &#125;            start = start.next        &#125;        return start    &#125;    private fun reverseList(head: ListNode?): ListNode? &#123;        var prev: ListNode? = null        var curr: ListNode? = head        while (curr != null) &#123;            val nextNode: ListNode? = curr?.next            curr?.next = prev            prev = curr            curr = nextNode        &#125;        return prev    &#125;&#125;\n\n结果执行用时 : 177 ms, 击败 87.88% 使用 Kotlin 的用户\n内存消耗 : 36.66 MB, 击败 90.91% 使用 Kotlin 的用户\n\nDart/** * Definition for singly-linked list. * class ListNode &#123; *   int val; *   ListNode? next; *   ListNode([this.val = 0, this.next]); * &#125; */class Solution &#123;  ListNode? reverseKGroup(ListNode? head, int k) &#123;    ListNode dummy = ListNode(0);    dummy.next = head;    ListNode? prevGroupEnd = dummy;    while (true) &#123;      ListNode? groupStart = prevGroupEnd?.next;      ListNode? groupEnd = getGroupEnd(groupStart, k);      if (groupEnd == null) &#123;        break;      &#125;      ListNode? nextGroupStart = groupEnd.next;      groupEnd.next = null;      prevGroupEnd?.next = reverseList(groupStart);      groupStart?.next = nextGroupStart;      prevGroupEnd = groupStart;    &#125;    return dummy.next;  &#125;  ListNode? getGroupEnd(ListNode? start, int k) &#123;    for (int i = 1; i &lt; k &amp;&amp; start != null; ++i) &#123;      start = start.next;    &#125;    return start;  &#125;  ListNode? reverseList(ListNode? head) &#123;    ListNode? prev = null;    ListNode? curr = head;    while (curr != null) &#123;      ListNode? nextNode = curr.next;      curr.next = prev;      prev = curr;      curr = nextNode;    &#125;    return prev;  &#125;&#125;\n\n结果执行用时 : 287 ms, 击败 33.33% 使用 Dart 的用户\n内存消耗 : 148.09 MB, 击败 66.67% 使用 Dart 的用户\n\nGo/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func reverseKGroup(head *ListNode, k int) *ListNode &#123;    dummy := &amp;ListNode&#123;0, head&#125;    prevGroupEnd := dummy    for &#123;        groupStart := prevGroupEnd.Next        groupEnd := getGroupEnd(groupStart, k)        if groupEnd == nil &#123;            break        &#125;        nextGroupStart := groupEnd.Next        groupEnd.Next = nil        prevGroupEnd.Next = reverseList(groupStart)        groupStart.Next = nextGroupStart        prevGroupEnd = groupStart    &#125;    return dummy.Next&#125;func getGroupEnd(start *ListNode, k int) *ListNode &#123;    for i := 1; i &lt; k &amp;&amp; start != nil; i++ &#123;        start = start.Next    &#125;    return start&#125;func reverseList(head *ListNode) *ListNode &#123;    var prev, curr *ListNode = nil, head    for curr != nil &#123;        nextNode := curr.Next        curr.Next = prev        prev, curr = curr, nextNode    &#125;    return prev&#125;\n\n结果执行用时 : 4 ms, 击败 72.33% 使用 Go 的用户\n内存消耗 : 3.39 MB, 击败 60.50% 使用 Go 的用户\n\nRuby# Definition for singly-linked list.# class ListNode#     attr_accessor :val, :next#     def initialize(val = 0, _next = nil)#         @val = val#         @next = _next#     end# end# @param &#123;ListNode&#125; head# @param &#123;Integer&#125; k# @return &#123;ListNode&#125;def reverse_k_group(head, k)  dummy = ListNode.new(0)  dummy.next = head  prev_group_end = dummy  while true    group_start = prev_group_end.next    group_end = get_group_end(group_start, k)    break unless group_end    next_group_start = group_end.next    group_end.next = nil    prev_group_end.next = reverse_list(group_start)    group_start.next = next_group_start    prev_group_end = group_start  end  dummy.nextenddef get_group_end(start, k)  i = 1  while i &lt; k &amp;&amp; start    start = start.next    i += 1  end  startenddef reverse_list(head)  prev = nil  curr = head  while curr    next_node = curr.next    curr.next = prev    prev = curr    curr = next_node  end  prevend\n\n结果执行用时 : 53 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.84 MB, 击败 -% 使用 Ruby 的用户\n\nScala/** * Definition for singly-linked list. * class ListNode(_x: Int = 0, next: ListNode = null) &#123; *   var next: ListNode = next *   var x: Int = _x * &#125; */object Solution &#123;  def reverseKGroup(head: ListNode, k: Int): ListNode = &#123;    var current = head    var count = 0    while (current != null &amp;&amp; count &lt; k) &#123;      current = current.next      count += 1    &#125;    if (count == k) &#123;      var prev: ListNode = null      var nextGroupStart = current      current = head      for (_ &lt;- 0 until k) &#123;        val nextNode = current.next        current.next = prev        prev = current        current = nextNode      &#125;      head.next = reverseKGroup(nextGroupStart, k)      prev    &#125; else &#123;      head    &#125;  &#125;&#125;\n\n结果执行用时 : 565 ms, 击败 20.00% 使用 Scala 的用户\n内存消耗 : 57.17 MB, 击败 20.00% 使用 Scala 的用户\n\nRust暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"元旦","url":"/zh-CN/ad928147d8e8/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  元旦快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","元旦"]},{"title":"力扣00026.删除有序数组中的重复项","url":"/zh-CN/c769caeb9e53/","content":"\n题目描述给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。\n返回 k 。\n\n判题标准:\n系统会用下面的代码来测试你的题解:\nint[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123;    assert nums[i] == expectedNums[i];&#125;\n\n如果所有断言都通过，那么您的题解将被 通过。\n示例 1：\n输入：nums &#x3D; [1,1,2]输出：2, nums &#x3D; [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n示例 2：\n输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]输出：5, nums &#x3D; [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n\n提示：\n$1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 10^4$\n$-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4$\nnums 已按 非严格递增 排列\n\n\n解决方法C++class Solution &#123;public:    int removeDuplicates(std::vector&lt;int&gt;&amp; nums) &#123;        if (nums.empty()) &#123;            return 0;        &#125;        int k = 1;        for (int i = 1; i &lt; nums.size(); i++) &#123;            if (nums[i] != nums[i - 1]) &#123;                nums[k++] = nums[i];            &#125;        &#125;        return k;    &#125;&#125;;\n\n结果执行用时 : 3 ms, 击败 97.81% 使用 C++ 的用户\n内存消耗 : 20.66 MB, 击败 5.12% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public int removeDuplicates(int[] nums) &#123;        if (nums.length == 0) &#123;            return 0;        &#125;        int k = 1;        for (int i = 1; i &lt; nums.length; i++) &#123;            if (nums[i] != nums[i - 1]) &#123;                nums[k++] = nums[i];            &#125;        &#125;        return k;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 43.79 MB, 击败 18.76% 使用 Java 的用户\n\nPythonclass Solution(object):    def removeDuplicates(self, nums):        if not nums:            return 0        k = 1        for i in range(1, len(nums)):            if nums[i] != nums[i - 1]:                nums[k] = nums[i]                k += 1        return k\n\n结果执行用时 : 28 ms, 击败 49.67% 使用 Python 的用户\n内存消耗 : 12.79 MB, 击败 95.46% 使用 Python 的用户\n\nPython3class Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        if not nums:            return 0        k = 1        for i in range(1, len(nums)):            if nums[i] != nums[i - 1]:                nums[k] = nums[i]                k += 1        return k\n\n结果执行用时 : 49 ms, 击败 41.19% 使用 Python3 的用户\n内存消耗 : 17.69 MB, 击败 30.93% 使用 Python3 的用户\n\nCint removeDuplicates(int* nums, int numsSize) &#123;    if (numsSize == 0) &#123;        return 0;    &#125;    int k = 1;    for (int i = 1; i &lt; numsSize; i++) &#123;        if (nums[i] != nums[i - 1]) &#123;            nums[k++] = nums[i];        &#125;    &#125;    return k;&#125;\n\n结果执行用时 : 9 ms, 击败 83.02% 使用 C 的用户\n内存消耗 : 7.13 MB, 击败 97.58% 使用 C 的用户\n\nC#public class Solution &#123;    public int RemoveDuplicates(int[] nums) &#123;        if (nums.Length == 0) &#123;            return 0;        &#125;        int k = 1;        for (int i = 1; i &lt; nums.Length; i++) &#123;            if (nums[i] != nums[i - 1]) &#123;                nums[k++] = nums[i];            &#125;        &#125;        return k;    &#125;&#125;\n\n结果执行用时 : 117 ms, 击败 86.81% 使用 C# 的用户\n内存消耗 : 49.80 MB, 击败 5.20% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123;    if (nums.length === 0) &#123;        return 0;    &#125;    let k = 1;    for (let i = 1; i &lt; nums.length; i++) &#123;        if (nums[i] !== nums[i - 1]) &#123;            nums[k++] = nums[i];        &#125;    &#125;    return k;&#125;;\n\n结果执行用时 : 72 ms, 击败 66.38% 使用 JavaScript 的用户\n内存消耗 : 52.09 MB, 击败 5.05% 使用 JavaScript 的用户\n\nTypeScriptfunction removeDuplicates(nums: number[]): number &#123;    if (nums.length === 0) &#123;        return 0;    &#125;    let k = 1;    for (let i = 1; i &lt; nums.length; i++) &#123;        if (nums[i] !== nums[i - 1]) &#123;            nums[k++] = nums[i];        &#125;    &#125;    return k;&#125;\n\n结果执行用时 : 57 ms, 击败 99.11% 使用 TypeScript 的用户\n内存消耗 : 52.73 MB, 击败 5.47% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @return Integer     */    function removeDuplicates(&amp;$nums) &#123;        if (empty($nums)) &#123;            return 0;        &#125;        $k = 1;        $count = count($nums);        for ($i = 1; $i &lt; $count; $i++) &#123;            if ($nums[$i] !== $nums[$i - 1]) &#123;                $nums[$k++] = $nums[$i];            &#125;        &#125;        return $k;    &#125;&#125;\n\n结果执行用时 : 23 ms, 击败 67.26% 使用 PHP 的用户\n内存消耗 : 21.22 MB, 击败 5.36% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func removeDuplicates(_ nums: inout [Int]) -&gt; Int &#123;        if nums.isEmpty &#123;            return 0        &#125;        var k = 1        for i in 1..&lt;nums.count &#123;            if nums[i] != nums[i - 1] &#123;                nums[k] = nums[i]                k += 1            &#125;        &#125;        return k    &#125;&#125;\n\n结果执行用时 : 46 ms, 击败 59.11% 使用 Swift 的用户\n内存消耗 : 16.09 MB, 击败 6.07% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun removeDuplicates(nums: IntArray): Int &#123;        if (nums.isEmpty()) &#123;            return 0        &#125;        var k = 1        for (i in 1 until nums.size) &#123;            if (nums[i] != nums[i - 1]) &#123;                nums[k++] = nums[i]            &#125;        &#125;        return k    &#125;&#125;\n\n结果执行用时 : 230 ms, 击败 67.37% 使用 Kotlin 的用户\n内存消耗 : 40.41 MB, 击败 23.69% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int removeDuplicates(List&lt;int&gt; nums) &#123;    if (nums.isEmpty) &#123;      return 0;    &#125;    int k = 1;    for (int i = 1; i &lt; nums.length; i++) &#123;      if (nums[i] != nums[i - 1]) &#123;        nums[k++] = nums[i];      &#125;    &#125;    return k;  &#125;&#125;\n\n结果执行用时 : 306 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 144.93 MB, 击败 88.24% 使用 Dart 的用户\n\nGofunc removeDuplicates(nums []int) int &#123;    if len(nums) == 0 &#123;        return 0    &#125;    k := 1    for i := 1; i &lt; len(nums); i++ &#123;        if nums[i] != nums[i-1] &#123;            nums[k] = nums[i]            k++        &#125;    &#125;    return k&#125;\n\n结果执行用时 : 6 ms, 击败 60.74% 使用 Go 的用户\n内存消耗 : 4.26 MB, 击败 91.32% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @return &#123;Integer&#125;def remove_duplicates(nums)  return 0 if nums.empty?  k = 1  (1...nums.length).each do |i|    if nums[i] != nums[i - 1]      nums[k] = nums[i]      k += 1    end  end  kend\n\n结果执行用时 : 75 ms, 击败 68.75% 使用 Ruby 的用户\n内存消耗 : 207.35 MB, 击败 50.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def removeDuplicates(nums: Array[Int]): Int = &#123;    if (nums.isEmpty) &#123;      return 0    &#125;    var k = 1    for (i &lt;- 1 until nums.length) &#123;      if (nums(i) != nums(i - 1)) &#123;        nums(k) = nums(i)        k += 1      &#125;    &#125;    k  &#125;&#125;\n\n结果执行用时 : 548 ms, 击败 68.00% 使用 Scala 的用户\n内存消耗 : 55.28 MB, 击败 84.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn remove_duplicates(nums: &amp;mut Vec&lt;i32&gt;) -&gt; i32 &#123;        if nums.is_empty() &#123;            return 0;        &#125;        let mut k = 1;        for i in 1..nums.len() &#123;            if nums[i] != nums[i - 1] &#123;                nums[k] = nums[i];                k += 1;            &#125;        &#125;        k as i32    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.39 MB, 击败 6.05% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket"]},{"title":"力扣00027.移除元素","url":"/zh-CN/90fd1264eb97/","content":"\n题目描述给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;\n\n示例 1：\n输入：nums &#x3D; [3,2,2,3], val &#x3D; 3输出：2, nums &#x3D; [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。\n\n示例 2：\n输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2输出：5, nums &#x3D; [0,1,3,0,4]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\n提示：\n0 &lt;&#x3D; nums.length &lt;&#x3D; 100\n0 &lt;&#x3D; nums[i] &lt;&#x3D; 50\n0 &lt;&#x3D; val &lt;&#x3D; 100\n\n\n解决方法C++class Solution &#123;public:    int removeElement(std::vector&lt;int&gt;&amp; nums, int val) &#123;        int i = 0;        for (int j = 0; j &lt; nums.size(); ++j) &#123;            if (nums[j] != val) &#123;                nums[i] = nums[j];                ++i;            &#125;        &#125;        return i;    &#125;&#125;;\n\n结果执行用时 : 3 ms, 击败 44.36% 使用 C++ 的用户\n内存消耗 : 10.24 MB, 击败 5.12% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int removeElement(int[] nums, int val) &#123;        int i = 0;        for (int j = 0; j &lt; nums.length; ++j) &#123;            if (nums[j] != val) &#123;                nums[i] = nums[j];                ++i;            &#125;        &#125;        return i;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 41.04 MB, 击败 5.14% 使用 Java 的用户\n\nPythonclass Solution(object):    def removeElement(self, nums, val):        i = 0        for j in range(len(nums)):            if nums[j] != val:                nums[i] = nums[j]                i += 1        return i\n\n结果执行用时 : 11 ms, 击败 94.27% 使用 Python 的用户\n内存消耗 : 11.30 MB, 击败 99.31% 使用 Python 的用户\n\nPython3class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        i = 0        for j in range(len(nums)):            if nums[j] != val:                nums[i] = nums[j]                i += 1        return i\n\n结果执行用时 : 23 ms, 击败 99.89% 使用 Python3 的用户\n内存消耗 : 16.32 MB, 击败 34.59% 使用 Python3 的用户\n\nCint removeElement(int* nums, int numsSize, int val) &#123;    int i = 0;    for (int j = 0; j &lt; numsSize; ++j) &#123;        if (nums[j] != val) &#123;            nums[i] = nums[j];            ++i;        &#125;    &#125;    return i;&#125;\n\n结果执行用时 : 6 ms, 击败 5.58% 使用 C 的用户\n内存消耗 : 5.76 MB, 击败 95.20% 使用 C 的用户\n\nC#public class Solution &#123;    public int RemoveElement(int[] nums, int val) &#123;        int i = 0;        for (int j = 0; j &lt; nums.Length; ++j) &#123;            if (nums[j] != val) &#123;                nums[i] = nums[j];                ++i;            &#125;        &#125;        return i;    &#125;&#125;\n\n结果执行用时 : 107 ms, 击败 75.62% 使用 C# 的用户\n内存消耗 : 45.52 MB, 击败 5.23% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; val * @return &#123;number&#125; */var removeElement = function(nums, val) &#123;    let i = 0;    for (let j = 0; j &lt; nums.length; ++j) &#123;        if (nums[j] !== val) &#123;            nums[i] = nums[j];            ++i;        &#125;    &#125;    return i;&#125;;\n\n结果执行用时 : 58 ms, 击败 70.84% 使用 JavaScript 的用户\n内存消耗 : 49.11 MB, 击败 6.76% 使用 JavaScript 的用户\n\nTypeScriptfunction removeElement(nums: number[], val: number): number &#123;    let i = 0;    for (let j = 0; j &lt; nums.length; ++j) &#123;        if (nums[j] !== val) &#123;            nums[i] = nums[j];            ++i;        &#125;    &#125;    return i;&#125;\n\n结果执行用时 : 70 ms, 击败 24.71% 使用 TypeScript 的用户\n内存消耗 : 51.71 MB, 击败 5.21% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @param Integer $val     * @return Integer     */    function removeElement(&amp;$nums, $val) &#123;        $i = 0;        foreach ($nums as $j =&gt; $num) &#123;            if ($num !== $val) &#123;                $nums[$i] = $num;                ++$i;            &#125;        &#125;        return $i;    &#125;&#125;\n\n结果执行用时 : 7 ms, 击败 70.04% 使用 PHP 的用户\n内存消耗 : 20.02 MB, 击败 5.29% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func removeElement(_ nums: inout [Int], _ val: Int) -&gt; Int &#123;        var i = 0        for j in 0..&lt;nums.count &#123;            if nums[j] != val &#123;                nums[i] = nums[j]                i += 1            &#125;        &#125;        return i    &#125;&#125;\n\n结果执行用时 : 6 ms, 击败 48.38% 使用 Swift 的用户\n内存消耗 : 15.58 MB, 击败 5.19% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun removeElement(nums: IntArray, `val`: Int): Int &#123;        var i = 0        for (j in nums.indices) &#123;            if (nums[j] != `val`) &#123;                nums[i] = nums[j]                i++            &#125;        &#125;        return i    &#125;&#125;\n\n结果执行用时 : 164 ms, 击败 79.06% 使用 Kotlin 的用户\n内存消耗 : 34.39 MB, 击败 11.96% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int removeElement(List&lt;int&gt; nums, int val) &#123;    int i = 0;    for (int j = 0; j &lt; nums.length; j++) &#123;      if (nums[j] != val) &#123;        nums[i] = nums[j];        i++;      &#125;    &#125;    return i;  &#125;&#125;\n\n结果执行用时 : 318 ms, 击败 25.00% 使用 Dart 的用户\n内存消耗 : 146.96 MB, 击败 50.00% 使用 Dart 的用户\n\nGofunc removeElement(nums []int, val int) int &#123;    i := 0    for j := 0; j &lt; len(nums); j++ &#123;        if nums[j] != val &#123;            nums[i] = nums[j]            i++        &#125;    &#125;    return i&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.01 MB, 击败 68.18% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @param &#123;Integer&#125; val# @return &#123;Integer&#125;def remove_element(nums, val)    i = 0    nums.each_with_index do |num, j|        if num != val            nums[i] = num            i += 1        end    end    iend\n\n结果执行用时 : 62 ms, 击败 62.50% 使用 Ruby 的用户\n内存消耗 : 206.46 MB, 击败 25.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;    def removeElement(nums: Array[Int], `val`: Int): Int = &#123;        var i = 0        for (j &lt;- nums.indices) &#123;            if (nums(j) != `val`) &#123;                nums(i) = nums(j)                i += 1            &#125;        &#125;        i    &#125;&#125;\n\n结果执行用时 : 483 ms, 击败 30.77% 使用 Scala 的用户\n内存消耗 : 54.35 MB, 击败 30.77% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn remove_element(nums: &amp;mut Vec&lt;i32&gt;, val: i32) -&gt; i32 &#123;        let mut i = 0;        for j in 0..nums.len() &#123;            if nums[j] != val &#123;                nums[i] = nums[j];                i += 1;            &#125;        &#125;        i as i32    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.03 MB, 击败 62.39% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket"]},{"title":"小寒","url":"/zh-CN/e814760cb269/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小寒\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小寒"]},{"title":"力扣00028.找出字符串中第一个匹配项的下标","url":"/zh-CN/dd322a2800fd/","content":"\n题目描述给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。\n示例 1：\n输入：haystack &#x3D; “sadbutsad”, needle &#x3D; “sad”输出：0解释：”sad” 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。\n\n示例 2：\n输入：haystack &#x3D; “leetcode”, needle &#x3D; “leeto”输出：-1解释：”leeto” 没有在 “leetcode” 中出现，所以返回 -1 。\n\n提示：\n$1 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 10^4$\nhaystack 和 needle 仅由小写英文字符组成\n\n\n解决方法C++class Solution &#123;public:    int strStr(std::string haystack, std::string needle) &#123;        size_t pos = haystack.find(needle);        if (pos != std::string::npos) &#123;            return static_cast&lt;int&gt;(pos);        &#125; else &#123;            return -1;        &#125;    &#125;&#125;;\n\n结果执行用时 : 1 ms, 击败 32.03% 使用 C++ 的用户\n内存消耗 : 7.45 MB, 击败 5.03% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public int strStr(String haystack, String needle) &#123;        int index = haystack.indexOf(needle);        return index;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 40.36 MB, 击败 20.59% 使用 Java 的用户\n\nPythonclass Solution(object):    def strStr(self, haystack, needle):        &quot;&quot;&quot;        :type haystack: str        :type needle: str        :rtype: int        &quot;&quot;&quot;        index = haystack.find(needle)        return index\n\n结果执行用时 : 15 ms, 击败 76.06% 使用 Python 的用户\n内存消耗 : 11.54 MB, 击败 92.21% 使用 Python 的用户\n\nPython3class Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        index = haystack.find(needle)        return index\n\n结果执行用时 : 38 ms, 击败 73.98% 使用 Python3 的用户\n内存消耗 : 16.38 MB, 击败 33.01% 使用 Python3 的用户\n\nCint strStr(char* haystack, char* needle) &#123;    char* result = strstr(haystack, needle);    if (result != NULL) &#123;        return result - haystack;    &#125; else &#123;        return -1;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 5.25 MB, 击败 99.47% 使用 C 的用户\n\nC#public class Solution &#123;    public int StrStr(string haystack, string needle) &#123;        int index = haystack.IndexOf(needle);        return index;    &#125;&#125;\n\n结果执行用时 : 50 ms, 击败 77.71% 使用 C# 的用户\n内存消耗 : 39.58 MB, 击败 5.22% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; haystack * @param &#123;string&#125; needle * @return &#123;number&#125; */var strStr = function(haystack, needle) &#123;    var index = haystack.indexOf(needle);    return index;&#125;;\n\n结果执行用时 : 58 ms, 击败 69.67% 使用 JavaScript 的用户\n内存消耗 : 48.68 MB, 击败 10.90% 使用 JavaScript 的用户\n\nTypeScriptfunction strStr(haystack: string, needle: string): number &#123;    const index: number = haystack.indexOf(needle);    return index;&#125;\n\n结果执行用时 : 68 ms, 击败 43.15% 使用 TypeScript 的用户\n内存消耗 : 50.23 MB, 击败 13.29% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String $haystack     * @param String $needle     * @return Integer     */    function strStr($haystack, $needle) &#123;        $index = strpos($haystack, $needle);        return $index !== false ? $index : -1;    &#125;&#125;\n\n结果执行用时 : 3 ms, 击败 92.96% 使用 PHP 的用户\n内存消耗 : 19.80 MB, 击败 5.63% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func strStr(_ haystack: String, _ needle: String) -&gt; Int &#123;        if let range = haystack.range(of: needle) &#123;            return haystack.distance(from: haystack.startIndex, to: range.lowerBound)        &#125; else &#123;            return -1        &#125;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 75.25% 使用 Swift 的用户\n内存消耗 : 16.25 MB, 击败 5.94% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun strStr(haystack: String, needle: String): Int &#123;        val index = haystack.indexOf(needle)        return if (index != -1) index else -1    &#125;&#125;\n\n结果执行用时 : 157 ms, 击败 24.11% 使用 Kotlin 的用户\n内存消耗 : 34.41 MB, 击败 16.96% 使用 Kotlin 的用户\n\nDartclass Solution &#123;    int strStr(String haystack, String needle) &#123;        int index = haystack.indexOf(needle);        return index;    &#125;&#125;\n\n结果执行用时 : 292 ms, 击败 23.08% 使用 Dart 的用户\n内存消耗 : 143.05 MB, 击败 92.31% 使用 Dart 的用户\n\nGofunc strStr(haystack string, needle string) int &#123;    index := strings.Index(haystack, needle)    return index&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 1.87 MB, 击败 47.87% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; haystack# @param &#123;String&#125; needle# @return &#123;Integer&#125;def str_str(haystack, needle)    index = haystack.index(needle)    return index.nil? ? -1 : indexend\n\n结果执行用时 : 59 ms, 击败 85.71% 使用 Ruby 的用户\n内存消耗 : 206.23 MB, 击败 71.43% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def strStr(haystack: String, needle: String): Int = &#123;    val index = haystack.indexOf(needle)    return index  &#125;&#125;\n\n结果执行用时 : 453 ms, 击败 53.85% 使用 Scala 的用户\n内存消耗 : 52.46 MB, 击败 46.15% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn str_str(haystack: String, needle: String) -&gt; i32 &#123;        if let Some(index) = haystack.find(&amp;needle) &#123;            return index as i32;        &#125; else &#123;            return -1;        &#125;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 1.95 MB, 击败 92.17% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00029.两数相除","url":"/zh-CN/d31dfec58332/","content":"\n题目描述给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。\n整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。\n返回被除数 dividend 除以除数 divisor 得到的 商 。\n注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 $[−2^{31},  2^{31} − 1]$ 。本题中，如果商 严格大于 $2^{31} − 1$ ，则返回 $2^{31} − 1$ ；如果商 严格小于 $−2^{31}$ ，则返回 $−2^{31}$ 。\n示例 1：\n输入: dividend &#x3D; 10, divisor &#x3D; 3输出: 3解释: 10&#x2F;3 &#x3D; 3.33333.. ，向零截断后得到 3 。\n\n示例 2：\n输入: dividend &#x3D; 7, divisor &#x3D; -3输出: -2解释: 7&#x2F;-3 &#x3D; -2.33333.. ，向零截断后得到 -2 。\n\n提示：\n$−2^{31} &lt;&#x3D; dividend, divisor &lt;&#x3D; 2^{31} − 1$\ndivisor !&#x3D; 0\n\n\n解决方法C++class Solution &#123;public:    int divide(int dividend, int divisor) &#123;        if (dividend == INT_MIN &amp;&amp; divisor == -1) &#123;            return INT_MAX;        &#125;        int sign = (dividend &lt; 0) ^ (divisor &lt; 0) ? -1 : 1;        long long absDividend = llabs(static_cast&lt;long long&gt;(dividend));        long long absDivisor = llabs(static_cast&lt;long long&gt;(divisor));        long long result = 0;        while (absDividend &gt;= absDivisor) &#123;            long long temp = absDivisor, multiple = 1;            while (absDividend &gt;= (temp &lt;&lt; 1)) &#123;                temp &lt;&lt;= 1;                multiple &lt;&lt;= 1;            &#125;            absDividend -= temp;            result += multiple;        &#125;        result *= sign;        return static_cast&lt;int&gt;(std::min(std::max(result, static_cast&lt;long long&gt;(INT_MIN)), static_cast&lt;long long&gt;(INT_MAX)));    &#125;&#125;;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C++ 的用户\n内存消耗 : 7.50 MB, 击败 5.02% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int divide(int dividend, int divisor) &#123;        if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) &#123;            return Integer.MAX_VALUE;        &#125;        int sign = (dividend &lt; 0) ^ (divisor &lt; 0) ? -1 : 1;        long absDividend = Math.abs((long)dividend);        long absDivisor = Math.abs((long)divisor);        long result = 0;        while (absDividend &gt;= absDivisor) &#123;            long temp = absDivisor, multiple = 1;            while (absDividend &gt;= (temp &lt;&lt; 1)) &#123;                temp &lt;&lt;= 1;                multiple &lt;&lt;= 1;            &#125;            absDividend -= temp;            result += multiple;        &#125;        result *= sign;        return (int)Math.min(Math.max(result, (long)Integer.MIN_VALUE), (long)Integer.MAX_VALUE);    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 72.66% 使用 Java 的用户\n内存消耗 : 39.83 MB, 击败 20.23% 使用 Java 的用户\n\nPythonclass Solution(object):    def divide(self, dividend, divisor):        &quot;&quot;&quot;        :type dividend: int        :type divisor: int        :rtype: int        &quot;&quot;&quot;        if dividend == 0:            return 0        INT_MAX = 2**31 - 1        INT_MIN = -2**31        sign = -1 if (dividend &lt; 0) ^ (divisor &lt; 0) else 1        abs_dividend = abs(dividend)        abs_divisor = abs(divisor)        quotient = 0        while abs_dividend &gt;= abs_divisor:            temp, multiple = abs_divisor, 1            while abs_dividend &gt;= (temp &lt;&lt; 1):                temp &lt;&lt;= 1                multiple &lt;&lt;= 1            abs_dividend -= temp            quotient += multiple        result = sign * quotient        return min(max(result, INT_MIN), INT_MAX)\n\n结果执行用时 : 19 ms, 击败 89.54% 使用 Python 的用户\n内存消耗 : 11.37 MB, 击败 92.81% 使用 Python 的用户\n\nPython3class Solution:    def divide(self, dividend: int, divisor: int) -&gt; int:        if dividend == 0:            return 0        INT_MAX = 2**31 - 1        INT_MIN = -2**31        sign = -1 if (dividend &lt; 0) ^ (divisor &lt; 0) else 1        abs_dividend = abs(dividend)        abs_divisor = abs(divisor)        quotient = 0        while abs_dividend &gt;= abs_divisor:            temp, multiple = abs_divisor, 1            while abs_dividend &gt;= (temp &lt;&lt; 1):                temp &lt;&lt;= 1                multiple &lt;&lt;= 1            abs_dividend -= temp            quotient += multiple        result = sign * quotient        return min(max(result, INT_MIN), INT_MAX)\n\n结果执行用时 : 30 ms, 击败 98.48% 使用 Python3 的用户\n内存消耗 : 16.41 MB, 击败 32.61% 使用 Python3 的用户\n\nCint divide(int dividend, int divisor) &#123;    if (dividend == 0) &#123;        return 0;    &#125;    int MAX_INT = INT_MAX;    int MIN_INT = INT_MIN;    int sign = (dividend &lt; 0) ^ (divisor &lt; 0) ? -1 : 1;    long long absDividend = labs((long long)dividend);    long long absDivisor = labs((long long)divisor);    long long quotient = 0;    while (absDividend &gt;= absDivisor) &#123;        long long temp = absDivisor, multiple = 1;        while (absDividend &gt;= (temp &lt;&lt; 1)) &#123;            temp &lt;&lt;= 1;            multiple &lt;&lt;= 1;        &#125;        absDividend -= temp;        quotient += multiple;    &#125;    long long result = sign * quotient;    return (int)fmin(fmax(result, (long long)MIN_INT), (long long)MAX_INT);&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 5.20 MB, 击败 98.80% 使用 C 的用户\n\nC#public class Solution &#123;    public int Divide(int dividend, int divisor) &#123;        if (dividend == 0) &#123;            return 0;        &#125;        int MAX_INT = int.MaxValue;        int MIN_INT = int.MinValue;        int sign = (dividend &lt; 0) ^ (divisor &lt; 0) ? -1 : 1;        long absDividend = Math.Abs((long)dividend);        long absDivisor = Math.Abs((long)divisor);        long quotient = 0;        while (absDividend &gt;= absDivisor) &#123;            long temp = absDivisor, multiple = 1;            while (absDividend &gt;= (temp &lt;&lt; 1)) &#123;                temp &lt;&lt;= 1;                multiple &lt;&lt;= 1;            &#125;            absDividend -= temp;            quotient += multiple;        &#125;        long result = sign * quotient;        return (int)Math.Min(Math.Max(result, (long)MIN_INT), (long)MAX_INT);    &#125;&#125;\n\n结果执行用时 : 24 ms, 击败 70.97% 使用 C# 的用户\n内存消耗 : 26.63 MB, 击败 12.90% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number&#125; dividend * @param &#123;number&#125; divisor * @return &#123;number&#125; */var divide = function(dividend, divisor) &#123;    let sign = &#x27;&#x27;;    dividend &gt; 0 ? (dividend = -dividend) : (sign = &#x27;-&#x27;);    divisor &gt; 0 ? (divisor = -divisor) : (sign = sign ? &#x27;&#x27; : &#x27;-&#x27;);    let quotient = 0;    while (dividend) &#123;        let i = 0;        while (            i &lt;= 31 &amp;&amp;            divisor &gt;= (-1 &lt;&lt; (31 - i)) &amp;&amp;            divisor &lt;&lt; i &gt;= dividend &amp;&amp;            ++i        ) &#123;&#125;        if (i === 0) &#123;            break;        &#125;        dividend = dividend - (divisor &lt;&lt; --i);        quotient += 2 ** i;    &#125;    return parseInt(sign + (!sign &amp;&amp; quotient &gt;= 2147483648 ? 2147483647 : quotient));&#125;;\n\n结果执行用时 : 74 ms, 击败 64.44% 使用 JavaScript 的用户\n内存消耗 : 53.24 MB, 击败 5.34% 使用 JavaScript 的用户\n\nTypeScriptfunction divide(a: number, b: number): number &#123;    const sign: number = (Number(a &gt; 0) ^ Number(b &gt; 0)) ? -1 : 1;    let result: number = 0;    if (a === 2 ** 31 - 1 &amp;&amp; b === 1) &#123;        return 2 ** 31 - 1;    &#125;    if (a === -(2 ** 31) &amp;&amp; b === 1) &#123;        return -(2 ** 31);    &#125;    if (a === -(2 ** 31) &amp;&amp; b === -1) &#123;        return 2 ** 31 - 1;    &#125;    if (a === 2 ** 31 - 1 &amp;&amp; b === -1) &#123;        return -(2 ** 31 - 1);    &#125;    a = Math.abs(a);    b = Math.abs(b);    for (let x = 31; x &gt;= 0; x--) &#123;        if ((a &gt;&gt;&gt; x) &gt;= b) &#123;            a -= (b &lt;&lt; x);            result += (1 &lt;&lt; x);        &#125;    &#125;    return sign === 1 ? result : -result;&#125;\n\n结果执行用时 : 98 ms, 击败 7.81% 使用 TypeScript 的用户\n内存消耗 : 53.46 MB, 击败 6.25% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer $dividend     * @param Integer $divisor     * @return Integer     */    function divide($dividend, $divisor) &#123;        $INT_MAX = pow(2, 31) - 1;        $INT_MIN = pow(-2, 31);        if ($dividend === 0) &#123;            return 0;        &#125;        $sign = ($dividend &gt; 0) ^ ($divisor &gt; 0) ? -1 : 1;        $dividend = abs($dividend);        $divisor = abs($divisor);        $quotient = 0;        while ($dividend &gt;= $divisor) &#123;            $tempDivisor = $divisor;            $multiple = 1;            while ($dividend &gt;= $tempDivisor &lt;&lt; 1) &#123;                $tempDivisor &lt;&lt;= 1;                $multiple &lt;&lt;= 1;            &#125;            $dividend -= $tempDivisor;            $quotient += $multiple;        &#125;        $result = $sign * $quotient;        if ($result &gt; $INT_MAX) &#123;            return $INT_MAX;        &#125; elseif ($result &lt; $INT_MIN) &#123;            return $INT_MIN;        &#125;        return $result;    &#125;&#125;\n\n结果执行用时 : 12 ms, 击败 40.00% 使用 PHP 的用户\n内存消耗 : 19.82 MB, 击败 -% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func divide(_ dividend: Int, _ divisor: Int) -&gt; Int &#123;        let INT_MAX = Int32.max        let INT_MIN = Int32.min        if dividend == 0 &#123;            return 0        &#125;        let sign = (dividend &gt; 0) != (divisor &gt; 0) ? -1 : 1        var dividend = abs(dividend)        let divisor = abs(divisor)        var quotient = 0        while dividend &gt;= divisor &#123;            var tempDivisor = divisor            var multiple = 1            while dividend &gt;= tempDivisor &lt;&lt; 1 &#123;                tempDivisor &lt;&lt;= 1                multiple &lt;&lt;= 1            &#125;            dividend -= tempDivisor            quotient += multiple        &#125;        let result = sign * quotient        if result &gt; Int32(INT_MAX) &#123;            return Int(INT_MAX)        &#125; else if result &lt; Int32(INT_MIN) &#123;            return Int(INT_MIN)        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 3 ms, 击败 90.00% 使用 Swift 的用户\n内存消耗 : 15.00 MB, 击败 10.00% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun divide(dividend: Int, divisor: Int): Int &#123;        val INT_MAX = Int.MAX_VALUE        val INT_MIN = Int.MIN_VALUE        if (dividend == 0) &#123;            return 0        &#125;        val sign = (dividend &gt; 0) xor (divisor &gt; 0)        var dividend = Math.abs(dividend.toLong())        val divisor = Math.abs(divisor.toLong())        var quotient = 0L        while (dividend &gt;= divisor) &#123;            var tempDivisor = divisor            var multiple = 1L            while (dividend &gt;= tempDivisor shl 1) &#123;                tempDivisor = tempDivisor shl 1                multiple = multiple shl 1            &#125;            dividend -= tempDivisor            quotient += multiple        &#125;        val result = if (sign) -quotient else quotient        if (result &gt; INT_MAX) &#123;            return INT_MAX        &#125; else if (result &lt; INT_MIN) &#123;            return INT_MIN        &#125;        return result.toInt()    &#125;&#125;\n\n结果执行用时 : 155 ms, 击败 40.00% 使用 Kotlin 的用户\n内存消耗 : 33.58 MB, 击败 8.00% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int divide(int dividend, int divisor) &#123;    const int INT_MAX = 2147483647;    const int INT_MIN = -2147483648;    if (dividend == 0) &#123;      return 0;    &#125;    bool isNegative = (dividend &gt; 0) ^ (divisor &gt; 0);    int longDividend = dividend.abs();    int longDivisor = divisor.abs();    int quotient = 0;    while (longDividend &gt;= longDivisor) &#123;      int tempDivisor = longDivisor;      int multiple = 1;      while (longDividend &gt;= tempDivisor &lt;&lt; 1) &#123;        tempDivisor &lt;&lt;= 1;        multiple &lt;&lt;= 1;      &#125;      longDividend -= tempDivisor;      quotient += multiple;    &#125;    int result = isNegative ? -quotient : quotient;    if (result &gt; INT_MAX) &#123;      return INT_MAX;    &#125; else if (result &lt; INT_MIN) &#123;      return INT_MIN;    &#125;    return result;  &#125;&#125;\n\n结果执行用时 : 327 ms, 击败 50.00% 使用 Dart 的用户\n内存消耗 : 147.92 MB, 击败 50.00% 使用 Dart 的用户\n\nGofunc divide(dividend int, divisor int) int &#123;\tconst INT_MAX = int(^uint32(0) &gt;&gt; 1)\tconst INT_MIN = ^INT_MAX\tif dividend == 0 &#123;\t\treturn 0\t&#125;\tisNegative := (dividend &gt; 0) != (divisor &gt; 0)\tlongDividend := abs(dividend)\tlongDivisor := abs(divisor)\tquotient := 0\tfor longDividend &gt;= longDivisor &#123;\t\ttempDivisor := longDivisor\t\tmultiple := 1\t\tfor longDividend &gt;= tempDivisor&lt;&lt;1 &#123;\t\t\ttempDivisor &lt;&lt;= 1\t\t\tmultiple &lt;&lt;= 1\t\t&#125;\t\tlongDividend -= tempDivisor\t\tquotient += multiple\t&#125;\tresult := quotient\tif isNegative &#123;\t\tresult = -quotient\t&#125;\tif result &gt; INT_MAX &#123;\t\treturn INT_MAX\t&#125; else if result &lt; INT_MIN &#123;\t\treturn INT_MIN\t&#125;\treturn result&#125;func abs(n int) int &#123;\tif n &lt; 0 &#123;\t\treturn -n\t&#125;\treturn n&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.20 MB, 击败 69.90% 使用 Go 的用户\n\nRuby# @param &#123;Integer&#125; dividend# @param &#123;Integer&#125; divisor# @return &#123;Integer&#125;def divide(dividend, divisor)  int_max = (2**31 - 1)  int_min = -(2**31)  return 0 if dividend == 0  is_negative = (dividend &gt; 0) ^ (divisor &gt; 0)  long_dividend = dividend.abs  long_divisor = divisor.abs  quotient = 0  while long_dividend &gt;= long_divisor    temp_divisor = long_divisor    multiple = 1    while long_dividend &gt;= temp_divisor &lt;&lt; 1      temp_divisor &lt;&lt;= 1      multiple &lt;&lt;= 1    end    long_dividend -= temp_divisor    quotient += multiple  end  result = is_negative ? -quotient : quotient  if result &gt; int_max    return int_max  elsif result &lt; int_min    return int_min  end  resultend\n\n结果执行用时 : 59 ms, 击败 75.00% 使用 Ruby 的用户\n内存消耗 : 206.44 MB, 击败 -% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def divide(dividend: Int, divisor: Int): Int = &#123;    val INT_MAX = Int.MaxValue    val INT_MIN = Int.MinValue    if (dividend == INT_MIN) &#123;      if (divisor == 1) return INT_MIN      else if (divisor == -1) return INT_MAX    &#125;    if (divisor == 0) return 0    var rev = false    var dividendVar = dividend    var divisorVar = divisor    if (dividend &gt; 0) &#123;      dividendVar = -dividend      rev = !rev    &#125;    if (divisor &gt; 0) &#123;      divisorVar = -divisor      rev = !rev    &#125;    var left = 1    var right = INT_MAX    var ans = 0    while (left &lt;= right) &#123;      val mid = left + ((right - left) &gt;&gt; 1)      val check = quickAdd(divisorVar, mid, dividendVar)      if (check) &#123;        ans = mid        if (mid == INT_MAX) &#123;          return if (rev) -ans else ans        &#125;        left = mid + 1      &#125; else &#123;        right = mid - 1      &#125;    &#125;    if (rev) -ans else ans  &#125;  def quickAdd(y: Int, z: Int, x: Int): Boolean = &#123;    var result = 0    var add = y    var zVar = z    while (zVar != 0) &#123;      if ((zVar &amp; 1) != 0) &#123;        if (result &lt; x - add) &#123;          return false        &#125;        result += add      &#125;      if (zVar != 1) &#123;        if (add &lt; x - add) &#123;          return false        &#125;        add += add      &#125;      zVar &gt;&gt;= 1    &#125;    true  &#125;&#125;\n\n结果执行用时 : 440 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 51.39 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn divide(dividend: i32, divisor: i32) -&gt; i32 &#123;        const INT_MAX: i32 = i32::MAX;        const INT_MIN: i32 = i32::MIN;        if dividend == INT_MIN &#123;            if divisor == 1 &#123;                return INT_MIN;            &#125; else if divisor == -1 &#123;                return INT_MAX;            &#125;        &#125;        if divisor == 0 &#123;            return 0;        &#125;        let mut rev = false;        let mut dividend_var = dividend;        let mut divisor_var = divisor;        if dividend &gt; 0 &#123;            dividend_var = -dividend;            rev = !rev;        &#125;        if divisor &gt; 0 &#123;            divisor_var = -divisor;            rev = !rev;        &#125;        let mut left = 1;        let mut right = INT_MAX;        let mut ans = 0;        while left &lt;= right &#123;            let mid = left + ((right - left) &gt;&gt; 1);            let check = Solution::quick_add(divisor_var, mid, dividend_var);            if check &#123;                ans = mid;                if mid == INT_MAX &#123;                    return if rev &#123; -ans &#125; else &#123; ans &#125;;                &#125;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        if rev &#123;            -ans        &#125; else &#123;            ans        &#125;    &#125;    fn quick_add(y: i32, z: i32, x: i32) -&gt; bool &#123;        let mut result = 0;        let mut add = y;        let mut z_var = z;        while z_var != 0 &#123;            if z_var &amp; 1 != 0 &#123;                if result &lt; x - add &#123;                    return false;                &#125;                result += add;            &#125;            if z_var != 1 &#123;                if add &lt; x - add &#123;                    return false;                &#125;                add += add;            &#125;            z_var &gt;&gt;= 1;        &#125;        true    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.14 MB, 击败 18.92% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00030.串联所有单词的子串","url":"/zh-CN/0ee3b09121e9/","content":"\n题目描述给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。\n s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。\n\n例如，如果 words &#x3D; [“ab”,”cd”,”ef”]， 那么 “abcdef”， “abefcd”，”cdabef”， “cdefab”，”efabcd”， 和 “efcdab” 都是串联子串。 “acdbef” 不是串联子串，因为他不是任何 words 排列的连接。\n\n返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。\n示例 1：\n输入：s &#x3D; “barfoothefoobarman”, words &#x3D; [“foo”,”bar”]输出：[0,9]解释：因为 words.length &#x3D;&#x3D; 2 同时 words[i].length &#x3D;&#x3D; 3，连接的子字符串的长度必须为 6。子串 “barfoo” 开始位置是 0。它是 words 中以 [“bar”,”foo”] 顺序排列的连接。子串 “foobar” 开始位置是 9。它是 words 中以 [“foo”,”bar”] 顺序排列的连接。输出顺序无关紧要。返回 [9,0] 也是可以的。\n\n示例 2：\n输入：s &#x3D; “wordgoodgoodgoodbestword”, words &#x3D; [“word”,”good”,”best”,”word”]输出：[]解释：因为 words.length &#x3D;&#x3D; 4 并且 words[i].length &#x3D;&#x3D; 4，所以串联子串的长度必须为 16。s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。所以我们返回一个空数组。\n\n示例 3：\n输入：s &#x3D; “barfoofoobarthefoobarman”, words &#x3D; [“bar”,”foo”,”the”]输出：[6,9,12]解释：因为 words.length &#x3D;&#x3D; 3 并且 words[i].length &#x3D;&#x3D; 3，所以串联子串的长度必须为 9。子串 “foobarthe” 开始位置是 6。它是 words 中以 [“foo”,”bar”,”the”] 顺序排列的连接。子串 “barthefoo” 开始位置是 9。它是 words 中以 [“bar”,”the”,”foo”] 顺序排列的连接。子串 “thefoobar” 开始位置是 12。它是 words 中以 [“the”,”foo”,”bar”] 顺序排列的连接。\n\n提示：\n$1 &lt;&#x3D; s.length &lt;&#x3D; 10^4$\n1 &lt;&#x3D; words.length &lt;&#x3D; 5000\n1 &lt;&#x3D; words[i].length &lt;&#x3D; 30\nwords[i] 和 s 由小写英文字母组成\n\n\n解决方法C++class Solution &#123;public:    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123;        vector&lt;int&gt; result;        if (s.empty() || words.empty()) &#123;            return result;        &#125;        int wordLen = words[0].length();        int totalLen = words.size() * wordLen;        unordered_map&lt;string, int&gt; wordCount;        for (const string&amp; word : words) &#123;            wordCount[word]++;        &#125;        for (int i = 0; i &lt; wordLen; ++i) &#123;            int left = i, right = i;            unordered_map&lt;string, int&gt; currentCount;            while (right + wordLen &lt;= s.length()) &#123;                string currentWord = s.substr(right, wordLen);                right += wordLen;                currentCount[currentWord]++;                while (currentCount[currentWord] &gt; wordCount[currentWord]) &#123;                    string leftWord = s.substr(left, wordLen);                    left += wordLen;                    currentCount[leftWord]--;                &#125;                if (right - left == totalLen) &#123;                    result.push_back(left);                &#125;            &#125;        &#125;        return result;    &#125;&#125;;\n\n结果执行用时 : 105 ms, 击败 21.11% 使用 C++ 的用户\n内存消耗 : 48.18 MB, 击败 9.14% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        if (s == null || s.isEmpty() || words == null || words.length == 0) &#123;            return result;        &#125;        int wordLen = words[0].length();        int totalLen = words.length * wordLen;        Map&lt;String, Integer&gt; wordCount = new HashMap&lt;&gt;();        for (String word : words) &#123;            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);        &#125;        for (int i = 0; i &lt; wordLen; i++) &#123;            int left = i, right = i;            Map&lt;String, Integer&gt; currentCount = new HashMap&lt;&gt;();            while (right + wordLen &lt;= s.length()) &#123;                String currentWord = s.substring(right, right + wordLen);                right += wordLen;                currentCount.put(currentWord, currentCount.getOrDefault(currentWord, 0) + 1);                while (currentCount.get(currentWord) &gt; wordCount.getOrDefault(currentWord, 0)) &#123;                    String leftWord = s.substring(left, left + wordLen);                    left += wordLen;                    currentCount.put(leftWord, currentCount.get(leftWord) - 1);                &#125;                if (right - left == totalLen) &#123;                    result.add(left);                &#125;            &#125;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 22 ms, 击败 54.43% 使用 Java 的用户\n内存消耗 : 44.55 MB, 击败 24.02% 使用 Java 的用户\n\nPythonclass Solution(object):    def findSubstring(self, s, words):        &quot;&quot;&quot;        :type s: str        :type words: List[str]        :rtype: List[int]        &quot;&quot;&quot;        result = []        if not s or not words:            return result        word_len = len(words[0])        total_len = len(words) * word_len        word_count = Counter(words)        for i in range(word_len):            left, right = i, i            current_count = Counter()            while right + word_len &lt;= len(s):                current_word = s[right:right + word_len]                right += word_len                current_count[current_word] += 1                while current_count[current_word] &gt; word_count[current_word]:                    left_word = s[left:left + word_len]                    left += word_len                    current_count[left_word] -= 1                if right - left == total_len:                    result.append(left)        return result\n\n结果执行用时 : 117 ms, 击败 65.90% 使用 Python 的用户\n内存消耗 : 11.96 MB, 击败 97.05% 使用 Python 的用户\n\nPython3class Solution:    def findSubstring(self, s: str, words: List[str]) -&gt; List[int]:        result = []        if not s or not words:            return result        word_len = len(words[0])        total_len = len(words) * word_len        word_count = Counter(words)        for i in range(word_len):            left, right = i, i            current_count = Counter()            while right + word_len &lt;= len(s):                current_word = s[right:right + word_len]                right += word_len                current_count[current_word] += 1                while current_count[current_word] &gt; word_count[current_word]:                    left_word = s[left:left + word_len]                    left += word_len                    current_count[left_word] -= 1                if right - left == total_len:                    result.append(left)        return result\n\n结果执行用时 : 104 ms, 击败 76.85% 使用 Python3 的用户\n内存消耗 : 17.09 MB, 击败 38.99% 使用 Python3 的用户\n\nC/** * Note: The returned array must be malloced, assume caller calls free(). */typedef struct &#123;    char key[32];    int val;    UT_hash_handle hh;&#125; HashItem;int* findSubstring(char * s, char ** words, int wordsSize, int* returnSize)&#123;        int m = wordsSize, n = strlen(words[0]), ls = strlen(s);    int *res = (int *)malloc(sizeof(int) * ls);    int pos = 0;    for (int i = 0; i &lt; n; i++) &#123;        if (i + m * n &gt; ls) &#123;            break;        &#125;        HashItem *diff = NULL;        char word[32] = &#123;0&#125;;        for (int j = 0; j &lt; m; j++) &#123;            snprintf(word, n + 1, &quot;%s&quot;, s + i + j * n);            HashItem * pEntry = NULL;            HASH_FIND_STR(diff, word, pEntry);            if (NULL == pEntry) &#123;                pEntry = (HashItem *)malloc(sizeof(HashItem));                strcpy(pEntry-&gt;key, word);                pEntry-&gt;val = 0;                HASH_ADD_STR(diff, key, pEntry);            &#125;             pEntry-&gt;val++;                    &#125;        for (int j = 0; j &lt; m; j++) &#123;            HashItem * pEntry = NULL;            HASH_FIND_STR(diff, words[j], pEntry);            if (NULL == pEntry) &#123;                pEntry = (HashItem *)malloc(sizeof(HashItem));                strcpy(pEntry-&gt;key, words[j]);                pEntry-&gt;val = 0;                HASH_ADD_STR(diff, key, pEntry);            &#125;             pEntry-&gt;val--;            if (pEntry-&gt;val == 0) &#123;                HASH_DEL(diff, pEntry);                free(pEntry);            &#125;        &#125;        for (int start = i; start &lt; ls - m * n + 1; start += n) &#123;            if (start != i) &#123;                char word[32];                snprintf(word, n + 1, &quot;%s&quot;, s + start + (m - 1) * n);                HashItem * pEntry = NULL;                HASH_FIND_STR(diff, word, pEntry);                if (NULL == pEntry) &#123;                    pEntry = (HashItem *)malloc(sizeof(HashItem));                    strcpy(pEntry-&gt;key, word);                    pEntry-&gt;val = 0;                    HASH_ADD_STR(diff, key, pEntry);                &#125;                 pEntry-&gt;val++;                if (pEntry-&gt;val == 0) &#123;                    HASH_DEL(diff, pEntry);                    free(pEntry);                &#125;                snprintf(word, n + 1, &quot;%s&quot;, s + start - n);                pEntry = NULL;                HASH_FIND_STR(diff, word, pEntry);                if (NULL == pEntry) &#123;                    pEntry = (HashItem *)malloc(sizeof(HashItem));                    strcpy(pEntry-&gt;key, word);                    pEntry-&gt;val = 0;                    HASH_ADD_STR(diff, key, pEntry);                &#125;                 pEntry-&gt;val--;                if (pEntry-&gt;val == 0) &#123;                    HASH_DEL(diff, pEntry);                    free(pEntry);                &#125;            &#125;            if (HASH_COUNT(diff) == 0) &#123;                res[pos++] = start;            &#125;        &#125;        HashItem *curr, *tmp;        HASH_ITER(hh, diff, curr, tmp) &#123;            HASH_DEL(diff, curr);              free(curr);              &#125;    &#125;    *returnSize = pos;    return res;&#125;\n\n结果执行用时 : 998 ms, 击败 50.36% 使用 C 的用户\n内存消耗 : 28.31 MB, 击败 41.85% 使用 C 的用户\n\nC#public class Solution &#123;    public IList&lt;int&gt; FindSubstring(string s, string[] words) &#123;        List&lt;int&gt; result = new List&lt;int&gt;();        if (string.IsNullOrEmpty(s) || words == null || words.Length == 0) &#123;            return result;        &#125;        int wordLen = words[0].Length;        int totalLen = wordLen * words.Length;        int wordCount = words.Length;        Dictionary&lt;string, int&gt; wordCounts = new Dictionary&lt;string, int&gt;();        foreach (string word in words) &#123;            if (wordCounts.ContainsKey(word)) &#123;                wordCounts[word]++;            &#125; else &#123;                wordCounts[word] = 1;            &#125;        &#125;        for (int i = 0; i &lt;= s.Length - totalLen; i++) &#123;            Dictionary&lt;string, int&gt; currentWordCounts = new Dictionary&lt;string, int&gt;(wordCounts);            int j;            for (j = 0; j &lt; totalLen; j += wordLen) &#123;                string currentWord = s.Substring(i + j, wordLen);                if (currentWordCounts.ContainsKey(currentWord) &amp;&amp; currentWordCounts[currentWord] &gt; 0) &#123;                    currentWordCounts[currentWord]--;                &#125; else &#123;                    break;                &#125;            &#125;            if (j == totalLen) &#123;                result.Add(i);            &#125;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 1752 ms, 击败 31.63% 使用 C# 的用户\n内存消耗 : 68.71 MB, 击败 15.31% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; s * @param &#123;string[]&#125; words * @return &#123;number[]&#125; */var findSubstring = function(s, words) &#123;    let result = [];    if (!s || !words || words.length === 0) &#123;        return result;    &#125;    let wordLen = words[0].length;    let totalLen = wordLen * words.length;    let wordCount = words.length;    let wordCounts = new Map();    for (let word of words) &#123;        if (wordCounts.has(word)) &#123;            wordCounts.set(word, wordCounts.get(word) + 1);        &#125; else &#123;            wordCounts.set(word, 1);        &#125;    &#125;    for (let i = 0; i &lt;= s.length - totalLen; i++) &#123;        let currentWordCounts = new Map(wordCounts);        for (let j = 0; j &lt; totalLen; j += wordLen) &#123;            let currentWord = s.substring(i + j, i + j + wordLen);            if (currentWordCounts.has(currentWord) &amp;&amp; currentWordCounts.get(currentWord) &gt; 0) &#123;                currentWordCounts.set(currentWord, currentWordCounts.get(currentWord) - 1);            &#125; else &#123;                break;            &#125;        &#125;        if (Array.from(currentWordCounts.values()).every(count =&gt; count === 0)) &#123;            result.push(i);        &#125;    &#125;    return result;&#125;;\n\n结果执行用时 : 907 ms, 击败 54.95% 使用 JavaScript 的用户\n内存消耗 : 56.55 MB, 击败 16.64% 使用 JavaScript 的用户\n\nTypeScriptfunction findSubstring(s: string, words: string[]): number[] &#123;    const result: number[] = [];    if (!s || !words || words.length === 0) &#123;        return result;    &#125;    const wordLen: number = words[0].length;    const totalLen: number = wordLen * words.length;    const wordCount: number = words.length;    const wordCounts: Map&lt;string, number&gt; = new Map();    for (const word of words) &#123;        if (wordCounts.has(word)) &#123;            wordCounts.set(word, wordCounts.get(word)! + 1);        &#125; else &#123;            wordCounts.set(word, 1);        &#125;    &#125;    for (let i = 0; i &lt;= s.length - totalLen; i++) &#123;        const currentWordCounts: Map&lt;string, number&gt; = new Map(wordCounts);        for (let j = 0; j &lt; totalLen; j += wordLen) &#123;            const currentWord: string = s.substring(i + j, i + j + wordLen);            if (currentWordCounts.has(currentWord) &amp;&amp; currentWordCounts.get(currentWord)! &gt; 0) &#123;                currentWordCounts.set(currentWord, currentWordCounts.get(currentWord)! - 1);            &#125; else &#123;                break;            &#125;        &#125;        if (Array.from(currentWordCounts.values()).every(count =&gt; count === 0)) &#123;            result.push(i);        &#125;    &#125;    return result;&#125;\n\n结果执行用时 : 874 ms, 击败 73.21% 使用 TypeScript 的用户\n内存消耗 : 57.38 MB, 击败 6.25% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String $s     * @param String[] $words     * @return Integer[]     */    function findSubstring($s, $words) &#123;        $result = [];        if (empty($s) || empty($words)) &#123;            return $result;        &#125;        $wordLen = strlen($words[0]);        $totalLen = $wordLen * count($words);        $wordCount = count($words);        $wordCounts = [];        foreach ($words as $word) &#123;            if (isset($wordCounts[$word])) &#123;                $wordCounts[$word]++;            &#125; else &#123;                $wordCounts[$word] = 1;            &#125;        &#125;        for ($i = 0; $i &lt;= strlen($s) - $totalLen; $i++) &#123;            $currentWordCounts = $wordCounts;            for ($j = 0; $j &lt; $totalLen; $j += $wordLen) &#123;                $currentWord = substr($s, $i + $j, $wordLen);                if (isset($currentWordCounts[$currentWord]) &amp;&amp; $currentWordCounts[$currentWord] &gt; 0) &#123;                    $currentWordCounts[$currentWord]--;                &#125; else &#123;                    break;                &#125;            &#125;            if (array_sum($currentWordCounts) === 0) &#123;                $result[] = $i;            &#125;        &#125;        return $result;    &#125;&#125;\n\n结果执行用时 : 1420 ms, 击败 100.00% 使用 PHP 的用户\n内存消耗 : 20.54 MB, 击败 -% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func findSubstring(_ s: String, _ words: [String]) -&gt; [Int] &#123;        guard !s.isEmpty, !words.isEmpty, !words[0].isEmpty else &#123;            return []        &#125;        let wordLength = words[0].count        let wordCount = words.count        let totalLength = wordLength * wordCount        let sArray = Array(s)        var results: [Int] = []        var wordsDict: [String: Int] = [:]        for word in words &#123;            wordsDict[word, default: 0] += 1        &#125;        for i in 0..&lt;wordLength &#123;            var left = i            var right = i            var currentDict: [String: Int] = [:]            var valid = 0            while right + wordLength &lt;= s.count &#123;                let currentWord = String(sArray[right..&lt;right + wordLength])                right += wordLength                if let count = currentDict[currentWord] &#123;                    currentDict[currentWord] = count + 1                    if count + 1 == wordsDict[currentWord] &#123;                        valid += 1                    &#125;                &#125;                while right - left &gt;= totalLength &#123;                    if valid == wordsDict.count &#123;                        results.append(left)                    &#125;                    let leftWord = String(sArray[left..&lt;left + wordLength])                    left += wordLength                    if let count = currentDict[leftWord] &#123;                        if count == wordsDict[leftWord] &#123;                            valid -= 1                        &#125;                        currentDict[leftWord] = count - 1                    &#125;                &#125;            &#125;        &#125;        return results    &#125;&#125;\n\n结果执行用时 : 272 ms, 击败 25.00% 使用 Swift 的用户\n内存消耗 : 16.11 MB, 击败 8.33% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun findSubstring(s: String, words: Array&lt;String&gt;): List&lt;Int&gt; &#123;        val result = mutableListOf&lt;Int&gt;()        if (s.isEmpty() || words.isEmpty() || s.length &lt; words[0].length || s.length &lt; words[0].length * words.size) &#123;            return result        &#125;        val wn = words[0].length        val count = words.groupBy &#123; it &#125;.mapValues &#123; it.value.size &#125;        val wordFreq = IntArray(count.size)        val uniqWords = count.keys.toList()        uniqWords.forEachIndexed &#123; index, w -&gt; wordFreq[index] = count[w]!! &#125;        val matchIndex = IntArray(s.length) &#123; -1 &#125;        ACTree(uniqWords).match(s) &#123; pos, strIndex, _ -&gt; matchIndex[pos] = strIndex &#125;        val freq = wordFreq.clone()        for (i in 0 until wn) &#123;            var j = i            while (j &lt; matchIndex.size &amp;&amp; matchIndex[j] == -1) j += wn            var dist = words.size            var left = j            var right = j            wordFreq.copyInto(freq)            while (right &lt; matchIndex.size) &#123;                if (matchIndex[right] == -1) &#123;                    right += wn                    left = right                    dist = words.size                    wordFreq.copyInto(freq)                    continue                &#125;                if (--freq[matchIndex[right]] &gt;= 0) dist--                right += wn                while (dist == 0) &#123;                    if (right - left == words.size * wn) &#123;                        result.add(left)                    &#125;                    if (++freq[matchIndex[left]] &gt; 0) dist++                    left += wn                &#125;            &#125;        &#125;        return result    &#125;    class ACTree(val strs: List&lt;String&gt;) &#123;        val root = AcNode(&#x27;a&#x27;)        init &#123;            strs.forEachIndexed &#123; i, it -&gt; putString(i, it) &#125;            buildFailurePointer()        &#125;        class AcNode(var data: Char) &#123;            val children = arrayOfNulls&lt;AcNode&gt;(26)            var isEndingChar = false            var length = 0            var fail: AcNode? = null            var strIndex = 0        &#125;        private fun putString(index: Int, str: String) &#123;            var p = root            str.forEach &#123;                val next = p.children[it - &#x27;a&#x27;]                if (next != null) &#123;                    p = next                &#125; else &#123;                    val new = AcNode(it)                    new.length = p.length + 1                    p.children[it - &#x27;a&#x27;] = new                    p = new                &#125;            &#125;            p.isEndingChar = true            p.strIndex = index        &#125;        private fun buildFailurePointer() &#123;            val queue: Queue&lt;AcNode&gt; = LinkedList()            root.fail = null            queue.add(root)            while (queue.isNotEmpty()) &#123;                val p: AcNode = queue.remove()                for (i in 0..25) &#123;                    val pc = p.children[i] ?: continue                    if (p == root) &#123;                        pc.fail = root                    &#125; else &#123;                        var q = p.fail                        while (q != null) &#123;                            val qc = q.children[pc.data - &#x27;a&#x27;]                            if (qc != null) &#123;                                pc.fail = qc                                break                            &#125;                            q = q.fail                        &#125;                        if (q == null) &#123;                            pc.fail = root                        &#125;                    &#125;                    queue.add(pc)                &#125;            &#125;        &#125;        fun match(text: String, action: (pos: Int, strIndex: Int, str: String) -&gt; Unit) &#123;            val n = text.length            var p: AcNode? = root            for (i in 0 until n) &#123;                val idx = text[i] - &#x27;a&#x27;                while (p!!.children[idx] == null &amp;&amp; p != root) &#123;                    p = p.fail                &#125;                p = p.children[idx]                if (p == null) p = root                var tmp = p                while (tmp != root) &#123;                    if (tmp!!.isEndingChar) &#123;                        val pos = i - tmp.length + 1                        action(pos, tmp.strIndex, strs[tmp.strIndex])                    &#125;                    tmp = tmp.fail                &#125;            &#125;        &#125;    &#125;&#125;\n\n结果执行用时 : 242 ms, 击败 80.00% 使用 Kotlin 的用户\n内存消耗 : 39.90 MB, 击败 60.00% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;int&gt; findSubstring(String s, List&lt;String&gt; words) &#123;    var wordMap = &lt;String, int&gt;&#123;&#125;;    for (String word in words) &#123;      wordMap.putIfAbsent(word, () =&gt; wordMap.length);    &#125;    var wordCounts = List&lt;int&gt;.filled(wordMap.length, 0);    for (String word in words) &#123;      wordCounts[wordMap[word]!]++;    &#125;    var result = &lt;int&gt;[];    int sLen = s.length;    int wordNum = words.length;    int wordLen = words[0].length;    int len = wordLen * wordNum;    for (int i = 0; i &lt; wordLen; i++) &#123;      for (int j = i; j &lt;= sLen - len; j += wordLen) &#123;        var windowCounts = List&lt;int&gt;.filled(wordMap.length, 0);        for (int k = wordNum - 1; k &gt;= 0; k--) &#123;          int begin = j + k * wordLen;          String word = s.substring(begin, begin + wordLen);          int index = wordMap[word] ?? -1;          if (index == -1 || windowCounts[index]++ == wordCounts[index]) &#123;            j = begin;            break;          &#125;          if (k == 0) &#123;            result.add(j);          &#125;        &#125;      &#125;    &#125;    return result;  &#125;&#125;\n\n结果执行用时 : 821 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 145.20 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc findSubstring(s string, words []string) []int &#123;    var result []int    wordMap := make(map[string]int)    if len(words) == 0 || len(words[0]) == 0 || len(s) &lt; len(words)*len(words[0]) &#123;        return result    &#125;    wordLen, wordNum := len(words[0]), len(words)    totalLen := wordLen * wordNum    for _, word := range words &#123;        wordMap[word]++    &#125;    for i := 0; i &lt; wordLen; i++ &#123;        left, right := i, i        window := make(map[string]int)        for right+wordLen &lt;= len(s) &#123;            currentWord := s[right : right+wordLen]            right += wordLen            window[currentWord]++            for window[currentWord] &gt; wordMap[currentWord] &#123;                leftWord := s[left : left+wordLen]                left += wordLen                window[leftWord]--            &#125;            if right-left == totalLen &#123;                result = append(result, left)            &#125;        &#125;    &#125;    return result&#125;\n\n结果执行用时 : 8 ms, 击败 91.82% 使用 Go 的用户\n内存消耗 : 6.72 MB, 击败 33.56% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; s# @param &#123;String[]&#125; words# @return &#123;Integer[]&#125;def find_substring(s, words)  result = []  word_map = Hash.new(0)  return result if words.empty? || words[0].empty? || s.length &lt; words.length * words[0].length  word_len, word_num = words[0].length, words.length  total_len = word_len * word_num  words.each &#123; |word| word_map[word] += 1 &#125;  (0...word_len).each do |i|    left = i    right = i    window = Hash.new(0)    while right + word_len &lt;= s.length      current_word = s[right, word_len]      right += word_len      window[current_word] += 1      while window[current_word] &gt; word_map[current_word]        left_word = s[left, word_len]        left += word_len        window[left_word] -= 1      end      result &lt;&lt; left if right - left == total_len    end  end  resultend\n\n结果执行用时 : 136 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 208.04 MB, 击败 100.00% 使用 Ruby 的用户\n\nScalaimport scala.collection.mutable.ListBufferobject Solution &#123;  def findSubstring(s: String, words: Array[String]): List[Int] = &#123;    var result = ListBuffer[Int]()    if (s.isEmpty || words.isEmpty || s.length &lt; words(0).length * words.length) &#123;      return result.toList    &#125;    val wordLen = words(0).length    val wordNum = words.length    val totalLen = wordLen * wordNum    val wordMap = words.groupBy(identity).mapValues(_.length)    for (i &lt;- 0 until wordLen) &#123;      var left = i      var right = i      var window = scala.collection.mutable.Map[String, Int]().withDefaultValue(0)      while (right + wordLen &lt;= s.length) &#123;        val currentWord = s.substring(right, right + wordLen)        right += wordLen        window(currentWord) += 1        while (window(currentWord) &gt; wordMap.getOrElse(currentWord, 0)) &#123;          val leftWord = s.substring(left, left + wordLen)          left += wordLen          window(leftWord) -= 1        &#125;        if (right - left == totalLen) &#123;          result += left        &#125;      &#125;    &#125;    result.toList  &#125;&#125;\n\n结果执行用时 : 663 ms, 击败 88.89% 使用 Scala 的用户\n内存消耗 : 55.71 MB, 击败 88.89% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn find_substring(s: String, words: Vec&lt;String&gt;) -&gt; Vec&lt;i32&gt; &#123;        use std::collections::HashMap;        macro_rules! update_diff &#123;            ($diff:expr, $s:expr, $cnt:expr) =&gt; &#123;                let t = $s as &amp;str;                *$diff.entry(t).or_insert(0) += $cnt;                if *$diff.get(t).unwrap() == 0 &#123;                    $diff.remove(t);                &#125;            &#125;;        &#125;        let mut diff = HashMap::new();        let (m, n) = (words.len(), words[0].len());        let mut ans = vec![];        for idx in 0..n &#123;            if idx + m * n &gt; s.len() &#123;                break;            &#125;            for i in (idx..idx + m * n).step_by(n) &#123;                update_diff!(diff, &amp;s[i..i + n], 1);            &#125;            for w in words.iter() &#123;                update_diff!(diff, w, -1);            &#125;            if diff.is_empty() &#123;                ans.push(idx as i32);            &#125;            for i in (idx + n..s.len() - m * n + 1).step_by(n) &#123;                update_diff!(diff, &amp;s[i - n..i], -1);                update_diff!(diff, &amp;s[i + (m - 1) * n..i + m * n], 1);                if diff.is_empty() &#123;                    ans.push(i as i32);                &#125;            &#125;            diff.clear();        &#125;        ans    &#125;&#125;\n\n结果执行用时 : 7 ms, 击败 93.94% 使用 Rust 的用户\n内存消耗 : 2.39 MB, 击败 84.85% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\n暂时未解决\nErlang\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00031.下一个排列","url":"/zh-CN/fba29e87c235/","content":"\n题目描述整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。\n\n例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。\n\n整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\n\n例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。\n类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。\n而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。\n\n给你一个整数数组 nums ，找出 nums 的下一个排列。\n必须 原地 修改，只允许使用额外常数空间。\n示例 1：\n输入：nums &#x3D; [1,2,3]输出：[1,3,2]\n\n示例 2：\n输入：nums &#x3D; [3,2,1]输出：[1,2,3]\n\n示例 3：\n输入：nums &#x3D; [1,1,5]输出：[1,5,1]\n\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 100\n0 &lt;&#x3D; nums[i] &lt;&#x3D; 100\n\n\n解决方法C++class Solution &#123;public:    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;        int i = nums.size() - 2;        while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;            i--;        &#125;        if (i == -1) &#123;            reverse(nums.begin(), nums.end());            return;        &#125;        int j = nums.size() - 1;        while (nums[j] &lt;= nums[i]) &#123;            j--;        &#125;        swap(nums[i], nums[j]);        reverse(nums.begin() + i + 1, nums.end());    &#125;&#125;;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C++ 的用户\n内存消耗 : 14.27 MB, 击败 5.56% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public void nextPermutation(int[] nums) &#123;        int i = nums.length - 2;        while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;            i--;        &#125;        if (i == -1) &#123;            reverse(nums, 0, nums.length - 1);            return;        &#125;        int j = nums.length - 1;        while (nums[j] &lt;= nums[i]) &#123;            j--;        &#125;        swap(nums, i, j);        reverse(nums, i + 1, nums.length - 1);    &#125;    private void swap(int[] nums, int i, int j) &#123;        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    &#125;    private void reverse(int[] nums, int start, int end) &#123;        while (start &lt; end) &#123;            swap(nums, start, end);            start++;            end--;        &#125;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 42.07 MB, 击败 22.67% 使用 Java 的用户\n\nPythonclass Solution(object):    def nextPermutation(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: None Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        i = len(nums) - 2        while i &gt;= 0 and nums[i] &gt;= nums[i + 1]:            i -= 1        if i == -1:            nums.reverse()            return        j = len(nums) - 1        while nums[j] &lt;= nums[i]:            j -= 1        nums[i], nums[j] = nums[j], nums[i]        nums[i + 1:] = reversed(nums[i + 1:])\n\n结果执行用时 : 7 ms, 击败 99.57% 使用 Python 的用户\n内存消耗 : 11.38 MB, 击败 96.34% 使用 Python 的用户\n\nPython3class Solution:    def nextPermutation(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        i = len(nums) - 2        while i &gt;= 0 and nums[i] &gt;= nums[i + 1]:            i -= 1        if i == -1:            nums.reverse()            return        j = len(nums) - 1        while nums[j] &lt;= nums[i]:            j -= 1        nums[i], nums[j] = nums[j], nums[i]        nums[i + 1:] = reversed(nums[i + 1:])\n\n结果执行用时 : 32 ms, 击败 96.03% 使用 Python3 的用户\n内存消耗 : 16.47 MB, 击败 30.51% 使用 Python3 的用户\n\nCvoid swap(int* a, int* b) &#123;    int temp = *a;    *a = *b;    *b = temp;&#125;void reverse(int* nums, int start, int end) &#123;    while (start &lt; end) &#123;        swap(&amp;nums[start], &amp;nums[end]);        start++;        end--;    &#125;&#125;void nextPermutation(int* nums, int numsSize) &#123;    int i = numsSize - 2;    while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;        i--;    &#125;    if (i == -1) &#123;        reverse(nums, 0, numsSize - 1);        return;    &#125;    int j = numsSize - 1;    while (nums[j] &lt;= nums[i]) &#123;        j--;    &#125;    swap(&amp;nums[i], &amp;nums[j]);    reverse(nums, i + 1, numsSize - 1);&#125;\n\n结果执行用时 : 3 ms, 击败 97.42% 使用 C 的用户\n内存消耗 : 6.12 MB, 击败 92.04% 使用 C 的用户\n\nC#public class Solution &#123;    public void NextPermutation(int[] nums) &#123;        int i = nums.Length - 2;        while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;            i--;        &#125;        if (i == -1) &#123;            Array.Reverse(nums);            return;        &#125;        int j = nums.Length - 1;        while (nums[j] &lt;= nums[i]) &#123;            j--;        &#125;        Swap(nums, i, j);        Array.Reverse(nums, i + 1, nums.Length - i - 1);    &#125;    private void Swap(int[] nums, int i, int j) &#123;        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    &#125;&#125;\n\n结果执行用时 : 100 ms, 击败 83.33% 使用 C# 的用户\n内存消耗 : 46.14 MB, 击败 5.88% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var nextPermutation = function(nums) &#123;    let i = nums.length - 2;    while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;        i--;    &#125;    if (i === -1) &#123;        nums.reverse();        return;    &#125;    let j = nums.length - 1;    while (nums[j] &lt;= nums[i]) &#123;        j--;    &#125;    [nums[i], nums[j]] = [nums[j], nums[i]];    reverse(nums, i + 1);&#125;;function reverse(nums, start) &#123;    let end = nums.length - 1;    while (start &lt; end) &#123;        [nums[start], nums[end]] = [nums[end], nums[start]];        start++;        end--;    &#125;&#125;\n\n结果执行用时 : 72 ms, 击败 42.58% 使用 JavaScript 的用户\n内存消耗 : 51.04 MB, 击败 5.08% 使用 JavaScript 的用户\n\nTypeScript/** Do not return anything, modify nums in-place instead. */function nextPermutation(nums: number[]): void &#123;    let i = nums.length - 2;    while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;        i--;    &#125;    if (i === -1) &#123;        nums.reverse();        return;    &#125;    let j = nums.length - 1;    while (nums[j] &lt;= nums[i]) &#123;        j--;    &#125;    [nums[i], nums[j]] = [nums[j], nums[i]];    reverse(nums, i + 1);&#125;function reverse(nums: number[], start: number): void &#123;    let end = nums.length - 1;    while (start &lt; end) &#123;        [nums[start], nums[end]] = [nums[end], nums[start]];        start++;        end--;    &#125;&#125;\n\n结果执行用时 : 69 ms, 击败 62.28% 使用 TypeScript 的用户\n内存消耗 : 52.34 MB, 击败 11.40% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @return NULL     */    function nextPermutation(&amp;$nums) &#123;        $i = count($nums) - 2;        while ($i &gt;= 0 &amp;&amp; $nums[$i] &gt;= $nums[$i + 1]) &#123;            $i--;        &#125;        if ($i === -1) &#123;            $this-&gt;reverse($nums, 0);            return;        &#125;        $j = count($nums) - 1;        while ($nums[$j] &lt;= $nums[$i]) &#123;            $j--;        &#125;        [$nums[$i], $nums[$j]] = [$nums[$j], $nums[$i]];        $this-&gt;reverse($nums, $i + 1);    &#125;    private function reverse(&amp;$nums, $start) &#123;        $end = count($nums) - 1;        while ($start &lt; $end) &#123;            [$nums[$start], $nums[$end]] = [$nums[$end], $nums[$start]];            $start++;            $end--;        &#125;    &#125;&#125;\n\n结果执行用时 : 15 ms, 击败 30.77% 使用 PHP 的用户\n内存消耗 : 20.43 MB, 击败 7.69% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func nextPermutation(_ nums: inout [Int]) &#123;        var i = nums.count - 2        while i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1] &#123;            i -= 1        &#125;        if i == -1 &#123;            nums.reverse()            return        &#125;        var j = nums.count - 1        while nums[j] &lt;= nums[i] &#123;            j -= 1        &#125;        nums.swapAt(i, j)        var start = i + 1        var end = nums.count - 1        while start &lt; end &#123;            nums.swapAt(start, end)            start += 1            end -= 1        &#125;    &#125;&#125;\n\n结果执行用时 : 12 ms, 击败 59.57% 使用 Swift 的用户\n内存消耗 : 15.65 MB, 击败 6.38% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun nextPermutation(nums: IntArray): Unit &#123;        var i = nums.size - 2        while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;            i--        &#125;        if (i == -1) &#123;            nums.reverse()            return        &#125;        var j = nums.size - 1        while (nums[j] &lt;= nums[i]) &#123;            j--        &#125;        nums.swap(i, j)        reverse(nums, i + 1)    &#125;    private fun reverse(nums: IntArray, start: Int) &#123;        var end = nums.size - 1        var s = start        var e = end        while (s &lt; e) &#123;            nums[s] = nums[e].also &#123; nums[e] = nums[s] &#125;            s++            e--        &#125;    &#125;    private fun IntArray.swap(i: Int, j: Int) &#123;        val temp = this[i]        this[i] = this[j]        this[j] = temp    &#125;&#125;\n\n结果执行用时 : 224 ms, 击败 21.74% 使用 Kotlin 的用户\n内存消耗 : 38.23 MB, 击败 8.70% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  void nextPermutation(List&lt;int&gt; nums) &#123;    int i = nums.length - 2;    while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;      i--;    &#125;    if (i &gt;= 0) &#123;      int j = nums.length - 1;      while (j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) &#123;        j--;      &#125;      _swap(nums, i, j);    &#125;    _reverse(nums, i + 1, nums.length - 1);  &#125;  void _swap(List&lt;int&gt; nums, int i, int j) &#123;    int temp = nums[i];    nums[i] = nums[j];    nums[j] = temp;  &#125;  void _reverse(List&lt;int&gt; nums, int left, int right) &#123;    while (left &lt; right) &#123;      int temp = nums[left];      nums[left] = nums[right];      nums[right] = temp;      left++;      right--;    &#125;  &#125;&#125;\n\n结果执行用时 : 318 ms, 击败 50.00% 使用 Dart 的用户\n内存消耗 : 148.27 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc nextPermutation(nums []int) &#123;    i := len(nums) - 2    for i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i+1] &#123;        i--    &#125;    if i &gt;= 0 &#123;        j := len(nums) - 1        for j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j] &#123;            j--        &#125;        nums[i], nums[j] = nums[j], nums[i]    &#125;    reverse(nums[i+1:])&#125;func reverse(nums []int) &#123;    i, j := 0, len(nums)-1    for i &lt; j &#123;        nums[i], nums[j] = nums[j], nums[i]        i++        j--    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.27 MB, 击败 81.13% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @return &#123;Void&#125; Do not return anything, modify nums in-place instead.def next_permutation(nums)  i = nums.length - 2  while i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]    i -= 1  end  if i &gt;= 0    j = nums.length - 1    while j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]      j -= 1    end    nums[i], nums[j] = nums[j], nums[i]  end  reverse(nums, i + 1)enddef reverse(nums, start)  i, j = start, nums.length - 1  while i &lt; j    nums[i], nums[j] = nums[j], nums[i]    i += 1    j -= 1  endend\n\n结果执行用时 : 63 ms, 击败 -% 使用 Ruby 的用户\n内存消耗 : 206.68 MB, 击败 100.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def nextPermutation(nums: Array[Int]): Unit = &#123;    var i = nums.length - 2    while (i &gt;= 0 &amp;&amp; nums(i) &gt;= nums(i + 1)) &#123;      i -= 1    &#125;    if (i &gt;= 0) &#123;      var j = nums.length - 1      while (j &gt;= 0 &amp;&amp; nums(i) &gt;= nums(j)) &#123;        j -= 1      &#125;      swap(nums, i, j)    &#125;    reverse(nums, i + 1, nums.length - 1)  &#125;  private def swap(nums: Array[Int], i: Int, j: Int): Unit = &#123;    val temp = nums(i)    nums(i) = nums(j)    nums(j) = temp  &#125;  private def reverse(nums: Array[Int], start: Int, end: Int): Unit = &#123;    var i = start    var j = end    while (i &lt; j) &#123;      swap(nums, i, j)      i += 1      j -= 1    &#125;  &#125;&#125;\n\n结果执行用时 : 523 ms, 击败 33.33% 使用 Scala 的用户\n内存消耗 : 55.04 MB, 击败 33.33% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn next_permutation(nums: &amp;mut Vec&lt;i32&gt;) &#123;        let mut i = nums.len() as i32 - 2;        while i &gt;= 0 &amp;&amp; nums[i as usize] &gt;= nums[(i + 1) as usize] &#123;            i -= 1;        &#125;        if i &gt;= 0 &#123;            let mut j = nums.len() as i32 - 1;            while j &gt;= 0 &amp;&amp; nums[i as usize] &gt;= nums[j as usize] &#123;                j -= 1;            &#125;            nums.swap(i as usize, j as usize);        &#125;        nums[(i + 1) as usize..].reverse();    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.09 MB, 击败 36.84% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket"]},{"title":"力扣00032.最长有效括号","url":"/zh-CN/7ec618965874/","content":"\n题目描述给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。\n示例 1：\n输入：s &#x3D; “(()”输出：2解释：最长有效括号子串是 “()”\n\n示例 2：\n输入：s &#x3D; “)()())”输出：4解释：最长有效括号子串是 “()()”\n\n示例 3：\n输入：s &#x3D; “”输出：0\n\n提示：\n$0 &lt;&#x3D; s.length &lt;&#x3D; 3 * 10^4$\ns[i] 为 ‘(‘ 或 ‘)’\n\n\n解决方法C++class Solution &#123;public:    int longestValidParentheses(string s) &#123;        stack&lt;int&gt; st;        st.push(-1);        int maxLen = 0;        for (int i = 0; i &lt; s.length(); ++i) &#123;            if (s[i] == &#x27;(&#x27;) &#123;                st.push(i);            &#125; else &#123;                st.pop();                if (st.empty()) &#123;                    st.push(i);                &#125; else &#123;                    maxLen = max(maxLen, i - st.top());                &#125;            &#125;        &#125;        return maxLen;    &#125;&#125;;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C++ 的用户\n内存消耗 : 8.35 MB, 击败 14.42% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int longestValidParentheses(String s) &#123;        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        stack.push(-1);        int maxLen = 0;        for (int i = 0; i &lt; s.length(); i++) &#123;            if (s.charAt(i) == &#x27;(&#x27;) &#123;                stack.push(i);            &#125; else &#123;                stack.pop();                if (stack.isEmpty()) &#123;                    stack.push(i);                &#125; else &#123;                    maxLen = Math.max(maxLen, i - stack.peek());                &#125;            &#125;        &#125;        return maxLen;    &#125;&#125;\n\n结果执行用时 : 6 ms, 击败 26.39% 使用 Java 的用户\n内存消耗 : 41.96 MB, 击败 36.08% 使用 Java 的用户\n\nPythonclass Solution(object):    def longestValidParentheses(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: int        &quot;&quot;&quot;        stack = [-1]        max_len = 0        for i in range(len(s)):            if s[i] == &#x27;(&#x27;:                stack.append(i)            else:                stack.pop()                if not stack:                    stack.append(i)                else:                    max_len = max(max_len, i - stack[-1])        return max_len\n\n结果执行用时 : 27 ms, 击败 76.27% 使用 Python 的用户\n内存消耗 : 11.87 MB, 击败 93.51% 使用 Python 的用户\n\nPython3class Solution:    def longestValidParentheses(self, s: str) -&gt; int:        stack = [-1]        max_len = 0        for i in range(len(s)):            if s[i] == &#x27;(&#x27;:                stack.append(i)            else:                stack.pop()                if not stack:                    stack.append(i)                else:                    max_len = max(max_len, i - stack[-1])        return max_len\n\n结果执行用时 : 37 ms, 击败 95.99% 使用 Python3 的用户\n内存消耗 : 17.03 MB, 击败 36.91% 使用 Python3 的用户\n\nCint longestValidParentheses(char* s) &#123;    int maxans = 0, n = strlen(s);    if (n == 0) return 0;    int dp[n + 1];    memset(dp, 0, sizeof(dp));    for (int i = 1; i &lt; n; i++) &#123;        if (s[i] == &#x27;)&#x27;) &#123;            if (s[i - 1] == &#x27;(&#x27;) &#123;                dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2;            &#125; else if (i - dp[i - 1] &gt; 0 &amp;&amp; s[i - dp[i - 1] - 1] == &#x27;(&#x27;) &#123;                dp[i] = dp[i - 1] +                        ((i - dp[i - 1]) &gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;            &#125;            maxans = fmax(maxans, dp[i]);        &#125;    &#125;    return maxans;&#125;\n\n结果执行用时 : 2 ms, 击败 58.87% 使用 C 的用户\n内存消耗 : 6.07 MB, 击败 92.90% 使用 C 的用户\n\nC#public class Solution &#123;    public int LongestValidParentheses(string s) &#123;        int maxans = 0;        int n = s.Length;        if (n == 0) return 0;        int[] dp = new int[n];        for (int i = 1; i &lt; n; i++) &#123;            if (s[i] == &#x27;)&#x27;) &#123;                if (s[i - 1] == &#x27;(&#x27;) &#123;                    dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2;                &#125; else if (i - dp[i - 1] &gt; 0 &amp;&amp; s[i - dp[i - 1] - 1] == &#x27;(&#x27;) &#123;                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) &gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;                &#125;                maxans = Math.Max(maxans, dp[i]);            &#125;        &#125;        return maxans;    &#125;&#125;\n\n结果执行用时 : 42 ms, 击败 91.38% 使用 C# 的用户\n内存消耗 : 39.19 MB, 击败 10.35% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; s * @return &#123;number&#125; */var longestValidParentheses = function(s) &#123;    let maxLen = 0;    let stack = [-1];    for (let i = 0; i &lt; s.length; i++) &#123;        if (s[i] === &#x27;(&#x27;) &#123;            stack.push(i);        &#125; else &#123;            stack.pop();            if (stack.length === 0) &#123;                stack.push(i);            &#125; else &#123;                maxLen = Math.max(maxLen, i - stack[stack.length - 1]);            &#125;        &#125;    &#125;    return maxLen;&#125;;\n\n结果执行用时 : 56 ms, 击败 95.40% 使用 JavaScript 的用户\n内存消耗 : 51.18 MB, 击败 13.28% 使用 JavaScript 的用户\n\nTypeScriptfunction longestValidParentheses(s: string): number &#123;    let maxLen: number = 0;    const stack: number[] = [-1];    for (let i = 0; i &lt; s.length; i++) &#123;        if (s[i] === &#x27;(&#x27;) &#123;            stack.push(i);        &#125; else &#123;            stack.pop();            if (stack.length === 0) &#123;                stack.push(i);            &#125; else &#123;                maxLen = Math.max(maxLen, i - stack[stack.length - 1]);            &#125;        &#125;    &#125;    return maxLen;&#125;\n\n结果执行用时 : 53 ms, 击败 97.96% 使用 TypeScript 的用户\n内存消耗 : 52.29 MB, 击败 21.43% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String $s     * @return Integer     */    function longestValidParentheses($s) &#123;        $maxLen = 0;        $stack = [-1];        for ($i = 0; $i &lt; strlen($s); $i++) &#123;            if ($s[$i] === &#x27;(&#x27;) &#123;                array_push($stack, $i);            &#125; else &#123;                array_pop($stack);                if (empty($stack)) &#123;                    array_push($stack, $i);                &#125; else &#123;                    $maxLen = max($maxLen, $i - end($stack));                &#125;            &#125;        &#125;        return $maxLen;    &#125;&#125;\n\n结果执行用时 : 11 ms, 击败 80.00% 使用 PHP 的用户\n内存消耗 : 20.43 MB, 击败 6.67% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func longestValidParentheses(_ s: String) -&gt; Int &#123;        var maxLen = 0        var stack = [-1]        for (i, char) in s.enumerated() &#123;            if char == &quot;(&quot; &#123;                stack.append(i)            &#125; else &#123;                stack.popLast()                if stack.isEmpty &#123;                    stack.append(i)                &#125; else &#123;                    maxLen = max(maxLen, i - stack.last!)                &#125;            &#125;        &#125;        return maxLen    &#125;&#125;\n\n结果执行用时 : 3 ms, 击败 87.80% 使用 Swift 的用户\n内存消耗 : 16.35 MB, 击败 7.32% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun longestValidParentheses(s: String): Int &#123;        var maxLen = 0        val stack = Stack&lt;Int&gt;().apply &#123; push(-1) &#125;        for (i in s.indices) &#123;            val char = s[i]            if (char == &#x27;(&#x27;) &#123;                stack.push(i)            &#125; else &#123;                stack.pop()                if (stack.isEmpty()) &#123;                    stack.push(i)                &#125; else &#123;                    maxLen = maxOf(maxLen, i - stack.peek())                &#125;            &#125;        &#125;        return maxLen    &#125;&#125;\n\n结果执行用时 : 175 ms, 击败 66.67% 使用 Kotlin 的用户\n内存消耗 : 37.00 MB, 击败 25.00% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int longestValidParentheses(String s) &#123;    int maxLen = 0;    List&lt;int&gt; stack = [-1];    for (int i = 0; i &lt; s.length; i++) &#123;      if (s[i] == &#x27;(&#x27;) &#123;        stack.add(i);      &#125; else &#123;        stack.removeLast();        if (stack.isEmpty) &#123;          stack.add(i);        &#125; else &#123;          maxLen = max(maxLen, i - stack.last);        &#125;      &#125;    &#125;    return maxLen;  &#125;&#125;\n\n结果执行用时 : 312 ms, 击败 -% 使用 Dart 的用户\n内存消耗 : 147.31 MB, 击败 -% 使用 Dart 的用户\n\nGofunc longestValidParentheses(s string) int &#123;\tmaxLen := 0\tstack := []int&#123;-1&#125;\tfor i, char := range s &#123;\t\tif char == &#x27;(&#x27; &#123;\t\t\tstack = append(stack, i)\t\t&#125; else &#123;\t\t\tstack = stack[:len(stack)-1]\t\t\tif len(stack) == 0 &#123;\t\t\t\tstack = append(stack, i)\t\t\t&#125; else &#123;\t\t\t\tmaxLen = max(maxLen, i-stack[len(stack)-1])\t\t\t&#125;\t\t&#125;\t&#125;\treturn maxLen&#125;func max(a, b int) int &#123;\tif a &gt; b &#123;\t\treturn a\t&#125;\treturn b&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 3.28 MB, 击败 27.17% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; s# @return &#123;Integer&#125;def longest_valid_parentheses(s)  max_len = 0  stack = [-1]  s.each_char.with_index do |char, i|    if char == &#x27;(&#x27;      stack.push(i)    else      stack.pop      if stack.empty?        stack.push(i)      else        max_len = [max_len, i - stack.last].max      end    end  end  max_lenend\n\n结果执行用时 : 70 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.87 MB, 击败 100.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def longestValidParentheses(s: String): Int = &#123;    var maxLen = 0    var stack = List(-1)    for ((char, i) &lt;- s.zipWithIndex) &#123;      if (char == &#x27;(&#x27;) &#123;        stack = i :: stack      &#125; else &#123;        stack = stack.tail        if (stack.isEmpty) &#123;          stack = i :: stack        &#125; else &#123;          maxLen = math.max(maxLen, i - stack.head)        &#125;      &#125;    &#125;    maxLen  &#125;&#125;\n\n结果执行用时 : 504 ms, 击败 80.00% 使用 Scala 的用户\n内存消耗 : 55.55 MB, 击败 80.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn longest_valid_parentheses(s: String) -&gt; i32 &#123;        let mut max_len = 0;        let mut stack = vec![-1];        for (i, c) in s.chars().enumerate() &#123;            if c == &#x27;(&#x27; &#123;                stack.push(i as i32);            &#125; else &#123;                stack.pop();                if stack.is_empty() &#123;                    stack.push(i as i32);                &#125; else &#123;                    max_len = max_len.max(i as i32 - stack.last().unwrap());                &#125;            &#125;        &#125;        max_len as i32    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.00 MB, 击败 98.53% 使用 Rust 的用户\n\nRacket(define (longest-valid-parentheses s)  (define max-len 0)  (define stack (list -1))  (for ([i (in-range (string-length s))])    (define char (string-ref s i))    (cond      [(char=? char #\\() (set! stack (cons i stack))]      [(char=? char #\\))       (set! stack (cdr stack))       (if (null? stack)           (set! stack (list i))           (set! max-len (max max-len (- i (car stack)))))]))  max-len)\n\n结果执行用时 : 187 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 97.80 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00033.搜索旋转排序数组","url":"/zh-CN/d52aa1cc3fae/","content":"\n题目描述整数数组 nums 按升序排列，数组中的值 互不相同 。\n在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n示例 1：\n输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0输出：4\n\n示例 2：\n输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3输出：-1\n\n示例 3：\n输入：nums &#x3D; [1], target &#x3D; 0输出：-1\n\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 5000\n$-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4$\nnums 中的每个值都 独一无二\n题目数据保证 nums 在预先未知的某个下标上进行了旋转\n$-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4$\n\n\n解决方法C++class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0, right = nums.size() - 1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                return mid;            &#125;            if (nums[left] &lt;= nums[mid]) &#123;                if (nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;                    right = mid - 1;                &#125; else &#123;                    left = mid + 1;                &#125;            &#125; else &#123;                if (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right]) &#123;                    left = mid + 1;                &#125; else &#123;                    right = mid - 1;                &#125;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n结果执行用时 : 3 ms, 击败 66.87% 使用 C++ 的用户\n内存消耗 : 13.30 MB, 击败 5.05% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public int search(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                return mid;            &#125;            if (nums[left] &lt;= nums[mid]) &#123;                if (nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;                    right = mid - 1;                &#125; else &#123;                    left = mid + 1;                &#125;            &#125; else &#123;                if (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right]) &#123;                    left = mid + 1;                &#125; else &#123;                    right = mid - 1;                &#125;            &#125;        &#125;        return -1;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 41.00 MB, 击败 19.74% 使用 Java 的用户\n\nPythonclass Solution(object):    def search(self, nums, target):        &quot;&quot;&quot;        :type nums: List[int]        :type target: int        :rtype: int        &quot;&quot;&quot;        left, right = 0, len(nums) - 1        while left &lt;= right:            mid = (left + right) // 2            if nums[mid] == target:                return mid            if nums[left] &lt;= nums[mid]:                if nums[left] &lt;= target &lt;= nums[mid]:                    right = mid - 1                else:                    left = mid + 1            else:                if nums[mid] &lt;= target &lt;= nums[right]:                    left = mid + 1                else:                    right = mid - 1        return -1\n\n结果执行用时 : 19 ms, 击败 52.22% 使用 Python 的用户\n内存消耗 : 11.41 MB, 击败 100.00% 使用 Python 的用户\n\nPython3class Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left, right = 0, len(nums) - 1        while left &lt;= right:            mid = (left + right) // 2            if nums[mid] == target:                return mid            if nums[left] &lt;= nums[mid]:                if nums[left] &lt;= target &lt;= nums[mid]:                    right = mid - 1                else:                    left = mid + 1            else:                if nums[mid] &lt;= target &lt;= nums[right]:                    left = mid + 1                else:                    right = mid - 1        return -1\n\n结果执行用时 : 39 ms, 击败 71.66% 使用 Python3 的用户\n内存消耗 : 16.74 MB, 击败 36.28% 使用 Python3 的用户\n\nCint search(int* nums, int numsSize, int target) &#123;    int left = 0, right = numsSize - 1;    while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] == target) &#123;            return mid;        &#125;        if (nums[left] &lt;= nums[mid]) &#123;            if (nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;                right = mid - 1;            &#125; else &#123;                left = mid + 1;            &#125;        &#125; else &#123;            if (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right]) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;    &#125;    return -1;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 5.86 MB, 击败 88.43% 使用 C 的用户\n\nC#public class Solution &#123;    public int Search(int[] nums, int target) &#123;        int left = 0, right = nums.Length - 1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                return mid;            &#125;            if (nums[left] &lt;= nums[mid]) &#123;                if (nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;                    right = mid - 1;                &#125; else &#123;                    left = mid + 1;                &#125;            &#125; else &#123;                if (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right]) &#123;                    left = mid + 1;                &#125; else &#123;                    right = mid - 1;                &#125;            &#125;        &#125;        return -1;    &#125;&#125;\n\n结果执行用时 : 63 ms, 击败 83.77% 使用 C# 的用户\n内存消耗 : 41.57 MB, 击败 5.19% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var search = function(nums, target) &#123;    let left = 0, right = nums.length - 1;    while (left &lt;= right) &#123;        let mid = Math.floor((left + right) / 2);        if (nums[mid] === target) &#123;            return mid;        &#125;        if (nums[left] &lt;= nums[mid]) &#123;            if (nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;                right = mid - 1;            &#125; else &#123;                left = mid + 1;            &#125;        &#125; else &#123;            if (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right]) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;    &#125;    return -1;&#125;;\n\n结果执行用时 : 52 ms, 击败 95.29% 使用 JavaScript 的用户\n内存消耗 : 49.34 MB, 击败 5.11% 使用 JavaScript 的用户\n\nTypeScriptfunction search(nums: number[], target: number): number &#123;    let left = 0, right = nums.length - 1;    while (left &lt;= right) &#123;        let mid = Math.floor((left + right) / 2);        if (nums[mid] === target) &#123;            return mid;        &#125;        if (nums[left] &lt;= nums[mid]) &#123;            if (nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;                right = mid - 1;            &#125; else &#123;                left = mid + 1;            &#125;        &#125; else &#123;            if (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right]) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;    &#125;    return -1;&#125;\n\n结果执行用时 : 59 ms, 击败 87.77% 使用 TypeScript 的用户\n内存消耗 : 51.68 MB, 击败 7.42% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @param Integer $target     * @return Integer     */    function search($nums, $target) &#123;        $left = 0;        $right = count($nums) - 1;        while ($left &lt;= $right) &#123;            $mid = (int)(($left + $right) / 2);            if ($nums[$mid] == $target) &#123;                return $mid;            &#125;            if ($nums[$left] &lt;= $nums[$mid]) &#123;                if ($nums[$left] &lt;= $target &amp;&amp; $target &lt;= $nums[$mid]) &#123;                    $right = $mid - 1;                &#125; else &#123;                    $left = $mid + 1;                &#125;            &#125; else &#123;                if ($nums[$mid] &lt;= $target &amp;&amp; $target &lt;= $nums[$right]) &#123;                    $left = $mid + 1;                &#125; else &#123;                    $right = $mid - 1;                &#125;            &#125;        &#125;        return -1;    &#125;&#125;\n\n结果执行用时 : 9 ms, 击败 46.15% 使用 PHP 的用户\n内存消耗 : 20.42 MB, 击败 7.69% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func search(_ nums: [Int], _ target: Int) -&gt; Int &#123;        var left = 0        var right = nums.count - 1        while left &lt;= right &#123;            let mid = (left + right) / 2            if nums[mid] == target &#123;                return mid            &#125;            if nums[left] &lt;= nums[mid] &#123;                if nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid] &#123;                    right = mid - 1                &#125; else &#123;                    left = mid + 1                &#125;            &#125; else &#123;                if nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right] &#123;                    left = mid + 1                &#125; else &#123;                    right = mid - 1                &#125;            &#125;        &#125;        return -1    &#125;&#125;\n\n结果执行用时 : 7 ms, 击败 99.07% 使用 Swift 的用户\n内存消耗 : 15.50 MB, 击败 18.69% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun search(nums: IntArray, target: Int): Int &#123;        var left = 0        var right = nums.size - 1        while (left &lt;= right) &#123;            val mid = (left + right) / 2            if (nums[mid] == target) &#123;                return mid            &#125;            if (nums[left] &lt;= nums[mid]) &#123;                if (nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;                    right = mid - 1                &#125; else &#123;                    left = mid + 1                &#125;            &#125; else &#123;                if (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right]) &#123;                    left = mid + 1                &#125; else &#123;                    right = mid - 1                &#125;            &#125;        &#125;        return -1    &#125;&#125;\n\n结果执行用时 : 154 ms, 击败 95.12% 使用 Kotlin 的用户\n内存消耗 : 34.81 MB, 击败 53.66% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int search(List&lt;int&gt; nums, int target) &#123;    int left = 0;    int right = nums.length - 1;    while (left &lt;= right) &#123;      int mid = (left + right) ~/ 2;      if (nums[mid] == target) &#123;        return mid;      &#125;      if (nums[left] &lt;= nums[mid]) &#123;        if (nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;          right = mid - 1;        &#125; else &#123;          left = mid + 1;        &#125;      &#125; else &#123;        if (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right]) &#123;          left = mid + 1;        &#125; else &#123;          right = mid - 1;        &#125;      &#125;    &#125;    return -1;  &#125;&#125;\n\n结果执行用时 : 289 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 147.27 MB, 击败 66.67% 使用 Dart 的用户\n\nGofunc search(nums []int, target int) int &#123;    left := 0    right := len(nums) - 1    for left &lt;= right &#123;        mid := (left + right) / 2        if nums[mid] == target &#123;            return mid        &#125;        if nums[left] &lt;= nums[mid] &#123;            if nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid] &#123;                right = mid - 1            &#125; else &#123;                left = mid + 1            &#125;        &#125; else &#123;            if nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right] &#123;                left = mid + 1            &#125; else &#123;                right = mid - 1            &#125;        &#125;    &#125;    return -1&#125;\n\n结果执行用时 : 2 ms, 击败 35.44% 使用 Go 的用户\n内存消耗 : 2.39 MB, 击败 30.05% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @param &#123;Integer&#125; target# @return &#123;Integer&#125;def search(nums, target)  left = 0  right = nums.length - 1  while left &lt;= right    mid = (left + right) / 2    if nums[mid] == target      return mid    end    if nums[left] &lt;= nums[mid]      if nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid]        right = mid - 1      else        left = mid + 1      end    else      if nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right]        left = mid + 1      else        right = mid - 1      end    end  end  return -1end\n\n结果执行用时 : 64 ms, 击败 40.00% 使用 Ruby 的用户\n内存消耗 : 206.52 MB, 击败 40.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def search(nums: Array[Int], target: Int): Int = &#123;    var left = 0    var right = nums.length - 1    while (left &lt;= right) &#123;      val mid = (left + right) / 2      if (nums(mid) == target) &#123;        return mid      &#125;      if (nums(left) &lt;= nums(mid)) &#123;        if (nums(left) &lt;= target &amp;&amp; target &lt;= nums(mid)) &#123;          right = mid - 1        &#125; else &#123;          left = mid + 1        &#125;      &#125; else &#123;        if (nums(mid) &lt;= target &amp;&amp; target &lt;= nums(right)) &#123;          left = mid + 1        &#125; else &#123;          right = mid - 1        &#125;      &#125;    &#125;    -1  &#125;&#125;\n\n结果执行用时 : 499 ms, 击败 28.57% 使用 Scala 的用户\n内存消耗 : 54.61 MB, 击败 14.29% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn search(nums: Vec&lt;i32&gt;, target: i32) -&gt; i32 &#123;        let mut left = 0;        let mut right = nums.len() - 1;        while left &lt;= right &#123;            let mid = (left + right) / 2;            if nums[mid] == target &#123;                return mid as i32;            &#125;            if nums[left] &lt;= nums[mid] &#123;                if nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid] &#123;                    right = mid - 1;                &#125; else &#123;                    left = mid + 1;                &#125;            &#125; else &#123;                if nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right] &#123;                    left = mid + 1;                &#125; else &#123;                    right = mid - 1;                &#125;            &#125;        &#125;        -1    &#125;&#125;\n\n结果执行用时 : 4 ms, 击败 8.57% 使用 Rust 的用户\n内存消耗 : 2.01 MB, 击败 77.14% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"绿箭侠 第八季 第八集 无限地球危机：第四部分（四）","url":"/zh-CN/0618b13d73fa/","content":"\n剧情介绍　　困在消失点（Vanishing Point）中，英雄们——被称为“最强之选”的几位人物——正在寻找逃脱的方法。然而，随着闪电侠（The Flash）的失踪，情况变得愈加绝望。然而，奥利弗（Oliver）的出现带来了希望，他揭示了自己已经变成了某种全新的存在。与此同时，监视者（The Monitor）和反监视者（Anti-Monitor）的起源故事也在这一过程中揭示。\n　　这个跨剧集事件从《女超人》第五季第九集、《蝙蝠女侠》第五季第九集以及《闪电侠》第六季第九集开始，最终在《明日传奇》第五季第一集中落下帷幕。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00034.在排序数组中查找元素的第一个和最后一个位置","url":"/zh-CN/577d1b888179/","content":"\n题目描述给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n示例 1：\n输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8输出：[3,4]\n\n示例 2：\n输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6输出：[-1,-1]\n\n示例 3：\n输入：nums &#x3D; [], target &#x3D; 0输出：[-1,-1]\n\n提示：\n$0 &lt;&#x3D; nums.length &lt;&#x3D; 10^5$\n$-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9$\nnums 是一个非递减数组\n$-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9$\n\n\n解决方法C++class Solution &#123;public:    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;        return &#123;find_first_occurrence(nums, target), find_last_occurrence(nums, target)&#125;;    &#125;private:    int find_first_occurrence(const vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0, right = nums.size() - 1, result = -1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                result = mid;                right = mid - 1;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        return result;    &#125;    int find_last_occurrence(const vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0, right = nums.size() - 1, result = -1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                result = mid;                left = mid + 1;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        return result;    &#125;&#125;;\n\n结果执行用时 : 10 ms, 击败 20.11% 使用 C++ 的用户\n内存消耗 : 15.74 MB, 击败 6.25% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int[] searchRange(int[] nums, int target) &#123;        return new int[]&#123;findFirstOccurrence(nums, target), findLastOccurrence(nums, target)&#125;;    &#125;    private int findFirstOccurrence(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1, result = -1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                result = mid;                right = mid - 1;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        return result;    &#125;    private int findLastOccurrence(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1, result = -1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                result = mid;                left = mid + 1;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 44.92 MB, 击败 12.98% 使用 Java 的用户\n\nPythonclass Solution(object):    def searchRange(self, nums, target):        &quot;&quot;&quot;        :type nums: List[int]        :type target: int        :rtype: List[int]        &quot;&quot;&quot;        def find_first_occurrence(nums, target):            left, right, result = 0, len(nums) - 1, -1            while left &lt;= right:                mid = left + (right - left) // 2                if nums[mid] == target:                    result = mid                    right = mid - 1                elif nums[mid] &lt; target:                    left = mid + 1                else:                    right = mid - 1            return result        def find_last_occurrence(nums, target):            left, right, result = 0, len(nums) - 1, -1            while left &lt;= right:                mid = left + (right - left) // 2                if nums[mid] == target:                    result = mid                    left = mid + 1                elif nums[mid] &lt; target:                    left = mid + 1                else:                    right = mid - 1            return result        first_occurrence = find_first_occurrence(nums, target)        last_occurrence = find_last_occurrence(nums, target)        return [first_occurrence, last_occurrence]\n\n结果执行用时 : 14 ms, 击败 82.57% 使用 Python 的用户\n内存消耗 : 11.77 MB, 击败 91.52% 使用 Python 的用户\n\nPython3class Solution:    def searchRange(self, nums: List[int], target: int) -&gt; List[int]:        def find_first_occurrence(nums, target):            left, right, result = 0, len(nums) - 1, -1            while left &lt;= right:                mid = left + (right - left) // 2                if nums[mid] == target:                    result = mid                    right = mid - 1                elif nums[mid] &lt; target:                    left = mid + 1                else:                    right = mid - 1            return result        def find_last_occurrence(nums, target):            left, right, result = 0, len(nums) - 1, -1            while left &lt;= right:                mid = left + (right - left) // 2                if nums[mid] == target:                    result = mid                    left = mid + 1                elif nums[mid] &lt; target:                    left = mid + 1                else:                    right = mid - 1            return result        first_occurrence = find_first_occurrence(nums, target)        last_occurrence = find_last_occurrence(nums, target)        return [first_occurrence, last_occurrence]\n\n结果执行用时 : 32 ms, 击败 95.63% 使用 Python3 的用户\n内存消耗 : 17.87 MB, 击败 30.78% 使用 Python3 的用户\n\nC/** * Note: The returned array must be malloced, assume caller calls free(). */int* searchRange(int* nums, int numsSize, int target, int* returnSize) &#123;    int* result = (int*)malloc(2 * sizeof(int));    *returnSize = 2;    result[0] = find_first_occurrence(nums, numsSize, target);    result[1] = find_last_occurrence(nums, numsSize, target);    return result;&#125;int find_first_occurrence(int* nums, int numsSize, int target) &#123;    int left = 0, right = numsSize - 1, result = -1;    while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] == target) &#123;            result = mid;            right = mid - 1;        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;    return result;&#125;int find_last_occurrence(int* nums, int numsSize, int target) &#123;    int left = 0, right = numsSize - 1, result = -1;    while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] == target) &#123;            result = mid;            left = mid + 1;        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;    return result;&#125;\n\n结果执行用时 : 5 ms, 击败 69.47% 使用 C 的用户\n内存消耗 : 6.95 MB, 击败 99.07% 使用 C 的用户\n\nC#public class Solution &#123;    public int[] SearchRange(int[] nums, int target) &#123;        int[] result = new int[2];        result[0] = FindFirstOccurrence(nums, target);        result[1] = FindLastOccurrence(nums, target);        return result;    &#125;    private int FindFirstOccurrence(int[] nums, int target) &#123;        int left = 0, right = nums.Length - 1, result = -1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                result = mid;                right = mid - 1;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        return result;    &#125;    private int FindLastOccurrence(int[] nums, int target) &#123;        int left = 0, right = nums.Length - 1, result = -1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                result = mid;                left = mid + 1;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 123 ms, 击败 70.95% 使用 C# 的用户\n内存消耗 : 48.65 MB, 击败 5.24% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var searchRange = function(nums, target) &#123;    const findFirstOccurrence = function(nums, target) &#123;        let left = 0, right = nums.length - 1, result = -1;        while (left &lt;= right) &#123;            let mid = left + Math.floor((right - left) / 2);            if (nums[mid] === target) &#123;                result = mid;                right = mid - 1;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        return result;    &#125;;    const findLastOccurrence = function(nums, target) &#123;        let left = 0, right = nums.length - 1, result = -1;        while (left &lt;= right) &#123;            let mid = left + Math.floor((right - left) / 2);            if (nums[mid] === target) &#123;                result = mid;                left = mid + 1;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        return result;    &#125;;    const firstOccurrence = findFirstOccurrence(nums, target);    const lastOccurrence = findLastOccurrence(nums, target);    return [firstOccurrence, lastOccurrence];&#125;;\n\n结果执行用时 : 48 ms, 击败 98.12% 使用 JavaScript 的用户\n内存消耗 : 49.98 MB, 击败 8.48% 使用 JavaScript 的用户\n\nTypeScriptfunction searchRange(nums: number[], target: number): number[] &#123;    const findFirstOccurrence = function(nums: number[], target: number): number &#123;        let left = 0, right = nums.length - 1, result = -1;        while (left &lt;= right) &#123;            let mid = left + Math.floor((right - left) / 2);            if (nums[mid] === target) &#123;                result = mid;                right = mid - 1;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        return result;    &#125;;    const findLastOccurrence = function(nums: number[], target: number): number &#123;        let left = 0, right = nums.length - 1, result = -1;        while (left &lt;= right) &#123;            let mid = left + Math.floor((right - left) / 2);            if (nums[mid] === target) &#123;                result = mid;                left = mid + 1;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        return result;    &#125;;    const firstOccurrence = findFirstOccurrence(nums, target);    const lastOccurrence = findLastOccurrence(nums, target);    return [firstOccurrence, lastOccurrence];&#125;\n\n结果执行用时 : 65 ms, 击败 45.11% 使用 TypeScript 的用户\n内存消耗 : 52.08 MB, 击败 14.82% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @param Integer $target     * @return Integer[]     */    function searchRange($nums, $target) &#123;        return [$this-&gt;findFirstOccurrence($nums, $target), $this-&gt;findLastOccurrence($nums, $target)];    &#125;    private function findFirstOccurrence($nums, $target) &#123;        $left = 0;        $right = count($nums) - 1;        $result = -1;        while ($left &lt;= $right) &#123;            $mid = $left + intdiv(($right - $left), 2);            if ($nums[$mid] === $target) &#123;                $result = $mid;                $right = $mid - 1;            &#125; elseif ($nums[$mid] &lt; $target) &#123;                $left = $mid + 1;            &#125; else &#123;                $right = $mid - 1;            &#125;        &#125;        return $result;    &#125;    private function findLastOccurrence($nums, $target) &#123;        $left = 0;        $right = count($nums) - 1;        $result = -1;        while ($left &lt;= $right) &#123;            $mid = $left + intdiv(($right - $left), 2);            if ($nums[$mid] === $target) &#123;                $result = $mid;                $left = $mid + 1;            &#125; elseif ($nums[$mid] &lt; $target) &#123;                $left = $mid + 1;            &#125; else &#123;                $right = $mid - 1;            &#125;        &#125;        return $result;    &#125;&#125;\n\n结果执行用时 : 19 ms, 击败 87.10% 使用 PHP 的用户\n内存消耗 : 21.48 MB, 击败 64.52% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func searchRange(_ nums: [Int], _ target: Int) -&gt; [Int] &#123;        return [findFirstOccurrence(nums, target), findLastOccurrence(nums, target)]    &#125;    private func findFirstOccurrence(_ nums: [Int], _ target: Int) -&gt; Int &#123;        var left = 0        var right = nums.count - 1        var result = -1        while left &lt;= right &#123;            let mid = left + (right - left) / 2            if nums[mid] == target &#123;                result = mid                right = mid - 1            &#125; else if nums[mid] &lt; target &#123;                left = mid + 1            &#125; else &#123;                right = mid - 1            &#125;        &#125;        return result    &#125;    private func findLastOccurrence(_ nums: [Int], _ target: Int) -&gt; Int &#123;        var left = 0        var right = nums.count - 1        var result = -1        while left &lt;= right &#123;            let mid = left + (right - left) / 2            if nums[mid] == target &#123;                result = mid                left = mid + 1            &#125; else if nums[mid] &lt; target &#123;                left = mid + 1            &#125; else &#123;                right = mid - 1            &#125;        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 14 ms, 击败 100.00% 使用 Swift 的用户\n内存消耗 : 16.85 MB, 击败 5.10% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun searchRange(nums: IntArray, target: Int): IntArray &#123;        return intArrayOf(findFirstOccurrence(nums, target), findLastOccurrence(nums, target))    &#125;    private fun findFirstOccurrence(nums: IntArray, target: Int): Int &#123;        var left = 0        var right = nums.size - 1        var result = -1        while (left &lt;= right) &#123;            val mid = left + (right - left) / 2            if (nums[mid] == target) &#123;                result = mid                right = mid - 1            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1            &#125; else &#123;                right = mid - 1            &#125;        &#125;        return result    &#125;    private fun findLastOccurrence(nums: IntArray, target: Int): Int &#123;        var left = 0        var right = nums.size - 1        var result = -1        while (left &lt;= right) &#123;            val mid = left + (right - left) / 2            if (nums[mid] == target) &#123;                result = mid                left = mid + 1            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1            &#125; else &#123;                right = mid - 1            &#125;        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 218 ms, 击败 48.00% 使用 Kotlin 的用户\n内存消耗 : 38.01 MB, 击败 56.00% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;int&gt; searchRange(List&lt;int&gt; nums, int target) &#123;    return [findFirstOccurrence(nums, target), findLastOccurrence(nums, target)];  &#125;  int findFirstOccurrence(List&lt;int&gt; nums, int target) &#123;    int left = 0, right = nums.length - 1, result = -1;    while (left &lt;= right) &#123;      int mid = left + ((right - left) ~/ 2);      if (nums[mid] == target) &#123;        result = mid;        right = mid - 1;      &#125; else if (nums[mid] &lt; target) &#123;        left = mid + 1;      &#125; else &#123;        right = mid - 1;      &#125;    &#125;    return result;  &#125;  int findLastOccurrence(List&lt;int&gt; nums, int target) &#123;    int left = 0, right = nums.length - 1, result = -1;    while (left &lt;= right) &#123;      int mid = left + ((right - left) ~/ 2);      if (nums[mid] == target) &#123;        result = mid;        left = mid + 1;      &#125; else if (nums[mid] &lt; target) &#123;        left = mid + 1;      &#125; else &#123;        right = mid - 1;      &#125;    &#125;    return result;  &#125;&#125;\n\n结果执行用时 : 302 ms, 击败 33.33% 使用 Dart 的用户\n内存消耗 : 147.61 MB, 击败 66.67% 使用 Dart 的用户\n\nGofunc searchRange(nums []int, target int) []int &#123;\treturn []int&#123;findFirstOccurrence(nums, target), findLastOccurrence(nums, target)&#125;&#125;func findFirstOccurrence(nums []int, target int) int &#123;\tleft, right, result := 0, len(nums)-1, -1\tfor left &lt;= right &#123;\t\tmid := left + (right-left)/2\t\tif nums[mid] == target &#123;\t\t\tresult = mid\t\t\tright = mid - 1\t\t&#125; else if nums[mid] &lt; target &#123;\t\t\tleft = mid + 1\t\t&#125; else &#123;\t\t\tright = mid - 1\t\t&#125;\t&#125;\treturn result&#125;func findLastOccurrence(nums []int, target int) int &#123;\tleft, right, result := 0, len(nums)-1, -1\tfor left &lt;= right &#123;\t\tmid := left + (right-left)/2\t\tif nums[mid] == target &#123;\t\t\tresult = mid\t\t\tleft = mid + 1\t\t&#125; else if nums[mid] &lt; target &#123;\t\t\tleft = mid + 1\t\t&#125; else &#123;\t\t\tright = mid - 1\t\t&#125;\t&#125;\treturn result&#125;\n\n结果执行用时 : 4 ms, 击败 89.67% 使用 Go 的用户\n内存消耗 : 4.32 MB, 击败 78.50% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @param &#123;Integer&#125; target# @return &#123;Integer[]&#125;def search_range(nums, target)  [find_first_occurrence(nums, target), find_last_occurrence(nums, target)]enddef find_first_occurrence(nums, target)  left, right, result = 0, nums.length - 1, -1  while left &lt;= right    mid = left + (right - left) / 2    if nums[mid] == target      result = mid      right = mid - 1    elsif nums[mid] &lt; target      left = mid + 1    else      right = mid - 1    end  end  resultenddef find_last_occurrence(nums, target)  left, right, result = 0, nums.length - 1, -1  while left &lt;= right    mid = left + (right - left) / 2    if nums[mid] == target      result = mid      left = mid + 1    elsif nums[mid] &lt; target      left = mid + 1    else      right = mid - 1    end  end  resultend\n\n结果执行用时 : 60 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.79 MB, 击败 66.67% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def searchRange(nums: Array[Int], target: Int): Array[Int] = &#123;    Array(findFirstOccurrence(nums, target), findLastOccurrence(nums, target))  &#125;  def findFirstOccurrence(nums: Array[Int], target: Int): Int = &#123;    var left = 0    var right = nums.length - 1    var result = -1    while (left &lt;= right) &#123;      val mid = left + (right - left) / 2      if (nums(mid) == target) &#123;        result = mid        right = mid - 1      &#125; else if (nums(mid) &lt; target) &#123;        left = mid + 1      &#125; else &#123;        right = mid - 1      &#125;    &#125;    result  &#125;  def findLastOccurrence(nums: Array[Int], target: Int): Int = &#123;    var left = 0    var right = nums.length - 1    var result = -1    while (left &lt;= right) &#123;      val mid = left + (right - left) / 2      if (nums(mid) == target) &#123;        result = mid        left = mid + 1      &#125; else if (nums(mid) &lt; target) &#123;        left = mid + 1      &#125; else &#123;        right = mid - 1      &#125;    &#125;    result  &#125;&#125;\n\n结果执行用时 : 549 ms, 击败 10.00% 使用 Scala 的用户\n内存消耗 : 59.05 MB, 击败 10.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn search_range(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; &#123;        vec![Self::find_first_occurrence(&amp;nums, target), Self::find_last_occurrence(&amp;nums, target)]    &#125;    fn find_first_occurrence(nums: &amp;Vec&lt;i32&gt;, target: i32) -&gt; i32 &#123;        let mut left = 0;        let mut right = nums.len() as i32 - 1;        let mut result = -1;        while left &lt;= right &#123;            let mid = left + (right - left) / 2;            if nums[mid as usize] == target &#123;                result = mid;                right = mid - 1;            &#125; else if nums[mid as usize] &lt; target &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        result    &#125;    fn find_last_occurrence(nums: &amp;Vec&lt;i32&gt;, target: i32) -&gt; i32 &#123;        let mut left = 0;        let mut right = nums.len() as i32 - 1;        let mut result = -1;        while left &lt;= right &#123;            let mid = left + (right - left) / 2;            if nums[mid as usize] == target &#123;                result = mid;                left = mid + 1;            &#125; else if nums[mid as usize] &lt; target &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        result    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.28 MB, 击败 75.00% 使用 Rust 的用户\n\nRacket(define/contract (search-range nums target)  (-&gt; (listof exact-integer?) exact-integer? (listof exact-integer?))  (define (find-first-occurrence nums target left right)    (cond      ((&gt; left right) -1)      (else       (let ((mid (quotient (+ left right) 2)))         (cond           ((= (list-ref nums mid) target)            (let ((first-left (find-first-occurrence nums target left (- mid 1))))              (if (= first-left -1) mid first-left)))           ((&lt; (list-ref nums mid) target)            (find-first-occurrence nums target (+ mid 1) right))           (else            (find-first-occurrence nums target left (- mid 1))))))))  (define (find-last-occurrence nums target left right)    (cond      ((&gt; left right) -1)      (else       (let ((mid (quotient (+ left right) 2)))         (cond           ((= (list-ref nums mid) target)            (let ((last-right (find-last-occurrence nums target (+ mid 1) right)))              (if (= last-right -1) mid last-right)))           ((&lt; (list-ref nums mid) target)            (find-last-occurrence nums target (+ mid 1) right))           (else            (find-last-occurrence nums target left (- mid 1))))))))  (list (find-first-occurrence nums target 0 (- (length nums) 1))        (find-last-occurrence nums target 0 (- (length nums) 1))))\n\n结果执行用时 : 214 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 98.83 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00035.搜索插入位置","url":"/zh-CN/3f4fd59df447/","content":"\n题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为 O(log n) 的算法。\n示例 1：\n输入: nums &#x3D; [1,3,5,6], target &#x3D; 5输出: 2\n\n示例 2：\n输入: nums &#x3D; [1,3,5,6], target &#x3D; 2输出: 1\n\n示例 3：\n输入: nums &#x3D; [1,3,5,6], target &#x3D; 7输出: 4\n\n提示：\n$1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4$\n$-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4$\nnums 为 无重复元素 的 升序 排列数组\n$-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4$\n\n\n解决方法C++class Solution &#123;public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0, right = nums.size() - 1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                return mid;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        return left;    &#125;&#125;;\n\n结果执行用时 : 8 ms, 击败 26.16% 使用 C++ 的用户\n内存消耗 : 11.93 MB, 击败 5.16% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int searchInsert(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                return mid;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        return left;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 42.02 MB, 击败 56.65% 使用 Java 的用户\n\nPythonclass Solution(object):    def searchInsert(self, nums, target):        &quot;&quot;&quot;        :type nums: List[int]        :type target: int        :rtype: int        &quot;&quot;&quot;        left, right = 0, len(nums) - 1        while left &lt;= right:            mid = left + (right - left) // 2            if nums[mid] == target:                return mid            elif nums[mid] &lt; target:                left = mid + 1            else:                right = mid - 1        return left\n\n结果执行用时 : 15 ms, 击败 75.84% 使用 Python 的用户\n内存消耗 : 11.91 MB, 击败 93.16% 使用 Python 的用户\n\nPython3class Solution:    def searchInsert(self, nums: List[int], target: int) -&gt; int:        left, right = 0, len(nums) - 1        while left &lt;= right:            mid = left + (right - left) // 2            if nums[mid] == target:                return mid            elif nums[mid] &lt; target:                left = mid + 1            else:                right = mid - 1        return left\n\n结果执行用时 : 31 ms, 击败 95.92% 使用 Python3 的用户\n内存消耗 : 17.02 MB, 击败 34.81% 使用 Python3 的用户\n\nCint searchInsert(int* nums, int numsSize, int target) &#123;    int left = 0, right = numsSize - 1;    while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] == target) &#123;            return mid;        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;    return left;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 5.89 MB, 击败 88.56% 使用 C 的用户\n\nC#public class Solution &#123;    public int SearchInsert(int[] nums, int target) &#123;        int left = 0, right = nums.Length - 1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                return mid;            &#125; else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        return left;    &#125;&#125;\n\n结果执行用时 : 72 ms, 击败 77.15% 使用 C# 的用户\n内存消耗 : 41.67 MB, 击败 9.28% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var searchInsert = function(nums, target) &#123;    let left = 0, right = nums.length - 1;    while (left &lt;= right) &#123;        let mid = left + Math.floor((right - left) / 2);        if (nums[mid] === target) &#123;            return mid;        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;    return left;&#125;;\n\n结果执行用时 : 59 ms, 击败 63.71% 使用 JavaScript 的用户\n内存消耗 : 49.24 MB, 击败 7.29% 使用 JavaScript 的用户\n\nTypeScriptfunction searchInsert(nums: number[], target: number): number &#123;    let left: number = 0;    let right: number = nums.length - 1;    while (left &lt;= right) &#123;        const mid: number = left + Math.floor((right - left) / 2);        if (nums[mid] === target) &#123;            return mid;        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;    return left;&#125;\n\n结果执行用时 : 54 ms, 击败 93.77% 使用 TypeScript 的用户\n内存消耗 : 51.66 MB, 击败 5.12% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @param Integer $target     * @return Integer     */    function searchInsert($nums, $target) &#123;        $left = 0;        $right = count($nums) - 1;        while ($left &lt;= $right) &#123;            $mid = $left + intdiv(($right - $left), 2);            if ($nums[$mid] === $target) &#123;                return $mid;            &#125; elseif ($nums[$mid] &lt; $target) &#123;                $left = $mid + 1;            &#125; else &#123;                $right = $mid - 1;            &#125;        &#125;        return $left;    &#125;&#125;\n\n结果执行用时 : 16 ms, 击败 45.63% 使用 PHP 的用户\n内存消耗 : 20.31 MB, 击败 14.56% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func searchInsert(_ nums: [Int], _ target: Int) -&gt; Int &#123;        var left = 0        var right = nums.count - 1        while left &lt;= right &#123;            let mid = left + (right - left) / 2            if nums[mid] == target &#123;                return mid            &#125; else if nums[mid] &lt; target &#123;                left = mid + 1            &#125; else &#123;                right = mid - 1            &#125;        &#125;        return left    &#125;&#125;\n\n结果执行用时 : 10 ms, 击败 99.43% 使用 Swift 的用户\n内存消耗 : 15.36 MB, 击败 36.93% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun searchInsert(nums: IntArray, target: Int): Int &#123;        var left = 0        var right = nums.size - 1        while (left &lt;= right) &#123;            val mid = left + (right - left) / 2            when &#123;                nums[mid] == target -&gt; return mid                nums[mid] &lt; target -&gt; left = mid + 1                else -&gt; right = mid - 1            &#125;        &#125;        return left    &#125;&#125;\n\n结果执行用时 : 190 ms, 击败 25.30% 使用 Kotlin 的用户\n内存消耗 : 38.00 MB, 击败 22.89% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int searchInsert(List&lt;int&gt; nums, int target) &#123;    int left = 0;    int right = nums.length - 1;    while (left &lt;= right) &#123;      int mid = left + ((right - left) ~/ 2);      if (nums[mid] == target) &#123;        return mid;      &#125; else if (nums[mid] &lt; target) &#123;        left = mid + 1;      &#125; else &#123;        right = mid - 1;      &#125;    &#125;    return left;  &#125;&#125;\n\n结果执行用时 : 334 ms, 击败 17.65% 使用 Dart 的用户\n内存消耗 : 147.11 MB, 击败 70.59% 使用 Dart 的用户\n\nGofunc searchInsert(nums []int, target int) int &#123;    left, right := 0, len(nums)-1    for left &lt;= right &#123;        mid := left + (right-left)/2        if nums[mid] == target &#123;            return mid        &#125; else if nums[mid] &lt; target &#123;            left = mid + 1        &#125; else &#123;            right = mid - 1        &#125;    &#125;    return left&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.84 MB, 击败 5.00% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @param &#123;Integer&#125; target# @return &#123;Integer&#125;def search_insert(nums, target)    left, right = 0, nums.length - 1    while left &lt;= right        mid = left + (right - left) / 2        if nums[mid] == target            return mid        elsif nums[mid] &lt; target            left = mid + 1        else            right = mid - 1        end    end    return leftend\n\n结果执行用时 : 68 ms, 击败 37.50% 使用 Ruby 的用户\n内存消耗 : 206.66 MB, 击败 25.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def searchInsert(nums: Array[Int], target: Int): Int = &#123;    var left = 0    var right = nums.length - 1    while (left &lt;= right) &#123;      val mid = left + (right - left) / 2      if (nums(mid) == target) &#123;        return mid      &#125; else if (nums(mid) &lt; target) &#123;        left = mid + 1      &#125; else &#123;        right = mid - 1      &#125;    &#125;    left  &#125;&#125;\n\n结果执行用时 : 481 ms, 击败 90.91% 使用 Scala 的用户\n内存消耗 : 54.70 MB, 击败 9.09% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn search_insert(nums: Vec&lt;i32&gt;, target: i32) -&gt; i32 &#123;        let mut left = 0;        let mut right = nums.len() as i32 - 1;        while left &lt;= right &#123;            let mid = left + (right - left) / 2;            if nums[mid as usize] == target &#123;                return mid;            &#125; else if nums[mid as usize] &lt; target &#123;                left = mid + 1;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        left    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.11 MB, 击败 56.38% 使用 Rust 的用户\n\nRacket(define/contract (search-insert nums target)  (-&gt; (listof exact-integer?) exact-integer? exact-integer?)  (let loop ([left 0]             [right (- (length nums) 1)])    (cond      [(&lt;= left right)       (let ([mid (quotient (+ left right) 2)])         (cond           [(= (list-ref nums mid) target) mid]           [(&lt; (list-ref nums mid) target) (loop (+ mid 1) right)]           [else (loop left (- mid 1))]))       ]      [else left])))\n\n结果执行用时 : 204 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 97.80 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00036.有效的数独","url":"/zh-CN/c56d6400e4cf/","content":"\n题目描述请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。\n\n数字 1-9 在每一行只能出现一次。\n数字 1-9 在每一列只能出现一次。\n数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）\n\n注意：\n\n一个有效的数独（部分已被填充）不一定是可解的。\n只需要根据以上规则，验证已经填入的数字是否有效即可。\n空白格用 ‘.’ 表示。\n\n示例 1：\n\n\n输入：board &#x3D;[[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]输出：true\n\n示例 2：\n输入：board &#x3D;[[“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]输出：false解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。\n\n提示：\nboard.length &#x3D;&#x3D; 9\nboard[i].length &#x3D;&#x3D; 9\nboard[i][j] 是一位数字（1-9）或者 ‘.’\n\n\n解决方法C++class Solution &#123;public:    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;        for (int i = 0; i &lt; 9; ++i) &#123;            unordered_set&lt;char&gt; rowSet;            for (int j = 0; j &lt; 9; ++j) &#123;                if (board[i][j] != &#x27;.&#x27;) &#123;                    if (rowSet.find(board[i][j]) != rowSet.end()) &#123;                        return false;                    &#125;                    rowSet.insert(board[i][j]);                &#125;            &#125;        &#125;        for (int j = 0; j &lt; 9; ++j) &#123;            unordered_set&lt;char&gt; colSet;            for (int i = 0; i &lt; 9; ++i) &#123;                if (board[i][j] != &#x27;.&#x27;) &#123;                    if (colSet.find(board[i][j]) != colSet.end()) &#123;                        return false;                    &#125;                    colSet.insert(board[i][j]);                &#125;            &#125;        &#125;        for (int blockRow = 0; blockRow &lt; 3; ++blockRow) &#123;            for (int blockCol = 0; blockCol &lt; 3; ++blockCol) &#123;                unordered_set&lt;char&gt; blockSet;                for (int i = 0; i &lt; 3; ++i) &#123;                    for (int j = 0; j &lt; 3; ++j) &#123;                        char currentNum = board[blockRow * 3 + i][blockCol * 3 + j];                        if (currentNum != &#x27;.&#x27;) &#123;                            if (blockSet.find(currentNum) != blockSet.end()) &#123;                                return false;                            &#125;                            blockSet.insert(currentNum);                        &#125;                    &#125;                &#125;            &#125;        &#125;        return true;    &#125;&#125;;\n\n结果执行用时 : 17 ms, 击败 54.62% 使用 C++ 的用户\n内存消耗 : 23.61 MB, 击败 5.03% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public boolean isValidSudoku(char[][] board) &#123;        for (int i = 0; i &lt; 9; ++i) &#123;            HashSet&lt;Character&gt; rowSet = new HashSet&lt;&gt;();            for (int j = 0; j &lt; 9; ++j) &#123;                if (board[i][j] != &#x27;.&#x27;) &#123;                    if (rowSet.contains(board[i][j])) &#123;                        return false;                    &#125;                    rowSet.add(board[i][j]);                &#125;            &#125;        &#125;        for (int j = 0; j &lt; 9; ++j) &#123;            HashSet&lt;Character&gt; colSet = new HashSet&lt;&gt;();            for (int i = 0; i &lt; 9; ++i) &#123;                if (board[i][j] != &#x27;.&#x27;) &#123;                    if (colSet.contains(board[i][j])) &#123;                        return false;                    &#125;                    colSet.add(board[i][j]);                &#125;            &#125;        &#125;        for (int blockRow = 0; blockRow &lt; 3; ++blockRow) &#123;            for (int blockCol = 0; blockCol &lt; 3; ++blockCol) &#123;                HashSet&lt;Character&gt; blockSet = new HashSet&lt;&gt;();                for (int i = 0; i &lt; 3; ++i) &#123;                    for (int j = 0; j &lt; 3; ++j) &#123;                        char currentNum = board[blockRow * 3 + i][blockCol * 3 + j];                        if (currentNum != &#x27;.&#x27;) &#123;                            if (blockSet.contains(currentNum)) &#123;                                return false;                            &#125;                            blockSet.add(currentNum);                        &#125;                    &#125;                &#125;            &#125;        &#125;        return true;    &#125;&#125;\n\n结果执行用时 : 2 ms, 击败 41.51% 使用 Java 的用户\n内存消耗 : 43.24 MB, 击败 26.12% 使用 Java 的用户\n\nPythonclass Solution(object):    def isValidSudoku(self, board):        &quot;&quot;&quot;        :type board: List[List[str]]        :rtype: bool        &quot;&quot;&quot;        for i in range(9):            row_set = set()            for j in range(9):                if board[i][j] != &#x27;.&#x27;:                    if board[i][j] in row_set:                        return False                    row_set.add(board[i][j])        for j in range(9):            col_set = set()            for i in range(9):                if board[i][j] != &#x27;.&#x27;:                    if board[i][j] in col_set:                        return False                    col_set.add(board[i][j])        for block_row in range(3):            for block_col in range(3):                block_set = set()                for i in range(3):                    for j in range(3):                        current_num = board[block_row * 3 + i][block_col * 3 + j]                        if current_num != &#x27;.&#x27;:                            if current_num in block_set:                                return False                            block_set.add(current_num)        return True\n\n结果执行用时 : 30 ms, 击败 73.11% 使用 Python 的用户\n内存消耗 : 11.45 MB, 击败 93.85% 使用 Python 的用户\n\nPython3class Solution:    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:        for i in range(9):            row_set = set()            for j in range(9):                if board[i][j] != &#x27;.&#x27;:                    if board[i][j] in row_set:                        return False                    row_set.add(board[i][j])        for j in range(9):            col_set = set()            for i in range(9):                if board[i][j] != &#x27;.&#x27;:                    if board[i][j] in col_set:                        return False                    col_set.add(board[i][j])        for block_row in range(3):            for block_col in range(3):                block_set = set()                for i in range(3):                    for j in range(3):                        current_num = board[block_row * 3 + i][block_col * 3 + j]                        if current_num != &#x27;.&#x27;:                            if current_num in block_set:                                return False                            block_set.add(current_num)        return True\n\n结果执行用时 : 44 ms, 击败 85.12% 使用 Python3 的用户\n内存消耗 : 16.44 MB, 击败 32.84% 使用 Python3 的用户\n\nCbool isValidSudoku(char** board, int boardSize, int* boardColSize) &#123;    for (int i = 0; i &lt; boardSize; ++i) &#123;        bool rowSet[10] = &#123;false&#125;;        for (int j = 0; j &lt; *boardColSize; ++j) &#123;            char currentNum = board[i][j];            if (currentNum != &#x27;.&#x27;) &#123;                int digit = currentNum - &#x27;0&#x27;;                if (rowSet[digit]) &#123;                    return false;                &#125;                rowSet[digit] = true;            &#125;        &#125;    &#125;    for (int j = 0; j &lt; *boardColSize; ++j) &#123;        bool colSet[10] = &#123;false&#125;;        for (int i = 0; i &lt; boardSize; ++i) &#123;            char currentNum = board[i][j];            if (currentNum != &#x27;.&#x27;) &#123;                int digit = currentNum - &#x27;0&#x27;;                if (colSet[digit]) &#123;                    return false;                &#125;                colSet[digit] = true;            &#125;        &#125;    &#125;    for (int blockRow = 0; blockRow &lt; 3; ++blockRow) &#123;        for (int blockCol = 0; blockCol &lt; 3; ++blockCol) &#123;            bool blockSet[10] = &#123;false&#125;;            for (int i = 0; i &lt; 3; ++i) &#123;                for (int j = 0; j &lt; 3; ++j) &#123;                    char currentNum = board[blockRow * 3 + i][blockCol * 3 + j];                    if (currentNum != &#x27;.&#x27;) &#123;                        int digit = currentNum - &#x27;0&#x27;;                        if (blockSet[digit]) &#123;                            return false;                        &#125;                        blockSet[digit] = true;                    &#125;                &#125;            &#125;        &#125;    &#125;    return true;&#125;\n\n结果执行用时 : 6 ms, 击败 88.64% 使用 C 的用户\n内存消耗 : 5.83 MB, 击败 77.45% 使用 C 的用户\n\nC#public class Solution &#123;    public bool IsValidSudoku(char[][] board) &#123;        for (int i = 0; i &lt; 9; ++i) &#123;            HashSet&lt;char&gt; rowSet = new HashSet&lt;char&gt;();            for (int j = 0; j &lt; 9; ++j) &#123;                if (board[i][j] != &#x27;.&#x27;) &#123;                    if (rowSet.Contains(board[i][j])) &#123;                        return false;                    &#125;                    rowSet.Add(board[i][j]);                &#125;            &#125;        &#125;        for (int j = 0; j &lt; 9; ++j) &#123;            HashSet&lt;char&gt; colSet = new HashSet&lt;char&gt;();            for (int i = 0; i &lt; 9; ++i) &#123;                if (board[i][j] != &#x27;.&#x27;) &#123;                    if (colSet.Contains(board[i][j])) &#123;                        return false;                    &#125;                    colSet.Add(board[i][j]);                &#125;            &#125;        &#125;        for (int blockRow = 0; blockRow &lt; 3; ++blockRow) &#123;            for (int blockCol = 0; blockCol &lt; 3; ++blockCol) &#123;                HashSet&lt;char&gt; blockSet = new HashSet&lt;char&gt;();                for (int i = 0; i &lt; 3; ++i) &#123;                    for (int j = 0; j &lt; 3; ++j) &#123;                        char currentNum = board[blockRow * 3 + i][blockCol * 3 + j];                        if (currentNum != &#x27;.&#x27;) &#123;                            if (blockSet.Contains(currentNum)) &#123;                                return false;                            &#125;                            blockSet.Add(currentNum);                        &#125;                    &#125;                &#125;            &#125;        &#125;        return true;    &#125;&#125;\n\n结果执行用时 : 91 ms, 击败 75.74% 使用 C# 的用户\n内存消耗 : 47.38 MB, 击败 6.39% 使用 C# 的用户\n\nJavaScript/** * @param &#123;character[][]&#125; board * @return &#123;boolean&#125; */var isValidSudoku = function(board) &#123;    for (let i = 0; i &lt; 9; ++i) &#123;        const rowSet = new Set();        for (let j = 0; j &lt; 9; ++j) &#123;            if (board[i][j] !== &#x27;.&#x27;) &#123;                if (rowSet.has(board[i][j])) &#123;                    return false;                &#125;                rowSet.add(board[i][j]);            &#125;        &#125;    &#125;    for (let j = 0; j &lt; 9; ++j) &#123;        const colSet = new Set();        for (let i = 0; i &lt; 9; ++i) &#123;            if (board[i][j] !== &#x27;.&#x27;) &#123;                if (colSet.has(board[i][j])) &#123;                    return false;                &#125;                colSet.add(board[i][j]);            &#125;        &#125;    &#125;    for (let blockRow = 0; blockRow &lt; 3; ++blockRow) &#123;        for (let blockCol = 0; blockCol &lt; 3; ++blockCol) &#123;            const blockSet = new Set();            for (let i = 0; i &lt; 3; ++i) &#123;                for (let j = 0; j &lt; 3; ++j) &#123;                    const currentNum = board[blockRow * 3 + i][blockCol * 3 + j];                    if (currentNum !== &#x27;.&#x27;) &#123;                        if (blockSet.has(currentNum)) &#123;                            return false;                        &#125;                        blockSet.add(currentNum);                    &#125;                &#125;            &#125;        &#125;    &#125;    return true;&#125;;\n\n结果执行用时 : 69 ms, 击败 87.97% 使用 JavaScript 的用户\n内存消耗 : 51.89 MB, 击败 29.43% 使用 JavaScript 的用户\n\nTypeScriptfunction isValidSudoku(board: string[][]): boolean &#123;    for (let i = 0; i &lt; 9; ++i) &#123;        const rowSet = new Set&lt;string&gt;();        for (let j = 0; j &lt; 9; ++j) &#123;            if (board[i][j] !== &#x27;.&#x27;) &#123;                if (rowSet.has(board[i][j])) &#123;                    return false;                &#125;                rowSet.add(board[i][j]);            &#125;        &#125;    &#125;    for (let j = 0; j &lt; 9; ++j) &#123;        const colSet = new Set&lt;string&gt;();        for (let i = 0; i &lt; 9; ++i) &#123;            if (board[i][j] !== &#x27;.&#x27;) &#123;                if (colSet.has(board[i][j])) &#123;                    return false;                &#125;                colSet.add(board[i][j]);            &#125;        &#125;    &#125;    for (let blockRow = 0; blockRow &lt; 3; ++blockRow) &#123;        for (let blockCol = 0; blockCol &lt; 3; ++blockCol) &#123;            const blockSet = new Set&lt;string&gt;();            for (let i = 0; i &lt; 3; ++i) &#123;                for (let j = 0; j &lt; 3; ++j) &#123;                    const currentNum = board[blockRow * 3 + i][blockCol * 3 + j];                    if (currentNum !== &#x27;.&#x27;) &#123;                        if (blockSet.has(currentNum)) &#123;                            return false;                        &#125;                        blockSet.add(currentNum);                    &#125;                &#125;            &#125;        &#125;    &#125;    return true;&#125;\n\n结果执行用时 : 60 ms, 击败 99.15% 使用 TypeScript 的用户\n内存消耗 : 52.70 MB, 击败 15.38% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String[][] $board     * @return Boolean     */    function isValidSudoku($board) &#123;        for ($i = 0; $i &lt; 9; ++$i) &#123;            $rowSet = [];            for ($j = 0; $j &lt; 9; ++$j) &#123;                if ($board[$i][$j] !== &#x27;.&#x27;) &#123;                    if (isset($rowSet[$board[$i][$j]])) &#123;                        return false;                    &#125;                    $rowSet[$board[$i][$j]] = true;                &#125;            &#125;        &#125;        for ($j = 0; $j &lt; 9; ++$j) &#123;            $colSet = [];            for ($i = 0; $i &lt; 9; ++$i) &#123;                if ($board[$i][$j] !== &#x27;.&#x27;) &#123;                    if (isset($colSet[$board[$i][$j]])) &#123;                        return false;                    &#125;                    $colSet[$board[$i][$j]] = true;                &#125;            &#125;        &#125;        for ($blockRow = 0; $blockRow &lt; 3; ++$blockRow) &#123;            for ($blockCol = 0; $blockCol &lt; 3; ++$blockCol) &#123;                $blockSet = [];                for ($i = 0; $i &lt; 3; ++$i) &#123;                    for ($j = 0; $j &lt; 3; ++$j) &#123;                        $currentNum = $board[$blockRow * 3 + $i][$blockCol * 3 + $j];                        if ($currentNum !== &#x27;.&#x27;) &#123;                            if (isset($blockSet[$currentNum])) &#123;                                return false;                            &#125;                            $blockSet[$currentNum] = true;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return true;    &#125;&#125;\n\n结果执行用时 : 29 ms, 击败 72.00% 使用 PHP 的用户\n内存消耗 : 19.94 MB, 击败 8.00% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func isValidSudoku(_ board: [[Character]]) -&gt; Bool &#123;        for i in 0..&lt;9 &#123;            var rowSet = Set&lt;Character&gt;()            for j in 0..&lt;9 &#123;                if board[i][j] != &quot;.&quot; &#123;                    if rowSet.contains(board[i][j]) &#123;                        return false                    &#125;                    rowSet.insert(board[i][j])                &#125;            &#125;        &#125;        for j in 0..&lt;9 &#123;            var colSet = Set&lt;Character&gt;()            for i in 0..&lt;9 &#123;                if board[i][j] != &quot;.&quot; &#123;                    if colSet.contains(board[i][j]) &#123;                        return false                    &#125;                    colSet.insert(board[i][j])                &#125;            &#125;        &#125;        for blockRow in 0..&lt;3 &#123;            for blockCol in 0..&lt;3 &#123;                var blockSet = Set&lt;Character&gt;()                for i in 0..&lt;3 &#123;                    for j in 0..&lt;3 &#123;                        let currentNum = board[blockRow * 3 + i][blockCol * 3 + j]                        if currentNum != &quot;.&quot; &#123;                            if blockSet.contains(currentNum) &#123;                                return false                            &#125;                            blockSet.insert(currentNum)                        &#125;                    &#125;                &#125;            &#125;        &#125;        return true    &#125;&#125;\n\n结果执行用时 : 49 ms, 击败 100.00% 使用 Swift 的用户\n内存消耗 : 16.05 MB, 击败 6.98% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun isValidSudoku(board: Array&lt;CharArray&gt;): Boolean &#123;        for (i in 0 until 9) &#123;            val rowSet = HashSet&lt;Char&gt;()            for (j in 0 until 9) &#123;                if (board[i][j] != &#x27;.&#x27;) &#123;                    if (rowSet.contains(board[i][j])) &#123;                        return false                    &#125;                    rowSet.add(board[i][j])                &#125;            &#125;        &#125;        for (j in 0 until 9) &#123;            val colSet = HashSet&lt;Char&gt;()            for (i in 0 until 9) &#123;                if (board[i][j] != &#x27;.&#x27;) &#123;                    if (colSet.contains(board[i][j])) &#123;                        return false                    &#125;                    colSet.add(board[i][j])                &#125;            &#125;        &#125;        for (blockRow in 0 until 3) &#123;            for (blockCol in 0 until 3) &#123;                val blockSet = HashSet&lt;Char&gt;()                for (i in 0 until 3) &#123;                    for (j in 0 until 3) &#123;                        val currentNum = board[blockRow * 3 + i][blockCol * 3 + j]                        if (currentNum != &#x27;.&#x27;) &#123;                            if (blockSet.contains(currentNum)) &#123;                                return false                            &#125;                            blockSet.add(currentNum)                        &#125;                    &#125;                &#125;            &#125;        &#125;        return true    &#125;&#125;\n\n结果执行用时 : 192 ms, 击败 57.89% 使用 Kotlin 的用户\n内存消耗 : 41.67 MB, 击败 36.84% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  bool isValidSudoku(List&lt;List&lt;String&gt;&gt; board) &#123;    for (int i = 0; i &lt; 9; ++i) &#123;      Set&lt;String&gt; rowSet = Set();      for (int j = 0; j &lt; 9; ++j) &#123;        if (board[i][j] != &quot;.&quot;) &#123;          if (rowSet.contains(board[i][j])) &#123;            return false;          &#125;          rowSet.add(board[i][j]);        &#125;      &#125;    &#125;    for (int j = 0; j &lt; 9; ++j) &#123;      Set&lt;String&gt; colSet = Set();      for (int i = 0; i &lt; 9; ++i) &#123;        if (board[i][j] != &quot;.&quot;) &#123;          if (colSet.contains(board[i][j])) &#123;            return false;          &#125;          colSet.add(board[i][j]);        &#125;      &#125;    &#125;    for (int blockRow = 0; blockRow &lt; 3; ++blockRow) &#123;      for (int blockCol = 0; blockCol &lt; 3; ++blockCol) &#123;        Set&lt;String&gt; blockSet = Set();        for (int i = 0; i &lt; 3; ++i) &#123;          for (int j = 0; j &lt; 3; ++j) &#123;            String currentNum = board[blockRow * 3 + i][blockCol * 3 + j];            if (currentNum != &quot;.&quot;) &#123;              if (blockSet.contains(currentNum)) &#123;                return false;              &#125;              blockSet.add(currentNum);            &#125;          &#125;        &#125;      &#125;    &#125;    return true;  &#125;&#125;\n\n结果执行用时 : 349 ms, 击败 -% 使用 Dart 的用户\n内存消耗 : 147.78 MB, 击败 75.00% 使用 Dart 的用户\n\nGofunc isValidSudoku(board [][]byte) bool &#123;    for i := 0; i &lt; 9; i++ &#123;        rowSet := make(map[byte]bool)        for j := 0; j &lt; 9; j++ &#123;            if board[i][j] != &#x27;.&#x27; &#123;                if rowSet[board[i][j]] &#123;                    return false                &#125;                rowSet[board[i][j]] = true            &#125;        &#125;    &#125;    for j := 0; j &lt; 9; j++ &#123;        colSet := make(map[byte]bool)        for i := 0; i &lt; 9; i++ &#123;            if board[i][j] != &#x27;.&#x27; &#123;                if colSet[board[i][j]] &#123;                    return false                &#125;                colSet[board[i][j]] = true            &#125;        &#125;    &#125;    for blockRow := 0; blockRow &lt; 3; blockRow++ &#123;        for blockCol := 0; blockCol &lt; 3; blockCol++ &#123;            blockSet := make(map[byte]bool)            for i := 0; i &lt; 3; i++ &#123;                for j := 0; j &lt; 3; j++ &#123;                    currentNum := board[blockRow*3+i][blockCol*3+j]                    if currentNum != &#x27;.&#x27; &#123;                        if blockSet[currentNum] &#123;                            return false                        &#125;                        blockSet[currentNum] = true                    &#125;                &#125;            &#125;        &#125;    &#125;    return true&#125;\n\n结果执行用时 : 3 ms, 击败 44.49% 使用 Go 的用户\n内存消耗 : 2.49 MB, 击败 65.52% 使用 Go 的用户\n\nRuby# @param &#123;Character[][]&#125; board# @return &#123;Boolean&#125;def is_valid_sudoku(board)  9.times do |i|    row_set = Set.new    9.times do |j|      current_num = board[i][j]      next if current_num == &#x27;.&#x27;      return false if row_set.include?(current_num)      row_set.add(current_num)    end  end  9.times do |j|    col_set = Set.new    9.times do |i|      current_num = board[i][j]      next if current_num == &#x27;.&#x27;      return false if col_set.include?(current_num)      col_set.add(current_num)    end  end  (0..2).each do |block_row|    (0..2).each do |block_col|      block_set = Set.new      (0..2).each do |i|        (0..2).each do |j|          current_num = board[block_row * 3 + i][block_col * 3 + j]          next if current_num == &#x27;.&#x27;          return false if block_set.include?(current_num)          block_set.add(current_num)        end      end    end  end  trueend\n\n结果执行用时 : 71 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.64 MB, 击败 -% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def isValidSudoku(board: Array[Array[Char]]): Boolean = &#123;    for (i &lt;- 0 until 9) &#123;      val rowSet = scala.collection.mutable.Set[Char]()      for (j &lt;- 0 until 9) &#123;        val currentNum = board(i)(j)        if (currentNum != &#x27;.&#x27;) &#123;          if (rowSet.contains(currentNum)) &#123;            return false          &#125;          rowSet.add(currentNum)        &#125;      &#125;    &#125;    for (j &lt;- 0 until 9) &#123;      val colSet = scala.collection.mutable.Set[Char]()      for (i &lt;- 0 until 9) &#123;        val currentNum = board(i)(j)        if (currentNum != &#x27;.&#x27;) &#123;          if (colSet.contains(currentNum)) &#123;            return false          &#125;          colSet.add(currentNum)        &#125;      &#125;    &#125;    for (blockRow &lt;- 0 until 3; blockCol &lt;- 0 until 3) &#123;      val blockSet = scala.collection.mutable.Set[Char]()      for (i &lt;- 0 until 3; j &lt;- 0 until 3) &#123;        val currentNum = board(blockRow * 3 + i)(blockCol * 3 + j)        if (currentNum != &#x27;.&#x27;) &#123;          if (blockSet.contains(currentNum)) &#123;            return false          &#125;          blockSet.add(currentNum)        &#125;      &#125;    &#125;    true  &#125;&#125;\n\n结果执行用时 : 553 ms, 击败 92.86% 使用 Scala 的用户\n内存消耗 : 56.34 MB, 击败 35.71% 使用 Scala 的用户\n\nRustuse std::collections::HashSet;impl Solution &#123;    pub fn is_valid_sudoku(board: Vec&lt;Vec&lt;char&gt;&gt;) -&gt; bool &#123;        for i in 0..9 &#123;            let mut row_set = HashSet::new();            for j in 0..9 &#123;                let current_num = board[i][j];                if current_num != &#x27;.&#x27; &#123;                    if !row_set.insert(current_num) &#123;                        return false;                    &#125;                &#125;            &#125;        &#125;        for j in 0..9 &#123;            let mut col_set = HashSet::new();            for i in 0..9 &#123;                let current_num = board[i][j];                if current_num != &#x27;.&#x27; &#123;                    if !col_set.insert(current_num) &#123;                        return false;                    &#125;                &#125;            &#125;        &#125;        for block_row in 0..3 &#123;            for block_col in 0..3 &#123;                let mut block_set = HashSet::new();                for i in 0..3 &#123;                    for j in 0..3 &#123;                        let current_num = board[block_row * 3 + i][block_col * 3 + j];                        if current_num != &#x27;.&#x27; &#123;                            if !block_set.insert(current_num) &#123;                                return false;                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;        true    &#125;&#125;\n\n结果执行用时 : 5 ms, 击败 18.57% 使用 Rust 的用户\n内存消耗 : 2.13 MB, 击败 44.29% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"女超人 第五季 第十集 酒瓶事件","url":"/zh-CN/bb25453abe97/","content":"\n剧情介绍　　“危机”事件后的后续复杂情况让女超人不得不面对一个混乱的威胁。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第一季 第十集 今天超酷","url":"/zh-CN/67e6b9cabfcb/","content":"\n剧情介绍　　当哥谭忙于应对蝙蝠女侠的尴尬遭遇时，爱丽丝与鼠男庆祝她复仇计划的最终成功。心碎的玛丽将注意力集中在雅各布·凯恩的审判上，而索菲则从一个意想不到的人那里寻求关于感情生活的建议。在应对哥谭的新威胁时，卢克优先考虑保护蝙蝠女侠的秘密，而凯特必须决定她愿意付出什么来维护蝙蝠女侠的身份……以及她自己的身份。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"大寒","url":"/zh-CN/25559fc796b9/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大寒\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大寒"]},{"title":"黑闪电 第三季 第十集 马科维亚之书：第一章：祸福重起","url":"/zh-CN/13b6fc8ba418/","content":"\n剧情介绍　　杰斐逊在危机事件后努力适应新的现实，而琳恩为拯救超能力孩子们所做的努力让她的困境更加深重。与此同时，安妮莎&#x2F;黑鸟面临着新的挑战。最后，珍妮弗与布兰登的关系开始逐渐加深。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"绿箭侠 第八季 第九集 待定","url":"/zh-CN/03a6c8b04c09/","content":"\n剧情介绍　　这是2040年的星城，Mia Queen 拥有她曾经梦寐以求的一切。然而，当 Laurel 和 Dinah 突然再次出现在她的生活中，一切发生了惊人的变化，她完美的世界也随之崩塌。Laurel 和 Dinah 正在追踪一名绑架受害者，而这名受害者与 Mia 有着直接的联系，他们需要 Mia 的帮助。知道这将改变一切，Mia 无法抑制内心的英雄情怀，最终与 Laurel 和 Dinah 再次穿上战衣，一起拯救这座城市。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00037.解数独","url":"/zh-CN/9e4d092657ff/","content":"\n题目描述编写一个程序，通过填充空格来解决数独问题。\n数独的解法需 遵循如下规则：\n\n数字 1-9 在每一行只能出现一次。\n数字 1-9 在每一列只能出现一次。\n数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）数独部分空格内已填入了数字，空白格用 ‘.’ 表示。\n\n示例 1：\n\n\n输入：board &#x3D; [  [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]输出：[  [“5”,”3”,”4”,”6”,”7”,”8”,”9”,”1”,”2”],  [“6”,”7”,”2”,”1”,”9”,”5”,”3”,”4”,”8”],  [“1”,”9”,”8”,”3”,”4”,”2”,”5”,”6”,”7”],  [“8”,”5”,”9”,”7”,”6”,”1”,”4”,”2”,”3”],  [“4”,”2”,”6”,”8”,”5”,”3”,”7”,”9”,”1”],  [“7”,”1”,”3”,”9”,”2”,”4”,”8”,”5”,”6”],  [“9”,”6”,”1”,”5”,”3”,”7”,”2”,”8”,”4”],  [“2”,”8”,”7”,”4”,”1”,”9”,”6”,”3”,”5”],  [“3”,”4”,”5”,”2”,”8”,”6”,”1”,”7”,”9”]]解释：输入的数独如上图所示，唯一有效的解决方案如下所示：\n\n\n\n提示：\nboard.length &#x3D;&#x3D; 9\nboard[i].length &#x3D;&#x3D; 9\nboard[i][j] 是一位数字或者 ‘.’\n题目数据 保证 输入数独仅有一个解\n\n\n解决方法C++class Solution &#123;public:    void solveSudoku(std::vector&lt;std::vector&lt;char&gt;&gt;&amp; board) &#123;        solve(board);    &#125;private:    bool solve(std::vector&lt;std::vector&lt;char&gt;&gt;&amp; board) &#123;        for (int i = 0; i &lt; 9; ++i) &#123;            for (int j = 0; j &lt; 9; ++j) &#123;                if (board[i][j] == &#x27;.&#x27;) &#123;                    for (char num = &#x27;1&#x27;; num &lt;= &#x27;9&#x27;; ++num) &#123;                        if (isValid(board, i, j, num)) &#123;                            board[i][j] = num;                            if (solve(board)) &#123;                                return true;                            &#125;                            board[i][j] = &#x27;.&#x27;;                        &#125;                    &#125;                    return false;                &#125;            &#125;        &#125;        return true;    &#125;    bool isValid(const std::vector&lt;std::vector&lt;char&gt;&gt;&amp; board, int row, int col, char num) &#123;        for (int i = 0; i &lt; 9; ++i) &#123;            if (board[row][i] == num || board[i][col] == num || board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n\n结果执行用时 : 11 ms, 击败 67.22% 使用 C++ 的用户\n内存消耗 : 7.55 MB, 击败 20.50% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public void solveSudoku(char[][] board) &#123;        solve(board);    &#125;    private boolean solve(char[][] board) &#123;        for (int i = 0; i &lt; 9; ++i) &#123;            for (int j = 0; j &lt; 9; ++j) &#123;                if (board[i][j] == &#x27;.&#x27;) &#123;                    for (char num = &#x27;1&#x27;; num &lt;= &#x27;9&#x27;; ++num) &#123;                        if (isValid(board, i, j, num)) &#123;                            board[i][j] = num;                            if (solve(board)) &#123;                                return true;                            &#125;                            board[i][j] = &#x27;.&#x27;;                        &#125;                    &#125;                    return false;                &#125;            &#125;        &#125;        return true;    &#125;    private boolean isValid(char[][] board, int row, int col, char num) &#123;        for (int i = 0; i &lt; 9; ++i) &#123;            if (board[row][i] == num || board[i][col] == num || board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n结果执行用时 : 10 ms, 击败 14.01% 使用 Java 的用户\n内存消耗 : 40.18 MB, 击败 12.93% 使用 Java 的用户\n\nPythonclass Solution(object):    def solveSudoku(self, board):        &quot;&quot;&quot;        :type board: List[List[str]]        :rtype: None Do not return anything, modify board in-place instead.        &quot;&quot;&quot;        self.solve(board)    def solve(self, board):        for i in range(9):            for j in range(9):                if board[i][j] == &#x27;.&#x27;:                    for num in map(str, range(1, 10)):                        if self.is_valid(board, i, j, num):                            board[i][j] = num                            if self.solve(board):                                return True                            board[i][j] = &#x27;.&#x27;                    return False        return True    def is_valid(self, board, row, col, num):        if num in board[row]:            return False        if num in [board[i][col] for i in range(9)]:            return False        start_row, start_col = 3 * (row // 3), 3 * (col // 3)        for i in range(3):            for j in range(3):                if board[start_row + i][start_col + j] == num:                    return False        return True\n\n结果执行用时 : 388 ms, 击败 59.52% 使用 Python 的用户\n内存消耗 : 11.52 MB, 击败 95.24% 使用 Python 的用户\n\nPython3class Solution:    def solveSudoku(self, board: List[List[str]]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify board in-place instead.        &quot;&quot;&quot;        self.solve(board)    def solve(self, board):        for i in range(9):            for j in range(9):                if board[i][j] == &#x27;.&#x27;:                    for num in map(str, range(1, 10)):                        if self.is_valid(board, i, j, num):                            board[i][j] = num                            if self.solve(board):                                return True                            board[i][j] = &#x27;.&#x27;                    return False        return True    def is_valid(self, board, row, col, num):        if num in board[row]:            return False        if num in [board[i][col] for i in range(9)]:            return False        start_row, start_col = 3 * (row // 3), 3 * (col // 3)        for i in range(3):            for j in range(3):                if board[start_row + i][start_col + j] == num:                    return False        return True\n\n结果执行用时 : 325 ms, 击败 42.81% 使用 Python3 的用户\n内存消耗 : 16.38 MB, 击败 40.06% 使用 Python3 的用户\n\nCvoid solveSudoku(char** board, int boardSize, int* boardColSize) &#123;    solve(board, boardSize, boardColSize);&#125;int isValid(char** board, int row, int col, char num, int boardSize) &#123;    for (int i = 0; i &lt; boardSize; ++i) &#123;        if (board[row][i] == num || board[i][col] == num || board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num) &#123;            return 0;        &#125;    &#125;    return 1;&#125;int solve(char** board, int boardSize, int* boardColSize) &#123;    for (int i = 0; i &lt; boardSize; ++i) &#123;        for (int j = 0; j &lt; *boardColSize; ++j) &#123;            if (board[i][j] == &#x27;.&#x27;) &#123;                for (char num = &#x27;1&#x27;; num &lt;= &#x27;9&#x27;; ++num) &#123;                    if (isValid(board, i, j, num, boardSize)) &#123;                        board[i][j] = num;                        if (solve(board, boardSize, boardColSize)) &#123;                            return 1;                        &#125;                        board[i][j] = &#x27;.&#x27;;                    &#125;                &#125;                return 0;            &#125;        &#125;    &#125;    return 1;&#125;\n\n结果执行用时 : 19 ms, 击败 6.45% 使用 C 的用户\n内存消耗 : 5.71 MB, 击败 86.69% 使用 C 的用户\n\nC#public class Solution &#123;    public void SolveSudoku(char[][] board) &#123;        Solve(board);    &#125;    private bool Solve(char[][] board) &#123;        for (int i = 0; i &lt; 9; ++i) &#123;            for (int j = 0; j &lt; 9; ++j) &#123;                if (board[i][j] == &#x27;.&#x27;) &#123;                    for (char num = &#x27;1&#x27;; num &lt;= &#x27;9&#x27;; ++num) &#123;                        if (IsValid(board, i, j, num)) &#123;                            board[i][j] = num;                            if (Solve(board)) &#123;                                return true;                            &#125;                            board[i][j] = &#x27;.&#x27;;                        &#125;                    &#125;                    return false;                &#125;            &#125;        &#125;        return true;    &#125;    private bool IsValid(char[][] board, int row, int col, char num) &#123;        for (int i = 0; i &lt; 9; ++i) &#123;            if (board[row][i] == num || board[i][col] == num || board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n结果执行用时 : 128 ms, 击败 88.89% 使用 C# 的用户\n内存消耗 : 46.63 MB, 击败 15.87% 使用 C# 的用户\n\nJavaScript/** * @param &#123;character[][]&#125; board * @return &#123;void&#125; Do not return anything, modify board in-place instead. */const solveSudoku = (board) =&gt; &#123;    const hasConflit = (r, c, val) =&gt; &#123;        for (let i = 0; i &lt; 9; i++) &#123;            if (board[i][c] == val || board[r][i] == val) &#123;                return true;            &#125;        &#125;        const subRowStart = Math.floor(r / 3) * 3;        const subColStart = Math.floor(c / 3) * 3;        for (let i = 0; i &lt; 3; i++) &#123;            for (let j = 0; j &lt; 3; j++) &#123;                if (val == board[subRowStart + i][subColStart + j]) &#123;                    return true;                &#125;            &#125;        &#125;        return false;    &#125;;    const fill = (i, j) =&gt; &#123;        if (j == 9) &#123;            i++;            j = 0;            if (i == 9) return true;        &#125;        if (board[i][j] != &quot;.&quot;) return fill(i, j + 1);        for (let num = 1; num &lt;= 9; num++) &#123;            if (hasConflit(i, j, String(num))) continue;            board[i][j] = String(num);            if (fill(i, j + 1)) return true;            board[i][j] = &quot;.&quot;;        &#125;        return false;    &#125;;    fill(0, 0);    return board;&#125;;\n\n结果执行用时 : 78 ms, 击败 84.59% 使用 JavaScript 的用户\n内存消耗 : 50.79 MB, 击败 15.41% 使用 JavaScript 的用户\n\nTypeScript/** Do not return anything, modify board in-place instead. */function solveSudoku(board: string[][]): void &#123;    const hasConflit = (r: number, c: number, val: string): boolean =&gt; &#123;        for (let i = 0; i &lt; 9; i++) &#123;            if (board[i][c] === val || board[r][i] === val) &#123;                return true;            &#125;        &#125;        const subRowStart = Math.floor(r / 3) * 3;        const subColStart = Math.floor(c / 3) * 3;        for (let i = 0; i &lt; 3; i++) &#123;            for (let j = 0; j &lt; 3; j++) &#123;                if (val === board[subRowStart + i][subColStart + j]) &#123;                    return true;                &#125;            &#125;        &#125;        return false;    &#125;;    const fill = (i: number, j: number): boolean =&gt; &#123;        if (j === 9) &#123;            i++;            j = 0;            if (i === 9) return true;        &#125;        if (board[i][j] !== &quot;.&quot;) return fill(i, j + 1);        for (let num = 1; num &lt;= 9; num++) &#123;            const strNum = String(num);            if (!hasConflit(i, j, strNum)) &#123;                board[i][j] = strNum;                if (fill(i, j + 1)) return true;                board[i][j] = &quot;.&quot;;            &#125;        &#125;        return false;    &#125;;    fill(0, 0);&#125;\n\n结果执行用时 : 82 ms, 击败 67.31% 使用 TypeScript 的用户\n内存消耗 : 51.56 MB, 击败 13.46% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String[][] $board     * @return NULL     */    function solveSudoku(&amp;$board) &#123;        $this-&gt;solve($board);    &#125;    function hasConflit($board, $r, $c, $val) &#123;        for ($i = 0; $i &lt; 9; $i++) &#123;            if ($board[$i][$c] === $val || $board[$r][$i] === $val) &#123;                return true;            &#125;        &#125;        $subRowStart = floor($r / 3) * 3;        $subColStart = floor($c / 3) * 3;        for ($i = 0; $i &lt; 3; $i++) &#123;            for ($j = 0; $j &lt; 3; $j++) &#123;                if ($val === $board[$subRowStart + $i][$subColStart + $j]) &#123;                    return true;                &#125;            &#125;        &#125;        return false;    &#125;    function fill(&amp;$board, $i, $j) &#123;        if ($j === 9) &#123;            $i++;            $j = 0;            if ($i === 9) return true;        &#125;        if ($board[$i][$j] !== &quot;.&quot;) return $this-&gt;fill($board, $i, $j + 1);        for ($num = 1; $num &lt;= 9; $num++) &#123;            $strNum = strval($num);            if (!$this-&gt;hasConflit($board, $i, $j, $strNum)) &#123;                $board[$i][$j] = $strNum;                if ($this-&gt;fill($board, $i, $j + 1)) return true;                $board[$i][$j] = &quot;.&quot;;            &#125;        &#125;        return false;    &#125;    function solve(&amp;$board) &#123;        $this-&gt;fill($board, 0, 0);    &#125;&#125;\n\n结果执行用时 : 113 ms, 击败 50.00% 使用 PHP 的用户\n内存消耗 : 20.03 MB, 击败 -% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    var line = Array(repeating: Set&lt;Int&gt;(), count: 9)    var column = Array(repeating: Set&lt;Int&gt;(), count: 9)    var block = Array(repeating: Array(repeating: Set&lt;Int&gt;(), count: 3), count: 3)    var valid = false    var spaces = [[Int]]()    func solveSudoku(_ board: inout [[Character]]) &#123;        initializeSets(with: board)        DFS(&amp;board, 0)    &#125;    func initializeSets(with board: [[Character]]) &#123;        for i in 0..&lt;9 &#123;            for j in 0..&lt;9 &#123;                if board[i][j] == &quot;.&quot; &#123;                    spaces.append([i, j])                &#125; else &#123;                    let digit = Int(String(board[i][j]))! - 1                    line[i].insert(digit)                    column[j].insert(digit)                    block[i/3][j/3].insert(digit)                &#125;            &#125;        &#125;    &#125;    func DFS(_ board: inout [[Character]], _ pos: Int) &#123;        if pos == spaces.count &#123;            valid = true            return        &#125;        let space = spaces[pos]        let i = space[0]        let j = space[1]        var digit = 0        while digit &lt; 9 &amp;&amp; !valid &#123;            if !line[i].contains(digit) &amp;&amp; !column[j].contains(digit) &amp;&amp; !block[i/3][j/3].contains(digit) &#123;                line[i].insert(digit)                column[j].insert(digit)                block[i/3][j/3].insert(digit)                board[i][j] = Character(String(digit + 1))                DFS(&amp;board, pos + 1)                line[i].remove(digit)                column[j].remove(digit)                block[i/3][j/3].remove(digit)            &#125;            digit += 1        &#125;    &#125;&#125;\n\n结果执行用时 : 46 ms, 击败 13.33% 使用 Swift 的用户\n内存消耗 : 16.30 MB, 击败 6.67% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun solveSudoku(board: Array&lt;CharArray&gt;): Unit &#123;        solve(board)    &#125;    private fun solve(board: Array&lt;CharArray&gt;): Boolean &#123;        for (i in 0 until 9) &#123;            for (j in 0 until 9) &#123;                if (board[i][j] == &#x27;.&#x27;) &#123;                    for (num in &#x27;1&#x27;..&#x27;9&#x27;) &#123;                        if (isValid(board, i, j, num)) &#123;                            board[i][j] = num                            if (solve(board)) &#123;                                return true                            &#125;                            board[i][j] = &#x27;.&#x27;                        &#125;                    &#125;                    return false                &#125;            &#125;        &#125;        return true    &#125;    private fun isValid(board: Array&lt;CharArray&gt;, row: Int, col: Int, num: Char): Boolean &#123;        for (i in 0 until 9) &#123;            if (board[row][i] == num || board[i][col] == num || board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num) &#123;                return false            &#125;        &#125;        return true    &#125;&#125;\n\n结果执行用时 : 149 ms, 击败 92.86% 使用 Kotlin 的用户\n内存消耗 : 34.05 MB, 击败 92.86% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  void solveSudoku(List&lt;List&lt;String&gt;&gt; board) &#123;    solve(board);  &#125;  bool solve(List&lt;List&lt;String&gt;&gt; board) &#123;    for (int i = 0; i &lt; 9; ++i) &#123;      for (int j = 0; j &lt; 9; ++j) &#123;        if (board[i][j] == &#x27;.&#x27;) &#123;          for (int num = 1; num &lt;= 9; ++num) &#123;            String strNum = num.toString();            if (isValid(board, i, j, strNum)) &#123;              board[i][j] = strNum;              if (solve(board)) &#123;                return true;              &#125;              board[i][j] = &#x27;.&#x27;;            &#125;          &#125;          return false;        &#125;      &#125;    &#125;    return true;  &#125;  bool isValid(List&lt;List&lt;String&gt;&gt; board, int row, int col, String num) &#123;    for (int i = 0; i &lt; 9; ++i) &#123;      if (board[row][i] == num || board[i][col] == num ||          board[3 * (row ~/ 3) + i ~/ 3][3 * (col ~/ 3) + i % 3] == num) &#123;        return false;      &#125;    &#125;    return true;  &#125;&#125;\n\n结果执行用时 : 289 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 145.09 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc solveSudoku(board [][]byte) &#123;\tsolve(board)&#125;func solve(board [][]byte) bool &#123;\tfor i := 0; i &lt; 9; i++ &#123;\t\tfor j := 0; j &lt; 9; j++ &#123;\t\t\tif board[i][j] == &#x27;.&#x27; &#123;\t\t\t\tfor num := byte(&#x27;1&#x27;); num &lt;= &#x27;9&#x27;; num++ &#123;\t\t\t\t\tif isValid(board, i, j, num) &#123;\t\t\t\t\t\tboard[i][j] = num\t\t\t\t\t\tif solve(board) &#123;\t\t\t\t\t\t\treturn true\t\t\t\t\t\t&#125;\t\t\t\t\t\tboard[i][j] = &#x27;.&#x27;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\treturn false\t\t\t&#125;\t\t&#125;\t&#125;\treturn true&#125;func isValid(board [][]byte, row, col int, num byte) bool &#123;\tfor i := 0; i &lt; 9; i++ &#123;\t\tif board[row][i] == num || board[i][col] == num ||\t\t\tboard[3*(row/3)+i/3][3*(col/3)+i%3] == num &#123;\t\t\treturn false\t\t&#125;\t&#125;\treturn true&#125;\n\n结果执行用时 : 3 ms, 击败 70.00% 使用 Go 的用户\n内存消耗 : 1.88 MB, 击败 86.32% 使用 Go 的用户\n\nRuby# @param &#123;Character[][]&#125; board# @return &#123;Void&#125; Do not return anything, modify board in-place instead.def solve_sudoku(board)  solve(board)enddef solve(board)  (0..8).each do |i|    (0..8).each do |j|      if board[i][j] == &#x27;.&#x27;        (&#x27;1&#x27;..&#x27;9&#x27;).each do |num|          if is_valid(board, i, j, num)            board[i][j] = num            return true if solve(board)            board[i][j] = &#x27;.&#x27;          end        end        return false      end    end  end  trueenddef is_valid(board, row, col, num)  num = num.to_s  (0..8).each do |i|    return false if board[row][i] == num || board[i][col] == num ||                   board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num  end  trueend\n\n结果执行用时 : 548 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.85 MB, 击败 100.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def solveSudoku(board: Array[Array[Char]]): Unit = &#123;    solve(board)  &#125;  def solve(board: Array[Array[Char]]): Boolean = &#123;    for (i &lt;- 0 until 9) &#123;      for (j &lt;- 0 until 9) &#123;        if (board(i)(j) == &#x27;.&#x27;) &#123;          for (num &lt;- &#x27;1&#x27; to &#x27;9&#x27;) &#123;            if (isValid(board, i, j, num)) &#123;              board(i)(j) = num              if (solve(board)) &#123;                return true              &#125;              board(i)(j) = &#x27;.&#x27;            &#125;          &#125;          return false        &#125;      &#125;    &#125;    true  &#125;  def isValid(board: Array[Array[Char]], row: Int, col: Int, num: Char): Boolean = &#123;    for (i &lt;- 0 until 9) &#123;      if (board(row)(i) == num || board(i)(col) == num ||        board(3 * (row / 3) + i / 3)(3 * (col / 3) + i % 3) == num) &#123;        return false      &#125;    &#125;    true  &#125;&#125;\n\n结果执行用时 : 637 ms, 击败 80.00% 使用 Scala 的用户\n内存消耗 : 56.14 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn solve_sudoku(board: &amp;mut Vec&lt;Vec&lt;char&gt;&gt;) &#123;        Self::solve(board);    &#125;    fn solve(board: &amp;mut Vec&lt;Vec&lt;char&gt;&gt;) -&gt; bool &#123;        for i in 0..9 &#123;            for j in 0..9 &#123;                if board[i][j] == &#x27;.&#x27; &#123;                    for num in &#x27;1&#x27;..=&#x27;9&#x27; &#123;                        if Self::is_valid(board, i, j, num) &#123;                            board[i][j] = num;                            if Self::solve(board) &#123;                                return true;                            &#125;                            board[i][j] = &#x27;.&#x27;;                        &#125;                    &#125;                    return false;                &#125;            &#125;        &#125;        true    &#125;    fn is_valid(board: &amp;Vec&lt;Vec&lt;char&gt;&gt;, row: usize, col: usize, num: char) -&gt; bool &#123;        let num = num as u8;        for i in 0..9 &#123;            if board[row][i] as u8 == num || board[i][col] as u8 == num ||               board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] as u8 == num &#123;                return false;            &#125;        &#125;        true    &#125;&#125;\n\n结果执行用时 : 6 ms, 击败 13.89% 使用 Rust 的用户\n内存消耗 : 2.06 MB, 击败 75.00% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket"]},{"title":"除夕","url":"/zh-CN/9f3be51aaf4c/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  除夕快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","除夕"]},{"title":"力扣00038.外观数列","url":"/zh-CN/7adb8cf4cae0/","content":"\n题目描述给定一个正整数 n ，输出外观数列的第 n 项。\n「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。\n你可以将其视作是由递归公式定义的数字字符串序列：\n\ncountAndSay(1) &#x3D; “1”\ncountAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。\n\n前五项如下：\n\n1\n11\n21\n1211\n111221\n第一项是数字 1描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 “11”描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 “21”描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 “1211”描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 “111221”要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。\n\n\n\n例如，数字字符串 “3322251” 的描述如下图：\n\n\n示例 1：\n输入：n &#x3D; 1输出：”1”解释：这是一个基本样例。\n\n示例 2：\n输入：n &#x3D; 4输出：”1211”解释：countAndSay(1) &#x3D; “1”countAndSay(2) &#x3D; 读 “1” &#x3D; 一 个 1 &#x3D; “11”countAndSay(3) &#x3D; 读 “11” &#x3D; 二 个 1 &#x3D; “21”countAndSay(4) &#x3D; 读 “21” &#x3D; 一 个 2 + 一 个 1 &#x3D; “12” + “11” &#x3D; “1211”\n\n提示：\n1 &lt;&#x3D; n &lt;&#x3D; 30\n\n\n解决方法C++class Solution &#123;public:    string countAndSay(int n) &#123;        if (n == 1) &#123;            return &quot;1&quot;;        &#125; else &#123;            string prev = countAndSay(n - 1);            string result = &quot;&quot;;            int count = 1;            for (size_t i = 0; i &lt; prev.length(); ++i) &#123;                if (i + 1 &lt; prev.length() &amp;&amp; prev[i] == prev[i + 1]) &#123;                    count++;                &#125; else &#123;                    result += to_string(count) + prev[i];                    count = 1;                &#125;            &#125;            return result;        &#125;    &#125;&#125;;\n\n结果执行用时 : 3 ms, 击败 78.05% 使用 C++ 的用户\n内存消耗 : 9.09 MB, 击败 12.48% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public String countAndSay(int n) &#123;        if (n == 1) &#123;            return &quot;1&quot;;        &#125; else &#123;            String prev = countAndSay(n - 1);            StringBuilder result = new StringBuilder();            int count = 1;            for (int i = 0; i &lt; prev.length(); i++) &#123;                if (i + 1 &lt; prev.length() &amp;&amp; prev.charAt(i) == prev.charAt(i + 1)) &#123;                    count++;                &#125; else &#123;                    result.append(count).append(prev.charAt(i));                    count = 1;                &#125;            &#125;            return result.toString();        &#125;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 97.05% 使用 Java 的用户\n内存消耗 : 40.21 MB, 击败 59.65% 使用 Java 的用户\n\nPythonclass Solution(object):    def countAndSay(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: str        &quot;&quot;&quot;        if n == 1:            return &quot;1&quot;        else:            prev = self.countAndSay(n - 1)            result = &quot;&quot;            count = 1            for i in range(len(prev)):                if i + 1 &lt; len(prev) and prev[i] == prev[i + 1]:                    count += 1                else:                    result += str(count) + prev[i]                    count = 1            return result\n\n结果执行用时 : 21 ms, 击败 87.04% 使用 Python 的用户\n内存消耗 : 11.59 MB, 击败 91.09% 使用 Python 的用户\n\nPython3class Solution:    def countAndSay(self, n: int) -&gt; str:        if n == 1:            return &quot;1&quot;        else:            prev = self.countAndSay(n - 1)            result = &quot;&quot;            count = 1            for i in range(len(prev)):                if i + 1 &lt; len(prev) and prev[i] == prev[i + 1]:                    count += 1                else:                    result += str(count) + prev[i]                    count = 1            return result\n\n结果执行用时 : 45 ms, 击败 81.55% 使用 Python3 的用户\n内存消耗 : 16.52 MB, 击败 29.61% 使用 Python3 的用户\n\nCchar* countAndSay(int n) &#123;    if (n == 1) &#123;        char* result = malloc(2);        strcpy(result, &quot;1&quot;);        return result;    &#125; else &#123;        char* prev = countAndSay(n - 1);        int len = strlen(prev);        char* result = malloc(2 * len + 1);        int count = 1;        int index = 0;        for (int i = 0; i &lt; len; ++i) &#123;            if (i + 1 &lt; len &amp;&amp; prev[i] == prev[i + 1]) &#123;                count++;            &#125; else &#123;                index += sprintf(result + index, &quot;%d%c&quot;, count, prev[i]);                count = 1;            &#125;        &#125;        free(prev);        return result;    &#125;&#125;\n\n结果执行用时 : 12 ms, 击败 7.90% 使用 C 的用户\n内存消耗 : 6.36 MB, 击败 90.88% 使用 C 的用户\n\nC#public class Solution &#123;    public string CountAndSay(int n) &#123;        if (n == 1) &#123;            return &quot;1&quot;;        &#125; else &#123;            string prev = CountAndSay(n - 1);            System.Text.StringBuilder result = new System.Text.StringBuilder();            int count = 1;            for (int i = 0; i &lt; prev.Length; ++i) &#123;                if (i + 1 &lt; prev.Length &amp;&amp; prev[i] == prev[i + 1]) &#123;                    count++;                &#125; else &#123;                    result.Append(count).Append(prev[i]);                    count = 1;                &#125;            &#125;            return result.ToString();        &#125;    &#125;&#125;\n\n结果执行用时 : 57 ms, 击败 86.11% 使用 C# 的用户\n内存消耗 : 40.65 MB, 击败 51.39% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number&#125; n * @return &#123;string&#125; */var countAndSay = function(n) &#123;    if (n === 1) &#123;        return &quot;1&quot;;    &#125; else &#123;        var prev = countAndSay(n - 1);        var result = &quot;&quot;;        var count = 1;        for (var i = 0; i &lt; prev.length; ++i) &#123;            if (i + 1 &lt; prev.length &amp;&amp; prev[i] === prev[i + 1]) &#123;                count++;            &#125; else &#123;                result += count + prev[i];                count = 1;            &#125;        &#125;        return result;    &#125;&#125;;\n\n结果执行用时 : 64 ms, 击败 66.33% 使用 JavaScript 的用户\n内存消耗 : 52.34 MB, 击败 5.01% 使用 JavaScript 的用户\n\nTypeScriptfunction countAndSay(n: number): string &#123;    if (n === 1) &#123;        return &quot;1&quot;;    &#125; else &#123;        const prev: string = countAndSay(n - 1);        let result: string = &quot;&quot;;        let count: number = 1;        for (let i: number = 0; i &lt; prev.length; ++i) &#123;            if (i + 1 &lt; prev.length &amp;&amp; prev[i] === prev[i + 1]) &#123;                count++;            &#125; else &#123;                result += count + prev[i];                count = 1;            &#125;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 64 ms, 击败 84.00% 使用 TypeScript 的用户\n内存消耗 : 52.96 MB, 击败 6.00% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer $n     * @return String     */    function countAndSay($n) &#123;        if ($n === 1) &#123;            return &quot;1&quot;;        &#125; else &#123;            $prev = $this-&gt;countAndSay($n - 1);            $result = &quot;&quot;;            $count = 1;            for ($i = 0; $i &lt; strlen($prev); ++$i) &#123;                if ($i + 1 &lt; strlen($prev) &amp;&amp; $prev[$i] === $prev[$i + 1]) &#123;                    $count++;                &#125; else &#123;                    $result .= $count . $prev[$i];                    $count = 1;                &#125;            &#125;            return $result;        &#125;    &#125;&#125;\n\n结果执行用时 : 7 ms, 击败 87.50% 使用 PHP 的用户\n内存消耗 : 20.10 MB, 击败 12.50% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func countAndSay(_ n: Int) -&gt; String &#123;        if n == 1 &#123;            return &quot;1&quot;        &#125; else &#123;            let prev = countAndSay(n - 1)            var result = &quot;&quot;            var count = 1            for i in 0..&lt;prev.count &#123;                if i + 1 &lt; prev.count &amp;&amp; prev[prev.index(prev.startIndex, offsetBy: i)] == prev[prev.index(prev.startIndex, offsetBy: i + 1)] &#123;                    count += 1                &#125; else &#123;                    result += &quot;\\(count)\\(prev[prev.index(prev.startIndex, offsetBy: i)])&quot;                    count = 1                &#125;            &#125;            return result        &#125;    &#125;&#125;\n\n结果执行用时 : 1663 ms, 击败 10.53% 使用 Swift 的用户\n内存消耗 : 14.85 MB, 击败 68.42% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun countAndSay(n: Int): String &#123;        if (n == 1) &#123;            return &quot;1&quot;        &#125; else &#123;            val prev = countAndSay(n - 1)            var result = &quot;&quot;            var count = 1            for (i in 0 until prev.length) &#123;                if (i + 1 &lt; prev.length &amp;&amp; prev[i] == prev[i + 1]) &#123;                    count++                &#125; else &#123;                    result += &quot;$count$&#123;prev[i]&#125;&quot;                    count = 1                &#125;            &#125;            return result        &#125;    &#125;&#125;\n\n结果执行用时 : 168 ms, 击败 82.35% 使用 Kotlin 的用户\n内存消耗 : 36.61 MB, 击败 64.71% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  String countAndSay(int n) &#123;    if (n == 1) &#123;      return &quot;1&quot;;    &#125; else &#123;      String prev = countAndSay(n - 1);      StringBuffer result = StringBuffer();      int count = 1;      for (int i = 0; i &lt; prev.length; ++i) &#123;        if (i + 1 &lt; prev.length &amp;&amp; prev[i] == prev[i + 1]) &#123;          count++;        &#125; else &#123;          result.write(&quot;$count$&#123;prev[i]&#125;&quot;);          count = 1;        &#125;      &#125;      return result.toString();    &#125;  &#125;&#125;\n\n结果执行用时 : 291 ms, 击败 -% 使用 Dart 的用户\n内存消耗 : 147.80 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc countAndSay(n int) string &#123;\tprev := &quot;1&quot;\tfor i := 2; i &lt;= n; i++ &#123;\t\tvar cur strings.Builder\t\tfor j, start := 0, 0; j &lt; len(prev); start = j &#123;\t\t\tfor j &lt; len(prev) &amp;&amp; prev[j] == prev[start] &#123;\t\t\t\tj++\t\t\t&#125;\t\t\tcur.WriteString(strconv.Itoa(j - start))\t\t\tcur.WriteByte(prev[start])\t\t&#125;\t\tprev = cur.String()\t&#125;\treturn prev&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.30 MB, 击败 90.00% 使用 Go 的用户\n\nRuby# @param &#123;Integer&#125; n# @return &#123;String&#125;def count_and_say(n)  prev = &quot;1&quot;  (2..n).each do    cur = &quot;&quot;    i, start = 0, 0    while i &lt; prev.length      while i &lt; prev.length &amp;&amp; prev[i] == prev[start]        i += 1      end      cur += &quot;#&#123;i - start&#125;#&#123;prev[start]&#125;&quot;      start = i    end    prev = cur  end  return prevend\n\n结果执行用时 : 91 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 210.46 MB, 击败 100.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def countAndSay(n: Int): String = &#123;    if (n == 1) &#123;      &quot;1&quot;    &#125; else &#123;      val prev = countAndSay(n - 1)      val result = new StringBuilder      var count = 1      for (i &lt;- 0 until prev.length) &#123;        if (i + 1 &lt; prev.length &amp;&amp; prev(i) == prev(i + 1)) &#123;          count += 1        &#125; else &#123;          result.append(count).append(prev(i))          count = 1        &#125;      &#125;      result.toString    &#125;  &#125;&#125;\n\n结果执行用时 : 428 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 52.55 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn count_and_say(n: i32) -&gt; String &#123;        if n == 1 &#123;            return &quot;1&quot;.to_string();        &#125; else &#123;            let prev = Solution::count_and_say(n - 1);            let mut result = String::new();            let mut count = 1;            for i in 0..prev.len() &#123;                if i + 1 &lt; prev.len() &amp;&amp; prev.chars().nth(i).unwrap() == prev.chars().nth(i + 1).unwrap() &#123;                    count += 1;                &#125; else &#123;                    result.push_str(&amp;count.to_string());                    result.push(prev.chars().nth(i).unwrap());                    count = 1;                &#125;            &#125;            result        &#125;    &#125;&#125;\n\n结果执行用时 : 52 ms, 击败 17.65% 使用 Rust 的用户\n内存消耗 : 2.07 MB, 击败 58.82% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"女超人 第五季 第十一集 从未来回来-第一部分","url":"/zh-CN/b50bb960a9eb/","content":"\n剧情介绍　　女超人试图阻止一个玩具人模仿者时，温恩·肖特从未来回到了现实。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第一季 第十一集 致命礼物","url":"/zh-CN/efffb0bcdec6/","content":"\n剧情介绍　　在凯恩姐妹的生日这一天，凯特和爱丽丝不得不面对来自过去的阴影，而一位意想不到的客人突然现身哥谭，带来了意外的惊喜。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"黑闪电 第三季 第十一集 马科维亚之书：第二章：林无法自拔","url":"/zh-CN/ef7dc0be2e5c/","content":"\n剧情介绍　　杰斐逊、安妮莎和珍妮弗发现，ASA现在正追捕整个皮尔斯家族。与此同时，琳恩做出了出人意料的决定。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00039.组合总和","url":"/zh-CN/4e0128a79bbd/","content":"\n题目描述给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\ncandidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 \n对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n示例 1：\n输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。7 也是一个候选， 7 &#x3D; 7 。仅有这两种组合。\n\n示例 2：\n输入: candidates &#x3D; [2,3,5], target &#x3D; 8输出: [[2,2,2,2],[2,3,3],[3,5]]\n\n示例 3：\n输入: candidates &#x3D; [2], target &#x3D; 1输出: []\n\n提示：\n1 &lt;&#x3D; candidates.length &lt;&#x3D; 30\n2 &lt;&#x3D; candidates[i] &lt;&#x3D; 40\ncandidates 的所有元素 互不相同\n1 &lt;&#x3D; target &lt;&#x3D; 40\n\n\n解决方法C++class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;        sort(candidates.begin(), candidates.end());        vector&lt;vector&lt;int&gt;&gt; result;        vector&lt;int&gt; path;        backtrack(candidates, target, 0, path, result);        return result;    &#125;private:    void backtrack(const vector&lt;int&gt;&amp; candidates, int target, int start,                   vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123;        if (target == 0) &#123;            result.push_back(path);            return;        &#125;        for (int i = start; i &lt; candidates.size(); ++i) &#123;            if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) &#123;                continue;            &#125;            if (candidates[i] &gt; target) &#123;                continue;            &#125;            path.push_back(candidates[i]);            backtrack(candidates, target - candidates[i], i, path, result);            path.pop_back();        &#125;    &#125;&#125;;\n\n结果执行用时 : 3 ms, 击败 87.96% 使用 C++ 的用户\n内存消耗 : 12.11 MB, 击败 40.40% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;        Arrays.sort(candidates);        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();        backtrack(candidates, target, 0, path, result);        return result;    &#125;    private void backtrack(int[] candidates, int target, int start,                           List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result) &#123;        if (target == 0) &#123;            result.add(new ArrayList&lt;&gt;(path));            return;        &#125;        for (int i = start; i &lt; candidates.length; ++i) &#123;            if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) &#123;                continue;            &#125;            if (candidates[i] &gt; target) &#123;                continue;            &#125;            path.add(candidates[i]);            backtrack(candidates, target - candidates[i], i, path, result);            path.remove(path.size() - 1);        &#125;    &#125;&#125;\n\n结果执行用时 : 2 ms, 击败 82.50% 使用 Java 的用户\n内存消耗 : 43.55 MB, 击败 28.62% 使用 Java 的用户\n\nPythonclass Solution(object):    def combinationSum(self, candidates, target):        &quot;&quot;&quot;        :type candidates: List[int]        :type target: int        :rtype: List[List[int]]        &quot;&quot;&quot;        candidates.sort()        result = []        path = []        def backtrack(start, target, path):            if target == 0:                result.append(path[:])                return            for i in range(start, len(candidates)):                if i &gt; start and candidates[i] == candidates[i-1]:                    continue                if candidates[i] &gt; target:                    continue                path.append(candidates[i])                backtrack(i, target - candidates[i], path)                path.pop()        backtrack(0, target, path)        return result\n\n结果执行用时 : 30 ms, 击败 76.75% 使用 Python 的用户\n内存消耗 : 11.51 MB, 击败 93.61% 使用 Python 的用户\n\nPython3class Solution:    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:        candidates.sort()        result = []        path = []        def backtrack(start, target, path):            if target == 0:                result.append(path[:])                return            for i in range(start, len(candidates)):                if i &gt; start and candidates[i] == candidates[i-1]:                    continue                if candidates[i] &gt; target:                    continue                path.append(candidates[i])                backtrack(i, target - candidates[i], path)                path.pop()        backtrack(0, target, path)        return result\n\n结果执行用时 : 46 ms, 击败 82.10% 使用 Python3 的用户\n内存消耗 : 16.65 MB, 击败 30.56% 使用 Python3 的用户\n\nC/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int candidatesSize_tmp;int ansSize;int combineSize;int* ansColumnSize;void backtrack(int* candidates, int target, int** ans, int* combine, int start) &#123;    if (target == 0) &#123;        int* tmp = malloc(sizeof(int) * combineSize);        for (int i = 0; i &lt; combineSize; ++i) &#123;            tmp[i] = combine[i];        &#125;        ans[ansSize] = tmp;        ansColumnSize[ansSize++] = combineSize;        return;    &#125;    for (int i = start; i &lt; candidatesSize_tmp; ++i) &#123;        if (target - candidates[i] &lt; 0) &#123;            continue;        &#125;        combine[combineSize++] = candidates[i];        backtrack(candidates, target - candidates[i], ans, combine, i);        combineSize--;    &#125;&#125;int** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes) &#123;    candidatesSize_tmp = candidatesSize;    ansSize = combineSize = 0;    int** ans = malloc(sizeof(int*) * 1001);    ansColumnSize = malloc(sizeof(int) * 1001);    int combine[2001];    backtrack(candidates, target, ans, combine, 0);    *returnSize = ansSize;    *returnColumnSizes = ansColumnSize;    return ans;&#125;\n\n结果执行用时 : 6 ms, 击败 94.16% 使用 C 的用户\n内存消耗 : 9.00 MB, 击败 51.89% 使用 C 的用户\n\nC#public class Solution &#123;    public IList&lt;IList&lt;int&gt;&gt; CombinationSum(int[] candidates, int target) &#123;        Array.Sort(candidates);        IList&lt;IList&lt;int&gt;&gt; result = new List&lt;IList&lt;int&gt;&gt;();        IList&lt;int&gt; path = new List&lt;int&gt;();        Backtrack(candidates, target, 0, path, result);        return result;    &#125;    private void Backtrack(int[] candidates, int target, int start, IList&lt;int&gt; path, IList&lt;IList&lt;int&gt;&gt; result) &#123;        if (target == 0) &#123;            result.Add(new List&lt;int&gt;(path));            return;        &#125;        for (int i = start; i &lt; candidates.Length; ++i) &#123;            if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) &#123;                continue;            &#125;            if (candidates[i] &gt; target) &#123;                continue;            &#125;            path.Add(candidates[i]);            Backtrack(candidates, target - candidates[i], i, path, result);            path.RemoveAt(path.Count - 1);        &#125;    &#125;&#125;\n\n结果执行用时 : 103 ms, 击败 91.01% 使用 C# 的用户\n内存消耗 : 46.77 MB, 击败 19.10% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; candidates * @param &#123;number&#125; target * @return &#123;number[][]&#125; */var combinationSum = function(candidates, target) &#123;    candidates.sort((a, b) =&gt; a - b);    const result = [];    const path = [];    function backtrack(start, target) &#123;        if (target === 0) &#123;            result.push([...path]);            return;        &#125;        for (let i = start; i &lt; candidates.length; i++) &#123;            if (i &gt; start &amp;&amp; candidates[i] === candidates[i - 1]) &#123;                continue;            &#125;            if (candidates[i] &gt; target) &#123;                continue;            &#125;            path.push(candidates[i]);            backtrack(i, target - candidates[i]);            path.pop();        &#125;    &#125;    backtrack(0, target);    return result;&#125;;\n\n结果执行用时 : 67 ms, 击败 94.88% 使用 JavaScript 的用户\n内存消耗 : 53.99 MB, 击败 13.71% 使用 JavaScript 的用户\n\nTypeScriptfunction combinationSum(candidates: number[], target: number): number[][] &#123;    candidates.sort((a, b) =&gt; a - b);    const result: number[][] = [];    const path: number[] = [];    function backtrack(start: number, target: number): void &#123;        if (target === 0) &#123;            result.push([...path]);            return;        &#125;        for (let i = start; i &lt; candidates.length; i++) &#123;            if (i &gt; start &amp;&amp; candidates[i] === candidates[i - 1]) &#123;                continue;            &#125;            if (candidates[i] &gt; target) &#123;                continue;            &#125;            path.push(candidates[i]);            backtrack(i, target - candidates[i]);            path.pop();        &#125;    &#125;    backtrack(0, target);    return result;&#125;\n\n结果执行用时 : 81 ms, 击败 55.52% 使用 TypeScript 的用户\n内存消耗 : 54.88 MB, 击败 12.61% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $candidates     * @param Integer $target     * @return Integer[][]     */    function combinationSum($candidates, $target) &#123;        sort($candidates);        $result = [];        $path = [];        $this-&gt;backtrack($candidates, $target, 0, $path, $result);        return $result;    &#125;    private function backtrack($candidates, $target, $start, &amp;$path, &amp;$result) &#123;        if ($target === 0) &#123;            $result[] = $path;            return;        &#125;        for ($i = $start; $i &lt; count($candidates); $i++) &#123;            if ($i &gt; $start &amp;&amp; $candidates[$i] === $candidates[$i - 1]) &#123;                continue;            &#125;            if ($candidates[$i] &gt; $target) &#123;                continue;            &#125;            $path[] = $candidates[$i];            $this-&gt;backtrack($candidates, $target - $candidates[$i], $i, $path, $result);            array_pop($path);        &#125;    &#125;&#125;\n\n结果执行用时 : 15 ms, 击败 56.10% 使用 PHP 的用户\n内存消耗 : 20.44 MB, 击败 7.32% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func combinationSum(_ candidates: [Int], _ target: Int) -&gt; [[Int]] &#123;        var candidates = candidates.sorted()        var result: [[Int]] = []        var path: [Int] = []        backtrack(&amp;candidates, target, 0, &amp;path, &amp;result)        return result    &#125;    private func backtrack(_ candidates: inout [Int], _ target: Int, _ start: Int, _ path: inout [Int], _ result: inout [[Int]]) &#123;        if target == 0 &#123;            result.append(path)            return        &#125;        for i in start..&lt;candidates.count &#123;            if i &gt; start &amp;&amp; candidates[i] == candidates[i - 1] &#123;                continue            &#125;            if candidates[i] &gt; target &#123;                continue            &#125;            path.append(candidates[i])            backtrack(&amp;candidates, target - candidates[i], i, &amp;path, &amp;result)            path.removeLast()        &#125;    &#125;&#125;\n\n结果执行用时 : 7 ms, 击败 99.16% 使用 Swift 的用户\n内存消耗 : 15.84 MB, 击败 5.88% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun combinationSum(candidates: IntArray, target: Int): List&lt;List&lt;Int&gt;&gt; &#123;        val candidatesSorted = candidates.sorted().toIntArray()        val result = mutableListOf&lt;List&lt;Int&gt;&gt;()        val path = mutableListOf&lt;Int&gt;()        backtrack(candidatesSorted, target, 0, path, result)        return result    &#125;    private fun backtrack(candidates: IntArray, target: Int, start: Int, path: MutableList&lt;Int&gt;, result: MutableList&lt;List&lt;Int&gt;&gt;) &#123;        if (target == 0) &#123;            result.add(ArrayList(path))            return        &#125;        for (i in start until candidates.size) &#123;            if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) &#123;                continue            &#125;            if (candidates[i] &gt; target) &#123;                continue            &#125;            path.add(candidates[i])            backtrack(candidates, target - candidates[i], i, path, result)            path.removeAt(path.size - 1)        &#125;    &#125;&#125;\n\n结果执行用时 : 232 ms, 击败 % 使用 Kotlin 的用户\n内存消耗 : 39.69 MB, 击败 % 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;List&lt;int&gt;&gt; combinationSum(List&lt;int&gt; candidates, int target) &#123;    List&lt;List&lt;int&gt;&gt; result = [];    List&lt;int&gt; path = [];    List&lt;int&gt; candidatesSorted = List.from(candidates)..sort();    void backtrack(int start, int target) &#123;      if (target == 0) &#123;        result.add(List.from(path));        return;      &#125;      for (int i = start; i &lt; candidatesSorted.length; i++) &#123;        if (i &gt; start &amp;&amp; candidatesSorted[i] == candidatesSorted[i - 1]) &#123;          continue;        &#125;        if (candidatesSorted[i] &gt; target) &#123;          continue;        &#125;        path.add(candidatesSorted[i]);        backtrack(i, target - candidatesSorted[i]);        path.removeLast();      &#125;    &#125;    backtrack(0, target);    return result;  &#125;&#125;\n\n结果执行用时 : 319 ms, 击败 -% 使用 Dart 的用户\n内存消耗 : 146.83 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc combinationSum(candidates []int, target int) [][]int &#123;\tvar result [][]int\tvar path []int\tsort.Ints(candidates)\tvar backtrack func(start, target int)\tbacktrack = func(start, target int) &#123;\t\tif target == 0 &#123;\t\t\tresult = append(result, append([]int(nil), path...))\t\t\treturn\t\t&#125;\t\tfor i := start; i &lt; len(candidates); i++ &#123;\t\t\tif i &gt; start &amp;&amp; candidates[i] == candidates[i-1] &#123;\t\t\t\tcontinue\t\t\t&#125;\t\t\tif candidates[i] &gt; target &#123;\t\t\t\tcontinue\t\t\t&#125;\t\t\tpath = append(path, candidates[i])\t\t\tbacktrack(i, target-candidates[i])\t\t\tpath = path[:len(path)-1]\t\t&#125;\t&#125;\tbacktrack(0, target)\treturn result&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.61 MB, 击败 84.99% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; candidates# @param &#123;Integer&#125; target# @return &#123;Integer[][]&#125;def combination_sum(candidates, target)  result = []  path = []  candidates.sort!  backtrack = lambda do |start, target|    if target == 0      result &lt;&lt; path.dup      return    end    (start...candidates.length).each do |i|      next if i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]      next if candidates[i] &gt; target      path &lt;&lt; candidates[i]      backtrack.call(i, target - candidates[i])      path.pop    end  end  backtrack.call(0, target)  resultend\n\n结果执行用时 : 67 ms, 击败 90.00% 使用 Ruby 的用户\n内存消耗 : 206.49 MB, 击败 20.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = &#123;    var result: List[List[Int]] = List()    var path: List[Int] = List()    def backtrack(start: Int, target: Int): Unit = &#123;      if (target == 0) &#123;        result = path.reverse :: result        return      &#125;      for (i &lt;- start until candidates.length) &#123;        if (i &gt; start &amp;&amp; candidates(i) == candidates(i - 1)) &#123;        &#125; else if (candidates(i) &lt;= target) &#123;          path = candidates(i) :: path          backtrack(i, target - candidates(i))          path = path.tail        &#125;      &#125;    &#125;    candidates.sorted    backtrack(0, target)    result  &#125;&#125;\n\n结果执行用时 : 522 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 55.73 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn combination_sum(candidates: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; &#123;        let mut result: Vec&lt;Vec&lt;i32&gt;&gt; = Vec::new();        let mut path: Vec&lt;i32&gt; = Vec::new();        let mut candidates_sorted = candidates.clone();        candidates_sorted.sort();        fn backtrack(            candidates: &amp;[i32],            target: i32,            start: usize,            path: &amp;mut Vec&lt;i32&gt;,            result: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;,        ) &#123;            if target == 0 &#123;                result.push(path.clone());                return;            &#125;            for i in start..candidates.len() &#123;                if i &gt; start &amp;&amp; candidates[i] == candidates[i - 1] &#123;                    continue;                &#125;                if candidates[i] &gt; target &#123;                    continue;                &#125;                path.push(candidates[i]);                backtrack(candidates, target - candidates[i], i, path, result);                path.pop();            &#125;        &#125;        backtrack(&amp;candidates_sorted, target, 0, &amp;mut path, &amp;mut result);        result    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.03 MB, 击败 91.36% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"绿箭侠 第八季 第十集 淡出","url":"/zh-CN/fdece2d943c7/","content":"\n剧情介绍　　经过八个赛季，并推出了无数超级英雄，这个系列最终迎来了绿箭侠故事的完结。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"黑闪电 第三季 第十二集 马科维亚之书：第三章：没有母亲的身份","url":"/zh-CN/4b38baf650e6/","content":"\n剧情介绍　　杰斐逊和安妮莎与ASA联手，帮助他们的同胞。与此同时，琳恩被迫继续与自己内心的恶魔作斗争。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"立春","url":"/zh-CN/f830c4da0719/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立春\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立春"]},{"title":"闪电侠 第六季 第十集 马拉松","url":"/zh-CN/62d44c1b22e2/","content":"\n剧情介绍　　在《城市日报》刊登出爆炸性故事后，艾瑞斯的生命受到威胁;艾瑞斯拒绝躲避袭击者，开始揭露一个危险的组织;巴里必须面对危机的后果，实现奥利弗·奎因对他的愿望。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"元宵节","url":"/zh-CN/8373f60c0ba6/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  元宵节快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","元宵节"]},{"title":"黑闪电 第三季 第十三集 马科维亚之书：第四章：十倍奉还","url":"/zh-CN/c7e4192de141/","content":"\n剧情介绍　　黑闪电和他的团队深入马尔科维亚，执行营救琳恩的任务。琳恩在遇到马尔科维亚一方的超能力者——墓地掘者后，陷入了更大的困境。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00040.组合总和 II","url":"/zh-CN/ce16c36a21a7/","content":"\n题目描述给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\ncandidates 中的每个数字在每个组合中只能使用 一次 。\n注意：解集不能包含重复的组合。\n示例 1：\n输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,输出:[[1,1,6],[1,2,5],[1,7],[2,6]]\n\n示例 2：\n输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,输出:[[1,2,2],[5]]\n\n提示：\n1 &lt;&#x3D; candidates.length &lt;&#x3D; 100\n1 &lt;&#x3D; candidates[i] &lt;&#x3D; 50\n1 &lt;&#x3D; target &lt;&#x3D; 30\n\n\n解决方法C++class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        sort(candidates.begin(), candidates.end());        vector&lt;int&gt; current;        backtrack(candidates, target, 0, current, result);        return result;    &#125;private:    void backtrack(const vector&lt;int&gt;&amp; candidates, int target, int start,                   vector&lt;int&gt;&amp; current, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123;        if (target == 0) &#123;            result.push_back(current);            return;        &#125;        for (int i = start; i &lt; candidates.size(); ++i) &#123;            if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) &#123;                continue;            &#125;            if (candidates[i] &gt; target) &#123;                continue;            &#125;            current.push_back(candidates[i]);            backtrack(candidates, target - candidates[i], i + 1, current, result);            current.pop_back();        &#125;    &#125;&#125;;\n\n结果执行用时 : 4 ms, 击败 86.36% 使用 C++ 的用户\n内存消耗 : 12.34 MB, 击败 35.00% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        Arrays.sort(candidates);        List&lt;Integer&gt; current = new ArrayList&lt;&gt;();        backtrack(candidates, target, 0, current, result);        return result;    &#125;    private void backtrack(int[] candidates, int target, int start,                           List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result) &#123;        if (target == 0) &#123;            result.add(new ArrayList&lt;&gt;(current));            return;        &#125;        for (int i = start; i &lt; candidates.length; ++i) &#123;            if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) &#123;                continue;            &#125;            if (candidates[i] &gt; target) &#123;                continue;            &#125;            current.add(candidates[i]);            backtrack(candidates, target - candidates[i], i + 1, current, result);            current.remove(current.size() - 1);        &#125;    &#125;&#125;\n\n结果执行用时 : 3 ms, 击败 66.48% 使用 Java 的用户\n内存消耗 : 42.18 MB, 击败 53.22% 使用 Java 的用户\n\nPythonclass Solution(object):    def combinationSum2(self, candidates, target):        &quot;&quot;&quot;        :type candidates: List[int]        :type target: int        :rtype: List[List[int]]        &quot;&quot;&quot;        def backtrack(start, target, path):            if target == 0:                result.append(path[:])                return            for i in range(start, len(candidates)):                if i &gt; start and candidates[i] == candidates[i-1]:                    continue                if candidates[i] &gt; target:                    continue                path.append(candidates[i])                backtrack(i+1, target-candidates[i], path)                path.pop()        result = []        candidates.sort()        backtrack(0, target, [])        return result\n\n结果执行用时 : 39 ms, 击败 59.84% 使用 Python 的用户\n内存消耗 : 11.57 MB, 击败 85.09% 使用 Python 的用户\n\nPython3class Solution:    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:        def backtrack(start, target, path):            if target == 0:                result.append(path[:])                return            for i in range(start, len(candidates)):                if i &gt; start and candidates[i] == candidates[i-1]:                    continue                if candidates[i] &gt; target:                    continue                path.append(candidates[i])                backtrack(i+1, target-candidates[i], path)                path.pop()        result = []        candidates.sort()        backtrack(0, target, [])        return result\n\n结果执行用时 : 34 ms, 击败 98.78% 使用 Python3 的用户\n内存消耗 : 16.48 MB, 击败 40.06% 使用 Python3 的用户\n\nC/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int compare(const void *a, const void *b) &#123;    return (*(int*)a - *(int*)b);&#125;void backtrack(int* candidates, int candidatesSize, int target, int start, int* path, int pathSize, int** result, int* returnSize, int** returnColumnSizes) &#123;    if (target == 0) &#123;        result[*returnSize] = (int*)malloc(pathSize * sizeof(int));        for (int i = 0; i &lt; pathSize; ++i) &#123;            result[*returnSize][i] = path[i];        &#125;        (*returnColumnSizes)[*returnSize] = pathSize;        (*returnSize)++;        return;    &#125;    for (int i = start; i &lt; candidatesSize; ++i) &#123;        if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) &#123;            continue;        &#125;        if (candidates[i] &gt; target) &#123;            continue;        &#125;        path[pathSize++] = candidates[i];        backtrack(candidates, candidatesSize, target - candidates[i], i + 1, path, pathSize, result, returnSize, returnColumnSizes);        pathSize--;    &#125;&#125;int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes) &#123;    int capacity = 1000;    int** result = (int**)malloc(capacity * sizeof(int*));    *returnColumnSizes = (int*)malloc(capacity * sizeof(int));    *returnSize = 0;    int* path = (int*)malloc(candidatesSize * sizeof(int));    int pathSize = 0;    qsort(candidates, candidatesSize, sizeof(int), compare);    backtrack(candidates, candidatesSize, target, 0, path, pathSize, result, returnSize, returnColumnSizes);    free(path);    return result;&#125;\n\n结果执行用时 : 3 ms, 击败 95.94% 使用 C 的用户\n内存消耗 : 8.56 MB, 击败 63.44% 使用 C 的用户\n\nC#public class Solution &#123;    public IList&lt;IList&lt;int&gt;&gt; CombinationSum2(int[] candidates, int target) &#123;        IList&lt;IList&lt;int&gt;&gt; result = new List&lt;IList&lt;int&gt;&gt;();        List&lt;int&gt; current = new List&lt;int&gt;();        Array.Sort(candidates);        Backtrack(candidates, target, 0, current, result);        return result;    &#125;    private void Backtrack(int[] candidates, int target, int start, List&lt;int&gt; current, IList&lt;IList&lt;int&gt;&gt; result) &#123;        if (target == 0) &#123;            result.Add(new List&lt;int&gt;(current));            return;        &#125;        for (int i = start; i &lt; candidates.Length; ++i) &#123;            if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) &#123;                continue;            &#125;            if (candidates[i] &gt; target) &#123;                continue;            &#125;            current.Add(candidates[i]);            Backtrack(candidates, target - candidates[i], i + 1, current, result);            current.RemoveAt(current.Count - 1);        &#125;    &#125;&#125;\n\n结果执行用时 : 109 ms, 击败 71.58% 使用 C# 的用户\n内存消耗 : 46.38 MB, 击败 13.69% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; candidates * @param &#123;number&#125; target * @return &#123;number[][]&#125; */var combinationSum2 = function(candidates, target) &#123;    let result = [];    let current = [];    candidates.sort((a, b) =&gt; a - b);    function backtrack(start, target) &#123;        if (target === 0) &#123;            result.push([...current]);            return;        &#125;        for (let i = start; i &lt; candidates.length; i++) &#123;            if (i &gt; start &amp;&amp; candidates[i] === candidates[i - 1]) &#123;                continue;            &#125;            if (candidates[i] &gt; target) &#123;                continue;            &#125;            current.push(candidates[i]);            backtrack(i + 1, target - candidates[i]);            current.pop();        &#125;    &#125;    backtrack(0, target);    return result;&#125;;\n\n结果执行用时 : 75 ms, 击败 47.12% 使用 JavaScript 的用户\n内存消耗 : 52.57 MB, 击败 15.22% 使用 JavaScript 的用户\n\nTypeScriptfunction combinationSum2(candidates: number[], target: number): number[][] &#123;    const result: number[][] = [];    const current: number[] = [];    candidates.sort((a, b) =&gt; a - b);    function backtrack(start: number, target: number): void &#123;        if (target === 0) &#123;            result.push([...current]);            return;        &#125;        for (let i = start; i &lt; candidates.length; i++) &#123;            if (i &gt; start &amp;&amp; candidates[i] === candidates[i - 1]) &#123;                continue;            &#125;            if (candidates[i] &gt; target) &#123;                continue;            &#125;            current.push(candidates[i]);            backtrack(i + 1, target - candidates[i]);            current.pop();        &#125;    &#125;    backtrack(0, target);    return result;&#125;\n\n结果执行用时 : 76 ms, 击败 56.86% 使用 TypeScript 的用户\n内存消耗 : 53.46 MB, 击败 11.11% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $candidates     * @param Integer $target     * @return Integer[][]     */    function combinationSum2($candidates, $target) &#123;        $result = [];        $current = [];        sort($candidates);        $this-&gt;backtrack($candidates, $target, 0, $current, $result);        return $result;    &#125;    private function backtrack($candidates, $target, $start, &amp;$current, &amp;$result) &#123;        if ($target === 0) &#123;            $result[] = $current;            return;        &#125;        for ($i = $start; $i &lt; count($candidates); ++$i) &#123;            if ($i &gt; $start &amp;&amp; $candidates[$i] == $candidates[$i - 1]) &#123;                continue;            &#125;            if ($candidates[$i] &gt; $target) &#123;                continue;            &#125;            $current[] = $candidates[$i];            $this-&gt;backtrack($candidates, $target - $candidates[$i], $i + 1, $current, $result);            array_pop($current);        &#125;    &#125;&#125;\n\n结果执行用时 : 18 ms, 击败 61.54% 使用 PHP 的用户\n内存消耗 : 20.05 MB, 击败 23.08% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func combinationSum2(_ candidates: [Int], _ target: Int) -&gt; [[Int]] &#123;        var result: [[Int]] = []        var current: [Int] = []        let sortedCandidates = candidates.sorted()        func backtrack(_ start: Int, _ target: Int) &#123;            if target == 0 &#123;                result.append(current)                return            &#125;            for i in start..&lt;sortedCandidates.count &#123;                if i &gt; start &amp;&amp; sortedCandidates[i] == sortedCandidates[i - 1] &#123;                    continue                &#125;                if sortedCandidates[i] &gt; target &#123;                    continue                &#125;                current.append(sortedCandidates[i])                backtrack(i + 1, target - sortedCandidates[i])                current.removeLast()            &#125;        &#125;        backtrack(0, target)        return result    &#125;&#125;\n\n结果执行用时 : 6 ms, 击败 92.86% 使用 Swift 的用户\n内存消耗 : 15.69 MB, 击败 9.52% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun combinationSum2(candidates: IntArray, target: Int): List&lt;List&lt;Int&gt;&gt; &#123;        val result = mutableListOf&lt;List&lt;Int&gt;&gt;()        val current = mutableListOf&lt;Int&gt;()        val sortedCandidates = candidates.sorted()        fun backtrack(start: Int, target: Int) &#123;            if (target == 0) &#123;                result.add(current.toList())                return            &#125;            for (i in start until sortedCandidates.size) &#123;                if (i &gt; start &amp;&amp; sortedCandidates[i] == sortedCandidates[i - 1]) &#123;                    continue                &#125;                if (sortedCandidates[i] &gt; target) &#123;                    continue                &#125;                current.add(sortedCandidates[i])                backtrack(i + 1, target - sortedCandidates[i])                current.removeAt(current.size - 1)            &#125;        &#125;        backtrack(0, target)        return result    &#125;&#125;\n\n结果执行用时 : 240 ms, 击败 53.85% 使用 Kotlin 的用户\n内存消耗 : 40.25 MB, 击败 7.69% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;List&lt;int&gt;&gt; combinationSum2(List&lt;int&gt; candidates, int target) &#123;    List&lt;List&lt;int&gt;&gt; result = [];    List&lt;int&gt; current = [];    candidates.sort();    void backtrack(int start, int target) &#123;      if (target == 0) &#123;        result.add(List&lt;int&gt;.from(current));        return;      &#125;      for (int i = start; i &lt; candidates.length; ++i) &#123;        if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) &#123;          continue;        &#125;        if (candidates[i] &gt; target) &#123;          continue;        &#125;        current.add(candidates[i]);        backtrack(i + 1, target - candidates[i]);        current.removeLast();      &#125;    &#125;    backtrack(0, target);    return result;  &#125;&#125;\n\n结果执行用时 : 338 ms, 击败 0.00% 使用 Dart 的用户\n内存消耗 : 148.07 MB, 击败 66.67% 使用 Dart 的用户\n\nGofunc combinationSum2(candidates []int, target int) [][]int &#123;    var result [][]int    var current []int    sort.Ints(candidates)    var backtrack func(int, int)    backtrack = func(start, target int) &#123;        if target == 0 &#123;            result = append(result, append([]int&#123;&#125;, current...))            return        &#125;        for i := start; i &lt; len(candidates); i++ &#123;            if i &gt; start &amp;&amp; candidates[i] == candidates[i-1] &#123;                continue            &#125;            if candidates[i] &gt; target &#123;                continue            &#125;            current = append(current, candidates[i])            backtrack(i+1, target-candidates[i])            current = current[:len(current)-1]        &#125;    &#125;    backtrack(0, target)    return result&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.33 MB, 击败 92.31% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; candidates# @param &#123;Integer&#125; target# @return &#123;Integer[][]&#125;def combination_sum2(candidates, target)    result = []    current = []    candidates.sort!    backtrack = lambda do |start, target|        if target == 0            result &lt;&lt; current.dup            return        end        (start...candidates.length).each do |i|            next if i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]            next if candidates[i] &gt; target            current &lt;&lt; candidates[i]            backtrack.call(i + 1, target - candidates[i])            current.pop        end    end    backtrack.call(0, target)    resultend\n\n结果执行用时 : 74 ms, 击败 50.00% 使用 Ruby 的用户\n内存消耗 : 206.58 MB, 击败 -% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def combinationSum2(candidates: Array[Int], target: Int): List[List[Int]] = &#123;    var result: List[List[Int]] = List()    var current: List[Int] = List()    val sortedCandidates = candidates.sorted    def backtrack(start: Int, target: Int): Unit = &#123;      if (target == 0) &#123;        result = result :+ current        return      &#125;      for (i &lt;- start until sortedCandidates.length) &#123;        if (i &gt; start &amp;&amp; sortedCandidates(i) == sortedCandidates(i - 1)) &#123;        &#125; else if (sortedCandidates(i) &lt;= target) &#123;          current = current :+ sortedCandidates(i)          backtrack(i + 1, target - sortedCandidates(i))          current = current.dropRight(1)        &#125;      &#125;    &#125;    backtrack(0, target)    result  &#125;&#125;\n\n结果执行用时 : 530 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 60.58 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn combination_sum2(candidates: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; &#123;        let mut result: Vec&lt;Vec&lt;i32&gt;&gt; = Vec::new();        let mut current: Vec&lt;i32&gt; = Vec::new();        let mut sorted_candidates = candidates;        sorted_candidates.sort();        fn backtrack(            start: usize,            target: i32,            current: &amp;mut Vec&lt;i32&gt;,            result: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;,            sorted_candidates: &amp;Vec&lt;i32&gt;,        ) &#123;            if target == 0 &#123;                result.push(current.clone());                return;            &#125;            for i in start..sorted_candidates.len() &#123;                if i &gt; start &amp;&amp; sorted_candidates[i] == sorted_candidates[i - 1] &#123;                    continue;                &#125;                if sorted_candidates[i] &gt; target &#123;                    continue;                &#125;                current.push(sorted_candidates[i]);                backtrack(i + 1, target - sorted_candidates[i], current, result, sorted_candidates);                current.pop();            &#125;        &#125;        backtrack(0, target, &amp;mut current, &amp;mut result, &amp;sorted_candidates);        result    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.00 MB, 击败 95.00% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00041.缺失的第一个正数","url":"/zh-CN/5b29713af56d/","content":"\n题目描述给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。\n请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。\n示例 1：\n输入：nums &#x3D; [1,2,0]输出：3\n\n示例 2：\n输入：nums &#x3D; [3,4,-1,1]输出：2\n\n示例 3：\n输入：nums &#x3D; [7,8,9,11,12]输出：1\n\n提示：\n$1 &lt;&#x3D; nums.length &lt;&#x3D; 5 * 10^5$\n$-2^{31} &lt;&#x3D; nums[i] &lt;&#x3D; 2^{31} - 1$\n\n\n解决方法C++class Solution &#123;public:    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        for (int i = 0; i &lt; n; ++i) &#123;            while (1 &lt;= nums[i] &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]) &#123;                swap(nums[nums[i] - 1], nums[i]);            &#125;        &#125;        for (int i = 0; i &lt; n; ++i) &#123;            if (nums[i] != i + 1) &#123;                return i + 1;            &#125;        &#125;        return n + 1;    &#125;&#125;;\n\n结果执行用时 : 39 ms, 击败 94.56% 使用 C++ 的用户\n内存消耗 : 42.63 MB, 击败 25.68% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public int firstMissingPositive(int[] nums) &#123;        int n = nums.length;        for (int i = 0; i &lt; n; ++i) &#123;            while (1 &lt;= nums[i] &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]) &#123;                swap(nums, nums[i] - 1, i);            &#125;        &#125;        for (int i = 0; i &lt; n; ++i) &#123;            if (nums[i] != i + 1) &#123;                return i + 1;            &#125;        &#125;        return n + 1;    &#125;    private void swap(int[] nums, int i, int j) &#123;        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 98.51% 使用 Java 的用户\n内存消耗 : 53.84 MB, 击败 68.75% 使用 Java 的用户\n\nPythonclass Solution(object):    def firstMissingPositive(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        n = len(nums)        for i in range(n):            while 1 &lt;= nums[i] &lt;= n and nums[nums[i] - 1] != nums[i]:                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]        for i in range(n):            if nums[i] != i + 1:                return i + 1        return n + 1\n\n结果执行用时 : 69 ms, 击败 72.86% 使用 Python 的用户\n内存消耗 : 19.07 MB, 击败 90.86% 使用 Python 的用户\n\nPython3class Solution:    def firstMissingPositive(self, nums: List[int]) -&gt; int:        n = len(nums)        for i in range(n):            while 1 &lt;= nums[i] &lt;= n and nums[nums[i] - 1] != nums[i]:                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]        for i in range(n):            if nums[i] != i + 1:                return i + 1        return n + 1\n\n结果执行用时 : 74 ms, 击败 % 使用 Python3 的用户\n内存消耗 : 27.45 MB, 击败 % 使用 Python3 的用户\n\nCvoid swap(int* a, int* b) &#123;    int temp = *a;    *a = *b;    *b = temp;&#125;int firstMissingPositive(int* nums, int numsSize) &#123;    for (int i = 0; i &lt; numsSize; ++i) &#123;        while (1 &lt;= nums[i] &amp;&amp; nums[i] &lt;= numsSize &amp;&amp; nums[nums[i] - 1] != nums[i]) &#123;            swap(&amp;nums[nums[i] - 1], &amp;nums[i]);        &#125;    &#125;    for (int i = 0; i &lt; numsSize; ++i) &#123;        if (nums[i] != i + 1) &#123;            return i + 1;        &#125;    &#125;    return numsSize + 1;&#125;\n\n结果执行用时 : 39 ms, 击败 95.26% 使用 C 的用户\n内存消耗 : 10.66 MB, 击败 92.39% 使用 C 的用户\n\nC#public class Solution &#123;    public int FirstMissingPositive(int[] nums) &#123;        int n = nums.Length;        for (int i = 0; i &lt; n; ++i) &#123;            while (1 &lt;= nums[i] &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]) &#123;                Swap(nums, nums[i] - 1, i);            &#125;        &#125;        for (int i = 0; i &lt; n; ++i) &#123;            if (nums[i] != i + 1) &#123;                return i + 1;            &#125;        &#125;        return n + 1;    &#125;    private void Swap(int[] nums, int i, int j) &#123;        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    &#125;&#125;\n\n结果执行用时 : 142 ms, 击败 66.90% 使用 C# 的用户\n内存消耗 : 57.28 MB, 击败 27.47% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var firstMissingPositive = function(nums) &#123;    const n = nums.length;    for (let i = 0; i &lt; n; ++i) &#123;        while (1 &lt;= nums[i] &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] !== nums[i]) &#123;            [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];        &#125;    &#125;    for (let i = 0; i &lt; n; ++i) &#123;        if (nums[i] !== i + 1) &#123;            return i + 1;        &#125;    &#125;    return n + 1;&#125;;\n\n结果执行用时 : 74 ms, 击败 70.49% 使用 JavaScript 的用户\n内存消耗 : 55.44 MB, 击败 36.87% 使用 JavaScript 的用户\n\nTypeScriptfunction firstMissingPositive(nums: number[]): number &#123;    const n = nums.length;    for (let i = 0; i &lt; n; ++i) &#123;        while (1 &lt;= nums[i] &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] !== nums[i]) &#123;            [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];        &#125;    &#125;    for (let i = 0; i &lt; n; ++i) &#123;        if (nums[i] !== i + 1) &#123;            return i + 1;        &#125;    &#125;    return n + 1;&#125;\n\n结果执行用时 : 74 ms, 击败 83.62% 使用 TypeScript 的用户\n内存消耗 : 57.48 MB, 击败 29.94% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;        /**     * @param Integer[] $nums     * @return Integer     */    function firstMissingPositive($nums) &#123;        $n = count($nums);        for ($i = 0; $i &lt; $n; ++$i) &#123;            while (1 &lt;= $nums[$i] &amp;&amp; $nums[$i] &lt;= $n &amp;&amp; $nums[$nums[$i] - 1] != $nums[$i]) &#123;                [$nums[$nums[$i] - 1], $nums[$i]] = [$nums[$i], $nums[$nums[$i] - 1]];            &#125;        &#125;        for ($i = 0; $i &lt; $n; ++$i) &#123;            if ($nums[$i] !== $i + 1) &#123;                return $i + 1;            &#125;        &#125;        return $n + 1;    &#125;&#125;\n\n结果执行用时 : 118 ms, 击败 76.19% 使用 PHP 的用户\n内存消耗 : 26.82 MB, 击败 100.00% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func firstMissingPositive(_ nums: [Int]) -&gt; Int &#123;        var nums = nums        let n = nums.count        for i in 0..&lt;n &#123;            while 1 &lt;= nums[i] &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i] &#123;                nums.swapAt(nums[i] - 1, i)            &#125;        &#125;        for i in 0..&lt;n &#123;            if nums[i] != i + 1 &#123;                return i + 1            &#125;        &#125;        return n + 1    &#125;&#125;\n\n结果执行用时 : 151 ms, 击败 100.00% 使用 Swift 的用户\n内存消耗 : 19.63 MB, 击败 14.14% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun firstMissingPositive(nums: IntArray): Int &#123;        val n = nums.size        for (i in 0 until n) &#123;            while (1 &lt;= nums[i] &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]) &#123;                nums[nums[i] - 1] = nums[i].also &#123; nums[i] = nums[nums[i] - 1] &#125;            &#125;        &#125;        for (i in 0 until n) &#123;            if (nums[i] != i + 1) &#123;                return i + 1            &#125;        &#125;        return n + 1    &#125;&#125;\n\n结果执行用时 : 318 ms, 击败 93.88% 使用 Kotlin 的用户\n内存消耗 : 49.80 MB, 击败 89.80% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int firstMissingPositive(List&lt;int&gt; nums) &#123;    final n = nums.length;    for (var i = 0; i &lt; n; ++i) &#123;      while (1 &lt;= nums[i] &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]) &#123;        final temp = nums[i];        nums[i] = nums[temp - 1];        nums[temp - 1] = temp;      &#125;    &#125;    for (var i = 0; i &lt; n; ++i) &#123;      if (nums[i] != i + 1) &#123;        return i + 1;      &#125;    &#125;    return n + 1;  &#125;&#125;\n\n结果执行用时 : 312 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 160.04 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc firstMissingPositive(nums []int) int &#123;\tn := len(nums)\tfor i := 0; i &lt; n; i++ &#123;\t\tfor 1 &lt;= nums[i] &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i]-1] != nums[i] &#123;\t\t\tnums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\t\t&#125;\t&#125;\tfor i := 0; i &lt; n; i++ &#123;\t\tif nums[i] != i+1 &#123;\t\t\treturn i + 1\t\t&#125;\t&#125;\treturn n + 1&#125;\n\n结果执行用时 : 38 ms, 击败 92.71% 使用 Go 的用户\n内存消耗 : 7.73 MB, 击败 97.26% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @return &#123;Integer&#125;def first_missing_positive(nums)  n = nums.length  (0...n).each do |i|    while 1 &lt;= nums[i] &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]      nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]    end  end  (0...n).each do |i|    return i + 1 if nums[i] != i + 1  end  n + 1end\n\n结果执行用时 : 122 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 210.50 MB, 击败 33.33% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def firstMissingPositive(nums: Array[Int]): Int = &#123;    val n = nums.length    def swap(i: Int, j: Int): Unit = &#123;      val temp = nums(i)      nums(i) = nums(j)      nums(j) = temp    &#125;    for (i &lt;- 0 until n) &#123;      while (1 &lt;= nums(i) &amp;&amp; nums(i) &lt;= n &amp;&amp; nums(nums(i) - 1) != nums(i)) &#123;        swap(i, nums(i) - 1)      &#125;    &#125;    for (i &lt;- 0 until n) &#123;      if (nums(i) != i + 1) &#123;        return i + 1      &#125;    &#125;    n + 1  &#125;&#125;\n\n结果执行用时 : 696 ms, 击败 92.31% 使用 Scala 的用户\n内存消耗 : 77.17 MB, 击败 84.62% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn first_missing_positive(mut nums: Vec&lt;i32&gt;) -&gt; i32 &#123;        let n = nums.len();        for i in 0..n &#123;            while 1 &lt;= nums[i] &amp;&amp; nums[i] &lt;= n as i32 &amp;&amp; nums[(nums[i] - 1) as usize] != nums[i] &#123;                let index = (nums[i] - 1) as usize;                nums.swap(i, index);            &#125;        &#125;        for i in 0..n &#123;            if nums[i] != (i + 1) as i32 &#123;                return (i + 1) as i32;            &#125;        &#125;        (n + 1) as i32    &#125;&#125;\n\n结果执行用时 : 4 ms, 击败 89.19% 使用 Rust 的用户\n内存消耗 : 2.98 MB, 击败 49.38% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"闪电侠 第六季 第十一集 爱是战场","url":"/zh-CN/1913f99ed1e4/","content":"\n剧情介绍　　巴里和艾瑞斯计划在情人节吃一顿浪漫的晚餐，但他们的夜晚被一个老对手——阿蒙内打断了;弗罗斯特融入了假日气氛，并试图帮助阿莱格拉与旧爱重新建立联系。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00042.接雨水","url":"/zh-CN/ba41afd51b99/","content":"\n题目描述给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n示例 1：\n\n\n输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n\n示例 2：\n输入：height &#x3D; [4,2,0,3,2,5]输出：9\n\n提示：\nn &#x3D;&#x3D; height.length\n$1 &lt;&#x3D; n &lt;&#x3D; 2 * 10^4$\n$0 &lt;&#x3D; height[i] &lt;&#x3D; 10^5$\n\n\n解决方法C++class Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        if (height.size() &lt; 3) &#123;            return 0;        &#125;        int left = 0, right = height.size() - 1;        int left_max = 0, right_max = 0;        int result = 0;        while (left &lt; right) &#123;            if (height[left] &lt; height[right]) &#123;                if (height[left] &gt;= left_max) &#123;                    left_max = height[left];                &#125; else &#123;                    result += left_max - height[left];                &#125;                left++;            &#125; else &#123;                if (height[right] &gt;= right_max) &#123;                    right_max = height[right];                &#125; else &#123;                    result += right_max - height[right];                &#125;                right--;            &#125;        &#125;        return result;    &#125;&#125;;\n\n结果执行用时 : 15 ms, 击败 50.80% 使用 C++ 的用户\n内存消耗 : 21.66 MB, 击败 17.09% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public int trap(int[] height) &#123;        if (height.length &lt; 3) &#123;            return 0;        &#125;        int left = 0, right = height.length - 1;        int left_max = 0, right_max = 0;        int result = 0;        while (left &lt; right) &#123;            if (height[left] &lt; height[right]) &#123;                if (height[left] &gt;= left_max) &#123;                    left_max = height[left];                &#125; else &#123;                    result += left_max - height[left];                &#125;                left++;            &#125; else &#123;                if (height[right] &gt;= right_max) &#123;                    right_max = height[right];                &#125; else &#123;                    result += right_max - height[right];                &#125;                right--;            &#125;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 45.56 MB, 击败 5.11% 使用 Java 的用户\n\nPythonclass Solution(object):    def trap(self, height):        &quot;&quot;&quot;        :type height: List[int]        :rtype: int        &quot;&quot;&quot;        if len(height) &lt; 3:            return 0        left, right = 0, len(height) - 1        left_max, right_max = 0, 0        result = 0        while left &lt; right:            if height[left] &lt; height[right]:                if height[left] &gt;= left_max:                    left_max = height[left]                else:                    result += left_max - height[left]                left += 1            else:                if height[right] &gt;= right_max:                    right_max = height[right]                else:                    result += right_max - height[right]                right -= 1        return result\n\n结果执行用时 : 18 ms, 击败 99.40% 使用 Python 的用户\n内存消耗 : 12.68 MB, 击败 91.49% 使用 Python 的用户\n\nPython3class Solution:    def trap(self, height: List[int]) -&gt; int:        if len(height) &lt; 3:            return 0        left, right = 0, len(height) - 1        left_max, right_max = 0, 0        result = 0        while left &lt; right:            if height[left] &lt; height[right]:                if height[left] &gt;= left_max:                    left_max = height[left]                else:                    result += left_max - height[left]                left += 1            else:                if height[right] &gt;= right_max:                    right_max = height[right]                else:                    result += right_max - height[right]                right -= 1        return result\n\n结果执行用时 : 47 ms, 击败 94.36% 使用 Python3 的用户\n内存消耗 : 17.77 MB, 击败 74.44% 使用 Python3 的用户\n\nCint trap(int* height, int heightSize) &#123;    if (heightSize &lt; 3) &#123;        return 0;    &#125;    int left = 0, right = heightSize - 1;    int left_max = 0, right_max = 0;    int result = 0;    while (left &lt; right) &#123;        if (height[left] &lt; height[right]) &#123;            if (height[left] &gt;= left_max) &#123;                left_max = height[left];            &#125; else &#123;                result += left_max - height[left];            &#125;            left++;        &#125; else &#123;            if (height[right] &gt;= right_max) &#123;                right_max = height[right];            &#125; else &#123;                result += right_max - height[right];            &#125;            right--;        &#125;    &#125;    return result;&#125;\n\n结果执行用时 : 9 ms, 击败 69.17% 使用 C 的用户\n内存消耗 : 6.44 MB, 击败 99.08% 使用 C 的用户\n\nC#public class Solution &#123;    public int Trap(int[] height) &#123;        if (height.Length &lt; 3) &#123;            return 0;        &#125;        int left = 0, right = height.Length - 1;        int left_max = 0, right_max = 0;        int result = 0;        while (left &lt; right) &#123;            if (height[left] &lt; height[right]) &#123;                if (height[left] &gt;= left_max) &#123;                    left_max = height[left];                &#125; else &#123;                    result += left_max - height[left];                &#125;                left++;            &#125; else &#123;                if (height[right] &gt;= right_max) &#123;                    right_max = height[right];                &#125; else &#123;                    result += right_max - height[right];                &#125;                right--;            &#125;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 76 ms, 击败 95.76% 使用 C# 的用户\n内存消耗 : 44.57 MB, 击败 26.25% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; height * @return &#123;number&#125; */var trap = function(height) &#123;    if (height.length &lt; 3) &#123;        return 0;    &#125;    let left = 0, right = height.length - 1;    let left_max = 0, right_max = 0;    let result = 0;    while (left &lt; right) &#123;        if (height[left] &lt; height[right]) &#123;            if (height[left] &gt;= left_max) &#123;                left_max = height[left];            &#125; else &#123;                result += left_max - height[left];            &#125;            left++;        &#125; else &#123;            if (height[right] &gt;= right_max) &#123;                right_max = height[right];            &#125; else &#123;                result += right_max - height[right];            &#125;            right--;        &#125;    &#125;    return result;&#125;;\n\n结果执行用时 : 52 ms, 击败 99.07% 使用 JavaScript 的用户\n内存消耗 : 50.02 MB, 击败 25.70% 使用 JavaScript 的用户\n\nTypeScriptfunction trap(height: number[]): number &#123;    if (height.length &lt; 3) &#123;        return 0;    &#125;    let left: number = 0, right: number = height.length - 1;    let left_max: number = 0, right_max: number = 0;    let result: number = 0;    while (left &lt; right) &#123;        if (height[left] &lt; height[right]) &#123;            if (height[left] &gt;= left_max) &#123;                left_max = height[left];            &#125; else &#123;                result += left_max - height[left];            &#125;            left++;        &#125; else &#123;            if (height[right] &gt;= right_max) &#123;                right_max = height[right];            &#125; else &#123;                result += right_max - height[right];            &#125;            right--;        &#125;    &#125;    return result;&#125;\n\n结果执行用时 : 70 ms, 击败 72.92% 使用 TypeScript 的用户\n内存消耗 : 52.29 MB, 击败 29.22% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $height     * @return Integer     */    function trap($height) &#123;        $length = count($height);        if ($length &lt; 3) &#123;            return 0;        &#125;        $left = 0;        $right = $length - 1;        $left_max = 0;        $right_max = 0;        $result = 0;        while ($left &lt; $right) &#123;            if ($height[$left] &lt; $height[$right]) &#123;                if ($height[$left] &gt;= $left_max) &#123;                    $left_max = $height[$left];                &#125; else &#123;                    $result += $left_max - $height[$left];                &#125;                $left++;            &#125; else &#123;                if ($height[$right] &gt;= $right_max) &#123;                    $right_max = $height[$right];                &#125; else &#123;                    $result += $right_max - $height[$right];                &#125;                $right--;            &#125;        &#125;        return $result;    &#125;&#125;\n\n结果执行用时 : 30 ms, 击败 65.31% 使用 PHP 的用户\n内存消耗 : 21.50 MB, 击败 79.59% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func trap(_ height: [Int]) -&gt; Int &#123;        let length = height.count        guard length &gt;= 3 else &#123;            return 0        &#125;        var left = 0        var right = length - 1        var leftMax = 0        var rightMax = 0        var result = 0        while left &lt; right &#123;            if height[left] &lt; height[right] &#123;                if height[left] &gt;= leftMax &#123;                    leftMax = height[left]                &#125; else &#123;                    result += leftMax - height[left]                &#125;                left += 1            &#125; else &#123;                if height[right] &gt;= rightMax &#123;                    rightMax = height[right]                &#125; else &#123;                    result += rightMax - height[right]                &#125;                right -= 1            &#125;        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 26 ms, 击败 100.00% 使用 Swift 的用户\n内存消耗 : 15.84 MB, 击败 7.33% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun trap(height: IntArray): Int &#123;        val length = height.size        if (length &lt; 3) &#123;            return 0        &#125;        var left = 0        var right = length - 1        var leftMax = 0        var rightMax = 0        var result = 0        while (left &lt; right) &#123;            if (height[left] &lt; height[right]) &#123;                if (height[left] &gt;= leftMax) &#123;                    leftMax = height[left]                &#125; else &#123;                    result += leftMax - height[left]                &#125;                left++            &#125; else &#123;                if (height[right] &gt;= rightMax) &#123;                    rightMax = height[right]                &#125; else &#123;                    result += rightMax - height[right]                &#125;                right--            &#125;        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 189 ms, 击败 98.29% 使用 Kotlin 的用户\n内存消耗 : 39.59 MB, 击败 43.59% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int trap(List&lt;int&gt; height) &#123;    if (height.length &lt; 3) &#123;      return 0;    &#125;    int left = 0, right = height.length - 1;    int leftMax = 0, rightMax = 0;    int result = 0;    while (left &lt; right) &#123;      if (height[left] &lt; height[right]) &#123;        if (height[left] &gt;= leftMax) &#123;          leftMax = height[left];        &#125; else &#123;          result += leftMax - height[left];        &#125;        left++;      &#125; else &#123;        if (height[right] &gt;= rightMax) &#123;          rightMax = height[right];        &#125; else &#123;          result += rightMax - height[right];        &#125;        right--;      &#125;    &#125;    return result;  &#125;&#125;\n\n结果执行用时 : 284 ms, 击败 88.89% 使用 Dart 的用户\n内存消耗 : 148.19 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc trap(height []int) int &#123;    if len(height) &lt; 3 &#123;        return 0    &#125;    left, right := 0, len(height)-1    leftMax, rightMax := 0, 0    result := 0    for left &lt; right &#123;        if height[left] &lt; height[right] &#123;            if height[left] &gt;= leftMax &#123;                leftMax = height[left]            &#125; else &#123;                result += leftMax - height[left]            &#125;            left++        &#125; else &#123;            if height[right] &gt;= rightMax &#123;                rightMax = height[right]            &#125; else &#123;                result += rightMax - height[right]            &#125;            right--        &#125;    &#125;    return result&#125;\n\n结果执行用时 : 10 ms, 击败 41.46% 使用 Go 的用户\n内存消耗 : 5.18 MB, 击败 99.69% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; height# @return &#123;Integer&#125;def trap(height)  return 0 if height.length &lt; 3  left = 0  right = height.length - 1  left_max = 0  right_max = 0  result = 0  while left &lt; right    if height[left] &lt; height[right]      if height[left] &gt;= left_max        left_max = height[left]      else        result += left_max - height[left]      end      left += 1    else      if height[right] &gt;= right_max        right_max = height[right]      else        result += right_max - height[right]      end      right -= 1    end  end  resultend\n\n结果执行用时 : 61 ms, 击败 % 使用 Ruby 的用户\n内存消耗 : 207.34 MB, 击败 % 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def trap(height: Array[Int]): Int = &#123;    if (height.length &lt; 3) &#123;      0    &#125; else &#123;      var left = 0      var right = height.length - 1      var leftMax = 0      var rightMax = 0      var result = 0      while (left &lt; right) &#123;        if (height(left) &lt; height(right)) &#123;          if (height(left) &gt;= leftMax) &#123;            leftMax = height(left)          &#125; else &#123;            result += leftMax - height(left)          &#125;          left += 1        &#125; else &#123;          if (height(right) &gt;= rightMax) &#123;            rightMax = height(right)          &#125; else &#123;            result += rightMax - height(right)          &#125;          right -= 1        &#125;      &#125;      result    &#125;  &#125;&#125;\n\n结果执行用时 : 548 ms, 击败 81.82% 使用 Scala 的用户\n内存消耗 : 56.33 MB, 击败 90.91% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn trap(height: Vec&lt;i32&gt;) -&gt; i32 &#123;        if height.len() &lt; 3 &#123;            return 0;        &#125;        let mut left = 0;        let mut right = height.len() - 1;        let mut left_max = 0;        let mut right_max = 0;        let mut result = 0;        while left &lt; right &#123;            if height[left] &lt; height[right] &#123;                if height[left] &gt;= left_max &#123;                    left_max = height[left];                &#125; else &#123;                    result += left_max - height[left];                &#125;                left += 1;            &#125; else &#123;                if height[right] &gt;= right_max &#123;                    right_max = height[right];                &#125; else &#123;                    result += right_max - height[right];                &#125;                right -= 1;            &#125;        &#125;        result    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.10 MB, 击败 92.50% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00043.字符串相乘","url":"/zh-CN/f75775a279c9/","content":"\n题目描述给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。\n注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。\n示例 1：\n输入: num1 &#x3D; “2”, num2 &#x3D; “3”输出: “6”\n\n示例 2：\n输入: num1 &#x3D; “123”, num2 &#x3D; “456”输出: “56088”\n\n提示：\n1 &lt;&#x3D; num1.length, num2.length &lt;&#x3D; 200\nnum1 和 num2 只能由数字组成。\nnum1 和 num2 都不包含任何前导零，除了数字0本身。\n\n\n解决方法C++class Solution &#123;public:    string multiply(string num1, string num2) &#123;        int len1 = num1.size();        int len2 = num2.size();        string result(len1 + len2, &#x27;0&#x27;);        for (int i = len1 - 1; i &gt;= 0; --i) &#123;            for (int j = len2 - 1; j &gt;= 0; --j) &#123;                int mul = (num1[i] - &#x27;0&#x27;) * (num2[j] - &#x27;0&#x27;);                int sum = mul + (result[i + j + 1] - &#x27;0&#x27;);                                result[i + j + 1] = sum % 10 + &#x27;0&#x27;;                result[i + j] += sum / 10;            &#125;        &#125;        size_t start_pos = result.find_first_not_of(&#x27;0&#x27;);        return (start_pos != string::npos) ? result.substr(start_pos) : &quot;0&quot;;    &#125;&#125;;\n\n结果执行用时 : 3 ms, 击败 91.44% 使用 C++ 的用户\n内存消耗 : 7.98 MB, 击败 51.38% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public String multiply(String num1, String num2) &#123;        int len1 = num1.length();        int len2 = num2.length();        int[] result = new int[len1 + len2];        for (int i = len1 - 1; i &gt;= 0; i--) &#123;            for (int j = len2 - 1; j &gt;= 0; j--) &#123;                int mul = (num1.charAt(i) - &#x27;0&#x27;) * (num2.charAt(j) - &#x27;0&#x27;);                int sum = mul + result[i + j + 1];                result[i + j + 1] = sum % 10;                result[i + j] += sum / 10;            &#125;        &#125;        StringBuilder sb = new StringBuilder();        for (int num : result) &#123;            sb.append(num);        &#125;        int start = 0;        while (start &lt; sb.length() - 1 &amp;&amp; sb.charAt(start) == &#x27;0&#x27;) &#123;            start++;        &#125;        return sb.substring(start);    &#125;&#125;\n\n结果执行用时 : 3 ms, 击败 % 使用 Java 的用户\n内存消耗 : 41.18 MB, 击败 % 使用 Java 的用户\n\nPythonclass Solution(object):    def multiply(self, num1, num2):        &quot;&quot;&quot;        :type num1: str        :type num2: str        :rtype: str        &quot;&quot;&quot;        len1, len2 = len(num1), len(num2)        result = [0] * (len1 + len2)        for i in range(len1 - 1, -1, -1):            for j in range(len2 - 1, -1, -1):                mul = int(num1[i]) * int(num2[j])                total_sum = mul + result[i + j + 1]                result[i + j + 1] = total_sum % 10                result[i + j] += total_sum // 10        result_str = &#x27;&#x27;.join(map(str, result))        result_str = result_str.lstrip(&#x27;0&#x27;)        return result_str if result_str else &#x27;0&#x27;\n\n结果执行用时 : 170 ms, 击败 38.93% 使用 Python 的用户\n内存消耗 : 11.59 MB, 击败 86.26% 使用 Python 的用户\n\nPython3class Solution:    def multiply(self, num1: str, num2: str) -&gt; str:        len1, len2 = len(num1), len(num2)        result = [0] * (len1 + len2)        for i in range(len1 - 1, -1, -1):            for j in range(len2 - 1, -1, -1):                mul = int(num1[i]) * int(num2[j])                total_sum = mul + result[i + j + 1]                result[i + j + 1] = total_sum % 10                result[i + j] += total_sum // 10        result_str = &#x27;&#x27;.join(map(str, result))        result_str = result_str.lstrip(&#x27;0&#x27;)        return result_str if result_str else &#x27;0&#x27;\n\n结果执行用时 : 95 ms, 击败 49.18% 使用 Python3 的用户\n内存消耗 : 16.41 MB, 击败 41.37% 使用 Python3 的用户\n\nCchar* multiply(char* num1, char* num2) &#123;    int len1 = strlen(num1);    int len2 = strlen(num2);    int len_result = len1 + len2;    int* result = (int*)malloc(sizeof(int) * len_result);    memset(result, 0, sizeof(int) * len_result);    for (int i = len1 - 1; i &gt;= 0; i--) &#123;        for (int j = len2 - 1; j &gt;= 0; j--) &#123;            int mul = (num1[i] - &#x27;0&#x27;) * (num2[j] - &#x27;0&#x27;);            int sum = mul + result[i + j + 1];            result[i + j + 1] = sum % 10;            result[i + j] += sum / 10;        &#125;    &#125;    char* result_str = (char*)malloc(len_result + 1);    int idx = 0;    while (idx &lt; len_result &amp;&amp; result[idx] == 0) &#123;        idx++;    &#125;    if (idx == len_result) &#123;        result_str[0] = &#x27;0&#x27;;        result_str[1] = &#x27;\\0&#x27;;    &#125; else &#123;        for (int i = idx; i &lt; len_result; i++) &#123;            result_str[i - idx] = result[i] + &#x27;0&#x27;;        &#125;        result_str[len_result - idx] = &#x27;\\0&#x27;;    &#125;    free(result);    return result_str;&#125;\n\n结果执行用时 : 7 ms, 击败 29.39% 使用 C 的用户\n内存消耗 : 6.01 MB, 击败 84.81% 使用 C 的用户\n\nC#public class Solution &#123;    public string Multiply(string num1, string num2) &#123;        int len1 = num1.Length;        int len2 = num2.Length;        int lenResult = len1 + len2;        int[] result = new int[lenResult];        for (int i = len1 - 1; i &gt;= 0; i--) &#123;            for (int j = len2 - 1; j &gt;= 0; j--) &#123;                int mul = (num1[i] - &#x27;0&#x27;) * (num2[j] - &#x27;0&#x27;);                int sum = mul + result[i + j + 1];                result[i + j + 1] = sum % 10;                result[i + j] += sum / 10;            &#125;        &#125;        StringBuilder resultStr = new StringBuilder();        int idx = 0;        while (idx &lt; lenResult &amp;&amp; result[idx] == 0) &#123;            idx++;        &#125;        if (idx == lenResult) &#123;            resultStr.Append(&#x27;0&#x27;);        &#125; else &#123;            for (int i = idx; i &lt; lenResult; i++) &#123;                resultStr.Append(result[i]);            &#125;        &#125;        return resultStr.ToString();    &#125;&#125;\n\n结果执行用时 : 63 ms, 击败 79.35% 使用 C# 的用户\n内存消耗 : 42.13 MB, 击败 48.91% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; num1 * @param &#123;string&#125; num2 * @return &#123;string&#125; */var multiply = function(num1, num2) &#123;    const len1 = num1.length;    const len2 = num2.length;    const lenResult = len1 + len2;    const result = Array(lenResult).fill(0);    for (let i = len1 - 1; i &gt;= 0; i--) &#123;        for (let j = len2 - 1; j &gt;= 0; j--) &#123;            const mul = (num1[i] - &#x27;0&#x27;) * (num2[j] - &#x27;0&#x27;);            const sum = mul + result[i + j + 1];            result[i + j + 1] = sum % 10;            result[i + j] += Math.floor(sum / 10);        &#125;    &#125;    let resultStr = &#x27;&#x27;;    let idx = 0;    while (idx &lt; lenResult &amp;&amp; result[idx] === 0) &#123;        idx++;    &#125;    if (idx === lenResult) &#123;        resultStr = &#x27;0&#x27;;    &#125; else &#123;        for (let i = idx; i &lt; lenResult; i++) &#123;            resultStr += result[i];        &#125;    &#125;    return resultStr;&#125;;\n\n结果执行用时 : 70 ms, 击败 69.68% 使用 JavaScript 的用户\n内存消耗 : 51.53 MB, 击败 21.49% 使用 JavaScript 的用户\n\nTypeScriptfunction multiply(num1: string, num2: string): string &#123;    const len1 = num1.length;    const len2 = num2.length;    const lenResult = len1 + len2;    const result: number[] = Array(lenResult).fill(0);    for (let i = len1 - 1; i &gt;= 0; i--) &#123;        for (let j = len2 - 1; j &gt;= 0; j--) &#123;            const mul = (num1[i].charCodeAt(0) - &#x27;0&#x27;.charCodeAt(0)) * (num2[j].charCodeAt(0) - &#x27;0&#x27;.charCodeAt(0));            const sum = mul + result[i + j + 1];            result[i + j + 1] = sum % 10;            result[i + j] += Math.floor(sum / 10);        &#125;    &#125;    let resultStr = &#x27;&#x27;;    let idx = 0;    while (idx &lt; lenResult &amp;&amp; result[idx] === 0) &#123;        idx++;    &#125;    if (idx === lenResult) &#123;        resultStr = &#x27;0&#x27;;    &#125; else &#123;        for (let i = idx; i &lt; lenResult; i++) &#123;            resultStr += result[i];        &#125;    &#125;    return resultStr;&#125;\n\n结果执行用时 : 67 ms, 击败 90.00% 使用 TypeScript 的用户\n内存消耗 : 52.91 MB, 击败 15.71% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;        /**     * @param String $num1     * @param String $num2     * @return String     */    function multiply($num1, $num2) &#123;        $len1 = strlen($num1);        $len2 = strlen($num2);        $lenResult = $len1 + $len2;        $result = array_fill(0, $lenResult, 0);        for ($i = $len1 - 1; $i &gt;= 0; $i--) &#123;            for ($j = $len2 - 1; $j &gt;= 0; $j--) &#123;                $mul = intval($num1[$i]) * intval($num2[$j]);                $sum = $mul + $result[$i + $j + 1];                $result[$i + $j + 1] = $sum % 10;                $result[$i + $j] += intdiv($sum, 10);            &#125;        &#125;        $resultStr = &#x27;&#x27;;        $idx = 0;        while ($idx &lt; $lenResult &amp;&amp; $result[$idx] === 0) &#123;            $idx++;        &#125;        if ($idx === $lenResult) &#123;            $resultStr = &#x27;0&#x27;;        &#125; else &#123;            for ($i = $idx; $i &lt; $lenResult; $i++) &#123;                $resultStr .= $result[$i];            &#125;        &#125;        return $resultStr;    &#125;&#125;\n\n结果执行用时 : 32 ms, 击败 0.00% 使用 PHP 的用户\n内存消耗 : 19.91 MB, 击败 0.00% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func multiply(_ num1: String, _ num2: String) -&gt; String &#123;        let len1 = num1.count        let len2 = num2.count        let lenResult = len1 + len2        var result = Array(repeating: 0, count: lenResult)        for i in stride(from: len1 - 1, through: 0, by: -1) &#123;            for j in stride(from: len2 - 1, through: 0, by: -1) &#123;                let mul = Int(String(num1[num1.index(num1.startIndex, offsetBy: i)]))! * Int(String(num2[num2.index(num2.startIndex, offsetBy: j)]))!                let sum = mul + result[i + j + 1]                result[i + j + 1] = sum % 10                result[i + j] += sum / 10            &#125;        &#125;        var resultStr = &quot;&quot;        var idx = 0        while idx &lt; lenResult &amp;&amp; result[idx] == 0 &#123;            idx += 1        &#125;        if idx == lenResult &#123;            resultStr = &quot;0&quot;        &#125; else &#123;            for i in idx..&lt;lenResult &#123;                resultStr += String(result[i])            &#125;        &#125;        return resultStr    &#125;&#125;\n\n结果执行用时 : 195 ms, 击败 7.32% 使用 Swift 的用户\n内存消耗 : 16.23 MB, 击败 7.32% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun multiply(num1: String, num2: String): String &#123;        val len1 = num1.length        val len2 = num2.length        val lenResult = len1 + len2        val result = IntArray(lenResult)        for (i in len1 - 1 downTo 0) &#123;            for (j in len2 - 1 downTo 0) &#123;                val mul = (num1[i] - &#x27;0&#x27;) * (num2[j] - &#x27;0&#x27;)                val sum = mul + result[i + j + 1]                result[i + j + 1] = sum % 10                result[i + j] += sum / 10            &#125;        &#125;        val resultStr = StringBuilder()        var idx = 0        while (idx &lt; lenResult &amp;&amp; result[idx] == 0) &#123;            idx++        &#125;        if (idx == lenResult) &#123;            resultStr.append(&#x27;0&#x27;)        &#125; else &#123;            for (i in idx until lenResult) &#123;                resultStr.append(result[i])            &#125;        &#125;        return resultStr.toString()    &#125;&#125;\n\n结果执行用时 : 176 ms, 击败 100.00% 使用 Kotlin 的用户\n内存消耗 : 35.16 MB, 击败 81.82% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  String multiply(String num1, String num2) &#123;    int len1 = num1.length;    int len2 = num2.length;    int lenResult = len1 + len2;    List&lt;int&gt; result = List.filled(lenResult, 0);    for (int i = len1 - 1; i &gt;= 0; i--) &#123;      for (int j = len2 - 1; j &gt;= 0; j--) &#123;        int mul = int.parse(num1[i]) * int.parse(num2[j]);        int sum = mul + result[i + j + 1];        result[i + j + 1] = sum % 10;        result[i + j] += sum ~/ 10;      &#125;    &#125;    StringBuffer resultStr = StringBuffer();    int idx = 0;    while (idx &lt; lenResult &amp;&amp; result[idx] == 0) &#123;      idx++;    &#125;    if (idx == lenResult) &#123;      resultStr.write(&#x27;0&#x27;);    &#125; else &#123;      for (int i = idx; i &lt; lenResult; i++) &#123;        resultStr.write(result[i]);      &#125;    &#125;    return resultStr.toString();  &#125;&#125;\n\n结果执行用时 : 317 ms, 击败 -% 使用 Dart 的用户\n内存消耗 : 143.64 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc multiply(num1 string, num2 string) string &#123;    len1, len2 := len(num1), len(num2)    lenResult := len1 + len2    result := make([]int, lenResult)    for i := len1 - 1; i &gt;= 0; i-- &#123;        for j := len2 - 1; j &gt;= 0; j-- &#123;            mul := int(num1[i]-&#x27;0&#x27;) * int(num2[j]-&#x27;0&#x27;)            sum := mul + result[i+j+1]            result[i+j+1] = sum % 10            result[i+j] += sum / 10        &#125;    &#125;    var resultStr string    idx := 0    for idx &lt; lenResult &amp;&amp; result[idx] == 0 &#123;        idx++    &#125;    if idx == lenResult &#123;        resultStr = &quot;0&quot;    &#125; else &#123;        for i := idx; i &lt; lenResult; i++ &#123;            resultStr += strconv.Itoa(result[i])        &#125;    &#125;    return resultStr&#125;\n\n结果执行用时 : 3 ms, 击败 60.96% 使用 Go 的用户\n内存消耗 : 2.93 MB, 击败 64.82% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; num1# @param &#123;String&#125; num2# @return &#123;String&#125;def multiply(num1, num2)    len1, len2 = num1.length, num2.length    len_result = len1 + len2    result = Array.new(len_result, 0)    (len1 - 1).downto(0) do |i|        (len2 - 1).downto(0) do |j|            mul = num1[i].to_i * num2[j].to_i            sum = mul + result[i + j + 1]            result[i + j + 1] = sum % 10            result[i + j] += sum / 10        end    end    idx = 0    while idx &lt; len_result &amp;&amp; result[idx] == 0        idx += 1    end    if idx == len_result        result_str = &#x27;0&#x27;    else        result_str = result[idx..-1].join    end    result_strend\n\n结果执行用时 : 145 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.50 MB, 击败 -% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def multiply(num1: String, num2: String): String = &#123;    val len1 = num1.length    val len2 = num2.length    val lenResult = len1 + len2    val result = Array.fill(lenResult)(0)    for (i &lt;- len1 - 1 to 0 by -1) &#123;      for (j &lt;- len2 - 1 to 0 by -1) &#123;        val mul = (num1(i) - &#x27;0&#x27;) * (num2(j) - &#x27;0&#x27;)        val sum = mul + result(i + j + 1)        result(i + j + 1) = sum % 10        result(i + j) += sum / 10      &#125;    &#125;    val idx = result.indexWhere(_ != 0)    val resultStr =      if (idx == -1) &quot;0&quot;      else result.slice(idx, lenResult).mkString    resultStr  &#125;&#125;\n\n结果执行用时 : 504 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 54.61 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn multiply(num1: String, num2: String) -&gt; String &#123;        let len1 = num1.len();        let len2 = num2.len();        let len_result = len1 + len2;        let mut result = vec![0; len_result];        for (i, c1) in num1.chars().rev().enumerate() &#123;            for (j, c2) in num2.chars().rev().enumerate() &#123;                let mul = (c1.to_digit(10).unwrap()) * (c2.to_digit(10).unwrap());                let sum = mul + result[i + j];                result[i + j] = sum % 10;                result[i + j + 1] += sum / 10;            &#125;        &#125;        let mut result_str: String = result            .iter()            .rev()            .skip_while(|&amp;&amp;x| x == 0)            .map(|&amp;x| char::from_digit(x, 10).unwrap())            .collect();        if result_str.is_empty() &#123;            result_str.push(&#x27;0&#x27;);        &#125;        result_str    &#125;&#125;\n\n结果执行用时 : 2 ms, 击败 33.33% 使用 Rust 的用户\n内存消耗 : 2.14 MB, 击败 55.56% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00044.通配符匹配","url":"/zh-CN/79f1751f0ddd/","content":"\n题目描述给你一个输入字符串 (s) 和一个字符模式 (p) ，请你实现一个支持 ‘?’ 和 ‘*’ 匹配规则的通配符匹配：\n\n‘?’ 可以匹配任何单个字符。\n‘*’ 可以匹配任意字符序列（包括空字符序列）。判定匹配成功的充要条件是：字符模式必须能够 完全匹配 输入字符串（而不是部分匹配）。\n\n示例 1：\n输入：s &#x3D; “aa”, p &#x3D; “a”输出：false解释：”a” 无法匹配 “aa” 整个字符串。\n\n示例 2：\n输入：s &#x3D; “aa”, p &#x3D; ““输出：true解释：’‘ 可以匹配任意字符串。\n\n示例 3：\n输入：s &#x3D; “cb”, p &#x3D; “?a”输出：false解释：’?’ 可以匹配 ‘c’, 但第二个 ‘a’ 无法匹配 ‘b’。\n\n提示：\n0 &lt;&#x3D; s.length, p.length &lt;&#x3D; 2000\ns 仅由小写英文字母组成\np 仅由小写英文字母、’?’ 或 ‘*’ 组成\n\n\n解决方法C++class Solution &#123;public:    bool isMatch(string s, string p) &#123;        int m = s.length();        int n = p.length();        vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false));        dp[0][0] = true;        for (int j = 1; j &lt;= n; ++j) &#123;            if (p[j - 1] == &#x27;*&#x27;) &#123;                dp[0][j] = dp[0][j - 1];            &#125;        &#125;        for (int i = 1; i &lt;= m; ++i) &#123;            for (int j = 1; j &lt;= n; ++j) &#123;                if (p[j - 1] == s[i - 1] || p[j - 1] == &#x27;?&#x27;) &#123;                    dp[i][j] = dp[i - 1][j - 1];                &#125; else if (p[j - 1] == &#x27;*&#x27;) &#123;                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];                &#125;            &#125;        &#125;        return dp[m][n];    &#125;&#125;;\n\n结果执行用时 : 69 ms, 击败 58.85% 使用 C++ 的用户\n内存消耗 : 15.31 MB, 击败 39.38% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public boolean isMatch(String s, String p) &#123;        int m = s.length();        int n = p.length();        boolean[][] dp = new boolean[m + 1][n + 1];        dp[0][0] = true;        for (int j = 1; j &lt;= n; j++) &#123;            if (p.charAt(j - 1) == &#x27;*&#x27;) &#123;                dp[0][j] = dp[0][j - 1];            &#125;        &#125;        for (int i = 1; i &lt;= m; i++) &#123;            for (int j = 1; j &lt;= n; j++) &#123;                if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == &#x27;?&#x27;) &#123;                    dp[i][j] = dp[i - 1][j - 1];                &#125;                else if (p.charAt(j - 1) == &#x27;*&#x27;) &#123;                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];                &#125;            &#125;        &#125;        return dp[m][n];    &#125;&#125;\n\n结果执行用时 : 24 ms, 击败 59.21% 使用 Java 的用户\n内存消耗 : 43.70 MB, 击败 56.23% 使用 Java 的用户\n\nPythonclass Solution(object):    def isMatch(self, s, p):        &quot;&quot;&quot;        :type s: str        :type p: str        :rtype: bool        &quot;&quot;&quot;        m, n = len(s), len(p)        dp = [[False] * (n + 1) for _ in range(m + 1)]        dp[0][0] = True        for j in range(1, n + 1):            if p[j - 1] == &#x27;*&#x27;:                dp[0][j] = dp[0][j - 1]        for i in range(1, m + 1):            for j in range(1, n + 1):                if p[j - 1] == s[i - 1] or p[j - 1] == &#x27;?&#x27;:                    dp[i][j] = dp[i - 1][j - 1]                elif p[j - 1] == &#x27;*&#x27;:                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]        return dp[m][n]\n\n结果执行用时 : 544 ms, 击败 74.67% 使用 Python 的用户\n内存消耗 : 19.36 MB, 击败 78.67% 使用 Python 的用户\n\nPython3class Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        m, n = len(s), len(p)        dp = [[False] * (n + 1) for _ in range(m + 1)]        dp[0][0] = True        for j in range(1, n + 1):            if p[j - 1] == &#x27;*&#x27;:                dp[0][j] = dp[0][j - 1]        for i in range(1, m + 1):            for j in range(1, n + 1):                if p[j - 1] == s[i - 1] or p[j - 1] == &#x27;?&#x27;:                    dp[i][j] = dp[i - 1][j - 1]                elif p[j - 1] == &#x27;*&#x27;:                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]        return dp[m][n]\n\n结果执行用时 : 399 ms, 击败 79.64% 使用 Python3 的用户\n内存消耗 : 24.43 MB, 击败 45.51% 使用 Python3 的用户\n\nCbool isMatch(char* s, char* p) &#123;    int m = strlen(s);    int n = strlen(p);    bool dp[m + 1][n + 1];    memset(dp, false, sizeof(dp));    dp[0][0] = true;    for (int j = 1; j &lt;= n; j++) &#123;        if (p[j - 1] == &#x27;*&#x27;) &#123;            dp[0][j] = dp[0][j - 1];        &#125;    &#125;    for (int i = 1; i &lt;= m; i++) &#123;        for (int j = 1; j &lt;= n; j++) &#123;            if (p[j - 1] == s[i - 1] || p[j - 1] == &#x27;?&#x27;) &#123;                dp[i][j] = dp[i - 1][j - 1];            &#125; else if (p[j - 1] == &#x27;*&#x27;) &#123;                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];            &#125;        &#125;    &#125;    return dp[m][n];&#125;\n\n结果执行用时 : 21 ms, 击败 62.82% 使用 C 的用户\n内存消耗 : 6.82 MB, 击败 81.41% 使用 C 的用户\n\nC#public class Solution &#123;    public bool IsMatch(string s, string p) &#123;        int m = s.Length;        int n = p.Length;        bool[,] dp = new bool[m + 1, n + 1];        dp[0, 0] = true;        for (int j = 1; j &lt;= n; j++) &#123;            if (p[j - 1] == &#x27;*&#x27;) &#123;                dp[0, j] = dp[0, j - 1];            &#125;        &#125;        for (int i = 1; i &lt;= m; i++) &#123;            for (int j = 1; j &lt;= n; j++) &#123;                if (p[j - 1] == s[i - 1] || p[j - 1] == &#x27;?&#x27;) &#123;                    dp[i, j] = dp[i - 1, j - 1];                &#125; else if (p[j - 1] == &#x27;*&#x27;) &#123;                    dp[i, j] = dp[i - 1, j] || dp[i, j - 1];                &#125;            &#125;        &#125;        return dp[m, n];    &#125;&#125;\n\n结果执行用时 : 65 ms, 击败 93.07% 使用 C# 的用户\n内存消耗 : 51.68 MB, 击败 19.80% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; s * @param &#123;string&#125; p * @return &#123;boolean&#125; */var isMatch = function(s, p) &#123;    const m = s.length;    const n = p.length;    const dp = Array.from(&#123; length: m + 1 &#125;, () =&gt; Array(n + 1).fill(false));    dp[0][0] = true;    for (let j = 1; j &lt;= n; j++) &#123;        if (p[j - 1] === &#x27;*&#x27;) &#123;            dp[0][j] = dp[0][j - 1];        &#125;    &#125;    for (let i = 1; i &lt;= m; i++) &#123;        for (let j = 1; j &lt;= n; j++) &#123;            if (p[j - 1] === s[i - 1] || p[j - 1] === &#x27;?&#x27;) &#123;                dp[i][j] = dp[i - 1][j - 1];            &#125; else if (p[j - 1] === &#x27;*&#x27;) &#123;                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];            &#125;        &#125;    &#125;    return dp[m][n];&#125;;\n\n结果执行用时 : 128 ms, 击败 85.29% 使用 JavaScript 的用户\n内存消耗 : 66.23 MB, 击败 16.67% 使用 JavaScript 的用户\n\nTypeScriptfunction isMatch(s: string, p: string): boolean &#123;    const m = s.length;    const n = p.length;    const dp: boolean[][] = Array.from(&#123; length: m + 1 &#125;, () =&gt; Array(n + 1).fill(false));    dp[0][0] = true;    for (let j = 1; j &lt;= n; j++) &#123;        if (p[j - 1] === &#x27;*&#x27;) &#123;            dp[0][j] = dp[0][j - 1];        &#125;    &#125;    for (let i = 1; i &lt;= m; i++) &#123;        for (let j = 1; j &lt;= n; j++) &#123;            if (p[j - 1] === s[i - 1] || p[j - 1] === &#x27;?&#x27;) &#123;                dp[i][j] = dp[i - 1][j - 1];            &#125; else if (p[j - 1] === &#x27;*&#x27;) &#123;                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];            &#125;        &#125;    &#125;    return dp[m][n];&#125;\n\n结果执行用时 : 133 ms, 击败 68.03% 使用 TypeScript 的用户\n内存消耗 : 64.14 MB, 击败 12.29% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;        /**     * @param String $s     * @param String $p     * @return Boolean     */    function isMatch($s, $p) &#123;        $m = strlen($s);        $n = strlen($p);        $dp = array_fill(0, $m + 1, array_fill(0, $n + 1, false));        $dp[0][0] = true;        for ($j = 1; $j &lt;= $n; $j++) &#123;            if ($p[$j - 1] === &#x27;*&#x27;) &#123;                $dp[0][$j] = $dp[0][$j - 1];            &#125;        &#125;        for ($i = 1; $i &lt;= $m; $i++) &#123;            for ($j = 1; $j &lt;= $n; $j++) &#123;                if ($p[$j - 1] === $s[$i - 1] || $p[$j - 1] === &#x27;?&#x27;) &#123;                    $dp[$i][$j] = $dp[$i - 1][$j - 1];                &#125;                elseif ($p[$j - 1] === &#x27;*&#x27;) &#123;                    $dp[$i][$j] = $dp[$i - 1][$j] || $dp[$i][$j - 1];                &#125;            &#125;        &#125;        return $dp[$m][$n];    &#125;&#125;\n\n结果执行用时 : 202 ms, 击败 100.00% 使用 PHP 的用户\n内存消耗 : 40.62 MB, 击败 100.00% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func isMatch(_ s: String, _ p: String) -&gt; Bool &#123;        var target = Array(s), regex = [Character](), flag = false        for c in p &#123;            if !(c == &quot;*&quot; &amp;&amp; flag) &#123;                regex.append(c)            &#125;            flag = c == &quot;*&quot;        &#125;        var visit = [[Bool]](repeating: [Bool](repeating: false, count: target.count), count: regex.count)        var table = [[Bool]](repeating: [Bool](repeating: false, count: target.count), count: regex.count)        func memory(_ x: Int, _ y: Int) -&gt; Bool &#123;            if x == -1 &amp;&amp; y == -1 &#123;                return true            &#125; else if x == -1 &#123;                return false            &#125; else if y == -1 &#123;                return x == 0 &amp;&amp; regex[0] == &quot;*&quot;            &#125; else &#123;                if !visit[x][y] &#123;                    table[x][y] = search(x, y)                    visit[x][y] = true                &#125;                return table[x][y]            &#125;        &#125;        func search(_ x: Int, _ y: Int) -&gt; Bool &#123;            if regex[x] == &quot;?&quot; || regex[x] == target[y] &#123;                return memory(x - 1, y - 1)            &#125; else if regex[x] == &quot;*&quot; &#123;                return memory(x - 1, y) || memory(x, y - 1)            &#125; else &#123;                return false            &#125;        &#125;        return memory(regex.count - 1, target.count - 1)    &#125;&#125;\n\n结果执行用时 : 66 ms, 击败 38.46% 使用 Swift 的用户\n内存消耗 : 17.84 MB, 击败 7.69% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun isMatch(s: String, p: String): Boolean &#123;        val m = s.length        val n = p.length        val dp = Array(m + 1) &#123; BooleanArray(n + 1) &#125;        dp[0][0] = true        for (j in 1..n) &#123;            if (p[j - 1] == &#x27;*&#x27;) &#123;                dp[0][j] = dp[0][j - 1]            &#125;        &#125;        for (i in 1..m) &#123;            for (j in 1..n) &#123;                if (p[j - 1] == s[i - 1] || p[j - 1] == &#x27;?&#x27;) &#123;                    dp[i][j] = dp[i - 1][j - 1]                &#125; else if (p[j - 1] == &#x27;*&#x27;) &#123;                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1]                &#125;            &#125;        &#125;        return dp[m][n]    &#125;&#125;\n\n结果执行用时 : 212 ms, 击败 85.71% 使用 Kotlin 的用户\n内存消耗 : 36.84 MB, 击败 78.57% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  bool isMatch(String s, String p) &#123;    int m = s.length;    int n = p.length;    List&lt;List&lt;bool&gt;&gt; dp =        List.generate(m + 1, (_) =&gt; List&lt;bool&gt;.filled(n + 1, false));    dp[0][0] = true;    for (int j = 1; j &lt;= n; ++j) &#123;      if (p[j - 1] == &#x27;*&#x27;) &#123;        dp[0][j] = dp[0][j - 1];      &#125;    &#125;    for (int i = 1; i &lt;= m; ++i) &#123;      for (int j = 1; j &lt;= n; ++j) &#123;        if (p[j - 1] == s[i - 1] || p[j - 1] == &#x27;?&#x27;) &#123;          dp[i][j] = dp[i - 1][j - 1];        &#125; else if (p[j - 1] == &#x27;*&#x27;) &#123;          dp[i][j] = dp[i - 1][j] || dp[i][j - 1];        &#125;      &#125;    &#125;    return dp[m][n];  &#125;&#125;\n\n结果执行用时 : 356 ms, 击败 -% 使用 Dart 的用户\n内存消耗 : 154.70 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc isMatch(s string, p string) bool &#123;    m, n := len(s), len(p)    dp := make([][]bool, m+1)    for i := range dp &#123;        dp[i] = make([]bool, n+1)    &#125;    dp[0][0] = true    for j := 1; j &lt;= n; j++ &#123;        if p[j-1] == &#x27;*&#x27; &#123;            dp[0][j] = dp[0][j-1]        &#125;    &#125;    for i := 1; i &lt;= m; i++ &#123;        for j := 1; j &lt;= n; j++ &#123;            if p[j-1] == s[i-1] || p[j-1] == &#x27;?&#x27; &#123;                dp[i][j] = dp[i-1][j-1]            &#125; else if p[j-1] == &#x27;*&#x27; &#123;                dp[i][j] = dp[i-1][j] || dp[i][j-1]            &#125;        &#125;    &#125;    return dp[m][n]&#125;\n\n结果执行用时 : 3 ms, 击败 97.78% 使用 Go 的用户\n内存消耗 : 6.34 MB, 击败 43.33% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; s# @param &#123;String&#125; p# @return &#123;Boolean&#125;def is_match(s, p)    m, n = s.length, p.length    dp = Array.new(m + 1) &#123; Array.new(n + 1, false) &#125;    dp[0][0] = true    (1..n).each do |j|        dp[0][j] = dp[0][j - 1] if p[j - 1] == &#x27;*&#x27;    end    (1..m).each do |i|        (1..n).each do |j|            if p[j - 1] == s[i - 1] || p[j - 1] == &#x27;?&#x27;                dp[i][j] = dp[i - 1][j - 1]            elsif p[j - 1] == &#x27;*&#x27;                dp[i][j] = dp[i - 1][j] || dp[i][j - 1]            end        end    end    dp[m][n]end\n\n结果执行用时 : 1296 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 231.35 MB, 击败 100.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def isMatch(s: String, p: String): Boolean = &#123;    val m = s.length    val n = p.length    val dp = Array.ofDim[Boolean](m + 1, n + 1)    dp(0)(0) = true    for (j &lt;- 1 to n) &#123;      if (p(j - 1) == &#x27;*&#x27;) &#123;        dp(0)(j) = dp(0)(j - 1)      &#125;    &#125;    for (i &lt;- 1 to m) &#123;      for (j &lt;- 1 to n) &#123;        if (p(j - 1) == s(i - 1) || p(j - 1) == &#x27;?&#x27;) &#123;          dp(i)(j) = dp(i - 1)(j - 1)        &#125; else if (p(j - 1) == &#x27;*&#x27;) &#123;          dp(i)(j) = dp(i - 1)(j) || dp(i)(j - 1)        &#125;      &#125;    &#125;    dp(m)(n)  &#125;&#125;\n\n结果执行用时 : 554 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 55.13 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn is_match(s: String, p: String) -&gt; bool &#123;        let m = s.len();        let n = p.len();        let mut dp = vec![vec![false; n + 1]; m + 1];        dp[0][0] = true;        for j in 1..=n &#123;            if p.chars().nth(j - 1).unwrap() == &#x27;*&#x27; &#123;                dp[0][j] = dp[0][j - 1];            &#125;        &#125;        for i in 1..=m &#123;            for j in 1..=n &#123;                if p.chars().nth(j - 1).unwrap() == s.chars().nth(i - 1).unwrap()                    || p.chars().nth(j - 1).unwrap() == &#x27;?&#x27;                &#123;                    dp[i][j] = dp[i - 1][j - 1];                &#125; else if p.chars().nth(j - 1).unwrap() == &#x27;*&#x27; &#123;                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];                &#125;            &#125;        &#125;        dp[m][n]    &#125;&#125;\n\n结果执行用时 : 998 ms, 击败 6.67% 使用 Rust 的用户\n内存消耗 : 2.82 MB, 击败 20.00% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"女超人 第五季 第十二集 从未来回来-第二部分","url":"/zh-CN/25a816efe225/","content":"\n剧情介绍　　女超人帮助温恩面对他最大的恐惧。在亚历克斯开始寻找对莱克斯的证据时，布雷尼必须在帮助朋友和继续为莱克斯秘密工作之间做出抉择。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第一季 第十二集 左右为难","url":"/zh-CN/6a3512e12f9f/","content":"\n剧情介绍　　随着对爱丽丝的追捕愈演愈烈，凯特面临一个艰难的抉择。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00045.跳跃游戏 II","url":"/zh-CN/3f2816f26199/","content":"\n题目描述给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。\n每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:\n\n0 &lt;&#x3D; j &lt;&#x3D; nums[i] \ni + j &lt; n\n\n返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。\n示例 1：\n输入: nums &#x3D; [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。    从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。\n\n示例 2：\n输入: nums &#x3D; [2,3,0,1,4]输出: 2\n\n提示：\n$1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4$\n0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000\n题目保证可以到达 nums[n-1]\n\n\n解决方法C++class Solution &#123;public:    int jump(std::vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        if (n == 1) &#123;            return 0;        &#125;        int steps = 0;        int max_reach = 0;        int end = 0;        for (int i = 0; i &lt; n - 1; ++i) &#123;            max_reach = std::max(max_reach, i + nums[i]);            if (i == end) &#123;                end = max_reach;                ++steps;            &#125;        &#125;        return steps;    &#125;&#125;;\n\n结果执行用时 : 11 ms, 击败 74.69% 使用 C++ 的用户\n内存消耗 : 18.50 MB, 击败 14.62% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public int jump(int[] nums) &#123;        int n = nums.length;        if (n == 1) &#123;            return 0;        &#125;        int steps = 0;        int maxReach = 0;        int end = 0;        for (int i = 0; i &lt; n - 1; ++i) &#123;            maxReach = Math.max(maxReach, i + nums[i]);            if (i == end) &#123;                end = maxReach;                ++steps;            &#125;        &#125;        return steps;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 99.09% 使用 Java 的用户\n内存消耗 : 44.09 MB, 击败 17.59% 使用 Java 的用户\n\nPythonclass Solution(object):    def jump(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        n = len(nums)        if n == 1:            return 0        steps = 0        max_reach = 0        end = 0        for i in range(n - 1):            max_reach = max(max_reach, i + nums[i])            if i == end:                end = max_reach                steps += 1        return steps\n\n结果执行用时 : 20 ms, 击败 97.05% 使用 Python 的用户\n内存消耗 : 12.15 MB, 击败 94.93% 使用 Python 的用户\n\nPython3class Solution:    def jump(self, nums: List[int]) -&gt; int:        n = len(nums)        if n == 1:            return 0        steps = 0        max_reach = 0        end = 0        for i in range(n - 1):            max_reach = max(max_reach, i + nums[i])            if i == end:                end = max_reach                steps += 1        return steps\n\n结果执行用时 : 49 ms, 击败 73.77% 使用 Python3 的用户\n内存消耗 : 17.19 MB, 击败 43.74% 使用 Python3 的用户\n\nCint jump(int* nums, int numsSize) &#123;    if (numsSize == 1) &#123;        return 0;    &#125;    int steps = 0;    int max_reach = 0;    int end = 0;    for (int i = 0; i &lt; numsSize - 1; ++i) &#123;        max_reach = max_reach &gt; i + nums[i] ? max_reach : i + nums[i];        if (i == end) &#123;            end = max_reach;            ++steps;        &#125;    &#125;    return steps;&#125;\n\n结果执行用时 : 14 ms, 击败 43.78% 使用 C 的用户\n内存消耗 : 6.32 MB, 击败 95.87% 使用 C 的用户\n\nC#public class Solution &#123;    public int Jump(int[] nums) &#123;        int n = nums.Length;        if (n == 1) &#123;            return 0;        &#125;        int steps = 0;        int maxReach = 0;        int end = 0;        for (int i = 0; i &lt; n - 1; ++i) &#123;            maxReach = Math.Max(maxReach, i + nums[i]);            if (i == end) &#123;                end = maxReach;                ++steps;            &#125;        &#125;        return steps;    &#125;&#125;\n\n结果执行用时 : 85 ms, 击败 74.49% 使用 C# 的用户\n内存消耗 : 44.60 MB, 击败 14.29% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var jump = function(nums) &#123;    const n = nums.length;    if (n === 1) &#123;        return 0;    &#125;    let steps = 0;    let maxReach = 0;    let end = 0;    for (let i = 0; i &lt; n - 1; ++i) &#123;        maxReach = Math.max(maxReach, i + nums[i]);        if (i === end) &#123;            end = maxReach;            ++steps;        &#125;    &#125;    return steps;&#125;;\n\n结果执行用时 : 63 ms, 击败 72.09% 使用 JavaScript 的用户\n内存消耗 : 51.27 MB, 击败 5.23% 使用 JavaScript 的用户\n\nTypeScriptfunction jump(nums: number[]): number &#123;    const n: number = nums.length;    if (n === 1) &#123;        return 0;    &#125;    let steps: number = 0;    let maxReach: number = 0;    let end: number = 0;    for (let i = 0; i &lt; n - 1; ++i) &#123;        maxReach = Math.max(maxReach, i + nums[i]);        if (i === end) &#123;            end = maxReach;            ++steps;        &#125;    &#125;    return steps;&#125;\n\n结果执行用时 : 55 ms, 击败 98.51% 使用 TypeScript 的用户\n内存消耗 : 52.32 MB, 击败 6.69% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @return Integer     */    function jump($nums) &#123;        $n = count($nums);        if ($n == 1) &#123;            return 0;        &#125;        $steps = 0;        $maxReach = 0;        $end = 0;        for ($i = 0; $i &lt; $n - 1; ++$i) &#123;            $maxReach = max($maxReach, $i + $nums[$i]);            if ($i == $end) &#123;                $end = $maxReach;                ++$steps;            &#125;        &#125;        return $steps;    &#125;&#125;\n\n结果执行用时 : 20 ms, 击败 100.00% 使用 PHP 的用户\n内存消耗 : 20.84 MB, 击败 24.00% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func jump(_ nums: [Int]) -&gt; Int &#123;        let n = nums.count        if n == 1 &#123;            return 0        &#125;        var steps = 0        var maxReach = 0        var end = 0        for i in 0..&lt;n-1 &#123;            maxReach = max(maxReach, i + nums[i])            if i == end &#123;                end = maxReach                steps += 1            &#125;        &#125;        return steps    &#125;&#125;\n\n结果执行用时 : 27 ms, 击败 100.00% 使用 Swift 的用户\n内存消耗 : 15.43 MB, 击败 29.41% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun jump(nums: IntArray): Int &#123;        val n = nums.size        if (n == 1) &#123;            return 0        &#125;        var steps = 0        var maxReach = 0        var end = 0        for (i in 0 until n - 1) &#123;            maxReach = maxOf(maxReach, i + nums[i])            if (i == end) &#123;                end = maxReach                steps += 1            &#125;        &#125;        return steps    &#125;&#125;\n\n结果执行用时 : 192 ms, 击败 97.10% 使用 Kotlin 的用户\n内存消耗 : 38.05 MB, 击败 52.17% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int jump(List&lt;int&gt; nums) &#123;    int n = nums.length;    if (n == 1) &#123;      return 0;    &#125;    int steps = 0;    int maxReach = 0;    int end = 0;    for (int i = 0; i &lt; n - 1; ++i) &#123;      maxReach = nums[i] + i &gt; maxReach ? nums[i] + i : maxReach;      if (i == end) &#123;        end = maxReach;        ++steps;      &#125;    &#125;    return steps;  &#125;&#125;\n\n结果执行用时 : 288 ms, 击败 62.50% 使用 Dart 的用户\n内存消耗 : 148.39 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc jump(nums []int) int &#123;    n := len(nums)    if n == 1 &#123;        return 0    &#125;    steps := 0    maxReach := 0    end := 0    for i := 0; i &lt; n-1; i++ &#123;        maxReach = max(maxReach, i+nums[i])        if i == end &#123;            end = maxReach            steps++        &#125;    &#125;    return steps&#125;func max(a, b int) int &#123;    if a &gt; b &#123;        return a    &#125;    return b&#125;\n\n结果执行用时 : 8 ms, 击败 92.06% 使用 Go 的用户\n内存消耗 : 5.89 MB, 击败 98.04% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @return &#123;Integer&#125;def jump(nums)  n = nums.length  return 0 if n == 1  steps = 0  max_reach = 0  end_pos = 0  (0..n-2).each do |i|    max_reach = [max_reach, i + nums[i]].max    if i == end_pos      end_pos = max_reach      steps += 1    end  end  stepsend\n\n结果执行用时 : 57 ms, 击败 85.71% 使用 Ruby 的用户\n内存消耗 : 207.21 MB, 击败 71.43% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def jump(nums: Array[Int]): Int = &#123;    val n = nums.length    if (n == 1) &#123;      return 0    &#125;    var steps = 0    var maxReach = 0    var endPos = 0    for (i &lt;- 0 until n - 1) &#123;      maxReach = math.max(maxReach, i + nums(i))      if (i == endPos) &#123;        endPos = maxReach        steps += 1      &#125;    &#125;    steps  &#125;&#125;\n\n结果执行用时 : 536 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 55.57 MB, 击败 30.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn jump(nums: Vec&lt;i32&gt;) -&gt; i32 &#123;        let n = nums.len();        if n == 1 &#123;            return 0;        &#125;        let mut steps = 0;        let mut max_reach = 0usize;        let mut end = 0usize;        for i in 0..n - 1 &#123;            max_reach = max_reach.max(i + nums[i] as usize);            if i == end &#123;                end = max_reach;                steps += 1;            &#125;        &#125;        steps    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.22 MB, 击败 33.64% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00046.全排列","url":"/zh-CN/5f34126db307/","content":"\n题目描述给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n示例 1：\n输入：nums &#x3D; [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n示例 2：\n输入：nums &#x3D; [0,1]输出：[[0,1],[1,0]]\n\n示例 3：\n输入：nums &#x3D; [1]输出：[[1]]\n\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 6\n-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10\nnums 中的所有整数 互不相同\n\n\n解决方法C++class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        backtrack(nums, 0, result);        return result;    &#125;private:    void backtrack(vector&lt;int&gt;&amp; nums, int start, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123;        if (start == nums.size()) &#123;            result.push_back(nums);            return;        &#125;        for (int i = start; i &lt; nums.size(); ++i) &#123;            swap(nums[start], nums[i]);            backtrack(nums, start + 1, result);            swap(nums[start], nums[i]);  // 回溯        &#125;    &#125;&#125;;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C++ 的用户\n内存消耗 : 8.74 MB, 击败 20.97% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        List&lt;Integer&gt; currentPermutation = new ArrayList&lt;&gt;();        boolean[] used = new boolean[nums.length];        backtrack(nums, used, currentPermutation, result);        return result;    &#125;    private void backtrack(int[] nums, boolean[] used, List&lt;Integer&gt; currentPermutation, List&lt;List&lt;Integer&gt;&gt; result) &#123;        if (currentPermutation.size() == nums.length) &#123;            result.add(new ArrayList&lt;&gt;(currentPermutation));            return;        &#125;        for (int i = 0; i &lt; nums.length; i++) &#123;            if (!used[i]) &#123;                used[i] = true;                currentPermutation.add(nums[i]);                backtrack(nums, used, currentPermutation, result);                currentPermutation.remove(currentPermutation.size() - 1);                used[i] = false;            &#125;        &#125;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 83.32% 使用 Java 的用户\n内存消耗 : 43.70 MB, 击败 5.05% 使用 Java 的用户\n\nPythonclass Solution(object):    def permute(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[List[int]]        &quot;&quot;&quot;        def backtrack(start):            if start == len(nums):                result.append(nums[:])                return            for i in range(start, len(nums)):                nums[start], nums[i] = nums[i], nums[start]                backtrack(start + 1)                nums[start], nums[i] = nums[i], nums[start]        result = []        backtrack(0)        return result\n\n结果执行用时 : 18 ms, 击败 67.64% 使用 Python 的用户\n内存消耗 : 11.63 MB, 击败 95.42% 使用 Python 的用户\n\nPython3class Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        def backtrack(start):            if start == len(nums):                result.append(nums[:])                return            for i in range(start, len(nums)):                nums[start], nums[i] = nums[i], nums[start]                backtrack(start + 1)                nums[start], nums[i] = nums[i], nums[start]        result = []        backtrack(0)        return result\n\n结果执行用时 : 43 ms, 击败 57.96% 使用 Python3 的用户\n内存消耗 : 16.61 MB, 击败 38.86% 使用 Python3 的用户\n\nC/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */void swap(int *a, int *b) &#123;    int temp = *a;    *a = *b;    *b = temp;&#125;void backtrack(int *nums, int numsSize, int start, int ***result, int *resultSize, int **resultColumnSizes) &#123;    if (start == numsSize) &#123;        (*resultSize)++;        *result = realloc(*result, sizeof(int *) * (*resultSize));        (*result)[(*resultSize) - 1] = malloc(sizeof(int) * numsSize);        for (int i = 0; i &lt; numsSize; i++) &#123;            (*result)[(*resultSize) - 1][i] = nums[i];        &#125;        (*resultColumnSizes) = realloc(*resultColumnSizes, sizeof(int) * (*resultSize));        (*resultColumnSizes)[(*resultSize) - 1] = numsSize;        return;    &#125;    for (int i = start; i &lt; numsSize; i++) &#123;        swap(&amp;nums[start], &amp;nums[i]);        backtrack(nums, numsSize, start + 1, result, resultSize, resultColumnSizes);        swap(&amp;nums[start], &amp;nums[i]);  // 回溯    &#125;&#125;int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) &#123;    int **result = NULL;    *returnSize = 0;    *returnColumnSizes = NULL;    backtrack(nums, numsSize, 0, &amp;result, returnSize, returnColumnSizes);    return result;&#125;\n\n结果执行用时 : 4 ms, 击败 99.53% 使用 C 的用户\n内存消耗 : 15.20 MB, 击败 5.08% 使用 C 的用户\n\nC#public class Solution &#123;    public IList&lt;IList&lt;int&gt;&gt; Permute(int[] nums) &#123;        List&lt;IList&lt;int&gt;&gt; result = new List&lt;IList&lt;int&gt;&gt;();        List&lt;int&gt; currentPermutation = new List&lt;int&gt;();        bool[] used = new bool[nums.Length];        Backtrack(nums, used, currentPermutation, result);        return result;    &#125;    private void Backtrack(int[] nums, bool[] used, List&lt;int&gt; currentPermutation, List&lt;IList&lt;int&gt;&gt; result) &#123;        if (currentPermutation.Count == nums.Length) &#123;            result.Add(new List&lt;int&gt;(currentPermutation));            return;        &#125;        for (int i = 0; i &lt; nums.Length; i++) &#123;            if (!used[i]) &#123;                used[i] = true;                currentPermutation.Add(nums[i]);                Backtrack(nums, used, currentPermutation, result);                currentPermutation.RemoveAt(currentPermutation.Count - 1);                used[i] = false;            &#125;        &#125;    &#125;&#125;\n\n结果执行用时 : 111 ms, 击败 55.73% 使用 C# 的用户\n内存消耗 : 46.11 MB, 击败 17.71% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var permute = function(nums) &#123;    let result = [];    let currentPermutation = [];    let used = new Array(nums.length).fill(false);    const backtrack = (start) =&gt; &#123;        if (start === nums.length) &#123;            result.push([...currentPermutation]);            return;        &#125;        for (let i = 0; i &lt; nums.length; i++) &#123;            if (!used[i]) &#123;                used[i] = true;                currentPermutation.push(nums[i]);                backtrack(start + 1);                currentPermutation.pop();                used[i] = false;            &#125;        &#125;    &#125;;    backtrack(0);    return result;&#125;;\n\n结果执行用时 : 67 ms, 击败 88.42% 使用 JavaScript 的用户\n内存消耗 : 53.24 MB, 击败 6.32% 使用 JavaScript 的用户\n\nTypeScriptfunction permute(nums: number[]): number[][] &#123;    const result: number[][] = [];    const currentPermutation: number[] = [];    const used: boolean[] = new Array(nums.length).fill(false);    const backtrack = (start: number): void =&gt; &#123;        if (start === nums.length) &#123;            result.push([...currentPermutation]);            return;        &#125;        for (let i = 0; i &lt; nums.length; i++) &#123;            if (!used[i]) &#123;                used[i] = true;                currentPermutation.push(nums[i]);                backtrack(start + 1);                currentPermutation.pop();                used[i] = false;            &#125;        &#125;    &#125;;    backtrack(0);    return result;&#125;\n\n结果执行用时 : 76 ms, 击败 74.55% 使用 TypeScript 的用户\n内存消耗 : 53.70 MB, 击败 20.45% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @return Integer[][]     */    function permute($nums) &#123;        $result = [];        $currentPermutation = [];        $used = array_fill(0, count($nums), false);        $this-&gt;backtrack($nums, $used, $currentPermutation, $result);        return $result;    &#125;    private function backtrack($nums, &amp;$used, &amp;$currentPermutation, &amp;$result) &#123;        if (count($currentPermutation) === count($nums)) &#123;            $result[] = $currentPermutation;            return;        &#125;        for ($i = 0; $i &lt; count($nums); $i++) &#123;            if (!$used[$i]) &#123;                $used[$i] = true;                $currentPermutation[] = $nums[$i];                $this-&gt;backtrack($nums, $used, $currentPermutation, $result);                array_pop($currentPermutation);                $used[$i] = false;            &#125;        &#125;    &#125;&#125;\n\n结果执行用时 : 14 ms, 击败 14.29% 使用 PHP 的用户\n内存消耗 : 20.39 MB, 击败 19.05% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func permute(_ nums: [Int]) -&gt; [[Int]] &#123;        var result: [[Int]] = []        var currentPermutation: [Int] = []        var used: [Bool] = Array(repeating: false, count: nums.count)        backtrack(nums, &amp;used, &amp;currentPermutation, &amp;result)        return result    &#125;    private func backtrack(_ nums: [Int], _ used: inout [Bool], _ currentPermutation: inout [Int], _ result: inout [[Int]]) &#123;        if currentPermutation.count == nums.count &#123;            result.append(currentPermutation)            return        &#125;        for i in 0..&lt;nums.count &#123;            if !used[i] &#123;                used[i] = true                currentPermutation.append(nums[i])                backtrack(nums, &amp;used, &amp;currentPermutation, &amp;result)                currentPermutation.removeLast()                used[i] = false            &#125;        &#125;    &#125;&#125;\n\n结果执行用时 : 15 ms, 击败 8.55% 使用 Swift 的用户\n内存消耗 : 15.90 MB, 击败 5.13% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun permute(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;        val result: MutableList&lt;MutableList&lt;Int&gt;&gt; = mutableListOf()        val currentPermutation: MutableList&lt;Int&gt; = mutableListOf()        val used: BooleanArray = BooleanArray(nums.size)        backtrack(nums, used, currentPermutation, result)        return result    &#125;    private fun backtrack(nums: IntArray, used: BooleanArray, currentPermutation: MutableList&lt;Int&gt;, result: MutableList&lt;MutableList&lt;Int&gt;&gt;) &#123;        if (currentPermutation.size == nums.size) &#123;            result.add(ArrayList(currentPermutation))            return        &#125;        for (i in nums.indices) &#123;            if (!used[i]) &#123;                used[i] = true                currentPermutation.add(nums[i])                backtrack(nums, used, currentPermutation, result)                currentPermutation.removeAt(currentPermutation.size - 1)                used[i] = false            &#125;        &#125;    &#125;&#125;\n\n结果执行用时 : 172 ms, 击败 98.86% 使用 Kotlin 的用户\n内存消耗 : 36.45 MB, 击败 96.59% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;List&lt;int&gt;&gt; permute(List&lt;int&gt; nums) &#123;    List&lt;List&lt;int&gt;&gt; result = [];    List&lt;int&gt; currentPermutation = [];    List&lt;bool&gt; used = List.filled(nums.length, false);    void backtrack() &#123;      if (currentPermutation.length == nums.length) &#123;        result.add(List.from(currentPermutation));        return;      &#125;      for (int i = 0; i &lt; nums.length; i++) &#123;        if (!used[i]) &#123;          used[i] = true;          currentPermutation.add(nums[i]);          backtrack();          currentPermutation.removeLast();          used[i] = false;        &#125;      &#125;    &#125;    backtrack();    return result;  &#125;&#125;\n\n结果执行用时 : 281 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 143.52 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc permute(nums []int) [][]int &#123;\tresult := [][]int&#123;&#125;\tcurrentPermutation := []int&#123;&#125;\tused := make([]bool, len(nums))\tvar backtrack func()\tbacktrack = func() &#123;\t\tif len(currentPermutation) == len(nums) &#123;\t\t\ttemp := make([]int, len(nums))\t\t\tcopy(temp, currentPermutation)\t\t\tresult = append(result, temp)\t\t\treturn\t\t&#125;\t\tfor i := 0; i &lt; len(nums); i++ &#123;\t\t\tif !used[i] &#123;\t\t\t\tused[i] = true\t\t\t\tcurrentPermutation = append(currentPermutation, nums[i])\t\t\t\tbacktrack()\t\t\t\tcurrentPermutation = currentPermutation[:len(currentPermutation)-1]\t\t\t\tused[i] = false\t\t\t&#125;\t\t&#125;\t&#125;\tbacktrack()\treturn result&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.48 MB, 击败 88.20% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @return &#123;Integer[][]&#125;def permute(nums)  result = []  current_permutation = []  used = Array.new(nums.length, false)  backtrack = lambda do    if current_permutation.length == nums.length      result &lt;&lt; current_permutation.dup      return    end    nums.each_with_index do |num, i|      next if used[i]      used[i] = true      current_permutation &lt;&lt; num      backtrack.call      current_permutation.pop      used[i] = false    end  end  backtrack.call  resultend\n\n结果执行用时 : 83 ms, 击败 22.22% 使用 Ruby 的用户\n内存消耗 : 206.71 MB, 击败 11.11% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def permute(nums: Array[Int]): List[List[Int]] = &#123;    var result: List[List[Int]] = List()    var currentPermutation: List[Int] = List()    var used: Array[Boolean] = Array.fill[Boolean](nums.length)(false)    def backtrack(): Unit = &#123;      if (currentPermutation.length == nums.length) &#123;        result = result :+ currentPermutation        return      &#125;      for (i &lt;- nums.indices) &#123;        if (!used(i)) &#123;          used(i) = true          currentPermutation = currentPermutation :+ nums(i)          backtrack()          currentPermutation = currentPermutation.init          used(i) = false        &#125;      &#125;    &#125;    backtrack()    result  &#125;&#125;\n\n结果执行用时 : 516 ms, 击败 66.67% 使用 Scala 的用户\n内存消耗 : 57.46 MB, 击败 16.67% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn permute(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; &#123;        let mut result = Vec::new();        let mut current_permutation = Vec::new();        let mut used = vec![false; nums.len()];        fn backtrack(            nums: &amp;Vec&lt;i32&gt;,            used: &amp;mut Vec&lt;bool&gt;,            current_permutation: &amp;mut Vec&lt;i32&gt;,            result: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;,        ) &#123;            if current_permutation.len() == nums.len() &#123;                result.push(current_permutation.clone());                return;            &#125;            for i in 0..nums.len() &#123;                if !used[i] &#123;                    used[i] = true;                    current_permutation.push(nums[i]);                    backtrack(nums, used, current_permutation, result);                    current_permutation.pop();                    used[i] = false;                &#125;            &#125;        &#125;        backtrack(&amp;nums, &amp;mut used, &amp;mut current_permutation, &amp;mut result);        result    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.11 MB, 击败 61.80% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang-spec permute([integer()]) -&gt; [[integer()]].permute(Nums) -&gt;    backtrack(Nums, []).backtrack([], Perms) -&gt;    [Perms];backtrack(Nums, Perms) -&gt;    lists:flatmap(fun(Elem) -&gt;        NewPerms = Perms ++ [Elem],        NewNums = lists:delete(Elem, Nums),        backtrack(NewNums, NewPerms)    end, Nums).\n\n结果执行用时 : 203 ms, 击败 100.00% 使用 Erlang 的用户\n内存消耗 : 55.70 MB, 击败 100.00% 使用 Erlang 的用户\n\nElixirdefmodule Solution do  @spec permute(nums :: [integer]) :: [[integer]]  def permute(nums) do    backtrack(nums, [])  end  defp backtrack([], perms) do    [perms]  end  defp backtrack(nums, perms) do    Enum.flat_map(nums, fn elem -&gt;      new_perms = perms ++ [elem]      new_nums = Enum.filter(nums, &amp;(&amp;1 != elem))      backtrack(new_nums, new_perms)    end)  endend\n\n结果执行用时 : 281 ms, 击败 -% 使用 Elixir 的用户\n内存消耗 : 68.01 MB, 击败 100.00% 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"闪电侠 第六季 第十二集 一个叫苏的女孩","url":"/zh-CN/470087590385/","content":"\n剧情介绍　　经过几个月的寻找苏·迪尔邦，拉尔夫得到了她下落的线索，终于与他失踪的客户面对面。然而，苏拒绝回家与家人团聚，而是带着拉尔夫进行了一次大胆的冒险。Iris面临着新的挑战，而Barry则考虑来自可信来源的潜在危险请求。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"雨水","url":"/zh-CN/089c21ef9821/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  雨水\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","雨水"]},{"title":"力扣00047.全排列 II","url":"/zh-CN/adda12a0e2b4/","content":"\n题目描述给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。\n示例 1：\n输入：nums &#x3D; [1,1,2]输出：[[1,1,2],[1,2,1],[2,1,1]]\n\n示例 2：\n输入：nums &#x3D; [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 8\n-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10\n\n\n解决方法C++class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(), nums.end());        vector&lt;vector&lt;int&gt;&gt; result;        vector&lt;int&gt; path;        vector&lt;bool&gt; used(nums.size(), false);        backtrack(nums, used, path, result);        return result;    &#125;private:    void backtrack(const vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123;        if (path.size() == nums.size()) &#123;            result.push_back(path);            return;        &#125;        for (int i = 0; i &lt; nums.size(); ++i) &#123;            if (used[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1])) &#123;                continue;            &#125;            used[i] = true;            path.push_back(nums[i]);            backtrack(nums, used, path, result);            path.pop_back();            used[i] = false;        &#125;    &#125;&#125;;\n\n结果执行用时 : 4 ms, 击败 90.72% 使用 C++ 的用户\n内存消耗 : 10.72 MB, 击败 29.84% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;        Arrays.sort(nums);        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();        boolean[] used = new boolean[nums.length];        backtrack(nums, used, path, result);        return result;    &#125;    private void backtrack(int[] nums, boolean[] used, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result) &#123;        if (path.size() == nums.length) &#123;            result.add(new ArrayList&lt;&gt;(path));            return;        &#125;        for (int i = 0; i &lt; nums.length; ++i) &#123;            if (used[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1])) &#123;                continue;            &#125;            used[i] = true;            path.add(nums[i]);            backtrack(nums, used, path, result);            path.remove(path.size() - 1);            used[i] = false;        &#125;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 99.84% 使用 Java 的用户\n内存消耗 : 43.82 MB, 击败 25.69% 使用 Java 的用户\n\nPythonclass Solution(object):    def permuteUnique(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[List[int]]        &quot;&quot;&quot;        nums.sort()        result = []        path = []        used = [False] * len(nums)        self.backtrack(nums, used, path, result)        return result    def backtrack(self, nums, used, path, result):        if len(path) == len(nums):            result.append(path[:])            return        for i in range(len(nums)):            if used[i] or (i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]):                continue            used[i] = True            path.append(nums[i])            self.backtrack(nums, used, path, result)            path.pop()            used[i] = False\n\n结果执行用时 : 28 ms, 击败 70.21% 使用 Python 的用户\n内存消耗 : 11.70 MB, 击败 98.38% 使用 Python 的用户\n\nPython3class Solution:    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:        nums.sort()        result = []        path = []        used = [False] * len(nums)        self.backtrack(nums, used, path, result)        return result    def backtrack(self, nums, used, path, result):        if len(path) == len(nums):            result.append(path[:])            return        for i in range(len(nums)):            if used[i] or (i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]):                continue            used[i] = True            path.append(nums[i])            self.backtrack(nums, used, path, result)            path.pop()            used[i] = False\n\n结果执行用时 : 39 ms, 击败 93.93% 使用 Python3 的用户\n内存消耗 : 16.72 MB, 击败 37.36% 使用 Python3 的用户\n\nC/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */void backtrack(int* nums, int numSize, int** ans, int* ansSize, int idx, int* perm, int* used) &#123;    if (idx == numSize) &#123;        int* tmp = malloc(sizeof(int) * numSize);        memcpy(tmp, perm, sizeof(int) * numSize);        ans[(*ansSize)++] = tmp;        return;    &#125;    for (int i = 0; i &lt; numSize; ++i) &#123;        if (used[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1])) &#123;            continue;        &#125;        perm[idx] = nums[i];        used[i] = 1;        backtrack(nums, numSize, ans, ansSize, idx + 1, perm, used);        used[i] = 0;    &#125;&#125;int cmp(const void* a, const void* b) &#123;    return *(int*)a - *(int*)b;&#125;int** permuteUnique(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) &#123;    int** ans = malloc(sizeof(int*) * 2001);    int* perm = malloc(sizeof(int) * 2001);    int* used = malloc(sizeof(int) * numsSize);    memset(used, 0, sizeof(int) * numsSize);    qsort(nums, numsSize, sizeof(int), cmp);    *returnSize = 0;    backtrack(nums, numsSize, ans, returnSize, 0, perm, used);    *returnColumnSizes = malloc(sizeof(int) * (*returnSize));    for (int i = 0; i &lt; *returnSize; i++) &#123;        (*returnColumnSizes)[i] = numsSize;    &#125;    free(used);    return ans;&#125;\n\n结果执行用时 : 20 ms, 击败 95.75% 使用 C 的用户\n内存消耗 : 9.37 MB, 击败 93.46% 使用 C 的用户\n\nC#public class Solution &#123;    public IList&lt;IList&lt;int&gt;&gt; PermuteUnique(int[] nums) &#123;        Array.Sort(nums);        IList&lt;IList&lt;int&gt;&gt; result = new List&lt;IList&lt;int&gt;&gt;();        IList&lt;int&gt; path = new List&lt;int&gt;();        bool[] used = new bool[nums.Length];        Backtrack(nums, used, path, result);        return result;    &#125;    private void Backtrack(int[] nums, bool[] used, IList&lt;int&gt; path, IList&lt;IList&lt;int&gt;&gt; result) &#123;        if (path.Count == nums.Length) &#123;            result.Add(new List&lt;int&gt;(path));            return;        &#125;        for (int i = 0; i &lt; nums.Length; ++i) &#123;            if (used[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1])) &#123;                continue;            &#125;            used[i] = true;            path.Add(nums[i]);            Backtrack(nums, used, path, result);            path.RemoveAt(path.Count - 1);            used[i] = false;        &#125;    &#125;&#125;\n\n结果执行用时 : 101 ms, 击败 89.89% 使用 C# 的用户\n内存消耗 : 48.13 MB, 击败 40.45% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var permuteUnique = function(nums) &#123;    nums.sort((a, b) =&gt; a - b);    const result = [];    const path = [];    const used = new Array(nums.length).fill(false);    backtrack(nums, used, path, result);    return result;&#125;;function backtrack(nums, used, path, result) &#123;    if (path.length === nums.length) &#123;        result.push([...path]);        return;    &#125;    for (let i = 0; i &lt; nums.length; ++i) &#123;        if (used[i] || (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1] &amp;&amp; !used[i - 1])) &#123;            continue;        &#125;        used[i] = true;        path.push(nums[i]);        backtrack(nums, used, path, result);        path.pop();        used[i] = false;    &#125;&#125;\n\n结果执行用时 : 75 ms, 击败 67.66% 使用 JavaScript 的用户\n内存消耗 : 52.87 MB, 击败 19.25% 使用 JavaScript 的用户\n\nTypeScriptfunction permuteUnique(nums: number[]): number[][] &#123;    nums.sort((a, b) =&gt; a - b);    const result: number[][] = [];    const path: number[] = [];    const used: boolean[] = new Array(nums.length).fill(false);    backtrack(nums, used, path, result);    return result;&#125;function backtrack(nums: number[], used: boolean[], path: number[], result: number[][]): void &#123;    if (path.length === nums.length) &#123;        result.push([...path]);        return;    &#125;    for (let i = 0; i &lt; nums.length; ++i) &#123;        if (used[i] || (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1] &amp;&amp; !used[i - 1])) &#123;            continue;        &#125;        used[i] = true;        path.push(nums[i]);        backtrack(nums, used, path, result);        path.pop();        used[i] = false;    &#125;&#125;\n\n结果执行用时 : 70 ms, 击败 93.66% 使用 TypeScript 的用户\n内存消耗 : 54.05 MB, 击败 28.87% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @return Integer[][]     */    function permuteUnique($nums) &#123;        sort($nums);        $result = [];        $path = [];        $used = array_fill(0, count($nums), false);        $this-&gt;backtrack($nums, $used, $path, $result);        return $result;    &#125;    private function backtrack($nums, &amp;$used, &amp;$path, &amp;$result) &#123;        if (count($path) === count($nums)) &#123;            $result[] = $path;            return;        &#125;        for ($i = 0; $i &lt; count($nums); ++$i) &#123;            if ($used[$i] || ($i &gt; 0 &amp;&amp; $nums[$i] === $nums[$i - 1] &amp;&amp; !$used[$i - 1])) &#123;                continue;            &#125;            $used[$i] = true;            $path[] = $nums[$i];            $this-&gt;backtrack($nums, $used, $path, $result);            array_pop($path);            $used[$i] = false;        &#125;    &#125;&#125;\n\n结果执行用时 : 7 ms, 击败 94.44% 使用 PHP 的用户\n内存消耗 : 20.77 MB, 击败 5.55% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func permuteUnique(_ nums: [Int]) -&gt; [[Int]] &#123;        var nums = nums.sorted()        var result = [[Int]]()        var path = [Int]()        var used = [Bool](repeating: false, count: nums.count)        backtrack(nums: &amp;nums, used: &amp;used, path: &amp;path, result: &amp;result)        return result    &#125;    private func backtrack(nums: inout [Int], used: inout [Bool], path: inout [Int], result: inout [[Int]]) &#123;        if path.count == nums.count &#123;            result.append(Array(path))            return        &#125;        for i in 0..&lt;nums.count &#123;            if used[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123;                continue            &#125;            used[i] = true            path.append(nums[i])            backtrack(nums: &amp;nums, used: &amp;used, path: &amp;path, result: &amp;result)            path.removeLast()            used[i] = false        &#125;    &#125;&#125;\n\n结果执行用时 : 16 ms, 击败 100.00% 使用 Swift 的用户\n内存消耗 : 16.30 MB, 击败 5.00% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun permuteUnique(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;        val result = mutableListOf&lt;List&lt;Int&gt;&gt;()        val path = mutableListOf&lt;Int&gt;()        val used = BooleanArray(nums.size)        nums.sort()        backtrack(nums, used, path, result)        return result    &#125;    private fun backtrack(nums: IntArray, used: BooleanArray, path: MutableList&lt;Int&gt;, result: MutableList&lt;List&lt;Int&gt;&gt;) &#123;        if (path.size == nums.size) &#123;            result.add(path.toList())            return        &#125;        for (i in nums.indices) &#123;            if (used[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1])) &#123;                continue            &#125;            used[i] = true            path.add(nums[i])            backtrack(nums, used, path, result)            path.removeAt(path.size - 1)            used[i] = false        &#125;    &#125;&#125;\n\n结果执行用时 : 248 ms, 击败 66.67% 使用 Kotlin 的用户\n内存消耗 : 39.59 MB, 击败 66.67% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;List&lt;int&gt;&gt; permuteUnique(List&lt;int&gt; nums) &#123;    nums.sort();    List&lt;List&lt;int&gt;&gt; result = [];    List&lt;int&gt; path = [];    List&lt;bool&gt; used = List.filled(nums.length, false);    void backtrack() &#123;      if (path.length == nums.length) &#123;        result.add([...path]);        return;      &#125;      for (int i = 0; i &lt; nums.length; ++i) &#123;        if (used[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1])) &#123;          continue;        &#125;        used[i] = true;        path.add(nums[i]);        backtrack();        path.removeLast();        used[i] = false;      &#125;    &#125;    backtrack();    return result;  &#125;&#125;\n\n结果执行用时 : 318 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 147.68 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc permuteUnique(nums []int) [][]int &#123;\tsort.Ints(nums)\tvar result [][]int\tvar path []int\tused := make([]bool, len(nums))\tvar backtrack func()\tbacktrack = func() &#123;\t\tif len(path) == len(nums) &#123;\t\t\tresult = append(result, append([]int(nil), path...))\t\t\treturn\t\t&#125;\t\tfor i := 0; i &lt; len(nums); i++ &#123;\t\t\tif used[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i-1]) &#123;\t\t\t\tcontinue\t\t\t&#125;\t\t\tused[i] = true\t\t\tpath = append(path, nums[i])\t\t\tbacktrack()\t\t\tpath = path[:len(path)-1]\t\t\tused[i] = false\t\t&#125;\t&#125;\tbacktrack()\treturn result&#125;\n\n结果执行用时 : 3 ms, 击败 62.79% 使用 Go 的用户\n内存消耗 : 3.52 MB, 击败 96.43% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @return &#123;Integer[][]&#125;def permute_unique(nums)  nums.sort!  result = []  path = []  used = Array.new(nums.length, false)  backtrack = lambda do    if path.length == nums.length      result.push(path.dup)      return    end    nums.each_with_index do |num, i|      next if used[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1])      used[i] = true      path.push(num)      backtrack.call      path.pop      used[i] = false    end  end  backtrack.call  resultend\n\n结果执行用时 : 84 ms, 击败 80.00% 使用 Ruby 的用户\n内存消耗 : 206.89 MB, 击败 -% 使用 Ruby 的用户\n\nScalaimport scala.collection.mutable._object Solution &#123;  def dfs(curres: Stack[Int], nums: Array[Int], states: Array[Boolean], res: ArrayBuffer[List[Int]]): Unit = &#123;    if (curres.length == nums.length) &#123;      res.append(curres.toList)      return    &#125;    var used = Set[Int]()    for (i &lt;- 0 until nums.length) &#123;      if (states(i) &amp;&amp; !used(nums(i))) &#123;        curres.push(nums(i))        states(i) = false        dfs(curres, nums, states, res)        curres.pop()        states(i) = true        used += nums(i)      &#125;    &#125;  &#125;  def permuteUnique(nums: Array[Int]): List[List[Int]] = &#123;    val states = Array.fill(nums.length)(true)    val res = ArrayBuffer[List[Int]]()    val curres = Stack[Int]()    dfs(curres, nums.sorted, states, res)    res.toList  &#125;&#125;\n\n结果执行用时 : 544 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 57.75 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn permute_unique(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; &#123;        let mut result = Vec::new();        let mut path = Vec::new();        let mut used = vec![false; nums.len()];        fn backtrack(nums: &amp;Vec&lt;i32&gt;, used: &amp;mut Vec&lt;bool&gt;, path: &amp;mut Vec&lt;i32&gt;, result: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) &#123;            if path.len() == nums.len() &#123;                result.push(path.clone());                return;            &#125;            let mut prev_used = None;            for i in 0..nums.len() &#123;                if used[i] || Some(nums[i]) == prev_used &#123;                    continue;                &#125;                prev_used = Some(nums[i]);                path.push(nums[i]);                used[i] = true;                backtrack(nums, used, path, result);                path.pop();                used[i] = false;            &#125;        &#125;        let mut nums_sorted = nums.clone();        nums_sorted.sort();        backtrack(&amp;nums_sorted, &amp;mut used, &amp;mut path, &amp;mut result);        result    &#125;&#125;\n\n结果执行用时 : 3 ms, 击败 47.37% 使用 Rust 的用户\n内存消耗 : 2.14 MB, 击败 55.26% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00048.旋转图像","url":"/zh-CN/68ba603aaff7/","content":"\n题目描述给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。\n示例 1：\n\n\n输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]输出：[[7,4,1],[8,5,2],[9,6,3]]\n\n示例 2：\n\n\n输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n提示：\nn &#x3D;&#x3D; matrix.length &#x3D;&#x3D; matrix[i].length\n1 &lt;&#x3D; n &lt;&#x3D; 20\n-1000 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 1000\n\n\n解决方法C++class Solution &#123;public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int n = matrix.size();        for (int i = 0; i &lt; n; ++i) &#123;            for (int j = i + 1; j &lt; n; ++j) &#123;                swap(matrix[i][j], matrix[j][i]);            &#125;        &#125;        for (int i = 0; i &lt; n; ++i) &#123;            reverse(matrix[i].begin(), matrix[i].end());        &#125;    &#125;&#125;;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C++ 的用户\n内存消耗 : 8.52 MB, 击败 12.36% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public void rotate(int[][] matrix) &#123;        int n = matrix.length;        for (int i = 0; i &lt; n; ++i) &#123;            for (int j = i + 1; j &lt; n; ++j) &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[j][i];                matrix[j][i] = temp;            &#125;        &#125;        for (int i = 0; i &lt; n; ++i) &#123;            for (int j = 0; j &lt; n / 2; ++j) &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[i][n - 1 - j];                matrix[i][n - 1 - j] = temp;            &#125;        &#125;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 41.23 MB, 击败 14.96% 使用 Java 的用户\n\nPythonclass Solution(object):    def rotate(self, matrix):        &quot;&quot;&quot;        :type matrix: List[List[int]]        :rtype: None Do not return anything, modify matrix in-place instead.        &quot;&quot;&quot;        n = len(matrix)        for i in range(n):            for j in range(i + 1, n):                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]        for i in range(n):            matrix[i].reverse()\n\n结果执行用时 : 18 ms, 击败 39.91% 使用 Python 的用户\n内存消耗 : 11.35 MB, 击败 98.01% 使用 Python 的用户\n\nPython3class Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify matrix in-place instead.        &quot;&quot;&quot;        n = len(matrix)        for i in range(n):            for j in range(i + 1, n):                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]        for i in range(n):            matrix[i].reverse()\n\n结果执行用时 : 35 ms, 击败 85.58% 使用 Python3 的用户\n内存消耗 : 16.36 MB, 击败 46.87% 使用 Python3 的用户\n\nCvoid rotate(int** matrix, int matrixSize, int* matrixColSize) &#123;    int n = matrixSize;    for (int i = 0; i &lt; n; ++i) &#123;        for (int j = i + 1; j &lt; n; ++j) &#123;            int temp = matrix[i][j];            matrix[i][j] = matrix[j][i];            matrix[j][i] = temp;        &#125;    &#125;    for (int i = 0; i &lt; n; ++i) &#123;        for (int j = 0; j &lt; n / 2; ++j) &#123;            int temp = matrix[i][j];            matrix[i][j] = matrix[i][n - 1 - j];            matrix[i][n - 1 - j] = temp;        &#125;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 6.14 MB, 击败 84.61% 使用 C 的用户\n\nC#public class Solution &#123;    public void Rotate(int[][] matrix) &#123;        int n = matrix.Length;        for (int i = 0; i &lt; n; ++i) &#123;            for (int j = i + 1; j &lt; n; ++j) &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[j][i];                matrix[j][i] = temp;            &#125;        &#125;        for (int i = 0; i &lt; n; ++i) &#123;            Array.Reverse(matrix[i]);        &#125;    &#125;&#125;\n\n结果执行用时 : 104 ms, 击败 73.95% 使用 C# 的用户\n内存消耗 : 45.74 MB, 击败 6.72% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[][]&#125; matrix * @return &#123;void&#125; Do not return anything, modify matrix in-place instead. */var rotate = function(matrix) &#123;    const n = matrix.length;    for (let i = 0; i &lt; n; ++i) &#123;        for (let j = i + 1; j &lt; n; ++j) &#123;            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];        &#125;    &#125;    for (let i = 0; i &lt; n; ++i) &#123;        matrix[i].reverse();    &#125;&#125;;\n\n结果执行用时 : 50 ms, 击败 94.94% 使用 JavaScript 的用户\n内存消耗 : 49.44 MB, 击败 13.07% 使用 JavaScript 的用户\n\nTypeScript/** Do not return anything, modify matrix in-place instead. */function rotate(matrix: number[][]): void &#123;    const n: number = matrix.length;    for (let i = 0; i &lt; n; ++i) &#123;        for (let j = i + 1; j &lt; n; ++j) &#123;            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];        &#125;    &#125;    for (let i = 0; i &lt; n; ++i) &#123;        matrix[i].reverse();    &#125;&#125;\n\n结果执行用时 : 47 ms, 击败 100.00% 使用 TypeScript 的用户\n内存消耗 : 51.76 MB, 击败 7.02% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;        /**     * @param Integer[][] $matrix     * @return NULL     */    function rotate(&amp;$matrix) &#123;        $n = count($matrix);        for ($i = 0; $i &lt; $n; ++$i) &#123;            for ($j = $i + 1; $j &lt; $n; ++$j) &#123;                [$matrix[$i][$j], $matrix[$j][$i]] = [$matrix[$j][$i], $matrix[$i][$j]];            &#125;        &#125;        for ($i = 0; $i &lt; $n; ++$i) &#123;            $matrix[$i] = array_reverse($matrix[$i]);        &#125;    &#125;&#125;\n\n结果执行用时 : 9 ms, 击败 25.00% 使用 PHP 的用户\n内存消耗 : 20.14 MB, 击败 5.00% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func rotate(_ matrix: inout [[Int]]) &#123;        let n = matrix.count        for i in 0..&lt;n &#123;            for j in i+1..&lt;n &#123;                (matrix[i][j], matrix[j][i]) = (matrix[j][i], matrix[i][j])            &#125;        &#125;        for i in 0..&lt;n &#123;            matrix[i].reverse()        &#125;    &#125;&#125;\n\n结果执行用时 : 6 ms, 击败 78.82% 使用 Swift 的用户\n内存消耗 : 15.69 MB, 击败 5.88% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun rotate(matrix: Array&lt;IntArray&gt;): Unit &#123;        val n = matrix.size        for (i in 0 until n) &#123;            for (j in i + 1 until n) &#123;                matrix[i][j] = matrix[j][i].also &#123; matrix[j][i] = matrix[i][j] &#125;            &#125;        &#125;        for (i in 0 until n) &#123;            matrix[i].reverse()        &#125;    &#125;&#125;\n\n结果执行用时 : 206 ms, 击败 8.33% 使用 Kotlin 的用户\n内存消耗 : 37.55 MB, 击败 6.25% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  void rotate(List&lt;List&lt;int&gt;&gt; matrix) &#123;    final n = matrix.length;    for (var i = 0; i &lt; n; ++i) &#123;      for (var j = i + 1; j &lt; n; ++j) &#123;        final temp = matrix[i][j];        matrix[i][j] = matrix[j][i];        matrix[j][i] = temp;      &#125;    &#125;    for (var i = 0; i &lt; n; ++i) &#123;      matrix[i] = List&lt;int&gt;.from(matrix[i].reversed);    &#125;  &#125;&#125;\n\n结果执行用时 : 299 ms, 击败 -% 使用 Dart 的用户\n内存消耗 : 144.31 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc rotate(matrix [][]int) &#123;    n := len(matrix)    for i := 0; i &lt; n; i++ &#123;        for j := i + 1; j &lt; n; j++ &#123;            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]        &#125;    &#125;    for i := 0; i &lt; n; i++ &#123;        for j, k := 0, n-1; j &lt; k; j, k = j+1, k-1 &#123;            matrix[i][j], matrix[i][k] = matrix[i][k], matrix[i][j]        &#125;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.11 MB, 击败 16.92% 使用 Go 的用户\n\nRuby# @param &#123;Integer[][]&#125; matrix# @return &#123;Void&#125; Do not return anything, modify matrix in-place instead.def rotate(matrix)  n = matrix.length  (0...n).each do |i|    (i + 1...n).each do |j|      matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]    end  end  matrix.each &#123; |row| row.reverse! &#125;end\n\n结果执行用时 : 41 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.51 MB, 击败 50.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def rotate(matrix: Array[Array[Int]]): Unit = &#123;    val n = matrix.length    for (i &lt;- 0 until n) &#123;      for (j &lt;- i + 1 until n) &#123;        val temp = matrix(i)(j)        matrix(i)(j) = matrix(j)(i)        matrix(j)(i) = temp      &#125;    &#125;    for (i &lt;- 0 until n) &#123;      matrix(i) = matrix(i).reverse    &#125;  &#125;  def main(args: Array[String]): Unit = &#123;    val matrix = Array(      Array(1, 2, 3),      Array(4, 5, 6),      Array(7, 8, 9)    )    rotate(matrix)    for (row &lt;- matrix) &#123;      println(row.mkString(&quot;, &quot;))    &#125;  &#125;&#125;\n\n结果执行用时 : 464 ms, 击败 88.89% 使用 Scala 的用户\n内存消耗 : 54.36 MB, 击败 22.22% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn rotate(matrix: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) &#123;        let n = matrix.len();        for i in 0..n &#123;            for j in i + 1..n &#123;                let temp = matrix[i][j];                matrix[i][j] = matrix[j][i];                matrix[j][i] = temp;            &#125;        &#125;        for row in matrix.iter_mut() &#123;            row.reverse();        &#125;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.23 MB, 击败 16.67% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket"]},{"title":"女超人 第五季 第十三集 这是超级人生","url":"/zh-CN/e5eec8383292/","content":"\n剧情介绍　　Mxyzptlk 回来向卡拉提出一个建议——如果她可以回到过去，在莱克斯之前告诉莉娜她的秘密，事情会不会变得不同？回顾系列中的关键时刻，卡拉必须决定是否想要改变历史，以便重新和莉娜成为朋友。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第一季 第十三集 一针见血","url":"/zh-CN/bc2338835b71/","content":"\n剧情介绍　　一位新反派在哥谭展开行动，而“The Hold Up”酒吧以盛大的方式开业。索菲不情愿地请求蝙蝠女侠保持距离，因为她知道她们的接触可能会影响自己的职业生涯。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00049.字母异位词分组","url":"/zh-CN/9453a0ee5ccb/","content":"\n题目描述给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n示例 1：\n输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]\n\n示例 2：\n输入: strs &#x3D; [“”]输出: [[“”]]\n\n示例 3：\n输入: strs &#x3D; [“a”]输出: [[“a”]]\n\n提示：\n$1 &lt;&#x3D; strs.length &lt;&#x3D; 10^4$\n0 &lt;&#x3D; strs[i].length &lt;&#x3D; 100\nstrs[i] 仅包含小写字母\n\n\n解决方法C++class Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;        unordered_map&lt;string, vector&lt;string&gt;&gt; anagrams_dict;        for (const auto&amp; word : strs) &#123;            string sorted_word = word;            sort(sorted_word.begin(), sorted_word.end());            anagrams_dict[sorted_word].push_back(word);        &#125;        vector&lt;vector&lt;string&gt;&gt; result;        for (const auto&amp; entry : anagrams_dict) &#123;            result.push_back(entry.second);        &#125;        return result;    &#125;&#125;;\n\n结果执行用时 : 18 ms, 击败 98.21% 使用 C++ 的用户\n内存消耗 : 22.84 MB, 击败 18.42% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        Map&lt;String, List&lt;String&gt;&gt; anagramsMap = new HashMap&lt;&gt;();        for (String word : strs) &#123;            char[] charArray = word.toCharArray();            Arrays.sort(charArray);            String sortedWord = new String(charArray);            anagramsMap.computeIfAbsent(sortedWord, k -&gt; new ArrayList&lt;&gt;()).add(word);        &#125;        return new ArrayList&lt;&gt;(anagramsMap.values());    &#125;&#125;\n\n结果执行用时 : 6 ms, 击败 89.04% 使用 Java 的用户\n内存消耗 : 46.59 MB, 击败 24.25% 使用 Java 的用户\n\nPythonclass Solution(object):    def groupAnagrams(self, strs):        &quot;&quot;&quot;        :type strs: List[str]        :rtype: List[List[str]]        &quot;&quot;&quot;        anagrams_dict = defaultdict(list)        for word in strs:            sorted_word = &#x27;&#x27;.join(sorted(word))            anagrams_dict[sorted_word].append(word)        return list(anagrams_dict.values())\n\n结果执行用时 : 47 ms, 击败 46.09% 使用 Python 的用户\n内存消耗 : 15.33 MB, 击败 94.22% 使用 Python 的用户\n\nPython3class Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        anagrams_dict = defaultdict(list)        for word in strs:            sorted_word = &#x27;&#x27;.join(sorted(word))            anagrams_dict[sorted_word].append(word)        return list(anagrams_dict.values())\n\n结果执行用时 : 52 ms, 击败 % 使用 Python3 的用户\n内存消耗 : 19.39 MB, 击败 % 使用 Python3 的用户\n\nC/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */#define MAX_STRING_LENGTH 102typedef struct listnode &#123;    char key[MAX_STRING_LENGTH];    int index[100];    int count;    int resultIndex;    UT_hash_handle hh;&#125; Node;int compareChars(const void* a, const void* b) &#123;    return *(char*)a - *(char*)b;&#125;char*** groupAnagrams(char** strs, int strsSize, int* returnSize, int** returnColumnSizes) &#123;    if (strsSize == 0) &#123;        *returnSize = 0;        return NULL;    &#125;    Node* hashTable = NULL;    *returnSize = 0;    for (int i = 0; i &lt; strsSize; i++) &#123;        char* sortedStr = (char*)malloc(sizeof(char) * (strlen(strs[i]) + 1));        strcpy(sortedStr, strs[i]);        qsort(sortedStr, strlen(sortedStr), sizeof(char), compareChars);        Node* currentNode = NULL;        HASH_FIND_STR(hashTable, sortedStr, currentNode);        if (currentNode == NULL) &#123;            currentNode = (Node*)malloc(sizeof(Node));            strcpy(currentNode-&gt;key, sortedStr);            currentNode-&gt;count = 0;            currentNode-&gt;resultIndex = (*returnSize)++;            currentNode-&gt;index[(currentNode-&gt;count)++] = i;            HASH_ADD_STR(hashTable, key, currentNode);        &#125; else &#123;            currentNode-&gt;index[(currentNode-&gt;count)++] = i;        &#125;        free(sortedStr);    &#125;    char*** result = (char***)malloc(sizeof(char**) * (*returnSize));    *returnColumnSizes = (int*)malloc(sizeof(int) * (*returnSize));    Node *currentNode, *tempNode;    HASH_ITER(hh, hashTable, currentNode, tempNode) &#123;        result[currentNode-&gt;resultIndex] = (char**)malloc(sizeof(char*) * (currentNode-&gt;count));        for (int j = 0; j &lt; currentNode-&gt;count; j++) &#123;            result[currentNode-&gt;resultIndex][j] = strdup(strs[currentNode-&gt;index[j]]);        &#125;        (*returnColumnSizes)[currentNode-&gt;resultIndex] = currentNode-&gt;count;        HASH_DEL(hashTable, currentNode);        free(currentNode);    &#125;    return result;&#125;\n\n结果执行用时 : 59 ms, 击败 64.66% 使用 C 的用户\n内存消耗 : 26.71 MB, 击败 69.77% 使用 C 的用户\n\nC#public class Solution &#123;    public IList&lt;IList&lt;string&gt;&gt; GroupAnagrams(string[] strs) &#123;        Dictionary&lt;string, List&lt;string&gt;&gt; anagramGroups = new Dictionary&lt;string, List&lt;string&gt;&gt;();        foreach (var str in strs) &#123;            char[] charArray = str.ToCharArray();            Array.Sort(charArray);            string sortedStr = new string(charArray);            if (!anagramGroups.ContainsKey(sortedStr)) &#123;                anagramGroups[sortedStr] = new List&lt;string&gt;();            &#125;            anagramGroups[sortedStr].Add(str);        &#125;        return new List&lt;IList&lt;string&gt;&gt;(anagramGroups.Values);    &#125;&#125;\n\n结果执行用时 : 154 ms, 击败 82.85% 使用 C# 的用户\n内存消耗 : 72.99 MB, 击败 16.95% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string[]&#125; strs * @return &#123;string[][]&#125; */var groupAnagrams = function(strs) &#123;    const anagramGroups = &#123;&#125;;    for (const str of strs) &#123;        const sortedStr = str.split(&#x27;&#x27;).sort().join(&#x27;&#x27;);        if (!anagramGroups[sortedStr]) &#123;            anagramGroups[sortedStr] = [];        &#125;        anagramGroups[sortedStr].push(str);    &#125;    return Object.values(anagramGroups);&#125;;\n\n结果执行用时 : 112 ms, 击败 58.19% 使用 JavaScript 的用户\n内存消耗 : 63.09 MB, 击败 5.02% 使用 JavaScript 的用户\n\nTypeScriptfunction groupAnagrams(strs: string[]): string[][] &#123;    const anagramGroups: &#123; [key: string]: string[] &#125; = &#123;&#125;;    for (const str of strs) &#123;        const sortedStr = str.split(&#x27;&#x27;).sort().join(&#x27;&#x27;);        if (!anagramGroups[sortedStr]) &#123;            anagramGroups[sortedStr] = [];        &#125;        anagramGroups[sortedStr].push(str);    &#125;    return Object.values(anagramGroups);&#125;\n\n结果执行用时 : 108 ms, 击败 79.49% 使用 TypeScript 的用户\n内存消耗 : 63.50 MB, 击败 5.08% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;        /**     * @param String[] $strs     * @return String[][]     */    function groupAnagrams($strs) &#123;        $anagramGroups = [];        foreach ($strs as $str) &#123;            $sortedStr = $this-&gt;sortString($str);            if (!isset($anagramGroups[$sortedStr])) &#123;                $anagramGroups[$sortedStr] = [];            &#125;            $anagramGroups[$sortedStr][] = $str;        &#125;        return array_values($anagramGroups);    &#125;    private function sortString($str) &#123;        $charArray = str_split($str);        sort($charArray);        return implode(&#x27;&#x27;, $charArray);    &#125;&#125;\n\n结果执行用时 : 25 ms, 击败 84.62% 使用 PHP 的用户\n内存消耗 : 24.56 MB, 击败 68.27% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func groupAnagrams(_ strs: [String]) -&gt; [[String]] &#123;        var anagramGroups: [String: [String]] = [:]        for str in strs &#123;            let sortedStr = String(str.sorted())            if anagramGroups[sortedStr] == nil &#123;                anagramGroups[sortedStr] = []            &#125;            anagramGroups[sortedStr]?.append(str)        &#125;        return Array(anagramGroups.values)    &#125;&#125;\n\n结果执行用时 : 68 ms, 击败 96.37% 使用 Swift 的用户\n内存消耗 : 18.21 MB, 击败 11.92% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun groupAnagrams(strs: Array&lt;String&gt;): List&lt;List&lt;String&gt;&gt; &#123;        return strs.groupBy &#123; it.toCharArray().sorted().joinToString(&quot;&quot;) &#125;            .values            .toList()    &#125;&#125;\n\n结果执行用时 : 342 ms, 击败 50.00% 使用 Kotlin 的用户\n内存消耗 : 46.57 MB, 击败 15.45% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;List&lt;String&gt;&gt; groupAnagrams(List&lt;String&gt; strs) &#123;    Map&lt;String, List&lt;String&gt;&gt; anagramGroups = &#123;&#125;;    for (String str in strs) &#123;      String sortedStr = String.fromCharCodes(str.runes.toList()..sort());      if (anagramGroups.containsKey(sortedStr)) &#123;        anagramGroups[sortedStr]!.add(str);      &#125; else &#123;        anagramGroups[sortedStr] = [str];      &#125;    &#125;    return anagramGroups.values.toList();  &#125;&#125;\n\n结果执行用时 : 335 ms, 击败 82.61% 使用 Dart 的用户\n内存消耗 : 149.44 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc groupAnagrams(strs []string) [][]string &#123;    anagramGroups := make(map[string][]string)    for _, str := range strs &#123;        sortedStr := sortString(str)        if _, ok := anagramGroups[sortedStr]; ok &#123;            anagramGroups[sortedStr] = append(anagramGroups[sortedStr], str)        &#125; else &#123;            anagramGroups[sortedStr] = []string&#123;str&#125;        &#125;    &#125;    result := make([][]string, 0, len(anagramGroups))    for _, group := range anagramGroups &#123;        result = append(result, group)    &#125;    return result&#125;func sortString(s string) string &#123;    charArray := []rune(s)    sort.Slice(charArray, func(i, j int) bool &#123;        return charArray[i] &lt; charArray[j]    &#125;)    return string(charArray)&#125;\n\n结果执行用时 : 15 ms, 击败 90.09% 使用 Go 的用户\n内存消耗 : 7.60 MB, 击败 65.09% 使用 Go 的用户\n\nRuby# @param &#123;String[]&#125; strs# @return &#123;String[][]&#125;def group_anagrams(strs)  anagram_groups = &#123;&#125;  strs.each do |str|    sorted_str = str.chars.sort.join    if anagram_groups.key?(sorted_str)      anagram_groups[sorted_str] &lt;&lt; str    else      anagram_groups[sorted_str] = [str]    end  end  anagram_groups.valuesend\n\n结果执行用时 : 148 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 211.83 MB, 击败 62.50% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def groupAnagrams(strs: Array[String]): List[List[String]] = &#123;    val anagramGroups = strs.groupBy(str =&gt; str.sorted)    anagramGroups.values.map(_.toList).toList  &#125;&#125;\n\n结果执行用时 : 691 ms, 击败 47.06% 使用 Scala 的用户\n内存消耗 : 61.43 MB, 击败 17.65% 使用 Scala 的用户\n\nRustuse std::collections::HashMap;impl Solution &#123;    pub fn group_anagrams(strs: Vec&lt;String&gt;) -&gt; Vec&lt;Vec&lt;String&gt;&gt; &#123;        let mut anagram_groups: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();        for str in strs &#123;            let sorted_str = sort_string(&amp;str);            if let Some(group) = anagram_groups.get_mut(&amp;sorted_str) &#123;                group.push(str);            &#125; else &#123;                anagram_groups.insert(sorted_str, vec![str]);            &#125;        &#125;        anagram_groups.values().cloned().collect()    &#125;&#125;fn sort_string(s: &amp;str) -&gt; String &#123;    let mut char_array: Vec&lt;char&gt; = s.chars().collect();    char_array.sort();    char_array.into_iter().collect()&#125;\n\n结果执行用时 : 7 ms, 击败 91.25% 使用 Rust 的用户\n内存消耗 : 4.77 MB, 击败 60.42% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"黑闪电 第三季 第十四集 战争之书：第一章：回家","url":"/zh-CN/560189f829e1/","content":"\n剧情介绍　　随着战斗的继续，旧有的联盟被重新审视，新的联盟也开始结成。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00050.Pow(x, n)","url":"/zh-CN/a8d09a25dc5a/","content":"\n题目描述实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，$x^n$ ）。\n示例 1：\n输入：x &#x3D; 2.00000, n &#x3D; 10输出：1024.00000\n\n示例 2：\n输入：x &#x3D; 2.10000, n &#x3D; 3输出：9.26100\n\n示例 3：\n输入：x &#x3D; 2.00000, n &#x3D; -2输出：0.25000解释：$2^{-2} &#x3D; 1&#x2F;2^2 &#x3D; 1&#x2F;4 &#x3D; 0.25$\n\n提示：\n-100.0 &lt; x &lt; 100.0\n$-2^{31} &lt;&#x3D; n &lt;&#x3D; 2^{31}-1$\nn 是一个整数\n要么 x 不为零，要么 n &gt; 0 。\n$-10^4 &lt;&#x3D; xn &lt;&#x3D; 10^4$\n\n\n解决方法C++class Solution &#123;public:    double myPow(double x, int n) &#123;        long long N = n;        if (N == 0) &#123;            return 1;        &#125;        if (N &lt; 0) &#123;            x = 1 / x;            N = -N;        &#125;        return fastPow(x, N);    &#125;    double fastPow(double x, long long n) &#123;        if (n == 0) &#123;            return 1;        &#125;        double half_pow = fastPow(x, n / 2);        if (n % 2 == 0) &#123;            return half_pow * half_pow;        &#125; else &#123;            return x * half_pow * half_pow;        &#125;    &#125;&#125;;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C++ 的用户\n内存消耗 : 7.98 MB, 击败 5.16% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public double myPow(double x, int n) &#123;        long N = n;        if (N == 0) &#123;            return 1;        &#125;        if (N &lt; 0) &#123;            x = 1 / x;            N = -N;        &#125;        return fastPow(x, N);    &#125;    private double fastPow(double x, long n) &#123;        if (n == 0) &#123;            return 1;        &#125;        double halfPow = fastPow(x, n / 2);        if (n % 2 == 0) &#123;            return halfPow * halfPow;        &#125; else &#123;            return x * halfPow * halfPow;        &#125;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 41.63 MB, 击败 14.98% 使用 Java 的用户\n\nPythonclass Solution(object):    def myPow(self, x, n):        &quot;&quot;&quot;        :type x: float        :type n: int        :rtype: float        &quot;&quot;&quot;        def fastPow(x, n):            if n == 0:                return 1            half_pow = fastPow(x, n // 2)            if n % 2 == 0:                return half_pow * half_pow            else:                return x * half_pow * half_pow        if n &lt; 0:            x = 1 / x            n = -n        return fastPow(x, n)\n\n结果执行用时 : 11 ms, 击败 95.15% 使用 Python 的用户\n内存消耗 : 11.53 MB, 击败 83.10% 使用 Python 的用户\n\nPython3class Solution:    def myPow(self, x: float, n: int) -&gt; float:        def fastPow(x, n):            if n == 0:                return 1            half_pow = fastPow(x, n // 2)            if n % 2 == 0:                return half_pow * half_pow            else:                return x * half_pow * half_pow        if n &lt; 0:            x = 1 / x            n = -n        return fastPow(x, n)\n\n结果执行用时 : 37 ms, 击败 73.10% 使用 Python3 的用户\n内存消耗 : 16.41 MB, 击败 44.13% 使用 Python3 的用户\n\nCdouble fastPow(double x, long long n) &#123;    if (n == 0) &#123;        return 1;    &#125;    double half_pow = fastPow(x, n / 2);    if (n % 2 == 0) &#123;        return half_pow * half_pow;    &#125; else &#123;        return x * half_pow * half_pow;    &#125;&#125;double myPow(double x, int n) &#123;    long long N = n;    if (N &lt; 0) &#123;        x = 1 / x;        N = -N;    &#125;    return fastPow(x, N);&#125;\n\n结果执行用时 : 2 ms, 击败 43.98% 使用 C 的用户\n内存消耗 : 5.24 MB, 击败 97.88% 使用 C 的用户\n\nC#public class Solution &#123;    public double MyPow(double x, int n) &#123;        long N = n;        if (N == 0) &#123;            return 1;        &#125;        if (N &lt; 0) &#123;            x = 1 / x;            N = -N;        &#125;        return FastPow(x, N);    &#125;    private double FastPow(double x, long n) &#123;        if (n == 0) &#123;            return 1;        &#125;        double halfPow = FastPow(x, n / 2);        if (n % 2 == 0) &#123;            return halfPow * halfPow;        &#125; else &#123;            return x * halfPow * halfPow;        &#125;    &#125;&#125;\n\n结果执行用时 : 32 ms, 击败 31.82% 使用 C# 的用户\n内存消耗 : 27.09 MB, 击败 10.60% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number&#125; x * @param &#123;number&#125; n * @return &#123;number&#125; */var myPow = function(x, n) &#123;    const fastPow = (x, n) =&gt; &#123;        if (n === 0) &#123;            return 1;        &#125;        const halfPow = fastPow(x, Math.floor(n / 2));        if (n % 2 === 0) &#123;            return halfPow * halfPow;        &#125; else &#123;            return x * halfPow * halfPow;        &#125;    &#125;;    if (n &lt; 0) &#123;        x = 1 / x;        n = -n;    &#125;    return fastPow(x, n);&#125;;\n\n结果执行用时 : 53 ms, 击败 88.04% 使用 JavaScript 的用户\n内存消耗 : 49.24 MB, 击败 5.17% 使用 JavaScript 的用户\n\nTypeScriptfunction myPow(x: number, n: number): number &#123;    const fastPow = (x: number, n: number): number =&gt; &#123;        if (n === 0) &#123;            return 1;        &#125;        const halfPow = fastPow(x, Math.floor(n / 2));        if (n % 2 === 0) &#123;            return halfPow * halfPow;        &#125; else &#123;            return x * halfPow * halfPow;        &#125;    &#125;;    if (n &lt; 0) &#123;        x = 1 / x;        n = -n;    &#125;    return fastPow(x, n);&#125;\n\n结果执行用时 : 71 ms, 击败 34.78% 使用 TypeScript 的用户\n内存消耗 : 51.68 MB, 击败 6.52% 使用 TypeScript 的用户\n\nPHP暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 PHP 的用户\n内存消耗 :  MB, 击败 % 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func myPow(_ x: Double, _ n: Int) -&gt; Double &#123;        if x == 0 || x == 1 &#123;            return x        &#125;        var x = x        var n = n        if n &lt; 0 &#123;            x = 1 / x            n = -n        &#125;        let result = fastPow(x, n)        return result    &#125;    private func fastPow(_ x: Double, _ n: Int) -&gt; Double &#123;        if n == 0 &#123;            return 1        &#125;        let halfPow = fastPow(x, n / 2)        return n % 2 == 0 ? halfPow * halfPow : halfPow * halfPow * x    &#125;&#125;\n\n结果执行用时 : 3 ms, 击败 69.23% 使用 Swift 的用户\n内存消耗 : 15.92 MB, 击败 5.77% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun myPow(x: Double, n: Int): Double &#123;        if (x == 0.0 || x == 1.0) &#123;            return x        &#125;        val result = if (n &lt; 0) &#123;            1 / fastPow(x, -n)        &#125; else &#123;            fastPow(x, n)        &#125;        return result    &#125;    private fun fastPow(x: Double, n: Int): Double &#123;        if (n == 0) &#123;            return 1.0        &#125;        val halfPow = fastPow(x, n / 2)        return if (n % 2 == 0) &#123;            halfPow * halfPow        &#125; else &#123;            halfPow * halfPow * x        &#125;    &#125;&#125;\n\n结果执行用时 : 171 ms, 击败 36.84% 使用 Kotlin 的用户\n内存消耗 : 35.70 MB, 击败 5.26% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  double myPow(double x, int n) &#123;    if (x == 0.0 || x == 1.0) &#123;      return x;    &#125;    if (n &lt; 0) &#123;      x = 1 / x;      n = -n;    &#125;    return fastPow(x, n);  &#125;  double fastPow(double x, int n) &#123;    if (n == 0) &#123;      return 1.0;    &#125;    double halfPow = fastPow(x, n ~/ 2);    return (n % 2 == 0) ? halfPow * halfPow : halfPow * halfPow * x;  &#125;&#125;\n\n结果执行用时 : 283 ms, 击败 40.00% 使用 Dart 的用户\n内存消耗 : 147.48 MB, 击败 60.00% 使用 Dart 的用户\n\nGofunc myPow(x float64, n int) float64 &#123;\tif x == 0.0 || x == 1.0 &#123;\t\treturn x\t&#125;\tif n &lt; 0 &#123;\t\tx = 1 / x\t\tn = -n\t&#125;\treturn fastPow(x, n)&#125;func fastPow(x float64, n int) float64 &#123;\tif n == 0 &#123;\t\treturn 1.0\t&#125;\thalfPow := fastPow(x, n/2)\tif n%2 == 0 &#123;\t\treturn halfPow * halfPow\t&#125; else &#123;\t\treturn halfPow * halfPow * x\t&#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 1.92 MB, 击败 80.42% 使用 Go 的用户\n\nRuby# @param &#123;Float&#125; x# @param &#123;Integer&#125; n# @return &#123;Float&#125;def my_pow(x, n)  return x if x == 0.0 || x == 1.0  if n &lt; 0    x = 1 / x    n = -n  end  fast_pow(x, n)enddef fast_pow(x, n)  return 1.0 if n == 0  half_pow = fast_pow(x, n / 2)  if n % 2 == 0    half_pow * half_pow  else    half_pow * half_pow * x  endend\n\n结果执行用时 : 69 ms, 击败 50.00% 使用 Ruby 的用户\n内存消耗 : 206.46 MB, 击败 -% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def myPow(x: Double, n: Int): Double = &#123;    if (x == 0.0 || x == 1.0) &#123;      return x    &#125;    val result = if (n &lt; 0) &#123;      1 / fastPow(x, -n)    &#125; else &#123;      fastPow(x, n)    &#125;    result  &#125;  private def fastPow(x: Double, n: Int): Double = &#123;    if (n == 0) &#123;      return 1.0    &#125;    val halfPow = fastPow(x, n / 2)    if (n % 2 == 0) &#123;      halfPow * halfPow    &#125; else &#123;      halfPow * halfPow * x    &#125;  &#125;&#125;\n\n结果执行用时 : 472 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 52.38 MB, 击败 -% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn my_pow(x: f64, n: i32) -&gt; f64 &#123;        if x == 0.0 || x == 1.0 &#123;            return x;        &#125;        let result = if n &lt; 0 &#123;            1.0 / Solution::fast_pow(x, -n)        &#125; else &#123;            Solution::fast_pow(x, n)        &#125;;        result    &#125;    fn fast_pow(x: f64, n: i32) -&gt; f64 &#123;        if n == 0 &#123;            return 1.0;        &#125;        let half_pow = Solution::fast_pow(x, n / 2);        if n % 2 == 0 &#123;            half_pow * half_pow        &#125; else &#123;            half_pow * half_pow * x        &#125;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.00 MB, 击败 78.18% 使用 Rust 的用户\n\nRacket(define/contract (my-pow x n)  (-&gt; flonum? exact-integer? flonum?)  (if (or (= x 0.0) (= x 1.0))      x      (if (&lt; n 0)          (/ 1.0 (fast-pow-iter x (- n) 1.0))          (fast-pow-iter x n 1.0))))(define (fast-pow-iter x n result)  (if (= n 0)      result      (if (even? n)          (fast-pow-iter (* x x) (/ n 2) result)          (fast-pow-iter x (- n 1) (* result x)))))\n\n结果执行用时 : 169 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 97.57 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"女超人 第六季 第十三集 勇往直前","url":"/zh-CN/f22a5f52f550/","content":"\n剧情介绍　　巴里对危机以来的所有变化感到不知所措，他进行了一项出错的实验，并将他直接置于大猩猩格罗德的道路上。巴里预料到了最坏的情况，当格罗德寻求他的帮助时，他感到惊讶。不幸的是，对于闪电侠和格罗德来说，当另一个反派出现时，情况变得更糟——索洛瓦。与此同时，艾瑞斯与伊娃一起逃离了镜像宇宙。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00051.N 皇后","url":"/zh-CN/55654bc13130/","content":"\n题目描述按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\n每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。\n示例 1：\n\n\n输入：n &#x3D; 4输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]解释：如上图所示，4 皇后问题存在两个不同的解法。\n\n示例 2：\n输入：n &#x3D; 1输出：[[“Q”]]\n\n提示：\n1 &lt;&#x3D; n &lt;&#x3D; 9\n\n\n解决方法C++class Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        vector&lt;vector&lt;string&gt;&gt; result;        vector&lt;string&gt; current_board(n, string(n, &#x27;.&#x27;));        solveNQueensRecursive(result, current_board, 0, n);                return result;    &#125;private:    void solveNQueensRecursive(vector&lt;vector&lt;string&gt;&gt;&amp; result,                                vector&lt;string&gt;&amp; current_board,                                int row, int n) &#123;        if (row == n) &#123;            result.push_back(current_board);            return;        &#125;        for (int col = 0; col &lt; n; ++col) &#123;            if (isNotUnderAttack(current_board, row, col, n)) &#123;                current_board[row][col] = &#x27;Q&#x27;;                solveNQueensRecursive(result, current_board, row + 1, n);                current_board[row][col] = &#x27;.&#x27;;            &#125;        &#125;    &#125;    bool isNotUnderAttack(const vector&lt;string&gt;&amp; current_board, int row, int col, int n) &#123;        for (int i = 0; i &lt; row; ++i) &#123;            if (current_board[i][col] == &#x27;Q&#x27;) &#123;                return false;            &#125;            if (col - (row - i) &gt;= 0 &amp;&amp; current_board[i][col - (row - i)] == &#x27;Q&#x27;) &#123;                return false;            &#125;            if (col + (row - i) &lt; n &amp;&amp; current_board[i][col + (row - i)] == &#x27;Q&#x27;) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n\n结果执行用时 : 7 ms, 击败 55.24% 使用 C++ 的用户\n内存消耗 : 9.03 MB, 击败 49.91% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;        List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();        char[][] board = new char[n][n];        for (int i = 0; i &lt; n; i++) &#123;            for (int j = 0; j &lt; n; j++) &#123;                board[i][j] = &#x27;.&#x27;;            &#125;        &#125;        solveNQueensRecursive(result, board, 0, n);        return result;    &#125;    private void solveNQueensRecursive(List&lt;List&lt;String&gt;&gt; result, char[][] board, int row, int n) &#123;        if (row == n) &#123;            result.add(generateBoard(board));            return;        &#125;        for (int col = 0; col &lt; n; col++) &#123;            if (isNotUnderAttack(board, row, col, n)) &#123;                board[row][col] = &#x27;Q&#x27;;                solveNQueensRecursive(result, board, row + 1, n);                board[row][col] = &#x27;.&#x27;;            &#125;        &#125;    &#125;    private boolean isNotUnderAttack(char[][] board, int row, int col, int n) &#123;        for (int i = 0; i &lt; row; i++) &#123;            if (board[i][col] == &#x27;Q&#x27;) &#123;                return false;            &#125;            if (col - (row - i) &gt;= 0 &amp;&amp; board[i][col - (row - i)] == &#x27;Q&#x27;) &#123;                return false;            &#125;            if (col + (row - i) &lt; n &amp;&amp; board[i][col + (row - i)] == &#x27;Q&#x27;) &#123;                return false;            &#125;        &#125;        return true;    &#125;    private List&lt;String&gt; generateBoard(char[][] board) &#123;        List&lt;String&gt; result = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; board.length; i++) &#123;            result.add(new String(board[i]));        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 2 ms, 击败 89.58% 使用 Java 的用户\n内存消耗 : 43.92 MB, 击败 16.22% 使用 Java 的用户\n\nPythonclass Solution(object):    def solveNQueens(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: List[List[str]]        &quot;&quot;&quot;        def is_not_under_attack(row, col, queens):            for prev_row, prev_col in queens:                if prev_col == col or \\                   prev_row - prev_col == row - col or \\                   prev_row + prev_col == row + col:                    return False            return True        def place_queen(row, queens, result):            if row == n:                result.append(queens[:])                return            for col in range(n):                if is_not_under_attack(row, col, queens):                    queens.append((row, col))                    place_queen(row + 1, queens, result)                    queens.pop()        result = []        place_queen(0, [], result)        def format_solution(queens):            solution = []            for row, col in queens:                row_str = &#x27;.&#x27; * col + &#x27;Q&#x27; + &#x27;.&#x27; * (n - col - 1)                solution.append(row_str)            return solution        return [format_solution(queens) for queens in result]\n\n结果执行用时 : 53 ms, 击败 65.08% 使用 Python 的用户\n内存消耗 : 11.82 MB, 击败 78.96% 使用 Python 的用户\n\nPython3class Solution:    def solveNQueens(self, n: int) -&gt; List[List[str]]:        def is_not_under_attack(row, col, queens):            for prev_row, prev_col in queens:                if prev_col == col or \\                   prev_row - prev_col == row - col or \\                   prev_row + prev_col == row + col:                    return False            return True        def place_queen(row, queens, result):            if row == n:                result.append(queens[:])                return            for col in range(n):                if is_not_under_attack(row, col, queens):                    queens.append((row, col))                    place_queen(row + 1, queens, result)                    queens.pop()        result = []        place_queen(0, [], result)        def format_solution(queens):            solution = []            for row, col in queens:                row_str = &#x27;.&#x27; * col + &#x27;Q&#x27; + &#x27;.&#x27; * (n - col - 1)                solution.append(row_str)            return solution        return [format_solution(queens) for queens in result]\n\n结果执行用时 : 53 ms, 击败 73.96% 使用 Python3 的用户\n内存消耗 : 16.84 MB, 击败 46.26% 使用 Python3 的用户\n\nC/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */char*** solveNQueens(int n, int* returnSize, int** returnColumnSizes) &#123;    char*** result = (char***)malloc(sizeof(char**) * 1000);    *returnColumnSizes = (int*)malloc(sizeof(int) * 1000);    *returnSize = 0;    char** board = (char**)malloc(sizeof(char*) * n);    for (int i = 0; i &lt; n; ++i) &#123;        board[i] = (char*)malloc(sizeof(char) * (n + 1));        for (int j = 0; j &lt; n; ++j) &#123;            board[i][j] = &#x27;.&#x27;;        &#125;        board[i][n] = &#x27;\\0&#x27;;    &#125;    solveNQueensRecursive(result, board, 0, n, returnSize, returnColumnSizes);    return result;&#125;void solveNQueensRecursive(char*** result, char** board, int row, int n, int* returnSize, int** returnColumnSizes) &#123;    if (row == n) &#123;        result[*returnSize] = (char**)malloc(sizeof(char*) * n);        for (int i = 0; i &lt; n; ++i) &#123;            result[*returnSize][i] = (char*)malloc(sizeof(char) * (n + 1));            strcpy(result[*returnSize][i], board[i]);        &#125;        (*returnColumnSizes)[*returnSize] = n;        (*returnSize)++;        return;    &#125;    for (int col = 0; col &lt; n; ++col) &#123;        if (isNotUnderAttack(board, row, col, n)) &#123;            board[row][col] = &#x27;Q&#x27;;            solveNQueensRecursive(result, board, row + 1, n, returnSize, returnColumnSizes);            board[row][col] = &#x27;.&#x27;;        &#125;    &#125;&#125;int isNotUnderAttack(char** board, int row, int col, int n) &#123;    for (int i = 0; i &lt; row; ++i) &#123;        if (board[i][col] == &#x27;Q&#x27;) &#123;            return 0;        &#125;        if (col - (row - i) &gt;= 0 &amp;&amp; board[i][col - (row - i)] == &#x27;Q&#x27;) &#123;            return 0;        &#125;        if (col + (row - i) &lt; n &amp;&amp; board[i][col + (row - i)] == &#x27;Q&#x27;) &#123;            return 0;        &#125;    &#125;    return 1;&#125;\n\n结果执行用时 : 9 ms, 击败 21.48% 使用 C 的用户\n内存消耗 : 6.90 MB, 击败 89.77% 使用 C 的用户\n\nC#public class Solution &#123;    public IList&lt;IList&lt;string&gt;&gt; SolveNQueens(int n) &#123;        IList&lt;IList&lt;string&gt;&gt; result = new List&lt;IList&lt;string&gt;&gt;();        char[,] board = new char[n, n];        for (int i = 0; i &lt; n; i++) &#123;            for (int j = 0; j &lt; n; j++) &#123;                board[i, j] = &#x27;.&#x27;;            &#125;        &#125;        SolveNQueensRecursive(result, board, 0, n);        return result;    &#125;    private void SolveNQueensRecursive(IList&lt;IList&lt;string&gt;&gt; result, char[,] board, int row, int n) &#123;        if (row == n) &#123;            result.Add(GenerateBoard(board));            return;        &#125;        for (int col = 0; col &lt; n; col++) &#123;            if (IsNotUnderAttack(board, row, col, n)) &#123;                board[row, col] = &#x27;Q&#x27;;                SolveNQueensRecursive(result, board, row + 1, n);                board[row, col] = &#x27;.&#x27;;            &#125;        &#125;    &#125;    private bool IsNotUnderAttack(char[,] board, int row, int col, int n) &#123;        for (int i = 0; i &lt; row; i++) &#123;            if (board[i, col] == &#x27;Q&#x27;) &#123;                return false;            &#125;            if (col - (row - i) &gt;= 0 &amp;&amp; board[i, col - (row - i)] == &#x27;Q&#x27;) &#123;                return false;            &#125;            if (col + (row - i) &lt; n &amp;&amp; board[i, col + (row - i)] == &#x27;Q&#x27;) &#123;                return false;            &#125;        &#125;        return true;    &#125;    private IList&lt;string&gt; GenerateBoard(char[,] board) &#123;        IList&lt;string&gt; solution = new List&lt;string&gt;();        for (int i = 0; i &lt; board.GetLength(0); i++) &#123;            StringBuilder rowStr = new StringBuilder();            for (int j = 0; j &lt; board.GetLength(1); j++) &#123;                rowStr.Append(board[i, j]);            &#125;            solution.Add(rowStr.ToString());        &#125;        return solution;    &#125;&#125;\n\n结果执行用时 : 115 ms, 击败 54.84% 使用 C# 的用户\n内存消耗 : 52.49 MB, 击败 25.80% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number&#125; n * @return &#123;string[][]&#125; */var solveNQueens = function(n) &#123;    let result = [];    let board = Array.from(&#123; length: n &#125;, () =&gt; Array(n).fill(&#x27;.&#x27;));    const solveNQueensRecursive = (row) =&gt; &#123;        if (row === n) &#123;            result.push(board.map(row =&gt; row.join(&#x27;&#x27;)));            return;        &#125;        for (let col = 0; col &lt; n; col++) &#123;            if (isNotUnderAttack(row, col)) &#123;                board[row][col] = &#x27;Q&#x27;;                solveNQueensRecursive(row + 1);                board[row][col] = &#x27;.&#x27;;            &#125;        &#125;    &#125;;    const isNotUnderAttack = (row, col) =&gt; &#123;        for (let i = 0; i &lt; row; i++) &#123;            if (board[i][col] === &#x27;Q&#x27; ||                (col - (row - i) &gt;= 0 &amp;&amp; board[i][col - (row - i)] === &#x27;Q&#x27;) ||                (col + (row - i) &lt; n &amp;&amp; board[i][col + (row - i)] === &#x27;Q&#x27;)) &#123;                return false;            &#125;        &#125;        return true;    &#125;;    solveNQueensRecursive(0);    return result;&#125;;\n\n结果执行用时 : 68 ms, 击败 89.66% 使用 JavaScript 的用户\n内存消耗 : 53.46 MB, 击败 13.59% 使用 JavaScript 的用户\n\nTypeScriptfunction solveNQueens(n: number): string[][] &#123;    const result: string[][] = [];    const board: string[][] = Array.from(&#123; length: n &#125;, () =&gt; Array(n).fill(&#x27;.&#x27;));    const solveNQueensRecursive = (row: number): void =&gt; &#123;        if (row === n) &#123;            result.push(board.map(row =&gt; row.join(&#x27;&#x27;)));            return;        &#125;        for (let col = 0; col &lt; n; col++) &#123;            if (isNotUnderAttack(row, col)) &#123;                board[row][col] = &#x27;Q&#x27;;                solveNQueensRecursive(row + 1);                board[row][col] = &#x27;.&#x27;;            &#125;        &#125;    &#125;;    const isNotUnderAttack = (row: number, col: number): boolean =&gt; &#123;        for (let i = 0; i &lt; row; i++) &#123;            if (board[i][col] === &#x27;Q&#x27; ||                (col - (row - i) &gt;= 0 &amp;&amp; board[i][col - (row - i)] === &#x27;Q&#x27;) ||                (col + (row - i) &lt; n &amp;&amp; board[i][col + (row - i)] === &#x27;Q&#x27;)) &#123;                return false;            &#125;        &#125;        return true;    &#125;;    solveNQueensRecursive(0);    return result;&#125;\n\n结果执行用时 : 82 ms, 击败 46.56% 使用 TypeScript 的用户\n内存消耗 : 53.47 MB, 击败 35.87% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer $n     * @return String[][]     */    function solveNQueens($n) &#123;        $result = [];        $board = array_fill(0, $n, array_fill(0, $n, &#x27;.&#x27;));        $solveNQueensRecursive = function ($row) use (&amp;$result, &amp;$board, $n, &amp;$solveNQueensRecursive) &#123;            if ($row == $n) &#123;                $result[] = array_map(&#x27;implode&#x27;, $board);                return;            &#125;            for ($col = 0; $col &lt; $n; $col++) &#123;                if ($this-&gt;isNotUnderAttack($row, $col, $board, $n)) &#123;                    $board[$row][$col] = &#x27;Q&#x27;;                    $solveNQueensRecursive($row + 1);                    $board[$row][$col] = &#x27;.&#x27;;                &#125;            &#125;        &#125;;        $solveNQueensRecursive(0);        return $result;    &#125;    private function isNotUnderAttack($row, $col, $board, $n) &#123;        for ($i = 0; $i &lt; $row; $i++) &#123;            if ($board[$i][$col] === &#x27;Q&#x27; ||                ($col - ($row - $i) &gt;= 0 &amp;&amp; $board[$i][$col - ($row - $i)] === &#x27;Q&#x27;) ||                ($col + ($row - $i) &lt; $n &amp;&amp; $board[$i][$col + ($row - $i)] === &#x27;Q&#x27;)) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n结果执行用时 : 32 ms, 击败 40.00% 使用 PHP 的用户\n内存消耗 : 20.85 MB, 击败 -% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func solveNQueens(_ n: Int) -&gt; [[String]] &#123;        var result = [[String]]()        var board = Array(repeating: Array(repeating: &quot;.&quot;, count: n), count: n)        func solveNQueensRecursive(_ row: Int) &#123;            if row == n &#123;                result.append(board.map &#123; $0.joined() &#125;)                return            &#125;            for col in 0..&lt;n &#123;                if isNotUnderAttack(row, col) &#123;                    board[row][col] = &quot;Q&quot;                    solveNQueensRecursive(row + 1)                    board[row][col] = &quot;.&quot;                &#125;            &#125;        &#125;        func isNotUnderAttack(_ row: Int, _ col: Int) -&gt; Bool &#123;            for i in 0..&lt;row &#123;                if board[i][col] == &quot;Q&quot; ||                   (col - (row - i) &gt;= 0 &amp;&amp; board[i][col - (row - i)] == &quot;Q&quot;) ||                   (col + (row - i) &lt; n &amp;&amp; board[i][col + (row - i)] == &quot;Q&quot;) &#123;                    return false                &#125;            &#125;            return true        &#125;        solveNQueensRecursive(0)        return result    &#125;&#125;\n\n结果执行用时 : 7 ms, 击败 100.00% 使用 Swift 的用户\n内存消耗 : 16.07 MB, 击败 6.98% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun solveNQueens(n: Int): List&lt;List&lt;String&gt;&gt; &#123;        val result = mutableListOf&lt;List&lt;String&gt;&gt;()        val board = Array(n) &#123; CharArray(n) &#123; &#x27;.&#x27; &#125; &#125;        fun isNotUnderAttack(row: Int, col: Int): Boolean &#123;            for (i in 0 until row) &#123;                if (board[i][col] == &#x27;Q&#x27; ||                    (col - (row - i) &gt;= 0 &amp;&amp; board[i][col - (row - i)] == &#x27;Q&#x27;) ||                    (col + (row - i) &lt; n &amp;&amp; board[i][col + (row - i)] == &#x27;Q&#x27;)) &#123;                    return false                &#125;            &#125;            return true        &#125;        fun solveNQueensRecursive(row: Int) &#123;            if (row == n) &#123;                result.add(board.map &#123; it.joinToString(&quot;&quot;) &#125;)                return            &#125;            for (col in 0 until n) &#123;                if (isNotUnderAttack(row, col)) &#123;                    board[row][col] = &#x27;Q&#x27;                    solveNQueensRecursive(row + 1)                    board[row][col] = &#x27;.&#x27;                &#125;            &#125;        &#125;        solveNQueensRecursive(0)        return result    &#125;&#125;\n\n结果执行用时 : 211 ms, 击败 46.15% 使用 Kotlin 的用户\n内存消耗 : 39.71 MB, 击败 30.77% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;    List&lt;List&lt;String&gt;&gt; result = [];    List&lt;List&lt;String&gt;&gt; board = List.generate(      n,      (row) =&gt; List.generate(n, (col) =&gt; &#x27;.&#x27;),    );    bool isNotUnderAttack(int row, int col) &#123;      for (int i = 0; i &lt; row; i++) &#123;        if (board[i][col] == &#x27;Q&#x27; ||            (col - (row - i) &gt;= 0 &amp;&amp; board[i][col - (row - i)] == &#x27;Q&#x27;) ||            (col + (row - i) &lt; n &amp;&amp; board[i][col + (row - i)] == &#x27;Q&#x27;)) &#123;          return false;        &#125;      &#125;      return true;    &#125;    void solveNQueensRecursive(int row) &#123;      if (row == n) &#123;        result.add(List.generate(n, (i) =&gt; board[i].join()));        return;      &#125;      for (int col = 0; col &lt; n; col++) &#123;        if (isNotUnderAttack(row, col)) &#123;          board[row][col] = &#x27;Q&#x27;;          solveNQueensRecursive(row + 1);          board[row][col] = &#x27;.&#x27;;        &#125;      &#125;    &#125;    solveNQueensRecursive(0);    return result;  &#125;&#125;\n\n结果执行用时 : 276 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 143.24 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc solveNQueens(n int) [][]string &#123;\tvar result [][]string\tboard := make([][]rune, n)\tfor i := 0; i &lt; n; i++ &#123;\t\tboard[i] = make([]rune, n)\t\tfor j := 0; j &lt; n; j++ &#123;\t\t\tboard[i][j] = &#x27;.&#x27;\t\t&#125;\t&#125;\tvar solveNQueensRecursive func(row int)\tsolveNQueensRecursive = func(row int) &#123;\t\tif row == n &#123;\t\t\tcopyBoard := make([][]rune, n)\t\t\tfor i := 0; i &lt; n; i++ &#123;\t\t\t\tcopyBoard[i] = make([]rune, n)\t\t\t\tcopy(copyBoard[i], board[i])\t\t\t&#125;\t\t\tresult = append(result, generateBoard(copyBoard))\t\t\treturn\t\t&#125;\t\tfor col := 0; col &lt; n; col++ &#123;\t\t\tif isNotUnderAttack(row, col, board, n) &#123;\t\t\t\tboard[row][col] = &#x27;Q&#x27;\t\t\t\tsolveNQueensRecursive(row + 1)\t\t\t\tboard[row][col] = &#x27;.&#x27;\t\t\t&#125;\t\t&#125;\t&#125;\tsolveNQueensRecursive(0)\treturn result&#125;func isNotUnderAttack(row, col int, board [][]rune, n int) bool &#123;\tfor i := 0; i &lt; row; i++ &#123;\t\tif board[i][col] == &#x27;Q&#x27; ||\t\t\t(col-(row-i) &gt;= 0 &amp;&amp; board[i][col-(row-i)] == &#x27;Q&#x27;) ||\t\t\t(col+(row-i) &lt; n &amp;&amp; board[i][col+(row-i)] == &#x27;Q&#x27;) &#123;\t\t\treturn false\t\t&#125;\t&#125;\treturn true&#125;func generateBoard(board [][]rune) []string &#123;\tvar solution []string\tfor i := 0; i &lt; len(board); i++ &#123;\t\tsolution = append(solution, string(board[i]))\t&#125;\treturn solution&#125;\n\n结果执行用时 : 4 ms, 击败 74.53% 使用 Go 的用户\n内存消耗 : 3.46 MB, 击败 13.50% 使用 Go 的用户\n\nRubydef solve_n_queens(n)  result = []  board = Array.new(n) &#123; Array.new(n, &#x27;.&#x27;) &#125;  solve_n_queens_recursive = lambda do |row|    if row == n      result &lt;&lt; board.map &#123; |row| row.join(&#x27;&#x27;) &#125;      return    end    is_not_under_attack = lambda do |row, col, board, n|      (0...row).each do |i|        return false if board[i][col] == &#x27;Q&#x27; ||                        (col - (row - i) &gt;= 0 &amp;&amp; board[i][col - (row - i)] == &#x27;Q&#x27;) ||                        (col + (row - i) &lt; n &amp;&amp; board[i][col + (row - i)] == &#x27;Q&#x27;)      end      true    end    (0...n).each do |col|      if is_not_under_attack.call(row, col, board, n)        board[row][col] = &#x27;Q&#x27;        solve_n_queens_recursive.call(row + 1)        board[row][col] = &#x27;.&#x27;      end    end  end  solve_n_queens_recursive.call(0)  resultend\n\n结果执行用时 : 160 ms, 击败 -% 使用 Ruby 的用户\n内存消耗 : 207.64 MB, 击败 50.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def solveNQueens(n: Int): List[List[String]] = &#123;    var result = List[List[String]]()    var board = Array.fill(n, n)(&#x27;.&#x27;)    def solveNQueensRecursive(row: Int): Unit = &#123;      if (row == n) &#123;        result = result :+ board.map(_.mkString(&quot;&quot;)).toList        return      &#125;      def isNotUnderAttack(row: Int, col: Int): Boolean = &#123;        for (i &lt;- 0 until row) &#123;          if (board(i)(col) == &#x27;Q&#x27; ||              (col - (row - i) &gt;= 0 &amp;&amp; board(i)(col - (row - i)) == &#x27;Q&#x27;) ||              (col + (row - i) &lt; n &amp;&amp; board(i)(col + (row - i)) == &#x27;Q&#x27;)) &#123;            return false          &#125;        &#125;        true      &#125;      for (col &lt;- 0 until n) &#123;        if (isNotUnderAttack(row, col)) &#123;          board(row)(col) = &#x27;Q&#x27;          solveNQueensRecursive(row + 1)          board(row)(col) = &#x27;.&#x27;        &#125;      &#125;    &#125;    solveNQueensRecursive(0)    result  &#125;&#125;\n\n结果执行用时 : 557 ms, 击败 88.89% 使用 Scala 的用户\n内存消耗 : 62.87 MB, 击败 11.11% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn solve_n_queens(n: i32) -&gt; Vec&lt;Vec&lt;String&gt;&gt; &#123;        let mut result = Vec::new();        let mut board = vec![vec![&#x27;.&#x27;; n as usize]; n as usize];        fn solve_n_queens_recursive(row: usize, n: usize, board: &amp;mut Vec&lt;Vec&lt;char&gt;&gt;, result: &amp;mut Vec&lt;Vec&lt;String&gt;&gt;) &#123;            if row == n &#123;                result.push(board.iter().map(|row| row.iter().collect()).collect());                return;            &#125;            fn is_not_under_attack(row: usize, col: usize, board: &amp;Vec&lt;Vec&lt;char&gt;&gt;, n: usize) -&gt; bool &#123;                for i in 0..row &#123;                    if board[i][col] == &#x27;Q&#x27;                        || (col as isize - (row as isize - i as isize)) &gt;= 0                            &amp;&amp; board[i][col - (row - i)] == &#x27;Q&#x27;                        || (col + (row - i)) &lt; n                            &amp;&amp; board[i][col + (row - i)] == &#x27;Q&#x27;                    &#123;                        return false;                    &#125;                &#125;                true            &#125;            for col in 0..n &#123;                if is_not_under_attack(row, col, &amp;board, n) &#123;                    board[row][col] = &#x27;Q&#x27;;                    solve_n_queens_recursive(row + 1, n, board, result);                    board[row][col] = &#x27;.&#x27;;                &#125;            &#125;        &#125;        solve_n_queens_recursive(0, n as usize, &amp;mut board, &amp;mut result);        result    &#125;&#125;\n\n结果执行用时 : 3 ms, 击败 47.62% 使用 Rust 的用户\n内存消耗 : 2.19 MB, 击败 92.86% 使用 Rust 的用户\n\nRacket(define/contract (solve-n-queens n)  (-&gt; exact-integer? (listof (listof string?)))  (define (is-safe? row col queens)    (define (under-attack? r1 c1 r2 c2)      (or (= r1 r2)          (= c1 c2)          (= (abs (- r1 r2)) (abs (- c1 c2)))))    (define (safe-in-current-row? r c)      (not (ormap (lambda (queen) (under-attack? r c (car queen) (cdr queen))) queens)))    (safe-in-current-row? row col))  (define (generate-result queens)    (map (lambda (queen)           (list-&gt;string            (for/list ([i (in-range n)])              (if (= i (cdr queen)) #\\Q #\\.))))         queens))  (define (solve-n-queens-recursive row queens)    (cond      ((= row n) (list (generate-result queens)))      (else       (append-map (lambda (col)                     (if (is-safe? row col queens)                         (solve-n-queens-recursive (add1 row) (cons (cons row col) queens))                         &#x27;()))                   (range n)))))  (solve-n-queens-recursive 0 &#x27;()))\n\n结果执行用时 : 192 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 92.87 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixirdefmodule Solution do  @spec solve_n_queens(n :: integer) :: [[String.t]]  def solve_n_queens(n) do    solve_n_queens_recursive(n, 0, [])  end  defp solve_n_queens_recursive(_n, n, queens) when n == _n do    [generate_result(queens)]  end  defp solve_n_queens_recursive(n, row, queens) do    Enum.flat_map(0..(n-1), fn col -&gt;      if is_safe?(row, col, queens) do        solve_n_queens_recursive(n, row + 1, [&#123;row, col&#125; | queens])      else        []      end    end)  end  defp generate_result(queens) do    Enum.map(queens, fn &#123;r, c&#125; -&gt;      String.duplicate(&quot;.&quot;, c) &lt;&gt; &quot;Q&quot; &lt;&gt; String.duplicate(&quot;.&quot;, length(queens) - c - 1)    end)  end  defp is_safe?(row, col, queens) do    Enum.all?(queens, fn &#123;r, c&#125; -&gt;      row != r and col != c and abs(row - r) != abs(col - c)    end)  endend\n\n结果执行用时 : 273 ms, 击败 100.00% 使用 Elixir 的用户\n内存消耗 : 68.00 MB, 击败 100.00% 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00052.N 皇后 II","url":"/zh-CN/946ae2f8fa1e/","content":"\n题目描述n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。\n示例 1：\n\n\n输入：n &#x3D; 4输出：2解释：如上图所示，4 皇后问题存在两个不同的解法。\n\n示例 2：\n输入：n &#x3D; 1输出：1\n\n提示：\n1 &lt;&#x3D; n &lt;&#x3D; 9\n\n\n解决方法C++class Solution &#123;public:    int totalNQueens(int n) &#123;        int count = 0;        vector&lt;int&gt; board(n, -1);        placeQueen(board, 0, count);        return count;    &#125;private:    bool isNotUnderAttack(const vector&lt;int&gt;&amp; board, int row, int col) &#123;        for (int prevRow = 0; prevRow &lt; row; ++prevRow) &#123;            if (board[prevRow] == col ||                 abs(board[prevRow] - col) == row - prevRow) &#123;                return false;            &#125;        &#125;        return true;    &#125;    void placeQueen(vector&lt;int&gt;&amp; board, int row, int&amp; count) &#123;        int n = board.size();        if (row == n) &#123;            ++count;            return;        &#125;        for (int col = 0; col &lt; n; ++col) &#123;            if (isNotUnderAttack(board, row, col)) &#123;                board[row] = col;                placeQueen(board, row + 1, count);                board[row] = -1;            &#125;        &#125;    &#125;&#125;;\n\n结果执行用时 : 2 ms, 击败 74.56% 使用 C++ 的用户\n内存消耗 : 6.99 MB, 击败 47.09% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public int totalNQueens(int n) &#123;        int[] board = new int[n];        return placeQueens(board, 0);    &#125;    private boolean isNotUnderAttack(int[] board, int row, int col) &#123;        for (int prevRow = 0; prevRow &lt; row; ++prevRow) &#123;            if (board[prevRow] == col || Math.abs(board[prevRow] - col) == row - prevRow) &#123;                return false;            &#125;        &#125;        return true;    &#125;    private int placeQueens(int[] board, int row) &#123;        int n = board.length;        int count = 0;        if (row == n) &#123;            return 1;        &#125;        for (int col = 0; col &lt; n; ++col) &#123;            if (isNotUnderAttack(board, row, col)) &#123;                board[row] = col;                count += placeQueens(board, row + 1);            &#125;        &#125;        return count;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 80.81% 使用 Java 的用户\n内存消耗 : 39.18 MB, 击败 65.14% 使用 Java 的用户\n\nPythonclass Solution(object):    def totalNQueens(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: int        &quot;&quot;&quot;        def is_not_under_attack(row, col):            for prev_row in range(row):                if board[prev_row] == col or \\                   board[prev_row] - prev_row == col - row or \\                   board[prev_row] + prev_row == col + row:                    return False            return True        def place_queen(row):            if row == n:                self.count[0] += 1                return            for col in range(n):                if is_not_under_attack(row, col):                    board[row] = col                    place_queen(row + 1)        self.count = [0]        board = [-1] * n        place_queen(0)        return self.count[0]\n\n结果执行用时 : 52 ms, 击败 52.31% 使用 Python 的用户\n内存消耗 : 11.39 MB, 击败 90.77% 使用 Python 的用户\n\nPython3class Solution:    def totalNQueens(self, n: int) -&gt; int:        def is_not_under_attack(row, col):            for prev_row in range(row):                if board[prev_row] == col or \\                   board[prev_row] - prev_row == col - row or \\                   board[prev_row] + prev_row == col + row:                    return False            return True        def place_queen(row):            if row == n:                self.count += 1                return            for col in range(n):                if is_not_under_attack(row, col):                    board[row] = col                    place_queen(row + 1)        self.count = 0        board = [-1] * n        place_queen(0)        return self.count\n\n结果执行用时 : 62 ms, 击败 42.31% 使用 Python3 的用户\n内存消耗 : 16.43 MB, 击败 51.02% 使用 Python3 的用户\n\nCvoid printSolution(int* board, int n) &#123;    for (int i = 0; i &lt; n; ++i) &#123;        for (int j = 0; j &lt; n; ++j) &#123;            if (board[i] == j) &#123;                printf(&quot;Q &quot;);            &#125; else &#123;                printf(&quot;. &quot;);            &#125;        &#125;        printf(&quot;\\n&quot;);    &#125;    printf(&quot;\\n&quot;);&#125;bool isNotUnderAttack(int* board, int row, int col) &#123;    for (int prevRow = 0; prevRow &lt; row; ++prevRow) &#123;        if (board[prevRow] == col || abs(board[prevRow] - col) == row - prevRow) &#123;            return false;        &#125;    &#125;    return true;&#125;void placeQueen(int* board, int row, int n, int* count) &#123;    if (row == n) &#123;        (*count)++;        return;    &#125;    for (int col = 0; col &lt; n; ++col) &#123;        if (isNotUnderAttack(board, row, col)) &#123;            board[row] = col;            placeQueen(board, row + 1, n, count);        &#125;    &#125;&#125;int totalNQueens(int n) &#123;    int* board = (int*)malloc(n * sizeof(int));    int count = 0;    placeQueen(board, 0, n, &amp;count);    free(board);    return count;&#125;\n\n结果执行用时 : 3 ms, 击败 72.43% 使用 C 的用户\n内存消耗 : 5.50 MB, 击败 90.12% 使用 C 的用户\n\nC#public class Solution &#123;    public int TotalNQueens(int n) &#123;        int[] board = new int[n];        int count = 0;        PlaceQueen(board, 0, ref count);        return count;    &#125;    private bool IsNotUnderAttack(int[] board, int row, int col) &#123;        for (int prevRow = 0; prevRow &lt; row; ++prevRow) &#123;            if (board[prevRow] == col || Math.Abs(board[prevRow] - col) == row - prevRow) &#123;                return false;            &#125;        &#125;        return true;    &#125;    private void PlaceQueen(int[] board, int row, ref int count) &#123;        int n = board.Length;        if (row == n) &#123;            count++;            return;        &#125;        for (int col = 0; col &lt; n; ++col) &#123;            if (IsNotUnderAttack(board, row, col)) &#123;                board[row] = col;                PlaceQueen(board, row + 1, ref count);            &#125;        &#125;    &#125;&#125;\n\n结果执行用时 : 33 ms, 击败 16.00% 使用 C# 的用户\n内存消耗 : 26.79 MB, 击败 36.00% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number&#125; n * @return &#123;number&#125; */var totalNQueens = function(n) &#123;    let count = 0;    const board = new Array(n).fill(-1);    const isNotUnderAttack = (row, col) =&gt; &#123;        for (let prevRow = 0; prevRow &lt; row; ++prevRow) &#123;            if (board[prevRow] === col ||                 Math.abs(board[prevRow] - col) === row - prevRow) &#123;                return false;            &#125;        &#125;        return true;    &#125;;    const placeQueen = (row) =&gt; &#123;        if (row === n) &#123;            count++;            return;        &#125;        for (let col = 0; col &lt; n; ++col) &#123;            if (isNotUnderAttack(row, col)) &#123;                board[row] = col;                placeQueen(row + 1);            &#125;        &#125;    &#125;;    placeQueen(0);    return count;&#125;;\n\n结果执行用时 : 52 ms, 击败 97.94% 使用 JavaScript 的用户\n内存消耗 : 49.46 MB, 击败 41.16% 使用 JavaScript 的用户\n\nTypeScriptfunction totalNQueens(n: number): number &#123;    let count = 0;    const board: number[] = Array(n).fill(-1);    const isNotUnderAttack = (row: number, col: number): boolean =&gt; &#123;        for (let prevRow = 0; prevRow &lt; row; ++prevRow) &#123;            if (board[prevRow] === col ||                 Math.abs(board[prevRow] - col) === row - prevRow) &#123;                return false;            &#125;        &#125;        return true;    &#125;;    const placeQueen = (row: number): void =&gt; &#123;        if (row === n) &#123;            count++;            return;        &#125;        for (let col = 0; col &lt; n; ++col) &#123;            if (isNotUnderAttack(row, col)) &#123;                board[row] = col;                placeQueen(row + 1);            &#125;        &#125;    &#125;;    placeQueen(0);    return count;&#125;\n\n结果执行用时 : 69 ms, 击败 50.00% 使用 TypeScript 的用户\n内存消耗 : 50.49 MB, 击败 51.79% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer $n     * @return Integer     */    function totalNQueens($n) &#123;        $this-&gt;result = [];        $this-&gt;solveQueens($n, 0, []);        return count($this-&gt;result);    &#125;    function solveQueens($n, $row, $current) &#123;        if ($row == $n) &#123;            $this-&gt;result[] = $current;            return;        &#125;        for ($col = 0; $col &lt; $n; ++$col) &#123;            if ($this-&gt;isValid($current, $row, $col, $n)) &#123;                $current[] = $col;                $this-&gt;solveQueens($n, $row + 1, $current);                array_pop($current);            &#125;        &#125;    &#125;    function isValid($current, $row, $col, $n) &#123;        foreach ($current as $prevRow =&gt; $prevCol) &#123;            if ($col == $prevCol || abs($row - $prevRow) == abs($col - $prevCol)) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n结果执行用时 : 14 ms, 击败 100.00% 使用 PHP 的用户\n内存消耗 : 20.34 MB, 击败 0.00% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    private var resultCount = 0    func totalNQueens(_ n: Int) -&gt; Int &#123;        var board = Array(repeating: -1, count: n)        placeQueens(&amp;board, 0)        return resultCount    &#125;    private func isNotUnderAttack(_ board: [Int], _ row: Int, _ col: Int) -&gt; Bool &#123;        for prevRow in 0..&lt;row &#123;            if board[prevRow] == col || abs(board[prevRow] - col) == row - prevRow &#123;                return false            &#125;        &#125;        return true    &#125;    private func placeQueens(_ board: inout [Int], _ row: Int) &#123;        let n = board.count        if row == n &#123;            resultCount += 1            return        &#125;        for col in 0..&lt;n &#123;            if isNotUnderAttack(board, row, col) &#123;                board[row] = col                placeQueens(&amp;board, row + 1)            &#125;        &#125;    &#125;&#125;\n\n结果执行用时 : 6 ms, 击败 71.43% 使用 Swift 的用户\n内存消耗 : 15.15 MB, 击败 50.00% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    private var resultCount = 0    fun totalNQueens(n: Int): Int &#123;        val board = IntArray(n) &#123; -1 &#125;        placeQueens(board, 0)        return resultCount    &#125;    private fun isNotUnderAttack(board: IntArray, row: Int, col: Int): Boolean &#123;        for (prevRow in 0 until row) &#123;            if (board[prevRow] == col || Math.abs(board[prevRow] - col) == row - prevRow) &#123;                return false            &#125;        &#125;        return true    &#125;    private fun placeQueens(board: IntArray, row: Int) &#123;        val n = board.size        if (row == n) &#123;            resultCount++            return        &#125;        for (col in 0 until n) &#123;            if (isNotUnderAttack(board, row, col)) &#123;                board[row] = col                placeQueens(board, row + 1)            &#125;        &#125;    &#125;&#125;\n\n结果执行用时 : 135 ms, 击败 85.71% 使用 Kotlin 的用户\n内存消耗 : 32.34 MB, 击败 78.57% 使用 Kotlin 的用户\n\nDart暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Dart 的用户\n内存消耗 :  MB, 击败 % 使用 Dart 的用户\n\nGofunc totalNQueens(n int) int &#123;\tcount := 0\tboard := make([]int, n)\tplaceQueens(board, 0, &amp;count)\treturn count&#125;func isNotUnderAttack(board []int, row, col int) bool &#123;\tfor prevRow := 0; prevRow &lt; row; prevRow++ &#123;\t\tif board[prevRow] == col || abs(board[prevRow]-col) == row-prevRow &#123;\t\t\treturn false\t\t&#125;\t&#125;\treturn true&#125;func placeQueens(board []int, row int, count *int) &#123;\tn := len(board)\tif row == n &#123;\t\t*count++\t\treturn\t&#125;\tfor col := 0; col &lt; n; col++ &#123;\t\tif isNotUnderAttack(board, row, col) &#123;\t\t\tnewBoard := append([]int(nil), board...)\t\t\tnewBoard[row] = col\t\t\tplaceQueens(newBoard, row+1, count)\t\t&#125;\t&#125;&#125;func abs(x int) int &#123;\tif x &lt; 0 &#123;\t\treturn -x\t&#125;\treturn x&#125;\n\n结果执行用时 : 2 ms, 击败 35.62% 使用 Go 的用户\n内存消耗 : 2.66 MB, 击败 5.48% 使用 Go 的用户\n\nRuby# @param &#123;Integer&#125; n# @return &#123;Integer&#125;def total_n_queens(n)  count = [0]  board = Array.new(n, -1)  place_queens(board, 0, count)  count[0]enddef is_not_under_attack(board, row, col)  (0...row).each do |prev_row|    return false if board[prev_row] == col || (board[prev_row] - col).abs == row - prev_row  end  trueenddef place_queens(board, row, count)  n = board.length  if row == n    count[0] += 1    return  end  (0...n).each do |col|    if is_not_under_attack(board, row, col)      new_board = board.dup      new_board[row] = col      place_queens(new_board, row + 1, count)    end  endend\n\n结果执行用时 : 110 ms, 击败 -% 使用 Ruby 的用户\n内存消耗 : 206.57 MB, 击败 -% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def totalNQueens(n: Int): Int = &#123;    def placeQueens(board: Array[Int], row: Int, count: Int): Int = &#123;      if (row == n) count + 1      else &#123;        (0 until n).foldLeft(count)((currentCount, col) =&gt;          if (isNotUnderAttack(board, row, col))            placeQueens(board.updated(row, col), row + 1, currentCount)          else            currentCount        )      &#125;    &#125;    placeQueens(Array.fill(n)(-1), 0, 0)  &#125;  private def isNotUnderAttack(board: Array[Int], row: Int, col: Int): Boolean =    (0 until row).forall(prevRow =&gt;      board(prevRow) != col &amp;&amp; math.abs(board(prevRow) - col) != row - prevRow    )&#125;\n\n结果执行用时 : 449 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 52.83 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn total_n_queens(n: i32) -&gt; i32 &#123;        let mut count = 0;        let mut board = vec![-1; n as usize];        Solution::place_queens(&amp;mut board, 0, &amp;mut count);        count    &#125;    fn is_not_under_attack(board: &amp;Vec&lt;i32&gt;, row: usize, col: i32) -&gt; bool &#123;        (0..row).all(|prev_row| &#123;            let prev_col = board[prev_row];            prev_col != col &amp;&amp; (prev_col - col).abs() as usize != (row - prev_row)        &#125;)    &#125;    fn place_queens(board: &amp;mut Vec&lt;i32&gt;, row: usize, count: &amp;mut i32) &#123;        let n = board.len();        if row == n &#123;            *count += 1;        &#125; else &#123;            for col in 0..n as i32 &#123;                if Solution::is_not_under_attack(board, row, col) &#123;                    board[row] = col;                    Solution::place_queens(board, row + 1, count);                &#125;            &#125;        &#125;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 37.50% 使用 Rust 的用户\n内存消耗 : 2.16 MB, 击败 37.50% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00053.最大子数组和","url":"/zh-CN/98c5fd388cba/","content":"\n题目描述给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组 是数组中的一个连续部分。\n示例 1：\n输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\n示例 2：\n输入：nums &#x3D; [1]输出：1\n\n示例 3：\n输入：nums &#x3D; [5,4,-1,7,8]输出：23\n\n提示：\n$1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5$\n$-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4$\n\n进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。\n\n解决方法C++class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        if (n == 0) &#123;            return 0;        &#125;        vector&lt;int&gt; dp(n, 0);        dp[0] = nums[0];        for (int i = 1; i &lt; n; ++i) &#123;            dp[i] = max(dp[i-1] + nums[i], nums[i]);        &#125;        int maxSum = dp[0];        for (int i = 1; i &lt; n; ++i) &#123;            maxSum = max(maxSum, dp[i]);        &#125;        return maxSum;    &#125;&#125;;\n\n结果执行用时 : 80 ms, 击败 83.49% 使用 C++ 的用户\n内存消耗 : 71.21 MB, 击败 6.83% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int maxSubArray(int[] nums) &#123;        int n = nums.length;        if (n == 0) &#123;            return 0;        &#125;        int[] dp = new int[n];        dp[0] = nums[0];        for (int i = 1; i &lt; n; ++i) &#123;            dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);        &#125;        int maxSum = dp[0];        for (int i = 1; i &lt; n; ++i) &#123;            maxSum = Math.max(maxSum, dp[i]);        &#125;        return maxSum;    &#125;&#125;\n\n结果执行用时 : 2 ms, 击败 41.66% 使用 Java 的用户\n内存消耗 : 56.18 MB, 击败 54.49% 使用 Java 的用户\n\nPythonclass Solution(object):    def maxSubArray(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        n = len(nums)        if n == 0:            return 0        dp = [0] * n        dp[0] = nums[0]        for i in range(1, n):            dp[i] = max(dp[i-1] + nums[i], nums[i])        maxSum = max(dp)        return maxSum\n\n结果执行用时 : 113 ms, 击败 45.81% 使用 Python 的用户\n内存消耗 : 23.09 MB, 击败 35.87% 使用 Python 的用户\n\nPython3class Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        n = len(nums)        if n == 0:            return 0        dp = [0] * n        dp[0] = nums[0]        for i in range(1, n):            dp[i] = max(dp[i-1] + nums[i], nums[i])        maxSum = max(dp)        return maxSum\n\n结果执行用时 : 125 ms, 击败 71.45% 使用 Python3 的用户\n内存消耗 : 30.97 MB, 击败 57.69% 使用 Python3 的用户\n\nCint maxSubArray(int* nums, int numsSize) &#123;    if (numsSize == 0) &#123;        return 0;    &#125;    int maxSum = nums[0];    int currentSum = nums[0];    for (int i = 1; i &lt; numsSize; ++i) &#123;        currentSum = (currentSum &gt; 0) ? currentSum + nums[i] : nums[i];        maxSum = (currentSum &gt; maxSum) ? currentSum : maxSum;    &#125;    return maxSum;&#125;\n\n结果执行用时 : 75 ms, 击败 98.24% 使用 C 的用户\n内存消耗 : 11.72 MB, 击败 98.27% 使用 C 的用户\n\nC#public class Solution &#123;    public int MaxSubArray(int[] nums) &#123;        int n = nums.Length;        if (n == 0) &#123;            return 0;        &#125;        int maxSum = nums[0];        int currentSum = nums[0];        for (int i = 1; i &lt; n; ++i) &#123;            currentSum = (currentSum &gt; 0) ? currentSum + nums[i] : nums[i];            maxSum = (currentSum &gt; maxSum) ? currentSum : maxSum;        &#125;        return maxSum;    &#125;&#125;\n\n结果执行用时 : 247 ms, 击败 16.12% 使用 C# 的用户\n内存消耗 : 60.21 MB, 击败 5.16% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maxSubArray = function(nums) &#123;    if (nums.length === 0) &#123;        return 0;    &#125;    let maxSum = nums[0];    let currentSum = nums[0];    for (let i = 1; i &lt; nums.length; ++i) &#123;        currentSum = (currentSum &gt; 0) ? currentSum + nums[i] : nums[i];        maxSum = (currentSum &gt; maxSum) ? currentSum : maxSum;    &#125;    return maxSum;&#125;;\n\n结果执行用时 : 85 ms, 击败 36.15% 使用 JavaScript 的用户\n内存消耗 : 57.37 MB, 击败 22.97% 使用 JavaScript 的用户\n\nTypeScriptfunction maxSubArray(nums: number[]): number &#123;    const n: number = nums.length;    if (n === 0) &#123;        return 0;    &#125;    let maxSum: number = nums[0];    let currentSum: number = nums[0];    for (let i = 1; i &lt; n; ++i) &#123;        currentSum = (currentSum &gt; 0) ? currentSum + nums[i] : nums[i];        maxSum = (currentSum &gt; maxSum) ? currentSum : maxSum;    &#125;    return maxSum;&#125;\n\n结果执行用时 : 83 ms, 击败 66.83% 使用 TypeScript 的用户\n内存消耗 : 59.46 MB, 击败 23.34% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @return Integer     */    function maxSubArray($nums) &#123;        $n = count($nums);        if ($n === 0) &#123;            return 0;        &#125;        $maxSum = $nums[0];        $currentSum = $nums[0];        for ($i = 1; $i &lt; $n; ++$i) &#123;            $currentSum = ($currentSum &gt; 0) ? $currentSum + $nums[$i] : $nums[$i];            $maxSum = ($currentSum &gt; $maxSum) ? $currentSum : $maxSum;        &#125;        return $maxSum;    &#125;&#125;\n\n结果执行用时 : 186 ms, 击败 92.16% 使用 PHP 的用户\n内存消耗 : 27.15 MB, 击败 80.39% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func maxSubArray(_ nums: [Int]) -&gt; Int &#123;        let n = nums.count        if n == 0 &#123;            return 0        &#125;        var maxSum = nums[0]        var currentSum = nums[0]        for i in 1..&lt;n &#123;            currentSum = (currentSum &gt; 0) ? currentSum + nums[i] : nums[i]            maxSum = max(currentSum, maxSum)        &#125;        return maxSum    &#125;&#125;\n\n结果执行用时 : 304 ms, 击败 89.96% 使用 Swift 的用户\n内存消耗 : 19.52 MB, 击败 40.17% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun maxSubArray(nums: IntArray): Int &#123;        val n = nums.size        if (n == 0) &#123;            return 0        &#125;        var maxSum = nums[0]        var currentSum = nums[0]        for (i in 1 until n) &#123;            currentSum = if (currentSum &gt; 0) currentSum + nums[i] else nums[i]            maxSum = maxOf(currentSum, maxSum)        &#125;        return maxSum    &#125;&#125;\n\n结果执行用时 : 478 ms, 击败 27.67% 使用 Kotlin 的用户\n内存消耗 : 58.28 MB, 击败 18.87% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int maxSubArray(List&lt;int&gt; nums) &#123;    int n = nums.length;    if (n == 0) &#123;      return 0;    &#125;    int maxSum = nums[0];    int currentSum = nums[0];    for (int i = 1; i &lt; n; ++i) &#123;      currentSum = (currentSum &gt; 0) ? currentSum + nums[i] : nums[i];      maxSum = (currentSum &gt; maxSum) ? currentSum : maxSum;    &#125;    return maxSum;  &#125;&#125;\n\n结果执行用时 : 368 ms, 击败 42.86% 使用 Dart 的用户\n内存消耗 : 175.44 MB, 击败 92.86% 使用 Dart 的用户\n\nGofunc maxSubArray(nums []int) int &#123;    n := len(nums)    if n == 0 &#123;        return 0    &#125;    maxSum := nums[0]    currentSum := nums[0]    for i := 1; i &lt; n; i++ &#123;        if currentSum &gt; 0 &#123;            currentSum += nums[i]        &#125; else &#123;            currentSum = nums[i]        &#125;        maxSum = max(maxSum, currentSum)    &#125;    return maxSum&#125;\n\n结果执行用时 : 79 ms, 击败 83.53% 使用 Go 的用户\n内存消耗 : 7.84 MB, 击败 82.57% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @return &#123;Integer&#125;def max_sub_array(nums)    n = nums.length    return 0 if n == 0    max_sum = nums[0]    current_sum = nums[0]    (1...n).each do |i|        current_sum = current_sum &gt; 0 ? current_sum + nums[i] : nums[i]        max_sum = [max_sum, current_sum].max    end    max_sumend\n\n结果执行用时 : 120 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 214.20 MB, 击败 13.33% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def maxSubArray(nums: Array[Int]): Int = &#123;    val n = nums.length    if (n == 0) &#123;      return 0    &#125;    var maxSum = nums(0)    var currentSum = nums(0)    for (i &lt;- 1 until n) &#123;      currentSum = if (currentSum &gt; 0) currentSum + nums(i) else nums(i)      maxSum = math.max(maxSum, currentSum)    &#125;    maxSum  &#125;&#125;\n\n结果执行用时 : 828 ms, 击败 30.77% 使用 Scala 的用户\n内存消耗 : 74.23 MB, 击败 46.15% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn max_sub_array(nums: Vec&lt;i32&gt;) -&gt; i32 &#123;        let n = nums.len();        if n == 0 &#123;            return 0;        &#125;        let mut max_sum = nums[0];        let mut current_sum = nums[0];        for i in 1..n &#123;            current_sum = if current_sum &gt; 0 &#123;                current_sum + nums[i]            &#125; else &#123;                nums[i]            &#125;;            max_sum = max_sum.max(current_sum);        &#125;        max_sum    &#125;&#125;\n\n结果执行用时 : 9 ms, 击败 64.43% 使用 Rust 的用户\n内存消耗 : 3.03 MB, 击败 98.04% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00054.螺旋矩阵","url":"/zh-CN/ca17823e0ac7/","content":"\n题目描述给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n示例 1：\n\n\n输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5]\n\n示例 2：\n\n\n输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n\n提示：\nm &#x3D;&#x3D; matrix.length\nn &#x3D;&#x3D; matrix[i].length\n1 &lt;&#x3D; m, n &lt;&#x3D; 10\n-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100\n\n\n解决方法C++class Solution &#123;public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        vector&lt;int&gt; result;        if (matrix.empty()) &#123;            return result;        &#125;        int m = matrix.size();        int n = matrix[0].size();        int top = 0, bottom = m - 1, left = 0, right = n - 1;        while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;            for (int j = left; j &lt;= right; ++j) &#123;                result.push_back(matrix[top][j]);            &#125;            top++;            for (int i = top; i &lt;= bottom; ++i) &#123;                result.push_back(matrix[i][right]);            &#125;            right--;            if (top &lt;= bottom) &#123;                for (int j = right; j &gt;= left; --j) &#123;                    result.push_back(matrix[bottom][j]);                &#125;                bottom--;            &#125;            if (left &lt;= right) &#123;                for (int i = bottom; i &gt;= top; --i) &#123;                    result.push_back(matrix[i][left]);                &#125;                left++;            &#125;        &#125;        return result;    &#125;&#125;;\n\n结果执行用时 : 3 ms, 击败 30.31% 使用 C++ 的用户\n内存消耗 : 8.05 MB, 击败 14.60% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;            return result;        &#125;        int m = matrix.length;        int n = matrix[0].length;        int top = 0, bottom = m - 1, left = 0, right = n - 1;        while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;            for (int j = left; j &lt;= right; ++j) &#123;                result.add(matrix[top][j]);            &#125;            top++;            for (int i = top; i &lt;= bottom; ++i) &#123;                result.add(matrix[i][right]);            &#125;            right--;            if (top &lt;= bottom) &#123;                for (int j = right; j &gt;= left; --j) &#123;                    result.add(matrix[bottom][j]);                &#125;                bottom--;            &#125;            if (left &lt;= right) &#123;                for (int i = bottom; i &gt;= top; --i) &#123;                    result.add(matrix[i][left]);                &#125;                left++;            &#125;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 40.52 MB, 击败 34.74% 使用 Java 的用户\n\nPythonclass Solution(object):    def spiralOrder(self, matrix):        &quot;&quot;&quot;        :type matrix: List[List[int]]        :rtype: List[int]        &quot;&quot;&quot;        result = []        if not matrix:            return result        m, n = len(matrix), len(matrix[0])        top, bottom, left, right = 0, m - 1, 0, n - 1        while top &lt;= bottom and left &lt;= right:            for j in range(left, right + 1):                result.append(matrix[top][j])            top += 1            for i in range(top, bottom + 1):                result.append(matrix[i][right])            right -= 1            if top &lt;= bottom:                for j in range(right, left - 1, -1):                    result.append(matrix[bottom][j])                bottom -= 1            if left &lt;= right:                for i in range(bottom, top - 1, -1):                    result.append(matrix[i][left])                left += 1        return result\n\n结果执行用时 : 10 ms, 击败 89.47% 使用 Python 的用户\n内存消耗 : 11.34 MB, 击败 94.82% 使用 Python 的用户\n\nPython3class Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        result = []        if not matrix:            return result        m, n = len(matrix), len(matrix[0])        top, bottom, left, right = 0, m - 1, 0, n - 1        while top &lt;= bottom and left &lt;= right:            for j in range(left, right + 1):                result.append(matrix[top][j])            top += 1            for i in range(top, bottom + 1):                result.append(matrix[i][right])            right -= 1            if top &lt;= bottom:                for j in range(right, left - 1, -1):                    result.append(matrix[bottom][j])                bottom -= 1            if left &lt;= right:                for i in range(bottom, top - 1, -1):                    result.append(matrix[i][left])                left += 1        return result\n\n结果执行用时 : 33 ms, 击败 84.52% 使用 Python3 的用户\n内存消耗 : 16.41 MB, 击败 52.20% 使用 Python3 的用户\n\nC/** * Note: The returned array must be malloced, assume caller calls free(). */int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) &#123;    if (matrix == NULL || matrixSize == 0 || matrixColSize == NULL || matrixColSize[0] == 0) &#123;        *returnSize = 0;        return NULL;    &#125;    int m = matrixSize;    int n = matrixColSize[0];    int* result = (int*)malloc(m * n * sizeof(int));    *returnSize = m * n;    int top = 0, bottom = m - 1, left = 0, right = n - 1;    int index = 0;    while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;        for (int j = left; j &lt;= right; ++j) &#123;            result[index++] = matrix[top][j];        &#125;        top++;        for (int i = top; i &lt;= bottom; ++i) &#123;            result[index++] = matrix[i][right];        &#125;        right--;        if (top &lt;= bottom) &#123;            for (int j = right; j &gt;= left; --j) &#123;                result[index++] = matrix[bottom][j];            &#125;            bottom--;        &#125;        if (left &lt;= right) &#123;            for (int i = bottom; i &gt;= top; --i) &#123;                result[index++] = matrix[i][left];            &#125;            left++;        &#125;    &#125;    return result;&#125;\n\n结果执行用时 : 2 ms, 击败 42.11% 使用 C 的用户\n内存消耗 : 5.34 MB, 击败 94.98% 使用 C 的用户\n\nC#public class Solution &#123;    public IList&lt;int&gt; SpiralOrder(int[][] matrix) &#123;        List&lt;int&gt; result = new List&lt;int&gt;();        if (matrix == null || matrix.Length == 0 || matrix[0].Length == 0) &#123;            return result;        &#125;        int m = matrix.Length;        int n = matrix[0].Length;        int top = 0, bottom = m - 1, left = 0, right = n - 1;        while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;            for (int j = left; j &lt;= right; ++j) &#123;                result.Add(matrix[top][j]);            &#125;            top++;            for (int i = top; i &lt;= bottom; ++i) &#123;                result.Add(matrix[i][right]);            &#125;            right--;            if (top &lt;= bottom) &#123;                for (int j = right; j &gt;= left; --j) &#123;                    result.Add(matrix[bottom][j]);                &#125;                bottom--;            &#125;            if (left &lt;= right) &#123;                for (int i = bottom; i &gt;= top; --i) &#123;                    result.Add(matrix[i][left]);                &#125;                left++;            &#125;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 105 ms, 击败 55.06% 使用 C# 的用户\n内存消耗 : 45.40 MB, 击败 5.66% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[][]&#125; matrix * @return &#123;number[]&#125; */var spiralOrder = function(matrix) &#123;    let result = [];    if (!matrix || matrix.length === 0 || matrix[0].length === 0) &#123;        return result;    &#125;    let m = matrix.length;    let n = matrix[0].length;    let top = 0, bottom = m - 1, left = 0, right = n - 1;    while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;        for (let j = left; j &lt;= right; ++j) &#123;            result.push(matrix[top][j]);        &#125;        top++;        for (let i = top; i &lt;= bottom; ++i) &#123;            result.push(matrix[i][right]);        &#125;        right--;        if (top &lt;= bottom) &#123;            for (let j = right; j &gt;= left; --j) &#123;                result.push(matrix[bottom][j]);            &#125;            bottom--;        &#125;        if (left &lt;= right) &#123;            for (let i = bottom; i &gt;= top; --i) &#123;                result.push(matrix[i][left]);            &#125;            left++;        &#125;    &#125;    return result;&#125;;\n\n结果执行用时 : 48 ms, 击败 97.03% 使用 JavaScript 的用户\n内存消耗 : 48.98 MB, 击败 21.36% 使用 JavaScript 的用户\n\nTypeScriptfunction spiralOrder(matrix: number[][]): number[] &#123;    let result: number[] = [];    if (!matrix || matrix.length === 0 || matrix[0].length === 0) &#123;        return result;    &#125;    let m: number = matrix.length;    let n: number = matrix[0].length;    let top: number = 0, bottom: number = m - 1, left: number = 0, right: number = n - 1;    while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;        for (let j = left; j &lt;= right; ++j) &#123;            result.push(matrix[top][j]);        &#125;        top++;        for (let i = top; i &lt;= bottom; ++i) &#123;            result.push(matrix[i][right]);        &#125;        right--;        if (top &lt;= bottom) &#123;            for (let j = right; j &gt;= left; --j) &#123;                result.push(matrix[bottom][j]);            &#125;            bottom--;        &#125;        if (left &lt;= right) &#123;            for (let i = bottom; i &gt;= top; --i) &#123;                result.push(matrix[i][left]);            &#125;            left++;        &#125;    &#125;    return result;&#125;\n\n结果执行用时 : 60 ms, 击败 70.37% 使用 TypeScript 的用户\n内存消耗 : 50.38 MB, 击败 10.70% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[][] $matrix     * @return Integer[]     */    function spiralOrder($matrix) &#123;        $result = [];        if ($matrix === null || empty($matrix) || empty($matrix[0])) &#123;            return $result;        &#125;        $m = count($matrix);        $n = count($matrix[0]);        $top = 0;        $bottom = $m - 1;        $left = 0;        $right = $n - 1;        while ($top &lt;= $bottom &amp;&amp; $left &lt;= $right) &#123;            for ($j = $left; $j &lt;= $right; ++$j) &#123;                $result[] = $matrix[$top][$j];            &#125;            $top++;            for ($i = $top; $i &lt;= $bottom; ++$i) &#123;                $result[] = $matrix[$i][$right];            &#125;            $right--;            if ($top &lt;= $bottom) &#123;                for ($j = $right; $j &gt;= $left; --$j) &#123;                    $result[] = $matrix[$bottom][$j];                &#125;                $bottom--;            &#125;            if ($left &lt;= $right) &#123;                for ($i = $bottom; $i &gt;= $top; --$i) &#123;                    $result[] = $matrix[$i][$left];                &#125;                $left++;            &#125;        &#125;        return $result;    &#125;&#125;\n\n结果执行用时 : 6 ms, 击败 64.29% 使用 PHP 的用户\n内存消耗 : 20.27 MB, 击败 7.14% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func spiralOrder(_ matrix: [[Int]]) -&gt; [Int] &#123;       var result = [matrix[0][0]], a = 0, b = 0, arrow = &quot;right&quot;,            leftmin = 0, rightmax = matrix[0].count - 1,            upmin = 0, downmax = matrix.count - 1        if matrix[0].count == 1 &#123; arrow = &quot;down&quot; &#125;        while result.count &lt; matrix.count * matrix[0].count &#123;            if arrow == &quot;right&quot; &#123;                b += 1                if b == rightmax &#123;                    upmin += 1                    arrow = &quot;down&quot;                &#125;            &#125; else if arrow == &quot;down&quot; &#123;                a += 1                if a == downmax &#123;                    rightmax -= 1                    arrow = &quot;left&quot;                &#125;            &#125; else if arrow == &quot;left&quot; &#123;                b -= 1                if b == leftmin &#123;                    downmax -= 1                    arrow = &quot;up&quot;                &#125;            &#125; else if arrow == &quot;up&quot; &#123;                a -= 1                if a == upmin &#123;                    leftmin += 1                    arrow = &quot;right&quot;                &#125;            &#125;            result.append(matrix[a][b])        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Swift 的用户\n内存消耗 : 15.66 MB, 击败 15.00% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun spiralOrder(matrix: Array&lt;IntArray&gt;): List&lt;Int&gt; &#123;        val result = mutableListOf&lt;Int&gt;()        if (matrix.isEmpty() || matrix[0].isEmpty()) &#123;            return result        &#125;        var top = 0        var bottom = matrix.size - 1        var left = 0        var right = matrix[0].size - 1        while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;            for (i in left..right) &#123;                result.add(matrix[top][i])            &#125;            top++            for (i in top..bottom) &#123;                result.add(matrix[i][right])            &#125;            right--            if (top &lt;= bottom) &#123;                for (i in right downTo left) &#123;                    result.add(matrix[bottom][i])                &#125;                bottom--            &#125;            if (left &lt;= right) &#123;                for (i in bottom downTo top) &#123;                    result.add(matrix[i][left])                &#125;                left++            &#125;        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 148 ms, 击败 71.93% 使用 Kotlin 的用户\n内存消耗 : 33.81 MB, 击败 28.07% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;int&gt; spiralOrder(List&lt;List&lt;int&gt;&gt; matrix) &#123;    List&lt;int&gt; result = [];    if (matrix.isEmpty || matrix[0].isEmpty) &#123;        return result;    &#125;    int top = 0, bottom = matrix.length - 1;    int left = 0, right = matrix[0].length - 1;    while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;        for (int i = left; i &lt;= right; i++) &#123;        result.add(matrix[top][i]);        &#125;        top++;        for (int i = top; i &lt;= bottom; i++) &#123;        result.add(matrix[i][right]);        &#125;        right--;        if (top &lt;= bottom) &#123;        for (int i = right; i &gt;= left; i--) &#123;            result.add(matrix[bottom][i]);        &#125;        bottom--;        &#125;        if (left &lt;= right) &#123;        for (int i = bottom; i &gt;= top; i--) &#123;            result.add(matrix[i][left]);        &#125;        left++;        &#125;    &#125;    return result;    &#125;&#125;\n\n结果执行用时 : 273 ms, 击败 50.00% 使用 Dart 的用户\n内存消耗 : 142.05 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc spiralOrder(matrix [][]int) []int &#123;    result := []int&#123;&#125;    if len(matrix) == 0 || len(matrix[0]) == 0 &#123;        return result    &#125;    top, bottom := 0, len(matrix)-1    left, right := 0, len(matrix[0])-1    for top &lt;= bottom &amp;&amp; left &lt;= right &#123;        for i := left; i &lt;= right; i++ &#123;            result = append(result, matrix[top][i])        &#125;        top++        for i := top; i &lt;= bottom; i++ &#123;            result = append(result, matrix[i][right])        &#125;        right--        if top &lt;= bottom &#123;            for i := right; i &gt;= left; i-- &#123;                result = append(result, matrix[bottom][i])            &#125;            bottom--        &#125;        if left &lt;= right &#123;            for i := bottom; i &gt;= top; i-- &#123;                result = append(result, matrix[i][left])            &#125;            left++        &#125;    &#125;    return result&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 1.86 MB, 击败 55.24% 使用 Go 的用户\n\nRuby# @param &#123;Integer[][]&#125; matrix# @return &#123;Integer[]&#125;def spiral_order(matrix)  result = []  return result if matrix.empty? || matrix[0].empty?  top, bottom = 0, matrix.length - 1  left, right = 0, matrix[0].length - 1  while top &lt;= bottom &amp;&amp; left &lt;= right    left.upto(right) do |i|      result.push(matrix[top][i])    end    top += 1    top.upto(bottom) do |i|      result.push(matrix[i][right])    end    right -= 1    if top &lt;= bottom      right.downto(left) do |i|        result.push(matrix[bottom][i])      end      bottom -= 1    end    if left &lt;= right      bottom.downto(top) do |i|        result.push(matrix[i][left])      end      left += 1    end  end  resultend\n\n结果执行用时 : 74 ms, 击败 0.00% 使用 Ruby 的用户\n内存消耗 : 206.35 MB, 击败 14.29% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def spiralOrder(matrix: Array[Array[Int]]): List[Int] = &#123;    var result: List[Int] = List()    if (matrix.isEmpty || matrix(0).isEmpty) &#123;      return result    &#125;    var top = 0    var bottom = matrix.length - 1    var left = 0    var right = matrix(0).length - 1    while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;      for (i &lt;- left to right) &#123;        result :+= matrix(top)(i)      &#125;      top += 1      for (i &lt;- top to bottom) &#123;        result :+= matrix(i)(right)      &#125;      right -= 1      if (top &lt;= bottom) &#123;        for (i &lt;- right to left by -1) &#123;          result :+= matrix(bottom)(i)        &#125;        bottom -= 1      &#125;      if (left &lt;= right) &#123;        for (i &lt;- bottom to top by -1) &#123;          result :+= matrix(i)(left)        &#125;        left += 1      &#125;    &#125;    result  &#125;&#125;\n\n结果执行用时 : 439 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 54.64 MB, 击败 25.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn spiral_order(matrix: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; Vec&lt;i32&gt; &#123;        let (rows, cols) = (matrix.len(), matrix[0].len());        let mut visited = vec![vec![false; cols]; rows];        let total = rows * cols;        let mut order = vec![0; total];        let directions: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![0, 1], vec![1, 0], vec![0, -1], vec![-1, 0]];        let mut direction_idx = 0;        let (mut row, mut col) = (0, 0);        for i in 0..total &#123;            order[i] = matrix[row][col];            visited[row][col] = true;            let next_row = row as i32 + directions[direction_idx][0];            let next_col = col as i32 + directions[direction_idx][1];            if next_row &lt; 0                || next_row &gt;= rows as i32                || next_col &lt; 0                || next_col &gt;= cols as i32                || visited[next_row as usize][next_col as usize]            &#123;                direction_idx = (direction_idx + 1) % 4;            &#125;            row = (row as i32 + directions[direction_idx][0]) as usize;            col = (col as i32 + directions[direction_idx][1]) as usize;        &#125;        order    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.09 MB, 击败 39.19% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"黑闪电 第三季 第十五集 战争之书：第二章：自由得来不易","url":"/zh-CN/cdc9716f72e7/","content":"\n剧情介绍　　得知墓地掘者和马尔科维亚人即将袭击弗里兰后，皮尔斯一家开始为战争做准备。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00055.跳跃游戏","url":"/zh-CN/86baf309a96b/","content":"\n题目描述给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。\n判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。\n示例 1：\n输入：nums &#x3D; [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n示例 2：\n输入：nums &#x3D; [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。\n\n提示：\n$1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4$\n$0 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5$\n\n\n解决方法C++class Solution &#123;public:    bool canJump(vector&lt;int&gt;&amp; nums) &#123;        int last_position = nums.size() - 1;        for (int i = nums.size() - 2; i &gt;= 0; --i) &#123;            if (i + nums[i] &gt;= last_position) &#123;                last_position = i;            &#125;        &#125;        return last_position == 0;    &#125;&#125;;\n\n结果执行用时 : 48 ms, 击败 65.72% 使用 C++ 的用户\n内存消耗 : 49.56 MB, 击败 36.51% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public boolean canJump(int[] nums) &#123;        int lastPosition = nums.length - 1;        for (int i = nums.length - 2; i &gt;= 0; i--) &#123;            if (i + nums[i] &gt;= lastPosition) &#123;                lastPosition = i;            &#125;        &#125;        return lastPosition == 0;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 99.97% 使用 Java 的用户\n内存消耗 : 44.63 MB, 击败 18.42% 使用 Java 的用户\n\nPythonclass Solution(object):    def canJump(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: bool        &quot;&quot;&quot;        last_position = len(nums) - 1        for i in range(len(nums) - 2, -1, -1):            if i + nums[i] &gt;= last_position:                last_position = i        return last_position == 0\n\n结果执行用时 : 45 ms, 击败 93.96% 使用 Python 的用户\n内存消耗 : 12.46 MB, 击败 70.46% 使用 Python 的用户\n\nPython3class Solution:    def canJump(self, nums: List[int]) -&gt; bool:        last_position = len(nums) - 1        for i in range(len(nums) - 2, -1, -1):            if i + nums[i] &gt;= last_position:                last_position = i        return last_position == 0\n\n结果执行用时 : 48 ms, 击败 99.62% 使用 Python3 的用户\n内存消耗 : 17.16 MB, 击败 48.79% 使用 Python3 的用户\n\nCbool canJump(int* nums, int numsSize) &#123;    int last_position = numsSize - 1;    for (int i = numsSize - 2; i &gt;= 0; --i) &#123;        if (i + nums[i] &gt;= last_position) &#123;            last_position = i;        &#125;    &#125;    return last_position == 0;&#125;\n\n结果执行用时 : 44 ms, 击败 95.37% 使用 C 的用户\n内存消耗 : 8.13 MB, 击败 76.50% 使用 C 的用户\n\nC#public class Solution &#123;    public bool CanJump(int[] nums) &#123;        int lastPosition = nums.Length - 1;        for (int i = nums.Length - 2; i &gt;= 0; i--) &#123;            if (i + nums[i] &gt;= lastPosition) &#123;                lastPosition = i;            &#125;        &#125;        return lastPosition == 0;    &#125;&#125;\n\n结果执行用时 : 183 ms, 击败 29.85% 使用 C# 的用户\n内存消耗 : 61.69 MB, 击败 10.84% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var canJump = function(nums) &#123;    let lastPosition = nums.length - 1;    for (let i = nums.length - 2; i &gt;= 0; i--) &#123;        if (i + nums[i] &gt;= lastPosition) &#123;            lastPosition = i;        &#125;    &#125;    return lastPosition === 0;&#125;;\n\n结果执行用时 : 62 ms, 击败 90.80% 使用 JavaScript 的用户\n内存消耗 : 52.84 MB, 击败 24.20% 使用 JavaScript 的用户\n\nTypeScriptfunction canJump(nums: number[]): boolean &#123;    let lastPosition: number = nums.length - 1;    for (let i: number = nums.length - 2; i &gt;= 0; i--) &#123;        if (i + nums[i] &gt;= lastPosition) &#123;            lastPosition = i;        &#125;    &#125;    return lastPosition === 0;&#125;\n\n结果执行用时 : 73 ms, 击败 62.09% 使用 TypeScript 的用户\n内存消耗 : 54.43 MB, 击败 27.67% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $nums     * @return Boolean     */    function canJump($nums) &#123;        $lastPosition = count($nums) - 1;        for ($i = count($nums) - 2; $i &gt;= 0; $i--) &#123;            if ($i + $nums[$i] &gt;= $lastPosition) &#123;                $lastPosition = $i;            &#125;        &#125;        return $lastPosition === 0;    &#125;&#125;\n\n结果执行用时 : 125 ms, 击败 64.52% 使用 PHP 的用户\n内存消耗 : 21.33 MB, 击败 16.13% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func canJump(_ nums: [Int]) -&gt; Bool &#123;        var lastPosition = nums.count - 1        for i in stride(from: nums.count - 2, through: 0, by: -1) &#123;            if i + nums[i] &gt;= lastPosition &#123;                lastPosition = i            &#125;        &#125;        return lastPosition == 0    &#125;&#125;\n\n结果执行用时 : 136 ms, 击败 96.55% 使用 Swift 的用户\n内存消耗 : 15.48 MB, 击败 28.74% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun canJump(nums: IntArray): Boolean &#123;        var lastPosition = nums.size - 1        for (i in nums.size - 2 downTo 0) &#123;            if (i + nums[i] &gt;= lastPosition) &#123;                lastPosition = i            &#125;        &#125;        return lastPosition == 0    &#125;&#125;\n\n结果执行用时 : 276 ms, 击败 96.52% 使用 Kotlin 的用户\n内存消耗 : 40.90 MB, 击败 34.78% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  bool canJump(List&lt;int&gt; nums) &#123;    int lastPosition = nums.length - 1;    for (int i = nums.length - 2; i &gt;= 0; i--) &#123;      if (i + nums[i] &gt;= lastPosition) &#123;        lastPosition = i;      &#125;    &#125;    return lastPosition == 0;  &#125;&#125;\n\n结果执行用时 : 323 ms, 击败 0.00% 使用 Dart 的用户\n内存消耗 : 154.08 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc canJump(nums []int) bool &#123;    lastPosition := len(nums) - 1    for i := len(nums) - 2; i &gt;= 0; i-- &#123;        if i+nums[i] &gt;= lastPosition &#123;            lastPosition = i        &#125;    &#125;    return lastPosition == 0&#125;\n\n结果执行用时 : 43 ms, 击败 80.85% 使用 Go 的用户\n内存消耗 : 6.72 MB, 击败 90.81% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; nums# @return &#123;Boolean&#125;def can_jump(nums)  last_position = nums.length - 1  (nums.length - 2).downto(0) do |i|    if i + nums[i] &gt;= last_position      last_position = i    end  end  last_position == 0end\n\n结果执行用时 : 92 ms, 击败 80.00% 使用 Ruby 的用户\n内存消耗 : 211.39 MB, 击败 60.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def canJump(nums: Array[Int]): Boolean = &#123;    var lastPosition = nums.length - 1    for (i &lt;- (nums.length - 2) to 0 by -1) &#123;      if (i + nums(i) &gt;= lastPosition) &#123;        lastPosition = i      &#125;    &#125;    lastPosition == 0  &#125;&#125;\n\n结果执行用时 : 626 ms, 击败 92.31% 使用 Scala 的用户\n内存消耗 : 56.00 MB, 击败 53.85% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn can_jump(nums: Vec&lt;i32&gt;) -&gt; bool &#123;        let mut last_position = nums.len() - 1;        for i in (0..nums.len() - 1).rev() &#123;            if i + nums[i] as usize &gt;= last_position &#123;                last_position = i;            &#125;        &#125;        last_position == 0    &#125;&#125;\n\n结果执行用时 : 6 ms, 击败 54.19% 使用 Rust 的用户\n内存消耗 : 2.17 MB, 击败 56.77% 使用 Rust 的用户\n\nRacket(define/contract (can-jump nums)  (-&gt; (listof exact-integer?) boolean?)  (define last-position (sub1 (length nums)))  (for ([i (in-range (sub1 (length nums)) -1 -1)])    (when (&gt;= (+ i (list-ref nums i)) last-position)      (set! last-position i)))  (= last-position 0))\n\n结果执行用时 : 2174 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 125.18 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00056.合并区间","url":"/zh-CN/d64fad88ff12/","content":"\n题目描述以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; $[start_i, end_i]$ 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。\n示例 1：\n输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]输出：[[1,6],[8,10],[15,18]]解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]。\n\n示例 2：\n输入：intervals &#x3D; [[1,4],[4,5]]输出：[[1,5]]解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。\n\n提示：\n$1 &lt;&#x3D; intervals.length &lt;&#x3D; 10^4$\nintervals[i].length &#x3D;&#x3D; 2\n$0 &lt;&#x3D; start_i &lt;&#x3D; end_i &lt;&#x3D; 10^4$\n\n\n解决方法C++class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        if (intervals.empty()) &#123;            return &#123;&#125;;        &#125;        sort(intervals.begin(), intervals.end(), [](const auto&amp; a, const auto&amp; b) &#123;            return a[0] &lt; b[0];        &#125;);        vector&lt;vector&lt;int&gt;&gt; merged = &#123;intervals[0]&#125;;        for (int i = 1; i &lt; intervals.size(); ++i) &#123;            const auto&amp; current_interval = intervals[i];            auto&amp; last_merged_interval = merged.back();            if (current_interval[0] &lt;= last_merged_interval[1]) &#123;                last_merged_interval[1] = max(last_merged_interval[1], current_interval[1]);            &#125; else &#123;                merged.push_back(current_interval);            &#125;        &#125;        return merged;    &#125;&#125;;\n\n结果执行用时 : 28 ms, 击败 76.03% 使用 C++ 的用户\n内存消耗 : 22.21 MB, 击败 26.87% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int[][] merge(int[][] intervals) &#123;        if (intervals == null || intervals.length == 0) &#123;            return new int[0][];        &#125;        Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[0], b[0]));        List&lt;int[]&gt; merged = new ArrayList&lt;&gt;();        merged.add(intervals[0]);        for (int i = 1; i &lt; intervals.length; i++) &#123;            int[] currentInterval = intervals[i];            int[] lastMergedInterval = merged.get(merged.size() - 1);            if (currentInterval[0] &lt;= lastMergedInterval[1]) &#123;                lastMergedInterval[1] = Math.max(lastMergedInterval[1], currentInterval[1]);            &#125; else &#123;                merged.add(currentInterval);            &#125;        &#125;        return merged.toArray(new int[merged.size()][]);    &#125;&#125;\n\n结果执行用时 : 7 ms, 击败 82.65% 使用 Java 的用户\n内存消耗 : 45.46 MB, 击败 33.21% 使用 Java 的用户\n\nPythonclass Solution(object):    def merge(self, intervals):        &quot;&quot;&quot;        :type intervals: List[List[int]]        :rtype: List[List[int]]        &quot;&quot;&quot;        if not intervals:            return []        intervals.sort(key=lambda x: x[0])        merged = [intervals[0]]        for i in range(1, len(intervals)):            current_interval = intervals[i]            last_merged_interval = merged[-1]            if current_interval[0] &lt;= last_merged_interval[1]:                last_merged_interval[1] = max(last_merged_interval[1], current_interval[1])            else:                merged.append(current_interval)        return merged\n\n结果执行用时 : 36 ms, 击败 49.08% 使用 Python 的用户\n内存消耗 : 15.06 MB, 击败 80.24% 使用 Python 的用户\n\nPython3class Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        if not intervals:            return []        intervals.sort(key=lambda x: x[0])        merged = [intervals[0]]        for i in range(1, len(intervals)):            current_interval = intervals[i]            last_merged_interval = merged[-1]            if current_interval[0] &lt;= last_merged_interval[1]:                last_merged_interval[1] = max(last_merged_interval[1], current_interval[1])            else:                merged.append(current_interval)        return merged\n\n结果执行用时 : 59 ms, 击败 26.44% 使用 Python3 的用户\n内存消耗 : 19.45 MB, 击败 73.68% 使用 Python3 的用户\n\nCstruct vat &#123;    int start;    int end;&#125;;int compare(const void* a, const void* b) &#123;    return (((struct vat*)a)-&gt;start &lt; ((struct vat*)b)-&gt;start) ? -1 : (((struct vat*)a)-&gt;start &gt; ((struct vat*)b)-&gt;start) ? 1 : 0;&#125;int** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes) &#123;    struct vat* newVat = (struct vat*)malloc(intervalsSize * sizeof(struct vat));    for (int i = 0; i &lt; intervalsSize; i++) &#123;        newVat[i].start = intervals[i][0];        newVat[i].end = intervals[i][1];    &#125;    qsort(newVat, intervalsSize, sizeof(struct vat), compare);    int** returnInteval = (int**)malloc(sizeof(int*) * intervalsSize);    *returnColumnSizes = (int*)malloc(sizeof(int) * intervalsSize);    *returnSize = 0;    for (int i = 0; i &lt; intervalsSize; i++) &#123;        if (*returnSize) &#123;            int preEnd = returnInteval[*returnSize - 1][1];            if (newVat[i].start &lt;= preEnd) &#123;                int maxEnd = (preEnd &gt; newVat[i].end) ? preEnd : newVat[i].end;                returnInteval[*returnSize - 1][1] = maxEnd;            &#125; else &#123;                int newRow = *returnSize;                returnInteval[newRow] = (int*)malloc(sizeof(int) * 2);                returnInteval[newRow][0] = newVat[i].start;                returnInteval[newRow][1] = newVat[i].end;                (*returnColumnSizes)[newRow] = 2;                *returnSize = *returnSize + 1;            &#125;        &#125; else &#123;            int newRow = *returnSize;            returnInteval[newRow] = (int*)malloc(sizeof(int) * 2);            returnInteval[newRow][0] = newVat[i].start;            returnInteval[newRow][1] = newVat[i].end;            (*returnColumnSizes)[newRow] = 2;            *returnSize = *returnSize + 1;        &#125;    &#125;    returnInteval = (int**)realloc(returnInteval, (*returnSize) * sizeof(int*));    free(newVat);    return returnInteval;&#125;\n\n结果执行用时 : 49 ms, 击败 88.06% 使用 C 的用户\n内存消耗 : 12.22 MB, 击败 77.87% 使用 C 的用户\n\nC#public class Solution &#123;    public int[][] Merge(int[][] intervals) &#123;        if (intervals == null || intervals.Length == 0) &#123;            return new int[0][];        &#125;        Array.Sort(intervals, (a, b) =&gt; a[0].CompareTo(b[0]));        List&lt;int[]&gt; mergedIntervals = new List&lt;int[]&gt;();        int[] currentInterval = intervals[0];        for (int i = 1; i &lt; intervals.Length; i++) &#123;            if (currentInterval[1] &gt;= intervals[i][0]) &#123;                currentInterval[1] = Math.Max(currentInterval[1], intervals[i][1]);            &#125; else &#123;                mergedIntervals.Add(currentInterval);                currentInterval = intervals[i];            &#125;        &#125;        mergedIntervals.Add(currentInterval);        return mergedIntervals.ToArray();    &#125;&#125;\n\n结果执行用时 : 134 ms, 击败 96.73% 使用 C# 的用户\n内存消耗 : 55.09 MB, 击败 38.56% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[][]&#125; intervals * @return &#123;number[][]&#125; */var merge = function(intervals) &#123;    if (!intervals || intervals.length === 0) &#123;        return [];    &#125;    intervals.sort((a, b) =&gt; a[0] - b[0]);    let mergedIntervals = [intervals[0]];    for (let i = 1; i &lt; intervals.length; i++) &#123;        let currentInterval = intervals[i];        let lastMergedInterval = mergedIntervals[mergedIntervals.length - 1];        if (currentInterval[0] &lt;= lastMergedInterval[1]) &#123;            lastMergedInterval[1] = Math.max(lastMergedInterval[1], currentInterval[1]);        &#125; else &#123;            mergedIntervals.push(currentInterval);        &#125;    &#125;    return mergedIntervals;&#125;;\n\n结果执行用时 : 91 ms, 击败 68.92% 使用 JavaScript 的用户\n内存消耗 : 56.80 MB, 击败 38.99% 使用 JavaScript 的用户\n\nTypeScriptfunction merge(intervals: number[][]): number[][] &#123;    if (!intervals || intervals.length === 0) &#123;        return [];    &#125;    intervals.sort((a, b) =&gt; a[0] - b[0]);    const mergedIntervals: number[][] = [intervals[0]];    for (let i = 1; i &lt; intervals.length; i++) &#123;        const currentInterval = intervals[i];        const lastMergedInterval = mergedIntervals[mergedIntervals.length - 1];        if (currentInterval[0] &lt;= lastMergedInterval[1]) &#123;            lastMergedInterval[1] = Math.max(lastMergedInterval[1], currentInterval[1]);        &#125; else &#123;            mergedIntervals.push(currentInterval);        &#125;    &#125;    return mergedIntervals;&#125;\n\n结果执行用时 : 90 ms, 击败 84.93% 使用 TypeScript 的用户\n内存消耗 : 57.93 MB, 击败 32.46% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[][] $intervals     * @return Integer[][]     */    function merge($intervals) &#123;        if (empty($intervals)) &#123;            return [];        &#125;        sort($intervals);        $mergeArray = [$intervals[0]];        foreach ($intervals as $interval) &#123;            $start = $interval[0];            $end = $interval[1];            $lastMergedInterval = &amp;$mergeArray[count($mergeArray) - 1];            if ($start &lt;= $lastMergedInterval[1]) &#123;                $lastMergedInterval[1] = max($lastMergedInterval[1], $end);            &#125; else &#123;                $mergeArray[] = $interval;            &#125;        &#125;        return $mergeArray;    &#125;&#125;\n\n结果执行用时 : 48 ms, 击败 75.00% 使用 PHP 的用户\n内存消耗 : 28.94 MB, 击败 50.00% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func merge(_ intervals: [[Int]]) -&gt; [[Int]] &#123;        if intervals.isEmpty &#123;            return []        &#125;        let sortedIntervals = intervals.sorted &#123; $0[0] &lt; $1[0] &#125;        var mergeArray = [sortedIntervals[0]]        for interval in sortedIntervals &#123;            let start = interval[0]            let end = interval[1]            if start &lt;= mergeArray.last![1] &#123;                mergeArray[mergeArray.count - 1][1] = max(mergeArray.last![1], end)            &#125; else &#123;                mergeArray.append(interval)            &#125;        &#125;        return mergeArray    &#125;&#125;\n\n结果执行用时 : 63 ms, 击败 96.53% 使用 Swift 的用户\n内存消耗 : 17.29 MB, 击败 20.14% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun merge(intervals: Array&lt;IntArray&gt;): Array&lt;IntArray&gt; &#123;        if (intervals.isEmpty()) &#123;            return emptyArray()        &#125;        val sortedIntervals = intervals.sortedBy &#123; it[0] &#125;        val mergeArray = mutableListOf(sortedIntervals[0])        for (interval in sortedIntervals) &#123;            val start = interval[0]            val end = interval[1]            if (start &lt;= mergeArray.last()[1]) &#123;                mergeArray.last()[1] = maxOf(mergeArray.last()[1], end)            &#125; else &#123;                mergeArray.add(interval)            &#125;        &#125;        return mergeArray.toTypedArray()    &#125;&#125;\n\n结果执行用时 : 345 ms, 击败 24.69% 使用 Kotlin 的用户\n内存消耗 : 48.93 MB, 击败 18.52% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;List&lt;int&gt;&gt; merge(List&lt;List&lt;int&gt;&gt; intervals) &#123;    if (intervals == null || intervals.isEmpty) &#123;      return [];    &#125;    intervals.sort((a, b) =&gt; a[0] - b[0]);    List&lt;List&lt;int&gt;&gt; mergeArray = [intervals[0]];    for (List&lt;int&gt; interval in intervals) &#123;      int start = interval[0];      int end = interval[1];      if (start &lt;= mergeArray.last[1]) &#123;        mergeArray.last[1] = mergeArray.last[1].compareTo(end) &gt; 0            ? mergeArray.last[1]            : end;      &#125; else &#123;        mergeArray.add([start, end]);      &#125;    &#125;    return mergeArray;  &#125;&#125;\n\n结果执行用时 : 344 ms, 击败 88.89% 使用 Dart 的用户\n内存消耗 : 153.66 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc merge(intervals [][]int) [][]int &#123;    if len(intervals) == 0 &#123;        return [][]int&#123;&#125;    &#125;    sort.Slice(intervals, func(i, j int) bool &#123;        return intervals[i][0] &lt; intervals[j][0]    &#125;)    merged := [][]int&#123;intervals[0]&#125;    for _, interval := range intervals &#123;        start, end := interval[0], interval[1]        if start &lt;= merged[len(merged)-1][1] &#123;            merged[len(merged)-1][1] = max(merged[len(merged)-1][1], end)        &#125; else &#123;            merged = append(merged, []int&#123;start, end&#125;)        &#125;    &#125;    return merged&#125;func max(a, b int) int &#123;    if a &gt; b &#123;        return a    &#125;    return b&#125;\n\n结果执行用时 : 15 ms, 击败 79.75% 使用 Go 的用户\n内存消耗 : 6.43 MB, 击败 29.05% 使用 Go 的用户\n\nRuby# @param &#123;Integer[][]&#125; intervals# @return &#123;Integer[][]&#125;def merge(intervals)  return [] if intervals.empty?  intervals.sort! &#123; |a, b| a[0] - b[0] &#125;  merged = [intervals[0]]  intervals.each do |interval|    start, end_point = interval    if start &lt;= merged.last[1]      merged.last[1] = [merged.last[1], end_point].max    else      merged &lt;&lt; [start, end_point]    end  end  mergedend\n\n结果执行用时 : 102 ms, 击败 50.00% 使用 Ruby 的用户\n内存消耗 : 209.96 MB, 击败 12.50% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def merge(intervals: Array[Array[Int]]): Array[Array[Int]] = &#123;    if (intervals.isEmpty) &#123;      Array.empty[Array[Int]]    &#125; else &#123;      val sortedIntervals = intervals.sortBy(_.head)      var mergeArray = Array(sortedIntervals.head)      for (interval &lt;- sortedIntervals.tail) &#123;        val start = interval.head        val end = interval.last        if (start &lt;= mergeArray.last.last) &#123;          mergeArray = mergeArray.init :+ Array(mergeArray.last.head, end.max(mergeArray.last.last))        &#125; else &#123;          mergeArray :+= interval        &#125;      &#125;      mergeArray    &#125;  &#125;&#125;\n\n结果执行用时 : 702 ms, 击败 33.33% 使用 Scala 的用户\n内存消耗 : 60.02 MB, 击败 83.33% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn merge(intervals: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; &#123;        if intervals.is_empty() &#123;            return Vec::new();        &#125;        let mut sorted_intervals = intervals.clone();        sorted_intervals.sort_by(|a, b| a[0].cmp(&amp;b[0]));        let mut merged = vec![sorted_intervals[0].clone()];        for interval in sorted_intervals.iter().skip(1) &#123;            let start = interval[0];            let end = interval[1];            if start &lt;= merged.last().unwrap()[1] &#123;                let last_merged = merged.last_mut().unwrap();                last_merged[1] = last_merged[1].max(end);            &#125; else &#123;                merged.push(interval.clone());            &#125;        &#125;        merged    &#125;&#125;\n\n结果执行用时 : 7 ms, 击败 38.30% 使用 Rust 的用户\n内存消耗 : 3.51 MB, 击败 5.68% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"惊蛰","url":"/zh-CN/43849f67794f/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  惊蛰\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","惊蛰"]},{"title":"力扣00057.插入区间","url":"/zh-CN/8f4205b77ba0/","content":"\n题目描述给你一个 无重叠的 ，按照区间起始端点排序的区间列表。\n在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。\n示例 1：\n输入：intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]输出：[[1,5],[6,9]]\n\n示例 2：\n输入：intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]输出：[[1,2],[3,10],[12,16]]解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。\n\n示例 3：\n输入：intervals &#x3D; [], newInterval &#x3D; [5,7]输出：[[5,7]]\n\n示例 4：\n输入：intervals &#x3D; [[1,5]], newInterval &#x3D; [2,3]输出：[[1,5]]\n\n示例 5：\n输入：intervals &#x3D; [[1,5]], newInterval &#x3D; [2,7]输出：[[1,7]]\n\n提示：\n$0 &lt;&#x3D; intervals.length &lt;&#x3D; 10^4$\nintervals[i].length &#x3D;&#x3D; 2\n$0 &lt;&#x3D; intervals[i][0] &lt;&#x3D; intervals[i][1] &lt;&#x3D; 10^5$\nintervals 根据 intervals[i][0] 按 升序 排列\nnewInterval.length &#x3D;&#x3D; 2\n$0 &lt;&#x3D; newInterval[0] &lt;&#x3D; newInterval[1] &lt;&#x3D; 10^5$\n\n\n解决方法C++class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        int i = 0;        while (i &lt; intervals.size() &amp;&amp; intervals[i][1] &lt; newInterval[0]) &#123;            result.push_back(intervals[i]);            i++;        &#125;        while (i &lt; intervals.size() &amp;&amp; intervals[i][0] &lt;= newInterval[1]) &#123;            newInterval[0] = min(newInterval[0], intervals[i][0]);            newInterval[1] = max(newInterval[1], intervals[i][1]);            i++;        &#125;        result.push_back(newInterval);        while (i &lt; intervals.size()) &#123;            result.push_back(intervals[i]);            i++;        &#125;        return result;    &#125;&#125;;\n\n结果执行用时 : 10 ms, 击败 83.58% 使用 C++ 的用户\n内存消耗 : 19.94 MB, 击败 34.44% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int[][] insert(int[][] intervals, int[] newInterval) &#123;        List&lt;int[]&gt; result = new ArrayList&lt;&gt;();        int i = 0;        while (i &lt; intervals.length &amp;&amp; intervals[i][1] &lt; newInterval[0]) &#123;            result.add(intervals[i]);            i++;        &#125;        while (i &lt; intervals.length &amp;&amp; intervals[i][0] &lt;= newInterval[1]) &#123;            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);            i++;        &#125;        result.add(newInterval);        while (i &lt; intervals.length) &#123;            result.add(intervals[i]);            i++;        &#125;        return result.toArray(new int[result.size()][]);    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 96.15% 使用 Java 的用户\n内存消耗 : 43.74 MB, 击败 44.16% 使用 Java 的用户\n\nPythonclass Solution(object):    def insert(self, intervals, newInterval):        &quot;&quot;&quot;        :type intervals: List[List[int]]        :type newInterval: List[int]        :rtype: List[List[int]]        &quot;&quot;&quot;        result = []        i = 0        while i &lt; len(intervals) and intervals[i][1] &lt; newInterval[0]:            result.append(intervals[i])            i += 1        while i &lt; len(intervals) and intervals[i][0] &lt;= newInterval[1]:            newInterval[0] = min(newInterval[0], intervals[i][0])            newInterval[1] = max(newInterval[1], intervals[i][1])            i += 1        result.append(newInterval)        while i &lt; len(intervals):            result.append(intervals[i])            i += 1        return result\n\n结果执行用时 : 20 ms, 击败 75.85% 使用 Python 的用户\n内存消耗 : 13.05 MB, 击败 81.10% 使用 Python 的用户\n\nPython3class Solution:    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:        result = []        i = 0        while i &lt; len(intervals) and intervals[i][1] &lt; newInterval[0]:            result.append(intervals[i])            i += 1        while i &lt; len(intervals) and intervals[i][0] &lt;= newInterval[1]:            newInterval[0] = min(newInterval[0], intervals[i][0])            newInterval[1] = max(newInterval[1], intervals[i][1])            i += 1        result.append(newInterval)        while i &lt; len(intervals):            result.append(intervals[i])            i += 1        return result\n\n结果执行用时 : 51 ms, 击败 20.89% 使用 Python3 的用户\n内存消耗 : 18.55 MB, 击败 50.93% 使用 Python3 的用户\n\nC/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int** insert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int* returnSize, int** returnColumnSizes) &#123;    *returnSize = 0;    int left = newInterval[0];    int right = newInterval[1];    bool placed = false;    int** ans = malloc(sizeof(int*) * (intervalsSize + 1));    *returnColumnSizes = malloc(sizeof(int) * (intervalsSize + 1));    for (int i = 0; i &lt; intervalsSize; ++i) &#123;        int* interval = intervals[i];        if (interval[0] &gt; right) &#123;            if (!placed) &#123;                int* tmp = malloc(sizeof(int) * 2);                tmp[0] = left, tmp[1] = right;                (*returnColumnSizes)[*returnSize] = 2;                ans[(*returnSize)++] = tmp;                placed = true;            &#125;            int* tmp = malloc(sizeof(int) * 2);            memcpy(tmp, interval, sizeof(int) * 2);            (*returnColumnSizes)[*returnSize] = 2;            ans[(*returnSize)++] = tmp;        &#125; else if (interval[1] &lt; left) &#123;            int* tmp = malloc(sizeof(int) * 2);            memcpy(tmp, interval, sizeof(int) * 2);            (*returnColumnSizes)[*returnSize] = 2;            ans[(*returnSize)++] = tmp;        &#125; else &#123;            left = fmin(left, interval[0]);            right = fmax(right, interval[1]);        &#125;    &#125;    if (!placed) &#123;        int* tmp = malloc(sizeof(int) * 2);        tmp[0] = left, tmp[1] = right;        (*returnColumnSizes)[*returnSize] = 2;        ans[(*returnSize)++] = tmp;    &#125;    return ans;&#125;void freeMemory(int** intervals, int returnSize, int* returnColumnSizes) &#123;    for (int i = 0; i &lt; returnSize; i++) &#123;        free(intervals[i]);    &#125;    free(intervals);    free(returnColumnSizes);&#125;\n\n结果执行用时 : 13 ms, 击败 69.23% 使用 C 的用户\n内存消耗 : 7.73 MB, 击败 93.01% 使用 C 的用户\n\nC#public class Solution &#123;    public int[][] Insert(int[][] intervals, int[] newInterval) &#123;        List&lt;int[]&gt; result = new List&lt;int[]&gt;();        int left = newInterval[0];        int right = newInterval[1];        bool placed = false;        foreach (int[] interval in intervals) &#123;            if (interval[1] &lt; left) &#123;                result.Add(interval);            &#125; else if (interval[0] &gt; right) &#123;                if (!placed) &#123;                    result.Add(new int[] &#123; left, right &#125;);                    placed = true;                &#125;                result.Add(interval);            &#125; else &#123;                left = Math.Min(left, interval[0]);                right = Math.Max(right, interval[1]);            &#125;        &#125;        if (!placed) &#123;            result.Add(new int[] &#123; left, right &#125;);        &#125;        return result.ToArray();    &#125;&#125;\n\n结果执行用时 : 125 ms, 击败 55.91% 使用 C# 的用户\n内存消耗 : 49.94 MB, 击败 16.13% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[][]&#125; intervals * @param &#123;number[]&#125; newInterval * @return &#123;number[][]&#125; */var insert = function(intervals, newInterval) &#123;    let result = [];    let left = newInterval[0];    let right = newInterval[1];    let placed = false;    for (let interval of intervals) &#123;        if (interval[1] &lt; left) &#123;            result.push(interval);        &#125; else if (interval[0] &gt; right) &#123;            if (!placed) &#123;                result.push([left, right]);                placed = true;            &#125;            result.push(interval);        &#125; else &#123;            left = Math.min(left, interval[0]);            right = Math.max(right, interval[1]);        &#125;    &#125;    if (!placed) &#123;        result.push([left, right]);    &#125;    return result;&#125;;\n\n结果执行用时 : 71 ms, 击败 72.40% 使用 JavaScript 的用户\n内存消耗 : 52.78 MB, 击败 14.99% 使用 JavaScript 的用户\n\nTypeScriptfunction insert(intervals: number[][], newInterval: number[]): number[][] &#123;    let result: number[][] = [];    let left: number = newInterval[0];    let right: number = newInterval[1];    let placed: boolean = false;    for (let interval of intervals) &#123;        if (interval[1] &lt; left) &#123;            result.push(interval);        &#125; else if (interval[0] &gt; right) &#123;            if (!placed) &#123;                result.push([left, right]);                placed = true;            &#125;            result.push(interval);        &#125; else &#123;            left = Math.min(left, interval[0]);            right = Math.max(right, interval[1]);        &#125;    &#125;    if (!placed) &#123;        result.push([left, right]);    &#125;    return result;&#125;\n\n结果执行用时 : 80 ms, 击败 52.83% 使用 TypeScript 的用户\n内存消耗 : 54.35 MB, 击败 13.21% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[][] $intervals     * @param Integer[] $newInterval     * @return Integer[][]     */    function insert($intervals, $newInterval) &#123;        $result = [];        $left = $newInterval[0];        $right = $newInterval[1];        $placed = false;        foreach ($intervals as $interval) &#123;            if ($interval[1] &lt; $left) &#123;                $result[] = $interval;            &#125; else if ($interval[0] &gt; $right) &#123;                if (!$placed) &#123;                    $result[] = [$left, $right];                    $placed = true;                &#125;                $result[] = $interval;            &#125; else &#123;                $left = min($left, $interval[0]);                $right = max($right, $interval[1]);            &#125;        &#125;        if (!$placed) &#123;            $result[] = [$left, $right];        &#125;        return $result;    &#125;&#125;\n\n结果执行用时 : 23 ms, 击败 54.55% 使用 PHP 的用户\n内存消耗 : 24.38 MB, 击败 72.73% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -&gt; [[Int]] &#123;        var result: [[Int]] = []        var left = newInterval[0]        var right = newInterval[1]        var placed = false        for interval in intervals &#123;            if interval[1] &lt; left &#123;                result.append(interval)            &#125; else if interval[0] &gt; right &#123;                if !placed &#123;                    result.append([left, right])                    placed = true                &#125;                result.append(interval)            &#125; else &#123;                left = min(left, interval[0])                right = max(right, interval[1])            &#125;        &#125;        if !placed &#123;            result.append([left, right])        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 33 ms, 击败 77.55% 使用 Swift 的用户\n内存消耗 : 16.31 MB, 击败 16.33% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun insert(intervals: Array&lt;IntArray&gt;, newInterval: IntArray): Array&lt;IntArray&gt; &#123;        val result = mutableListOf&lt;IntArray&gt;()        var left = newInterval[0]        var right = newInterval[1]        var placed = false        for (interval in intervals) &#123;            if (interval[1] &lt; left) &#123;                result.add(interval)            &#125; else if (interval[0] &gt; right) &#123;                if (!placed) &#123;                    result.add(intArrayOf(left, right))                    placed = true                &#125;                result.add(interval)            &#125; else &#123;                left = left.coerceAtMost(interval[0])                right = right.coerceAtLeast(interval[1])            &#125;        &#125;        if (!placed) &#123;            result.add(intArrayOf(left, right))        &#125;        return result.toTypedArray()    &#125;&#125;\n\n结果执行用时 : 237 ms, 击败 62.50% 使用 Kotlin 的用户\n内存消耗 : 42.70 MB, 击败 8.33% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;List&lt;int&gt;&gt; insert(List&lt;List&lt;int&gt;&gt; intervals, List&lt;int&gt; newInterval) &#123;    List&lt;List&lt;int&gt;&gt; result = [];    int left = newInterval[0];    int right = newInterval[1];    bool placed = false;    for (List&lt;int&gt; interval in intervals) &#123;        if (interval[1] &lt; left) &#123;        result.add(interval);        &#125; else if (interval[0] &gt; right) &#123;        if (!placed) &#123;            result.add([left, right]);            placed = true;        &#125;        result.add(interval);        &#125; else &#123;        left = left &lt; interval[0] ? left : interval[0];        right = right &gt; interval[1] ? right : interval[1];        &#125;    &#125;    if (!placed) &#123;        result.add([left, right]);    &#125;    return result;    &#125;&#125;\n\n结果执行用时 : 337 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 145.83 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc insert(intervals [][]int, newInterval []int) [][]int &#123;\tresult := make([][]int, 0)\tleft, right := newInterval[0], newInterval[1]\tplaced := false\tfor _, interval := range intervals &#123;\t\tif interval[1] &lt; left &#123;\t\t\tresult = append(result, interval)\t\t&#125; else if interval[0] &gt; right &#123;\t\t\tif !placed &#123;\t\t\t\tresult = append(result, []int&#123;left, right&#125;)\t\t\t\tplaced = true\t\t\t&#125;\t\t\tresult = append(result, interval)\t\t&#125; else &#123;\t\t\tleft = min(left, interval[0])\t\t\tright = max(right, interval[1])\t\t&#125;\t&#125;\tif !placed &#123;\t\tresult = append(result, []int&#123;left, right&#125;)\t&#125;\treturn result&#125;func min(a, b int) int &#123;\tif a &lt; b &#123;\t\treturn a\t&#125;\treturn b&#125;func max(a, b int) int &#123;\tif a &gt; b &#123;\t\treturn a\t&#125;\treturn b&#125;\n\n结果执行用时 : 7 ms, 击败 31.86% 使用 Go 的用户\n内存消耗 : 4.20 MB, 击败 33.05% 使用 Go 的用户\n\nRuby# @param &#123;Integer[][]&#125; intervals# @param &#123;Integer[]&#125; new_interval# @return &#123;Integer[][]&#125;def insert(intervals, new_interval)  result = []  left, right = new_interval[0], new_interval[1]  placed = false  intervals.each do |interval|    if interval[1] &lt; left      result &lt;&lt; interval    elsif interval[0] &gt; right      unless placed        result &lt;&lt; [left, right]        placed = true      end      result &lt;&lt; interval    else      left = [left, interval[0]].min      right = [right, interval[1]].max    end  end  result &lt;&lt; [left, right] unless placed  resultend\n\n结果执行用时 : 68 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.96 MB, 击败 50.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def insert(intervals: Array[Array[Int]], newInterval: Array[Int]): Array[Array[Int]] = &#123;    var result: List[Array[Int]] = List()    var left = newInterval(0)    var right = newInterval(1)    var placed = false    for (interval &lt;- intervals) &#123;      if (interval(1) &lt; left) &#123;        result :+= interval      &#125; else if (interval(0) &gt; right) &#123;        if (!placed) &#123;          result :+= Array(left, right)          placed = true        &#125;        result :+= interval      &#125; else &#123;        left = left min interval(0)        right = right max interval(1)      &#125;    &#125;    if (!placed) &#123;      result :+= Array(left, right)    &#125;    result.toArray  &#125;&#125;\n\n结果执行用时 : 540 ms, 击败 77.78% 使用 Scala 的用户\n内存消耗 : 57.64 MB, 击败 88.89% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn insert(intervals: Vec&lt;Vec&lt;i32&gt;&gt;, new_interval: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; &#123;        let mut result: Vec&lt;Vec&lt;i32&gt;&gt; = Vec::new();        let mut left = new_interval[0];        let mut right = new_interval[1];        let mut placed = false;        for interval in intervals &#123;            if interval[1] &lt; left &#123;                result.push(interval);            &#125; else if interval[0] &gt; right &#123;                if !placed &#123;                    result.push(vec![left, right]);                    placed = true;                &#125;                result.push(interval);            &#125; else &#123;                left = left.min(interval[0]);                right = right.max(interval[1]);            &#125;        &#125;        if !placed &#123;            result.push(vec![left, right]);        &#125;        result    &#125;&#125;\n\n结果执行用时 : 2 ms, 击败 50.00% 使用 Rust 的用户\n内存消耗 : 2.64 MB, 击败 40.32% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"女超人 第五季 第十四集 保镖","url":"/zh-CN/568370eace88/","content":"\n剧情介绍　　莱克斯指派女超人保护安德烈亚，免受一名反科技极端分子的威胁，但他的真正目的不仅仅是确保安德烈亚的安全。与此同时，莉娜在莱克斯的帮助下继续推进“非伤害计划”。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第一季 第十四集 喜笑颜开","url":"/zh-CN/775b8d737678/","content":"\n剧情介绍　　蝙蝠女侠和卢克追踪一名以社交媒体达人为目标的反派。索菲意外地接到母亲的拜访，而玛丽则提供她的专业知识来协助凯特。雅各布·凯恩被要求兑现一个人情，而爱丽丝则专注于她的复仇计划。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00058.最后一个单词的长度","url":"/zh-CN/f19586c0444b/","content":"\n题目描述给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。\n单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。\n示例 1：\n输入：s &#x3D; “Hello World”输出：5解释：最后一个单词是 “World” ，长度为 5 。\n\n示例 2：\n输入：s &#x3D; “   fly me   to   the moon  “输出：4解释：最后一个单词是 “moon” ，长度为 4 。\n\n示例 3：\n输入：s &#x3D; “luffy is still joyboy”输出：6解释：最后一个单词是长度为 6 的 “joyboy” 。\n\n提示：\n$1 &lt;&#x3D; s.length &lt;&#x3D; 10^4$\ns 仅有英文字母和空格 ‘ ‘ 组成\ns 中至少存在一个单词\n\n\n解决方法C++class Solution &#123;public:    int lengthOfLastWord(string s) &#123;        int end = s.length() - 1;        while (end &gt;= 0 &amp;&amp; s[end] == &#x27; &#x27;) &#123;            end--;        &#125;        int lastWordStart = end;        while (lastWordStart &gt;= 0 &amp;&amp; s[lastWordStart] != &#x27; &#x27;) &#123;            lastWordStart--;        &#125;        return end - lastWordStart;    &#125;&#125;;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C++ 的用户\n内存消耗 : 7.54 MB, 击败 19.53% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int lengthOfLastWord(String s) &#123;        int end = s.length() - 1;        while (end &gt;= 0 &amp;&amp; s.charAt(end) == &#x27; &#x27;) &#123;            end--;        &#125;        int lastWordStart = end;        while (lastWordStart &gt;= 0 &amp;&amp; s.charAt(lastWordStart) != &#x27; &#x27;) &#123;            lastWordStart--;        &#125;        return end - lastWordStart;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 40.55 MB, 击败 49.20% 使用 Java 的用户\n\nPythonclass Solution(object):    def lengthOfLastWord(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: int        &quot;&quot;&quot;        s = s.rstrip()        last_word_start = s.rfind(&#x27; &#x27;) + 1        last_word = s[last_word_start:]        return len(last_word)\n\n结果执行用时 : 18 ms, 击败 37.79% 使用 Python 的用户\n内存消耗 : 11.60 MB, 击败 80.19% 使用 Python 的用户\n\nPython3class Solution:    def lengthOfLastWord(self, s: str) -&gt; int:        s = s.rstrip()        last_word_start = s.rfind(&#x27; &#x27;) + 1        last_word = s[last_word_start:]        return len(last_word)\n\n结果执行用时 : 35 ms, 击败 81.73% 使用 Python3 的用户\n内存消耗 : 16.40 MB, 击败 52.41% 使用 Python3 的用户\n\nCint lengthOfLastWord(char* s) &#123;    int end = strlen(s) - 1;    while (end &gt;= 0 &amp;&amp; s[end] == &#x27; &#x27;) &#123;        end--;    &#125;    int lastWordStart = end;    while (lastWordStart &gt;= 0 &amp;&amp; s[lastWordStart] != &#x27; &#x27;) &#123;        lastWordStart--;    &#125;    return end - lastWordStart;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 5.57 MB, 击败 82.29% 使用 C 的用户\n\nC#public class Solution &#123;    public int LengthOfLastWord(string s) &#123;        s = s.TrimEnd();        int lastWordStart = s.LastIndexOf(&#x27; &#x27;) + 1;        string lastWord = s.Substring(lastWordStart);        return lastWord.Length;    &#125;&#125;\n\n结果执行用时 : 42 ms, 击败 82.74% 使用 C# 的用户\n内存消耗 : 37.95 MB, 击败 21.18% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLastWord = function(s) &#123;    s = s.trim();    var lastWordStart = s.lastIndexOf(&#x27; &#x27;) + 1;    var lastWord = s.substring(lastWordStart);    return lastWord.length;&#125;;\n\n结果执行用时 : 50 ms, 击败 92.33% 使用 JavaScript 的用户\n内存消耗 : 49.13 MB, 击败 12.51% 使用 JavaScript 的用户\n\nTypeScriptfunction lengthOfLastWord(s: string): number &#123;    s = s.trim();    const lastWordStart: number = s.lastIndexOf(&#x27; &#x27;) + 1;    const lastWord: string = s.substring(lastWordStart);    return lastWord.length;&#125;\n\n结果执行用时 : 69 ms, 击败 20.00% 使用 TypeScript 的用户\n内存消耗 : 51.54 MB, 击败 11.38% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String $s     * @return Integer     */    function lengthOfLastWord($s) &#123;        if (empty($s)) &#123;            return 0;        &#125;        $trimmed = rtrim($s);        $len = 0;        $i = strlen($trimmed) - 1;        while ($i &gt;= 0 &amp;&amp; $trimmed[$i] != &#x27; &#x27;) &#123;            $len++;            $i--;        &#125;        return $len;    &#125;&#125;\n\n结果执行用时 : 5 ms, 击败 64.58% 使用 PHP 的用户\n内存消耗 : 19.83 MB, 击败 35.42% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func lengthOfLastWord(_ s: String) -&gt; Int &#123;        let trimmed = s.trimmingCharacters(in: .whitespaces)        var len = 0        var i = trimmed.count - 1        while i &gt;= 0 &amp;&amp; trimmed[trimmed.index(trimmed.startIndex, offsetBy: i)] != &quot; &quot; &#123;            len += 1            i -= 1        &#125;        return len    &#125;&#125;\n\n结果执行用时 : 54 ms, 击败 9.48% 使用 Swift 的用户\n内存消耗 : 16.57 MB, 击败 6.89% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun lengthOfLastWord(s: String): Int &#123;        val trimmed = s.trim()        var len = 0        var i = trimmed.length - 1        while (i &gt;= 0 &amp;&amp; trimmed[i] != &#x27; &#x27;) &#123;            len++            i--        &#125;        return len    &#125;&#125;\n\n结果执行用时 : 160 ms, 击败 51.43% 使用 Kotlin 的用户\n内存消耗 : 36.84 MB, 击败 27.14% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int lengthOfLastWord(String s) &#123;    String trimmed = s.trim();    int len = 0;    int i = trimmed.length - 1;    while (i &gt;= 0 &amp;&amp; trimmed[i] != &#x27; &#x27;) &#123;      len++;      i--;    &#125;    return len;  &#125;&#125;\n\n结果执行用时 : 276 ms, 击败 44.44% 使用 Dart 的用户\n内存消耗 : 146.03 MB, 击败 72.22% 使用 Dart 的用户\n\nGofunc lengthOfLastWord(s string) int &#123;    trimmed := strings.TrimSpace(s)    wordLen := 0    i := len(trimmed) - 1    for i &gt;= 0 &amp;&amp; trimmed[i] != &#x27; &#x27; &#123;        wordLen++        i--    &#125;    return wordLen&#125;\n\n结果执行用时 : 1 ms, 击败 13.07% 使用 Go 的用户\n内存消耗 : 2.02 MB, 击败 86.59% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; s# @return &#123;Integer&#125;def length_of_last_word(s)  trimmed = s.strip  len = 0  i = trimmed.length - 1  while i &gt;= 0 &amp;&amp; trimmed[i] != &#x27; &#x27;    len += 1    i -= 1  end  lenend\n\n结果执行用时 : 53 ms, 击败 90.91% 使用 Ruby 的用户\n内存消耗 : 206.53 MB, 击败 45.45% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def lengthOfLastWord(s: String): Int = &#123;    val trimmed = s.trim    var len = 0    var i = trimmed.length - 1    while (i &gt;= 0 &amp;&amp; trimmed(i) != &#x27; &#x27;) &#123;      len += 1      i -= 1    &#125;    len  &#125;&#125;\n\n结果执行用时 : 517 ms, 击败 25.00% 使用 Scala 的用户\n内存消耗 : 53.95 MB, 击败 25.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn length_of_last_word(s: String) -&gt; i32 &#123;        let trimmed = s.trim();        let mut len = 0;        let mut i = trimmed.len() as i32 - 1;        while i &gt;= 0 &amp;&amp; trimmed.chars().nth(i as usize).unwrap() != &#x27; &#x27; &#123;            len += 1;            i -= 1;        &#125;        len    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.12 MB, 击败 31.82% 使用 Rust 的用户\n\nRacket(define/contract (length-of-last-word s)  (-&gt; string? exact-integer?)  (define trimmed (string-trim s))  (let loop ((len 0) (i (- (string-length trimmed) 1)))    (cond      ((and (&gt;= i 0) (not (char=? (string-ref trimmed i) #\\space)))       (loop (+ len 1) (- i 1)))      (else       len))))\n\n结果执行用时 : 189 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 99.26 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"黑闪电 第三季 第十六集 战争之书：第三章：解放","url":"/zh-CN/c6ddc682b3a3/","content":"\n剧情介绍　　黑闪电与墓地掘者展开对决。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00059.螺旋矩阵 II","url":"/zh-CN/8fe8227b4a88/","content":"\n题目描述给你一个正整数 n ，生成一个包含 1 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n示例 1：\n\n\n输入：n &#x3D; 3输出：[[1,2,3],[8,9,4],[7,6,5]]\n\n示例 2：\n输入：n &#x3D; 1输出：[[1]]\n\n提示：\n1 &lt;&#x3D; n &lt;&#x3D; 20\n\n\n解决方法C++class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n, 0));        int top = 0, bottom = n - 1, left = 0, right = n - 1;        int num = 1;        while (num &lt;= n * n) &#123;            for (int i = left; i &lt;= right; ++i) &#123;                matrix[top][i] = num++;            &#125;            ++top;            for (int i = top; i &lt;= bottom; ++i) &#123;                matrix[i][right] = num++;            &#125;            --right;            for (int i = right; i &gt;= left; --i) &#123;                matrix[bottom][i] = num++;            &#125;            --bottom;            for (int i = bottom; i &gt;= top; --i) &#123;                matrix[i][left] = num++;            &#125;            ++left;        &#125;        return matrix;    &#125;&#125;;\n\n结果执行用时 : 2 ms, 击败 31.17% 使用 C++ 的用户\n内存消耗 : 7.64 MB, 击败 7.68% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int[][] generateMatrix(int n) &#123;        int[][] matrix = new int[n][n];        int top = 0, bottom = n - 1, left = 0, right = n - 1;        int num = 1;        while (num &lt;= n * n) &#123;            for (int i = left; i &lt;= right; ++i) &#123;                matrix[top][i] = num++;            &#125;            ++top;            for (int i = top; i &lt;= bottom; ++i) &#123;                matrix[i][right] = num++;            &#125;            --right;            for (int i = right; i &gt;= left; --i) &#123;                matrix[bottom][i] = num++;            &#125;            --bottom;            for (int i = bottom; i &gt;= top; --i) &#123;                matrix[i][left] = num++;            &#125;            ++left;        &#125;        return matrix;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 40.53 MB, 击败 11.79% 使用 Java 的用户\n\nPythonclass Solution(object):    def generateMatrix(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: List[List[int]]        &quot;&quot;&quot;        matrix = [[0] * n for _ in range(n)]        top, bottom, left, right = 0, n - 1, 0, n - 1        num = 1        while num &lt;= n * n:            for i in range(left, right + 1):                matrix[top][i] = num                num += 1            top += 1            for i in range(top, bottom + 1):                matrix[i][right] = num                num += 1            right -= 1            for i in range(right, left - 1, -1):                matrix[bottom][i] = num                num += 1            bottom -= 1            for i in range(bottom, top - 1, -1):                matrix[i][left] = num                num += 1            left += 1        return matrix\n\n结果执行用时 : 12 ms, 击败 87.28% 使用 Python 的用户\n内存消耗 : 11.32 MB, 击败 97.99% 使用 Python 的用户\n\nPython3class Solution:    def generateMatrix(self, n: int) -&gt; List[List[int]]:        matrix = [[0] * n for _ in range(n)]        top, bottom, left, right = 0, n - 1, 0, n - 1        num = 1        while num &lt;= n * n:            for i in range(left, right + 1):                matrix[top][i] = num                num += 1            top += 1            for i in range(top, bottom + 1):                matrix[i][right] = num                num += 1            right -= 1            for i in range(right, left - 1, -1):                matrix[bottom][i] = num                num += 1            bottom -= 1            for i in range(bottom, top - 1, -1):                matrix[i][left] = num                num += 1            left += 1        return matrix\n\n结果执行用时 : 31 ms, 击败 93.71% 使用 Python3 的用户\n内存消耗 : 16.50 MB, 击败 40.40% 使用 Python3 的用户\n\nC/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int** generateMatrix(int n, int* returnSize, int** returnColumnSizes) &#123;    int** matrix = (int**)malloc(n * sizeof(int*));    for (int i = 0; i &lt; n; ++i) &#123;        matrix[i] = (int*)malloc(n * sizeof(int));    &#125;    int top = 0, bottom = n - 1, left = 0, right = n - 1;    int num = 1;    while (num &lt;= n * n) &#123;        for (int i = left; i &lt;= right; ++i) &#123;            matrix[top][i] = num++;        &#125;        ++top;        for (int i = top; i &lt;= bottom; ++i) &#123;            matrix[i][right] = num++;        &#125;        --right;        for (int i = right; i &gt;= left; --i) &#123;            matrix[bottom][i] = num++;        &#125;        --bottom;        for (int i = bottom; i &gt;= top; --i) &#123;            matrix[i][left] = num++;        &#125;        ++left;    &#125;    *returnSize = n;    *returnColumnSizes = (int*)malloc(n * sizeof(int));    for (int i = 0; i &lt; n; ++i) &#123;        (*returnColumnSizes)[i] = n;    &#125;    return matrix;&#125;\n\n结果执行用时 : 2 ms, 击败 62.52% 使用 C 的用户\n内存消耗 : 6.06 MB, 击败 76.93% 使用 C 的用户\n\nC#public class Solution &#123;    public int[][] GenerateMatrix(int n) &#123;        int[][] matrix = new int[n][];        for (int i = 0; i &lt; n; i++) &#123;            matrix[i] = new int[n];        &#125;        int top = 0, bottom = n - 1, left = 0, right = n - 1;        int num = 1;        while (num &lt;= n * n) &#123;            for (int i = left; i &lt;= right; i++) &#123;                matrix[top][i] = num++;            &#125;            top++;            for (int i = top; i &lt;= bottom; i++) &#123;                matrix[i][right] = num++;            &#125;            right--;            for (int i = right; i &gt;= left; i--) &#123;                matrix[bottom][i] = num++;            &#125;            bottom--;            for (int i = bottom; i &gt;= top; i--) &#123;                matrix[i][left] = num++;            &#125;            left++;        &#125;        return matrix;    &#125;&#125;\n\n结果执行用时 : 73 ms, 击败 68.89% 使用 C# 的用户\n内存消耗 : 37.83 MB, 击败 33.34% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number&#125; n * @return &#123;number[][]&#125; */var generateMatrix = function(n) &#123;    let matrix = new Array(n).fill().map(() =&gt; new Array(n).fill(0));    let top = 0, bottom = n - 1, left = 0, right = n - 1;    let num = 1;    while (num &lt;= n * n) &#123;        for (let i = left; i &lt;= right; i++) &#123;            matrix[top][i] = num++;        &#125;        top++;        for (let i = top; i &lt;= bottom; i++) &#123;            matrix[i][right] = num++;        &#125;        right--;        for (let i = right; i &gt;= left; i--) &#123;            matrix[bottom][i] = num++;        &#125;        bottom--;        for (let i = bottom; i &gt;= top; i--) &#123;            matrix[i][left] = num++;        &#125;        left++;    &#125;    return matrix;&#125;;\n\n结果执行用时 : 57 ms, 击败 65.69% 使用 JavaScript 的用户\n内存消耗 : 49.21 MB, 击败 16.31% 使用 JavaScript 的用户\n\nTypeScriptfunction generateMatrix(n: number): number[][] &#123;    const matrix: number[][] = Array.from(&#123; length: n &#125;, () =&gt; Array(n).fill(0));    let top = 0, bottom = n - 1, left = 0, right = n - 1;    let num = 1;    while (num &lt;= n * n) &#123;        for (let i = left; i &lt;= right; i++) &#123;            matrix[top][i] = num++;        &#125;        top++;        for (let i = top; i &lt;= bottom; i++) &#123;            matrix[i][right] = num++;        &#125;        right--;        for (let i = right; i &gt;= left; i--) &#123;            matrix[bottom][i] = num++;        &#125;        bottom--;        for (let i = bottom; i &gt;= top; i--) &#123;            matrix[i][left] = num++;        &#125;        left++;    &#125;    return matrix;&#125;\n\n结果执行用时 : 54 ms, 击败 95.24% 使用 TypeScript 的用户\n内存消耗 : 51.67 MB, 击败 14.88% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer $n     * @return Integer[][]     */    function generateMatrix($n) &#123;        $matrix = array_fill(0, $n, array_fill(0, $n, 0));        $top = 0; $bottom = $n - 1; $left = 0; $right = $n - 1;        $num = 1;        while ($num &lt;= $n * $n) &#123;            for ($i = $left; $i &lt;= $right; $i++) &#123;                $matrix[$top][$i] = $num++;            &#125;            $top++;            for ($i = $top; $i &lt;= $bottom; $i++) &#123;                $matrix[$i][$right] = $num++;            &#125;            $right--;            for ($i = $right; $i &gt;= $left; $i--) &#123;                $matrix[$bottom][$i] = $num++;            &#125;            $bottom--;            for ($i = $bottom; $i &gt;= $top; $i--) &#123;                $matrix[$i][$left] = $num++;            &#125;            $left++;        &#125;        return $matrix;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 PHP 的用户\n内存消耗 : 20.34 MB, 击败 12.50% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func generateMatrix(_ n: Int) -&gt; [[Int]] &#123;        var matrix = [[Int]].init(repeating: [Int].init(repeating: 0, count: n), count: n)        var direction: Direction = .right        var section = 0        var row = 0        for i in 1 ... (n * n) &#123;            if matrix[section][row] == 0 &#123;                matrix[section][row] = i            &#125;            switch direction &#123;            case .right:                if (row + 1) % n == 0 || matrix[section][row + 1] != 0 &#123;                    direction = .bottom                    section += 1                &#125; else &#123;                    row += 1                &#125;            case .bottom:                if section == n - 1 || matrix[section + 1][row] != 0 &#123;                    direction = .left                    row -= 1                &#125; else &#123;                    section += 1                &#125;            case .left:                if row == 0 || matrix[section][row - 1] != 0 &#123;                    direction = .top                    section -= 1                &#125; else &#123;                    row -= 1                &#125;            case .top:                if section == 0 || matrix[section - 1][row] != 0 &#123;                    direction = .right                    row += 1                &#125; else &#123;                    section -= 1                &#125;            &#125;        &#125;        return matrix    &#125;    enum Direction &#123;        case right, bottom, left, top    &#125;&#125;\n\n结果执行用时 : 6 ms, 击败 15.38% 使用 Swift 的用户\n内存消耗 : 16.06 MB, 击败 5.13% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun generateMatrix(n: Int): Array&lt;IntArray&gt; &#123;        val matrix = Array(n) &#123; IntArray(n) &#125;        var left = 0        var right = n - 1        var top = 0        var bottom = n - 1        var num = 1        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;            for (i in left..right) &#123;                matrix[top][i] = num++            &#125;            top++            for (i in top..bottom) &#123;                matrix[i][right] = num++            &#125;            right--            if (top &lt;= bottom) &#123;                for (i in right downTo left) &#123;                    matrix[bottom][i] = num++                &#125;                bottom--            &#125;            if (left &lt;= right) &#123;                for (i in bottom downTo top) &#123;                    matrix[i][left] = num++                &#125;                left++            &#125;        &#125;        return matrix    &#125;&#125;\n\n结果执行用时 : 146 ms, 击败 60.00% 使用 Kotlin 的用户\n内存消耗 : 33.64 MB, 击败 40.00% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;List&lt;int&gt;&gt; generateMatrix(int n) &#123;    List&lt;List&lt;int&gt;&gt; matrix = List.generate(n, (index) =&gt; List&lt;int&gt;.filled(n, 0));    int left = 0, right = n - 1, top = 0, bottom = n - 1;    int num = 1;    while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;        for (int i = left; i &lt;= right; i++) &#123;        matrix[top][i] = num++;        &#125;        top++;        for (int i = top; i &lt;= bottom; i++) &#123;        matrix[i][right] = num++;        &#125;        right--;        if (top &lt;= bottom) &#123;        for (int i = right; i &gt;= left; i--) &#123;            matrix[bottom][i] = num++;        &#125;        bottom--;        &#125;        if (left &lt;= right) &#123;        for (int i = bottom; i &gt;= top; i--) &#123;            matrix[i][left] = num++;        &#125;        left++;        &#125;    &#125;    return matrix;    &#125;&#125;\n\n结果执行用时 : 296 ms, 击败 50.00% 使用 Dart 的用户\n内存消耗 : 147.30 MB, 击败 -% 使用 Dart 的用户\n\nGofunc generateMatrix(n int) [][]int &#123;\tmatrix := make([][]int, n)\tfor i := range matrix &#123;\t\tmatrix[i] = make([]int, n)\t&#125;\tleft, right, top, bottom := 0, n-1, 0, n-1\tnum := 1\tfor left &lt;= right &amp;&amp; top &lt;= bottom &#123;\t\tfor i := left; i &lt;= right; i++ &#123;\t\t\tmatrix[top][i] = num\t\t\tnum++\t\t&#125;\t\ttop++\t\tfor i := top; i &lt;= bottom; i++ &#123;\t\t\tmatrix[i][right] = num\t\t\tnum++\t\t&#125;\t\tright--\t\tif top &lt;= bottom &#123;\t\t\tfor i := right; i &gt;= left; i-- &#123;\t\t\t\tmatrix[bottom][i] = num\t\t\t\tnum++\t\t\t&#125;\t\t\tbottom--\t\t&#125;\t\tif left &lt;= right &#123;\t\t\tfor i := bottom; i &gt;= top; i-- &#123;\t\t\t\tmatrix[i][left] = num\t\t\t\tnum++\t\t\t&#125;\t\t\tleft++\t\t&#125;\t&#125;\treturn matrix&#125;\n\n结果执行用时 : 1 ms, 击败 12.10% 使用 Go 的用户\n内存消耗 : 2.02 MB, 击败 74.07% 使用 Go 的用户\n\nRuby# @param &#123;Integer&#125; n# @return &#123;Integer[][]&#125;def generate_matrix(n)  matrix = Array.new(n) &#123; Array.new(n, 0) &#125;  left, right, top, bottom = 0, n - 1, 0, n - 1  num = 1  while left &lt;= right &amp;&amp; top &lt;= bottom    left.upto(right) do |i|      matrix[top][i] = num      num += 1    end    top += 1    top.upto(bottom) do |i|      matrix[i][right] = num      num += 1    end    right -= 1    if top &lt;= bottom      right.downto(left) do |i|        matrix[bottom][i] = num        num += 1      end      bottom -= 1    end    if left &lt;= right      bottom.downto(top) do |i|        matrix[i][left] = num        num += 1      end      left += 1    end  end  matrixend\n\n结果执行用时 : 63 ms, 击败 66.67% 使用 Ruby 的用户\n内存消耗 : 206.49 MB, 击败 33.33% 使用 Ruby 的用户\n\nScalaobject Solution &#123;    def generateMatrix(n: Int): Array[Array[Int]] = &#123;        val resultMatrix = new Array[Array[Int]](n)        (0 until n).foreach &#123; index =&gt;          resultMatrix(index) = new Array[Int](n)        &#125;        val resultNum = n * n        var rowBegin = 0        var rowEnd = n - 1        var columnBegin = 0        var columnEnd = n - 1        var insertNum = 1        while (insertNum &lt;= resultNum) &#123;          var columnTemp = columnBegin          while (columnTemp &lt;= columnEnd) &#123;            resultMatrix(rowBegin)(columnTemp) = insertNum            insertNum += 1            columnTemp += 1          &#125;          rowBegin += 1          var rowTemp = rowBegin          while (rowTemp &lt;= rowEnd) &#123;            resultMatrix(rowTemp)(columnEnd) = insertNum            insertNum += 1            rowTemp += 1          &#125;          columnEnd -= 1          columnTemp = columnEnd          while (columnTemp &gt;= columnBegin &amp;&amp; rowEnd &gt;= rowBegin) &#123;            resultMatrix(rowEnd)(columnTemp) = insertNum            insertNum += 1            columnTemp -= 1          &#125;          rowEnd -= 1          rowTemp = rowEnd          while (rowTemp &gt;= rowBegin &amp;&amp; columnEnd &gt;= columnBegin) &#123;            resultMatrix(rowTemp)(columnBegin) = insertNum            insertNum += 1            rowTemp -= 1          &#125;          columnBegin += 1        &#125;        resultMatrix    &#125;&#125;\n\n结果执行用时 : 428 ms, 击败 -% 使用 Scala 的用户\n内存消耗 : 51.61 MB, 击败 -% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn generate_matrix(n: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; &#123;        let mut result_matrix = vec![vec![0; n as usize]; n as usize];        let mut insert_num = 1;        let (mut row_begin, mut row_end, mut column_begin, mut column_end) = (0, n as usize - 1, 0, n as usize - 1);        while insert_num &lt;= n * n &#123;            for i in column_begin..=column_end &#123;                result_matrix[row_begin][i] = insert_num;                insert_num += 1;            &#125;            row_begin += 1;            for i in row_begin..=row_end &#123;                result_matrix[i][column_end] = insert_num;                insert_num += 1;            &#125;            column_end -= 1;            if row_begin &lt;= row_end &#123;                for i in (column_begin..=column_end).rev() &#123;                    result_matrix[row_end][i] = insert_num;                    insert_num += 1;                &#125;                row_end -= 1;            &#125;            if column_begin &lt;= column_end &#123;                for i in (row_begin..=row_end).rev() &#123;                    result_matrix[i][column_begin] = insert_num;                    insert_num += 1;                &#125;                column_begin += 1;            &#125;        &#125;        result_matrix    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.02 MB, 击败 65.00% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"闪电侠 第六季 第十三集 格罗德做我朋友","url":"/zh-CN/06a265d70f72/","content":"\n剧情介绍　　闪电小子带着禅宗的态度回到了中心城，并掌握了新的花样。虽然很高兴再次见到他的家人，但沃利向巴里透露他回来是因为他认为神速力有问题。与此同时，西斯科从他在Earth-Prime的实况调查任务中返回。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00060.排列序列","url":"/zh-CN/47af4952a91a/","content":"\n题目描述给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。\n按大小顺序列出所有排列情况，并一一标记，当 n &#x3D; 3 时, 所有排列如下：\n\n“123”\n“132”\n“213”\n“231”\n“312”\n“321”\n\n给定 n 和 k，返回第 k 个排列。\n示例 1：\n输入：n &#x3D; 3, k &#x3D; 3输出：”213”\n\n示例 2：\n输入：n &#x3D; 4, k &#x3D; 9输出：”2314”\n\n示例 3：\n输入：n &#x3D; 3, k &#x3D; 1输出：”123”\n\n提示：\n1 &lt;&#x3D; n &lt;&#x3D; 9\n1 &lt;&#x3D; k &lt;&#x3D; n!\n\n\n解决方法C++class Solution &#123;public:    string getPermutation(int n, int k) &#123;        vector&lt;char&gt; nums;        for (int i = 1; i &lt;= n; ++i) &#123;            nums.push_back(&#x27;0&#x27; + i);        &#125;        k -= 1;        string result;        for (int i = n; i &gt; 0; --i) &#123;            int index = k / factorial(i - 1);            k %= factorial(i - 1);            result.push_back(nums[index]);            nums.erase(nums.begin() + index);        &#125;        return result;    &#125;private:    int factorial(int n) &#123;        int result = 1;        for (int i = 2; i &lt;= n; ++i) &#123;            result *= i;        &#125;        return result;    &#125;&#125;;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C++ 的用户\n内存消耗 : 7.00 MB, 击败 32.22% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public String getPermutation(int n, int k) &#123;        List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();        for (int i = 1; i &lt;= n; ++i) &#123;            nums.add(i);        &#125;        k -= 1;        StringBuilder result = new StringBuilder();        for (int i = n; i &gt; 0; --i) &#123;            int index = k / factorial(i - 1);            k %= factorial(i - 1);            result.append(nums.get(index));            nums.remove(index);        &#125;        return result.toString();    &#125;    private int factorial(int n) &#123;        int result = 1;        for (int i = 2; i &lt;= n; ++i) &#123;            result *= i;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 91.08% 使用 Java 的用户\n内存消耗 : 40.16 MB, 击败 34.22% 使用 Java 的用户\n\nPythonclass Solution(object):    def getPermutation(self, n, k):        &quot;&quot;&quot;        :type n: int        :type k: int        :rtype: str        &quot;&quot;&quot;        nums = [str(i) for i in range(1, n + 1)]        result = []        k -= 1        for i in range(n, 0, -1):            index, k = divmod(k, math.factorial(i - 1))            result.append(nums.pop(index))        return &#x27;&#x27;.join(result)\n\n结果执行用时 : 13 ms, 击败 78.31% 使用 Python 的用户\n内存消耗 : 11.48 MB, 击败 78.31% 使用 Python 的用户\n\nPython3class Solution:    def getPermutation(self, n: int, k: int) -&gt; str:        nums = [str(i) for i in range(1, n + 1)]        result = []        k -= 1  # Convert k to index (0-based)        for i in range(n, 0, -1):            index, k = divmod(k, math.factorial(i - 1))            result.append(nums.pop(index))        return &#x27;&#x27;.join(result)\n\n结果执行用时 : 36 ms, 击败 86.75% 使用 Python3 的用户\n内存消耗 : 16.25 MB, 击败 61.79% 使用 Python3 的用户\n\nCint factorial(int n) &#123;    int result = 1;    for (int i = 2; i &lt;= n; ++i) &#123;        result *= i;    &#125;    return result;&#125;char* getPermutation(int n, int k) &#123;    char* result = (char*)malloc((n + 1) * sizeof(char));    result[n] = &#x27;\\0&#x27;;    char nums[n];    for (int i = 0; i &lt; n; ++i) &#123;        nums[i] = &#x27;0&#x27; + i + 1;    &#125;    k -= 1;    for (int i = n; i &gt; 0; --i) &#123;        int index = k / factorial(i - 1);        k %= factorial(i - 1);        result[n - i] = nums[index];        for (int j = index; j &lt; i - 1; ++j) &#123;            nums[j] = nums[j + 1];        &#125;    &#125;    return result;&#125;\n\n结果执行用时 : 2 ms, 击败 54.65% 使用 C 的用户\n内存消耗 : 5.56 MB, 击败 70.93% 使用 C 的用户\n\nC#public class Solution &#123;    public string GetPermutation(int n, int k) &#123;        char[] result = new char[n];        char[] nums = new char[n];        for (int i = 0; i &lt; n; i++) &#123;            nums[i] = (char)(&#x27;0&#x27; + i + 1);        &#125;        k--;        for (int i = n; i &gt; 0; i--) &#123;            int index = k / Factorial(i - 1);            k %= Factorial(i - 1);            result[n - i] = nums[index];            Array.Copy(nums, index + 1, nums, index, i - index - 1);        &#125;        return new string(result);    &#125;    private int Factorial(int n) &#123;        int result = 1;        for (int i = 2; i &lt;= n; i++) &#123;            result *= i;        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 52 ms, 击败 88.37% 使用 C# 的用户\n内存消耗 : 38.84 MB, 击败 16.28% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number&#125; n * @param &#123;number&#125; k * @return &#123;string&#125; */var getPermutation = function(n, k) &#123;    let result = [];    let nums = [];    for (let i = 1; i &lt;= n; i++) &#123;        nums.push(i);    &#125;    k--;    for (let i = n; i &gt; 0; i--) &#123;        let index = Math.floor(k / factorial(i - 1));        k %= factorial(i - 1);        result.push(nums[index]);        nums.splice(index, 1);    &#125;    return result.join(&#x27;&#x27;);&#125;;function factorial(n) &#123;    let result = 1;    for (let i = 2; i &lt;= n; i++) &#123;        result *= i;    &#125;    return result;&#125;\n\n结果执行用时 : 61 ms, 击败 70.33% 使用 JavaScript 的用户\n内存消耗 : 49.17 MB, 击败 53.85% 使用 JavaScript 的用户\n\nTypeScriptfunction getPermutation(n: number, k: number): string &#123;    const result: number[] = [];    const nums: number[] = [];    for (let i = 1; i &lt;= n; i++) &#123;        nums.push(i);    &#125;    k--;    for (let i = n; i &gt; 0; i--) &#123;        const index = Math.floor(k / factorial(i - 1));        k %= factorial(i - 1);        result.push(nums[index]);        nums.splice(index, 1);    &#125;    return result.join(&#x27;&#x27;);&#125;function factorial(n: number): number &#123;    let result = 1;    for (let i = 2; i &lt;= n; i++) &#123;        result *= i;    &#125;    return result;&#125;\n\n结果执行用时 : 69 ms, 击败 68.75% 使用 TypeScript 的用户\n内存消耗 : 51.75 MB, 击败 56.25% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer $n     * @param Integer $k     * @return String     */    function getPermutation($n, $k) &#123;        $result = [];        $nums = range(1, $n);        $k--;        for ($i = $n; $i &gt; 0; $i--) &#123;            $index = intval($k / $this-&gt;factorial($i - 1));            $k %= $this-&gt;factorial($i - 1);            $result[] = $nums[$index];            array_splice($nums, $index, 1);        &#125;        return implode(&#x27;&#x27;, $result);    &#125;    private function factorial($n) &#123;        $result = 1;        for ($i = 2; $i &lt;= $n; $i++) &#123;            $result *= $i;        &#125;        return $result;    &#125;&#125;\n\n结果执行用时 : 7 ms, 击败 100.00% 使用 PHP 的用户\n内存消耗 : 19.74 MB, 击败 100.00% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func getPermutation(_ n: Int, _ k: Int) -&gt; String &#123;        if n == 1 &amp;&amp; k == 1 &#123; return &quot;1&quot; &#125;        var nums = [Int]()        var remainingK = k        for i in 1...n &#123;            nums.append(i)        &#125;        var result = &quot;&quot;        for i in stride(from: n, to: 1, by: -1) &#123;            let count = getCount(i)            let count2 = count / i            let rest = remainingK % count2            var index = 0            if rest == 0 &#123;                index = remainingK / count2 - 1                result.append(&quot;\\(nums[index])&quot;)            &#125; else &#123;                index = (remainingK - rest) / count2                result.append(&quot;\\(nums[index])&quot;)            &#125;            nums.remove(at: index)            remainingK -= count2 * index        &#125;        if let num = nums.first &#123;            result.append(&quot;\\(num)&quot;)        &#125;        return result    &#125;    func getCount(_ n: Int) -&gt; Int &#123;        return n &lt; 2 ? n : n * getCount(n - 1)    &#125;&#125;\n\n结果执行用时 : 5 ms, 击败 40.00% 使用 Swift 的用户\n内存消耗 : 15.20 MB, 击败 53.33% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun getPermutation(n: Int, k: Int): String &#123;        if (n == 1 &amp;&amp; k == 1) return &quot;1&quot;        val nums = (1..n).toMutableList()        var remainingK = k        var result = &quot;&quot;        for (i in n downTo 1) &#123;            val count = getCount(i)            val count2 = count / i            val rest = remainingK % count2            var index = 0            if (rest == 0) &#123;                index = remainingK / count2 - 1                result += nums[index].toString()            &#125; else &#123;                index = (remainingK - rest) / count2                result += nums[index].toString()            &#125;            nums.removeAt(index)            remainingK -= count2 * index        &#125;        return result    &#125;    private fun getCount(n: Int): Int &#123;        return if (n &lt; 2) n else n * getCount(n - 1)    &#125;&#125;\n\n结果执行用时 : 163 ms, 击败 62.50% 使用 Kotlin 的用户\n内存消耗 : 34.95 MB, 击败 37.50% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  String getPermutation(int n, int k) &#123;    if (n == 1 &amp;&amp; k == 1) return &quot;1&quot;;    List&lt;int&gt; nums = List.generate(n, (index) =&gt; index + 1);    StringBuffer result = StringBuffer();    int remainingK = k;    for (int i = n; i &gt; 0; i--) &#123;      int count = getCount(i);      int count2 = count ~/ i;      int rest = remainingK % count2;      int index;      if (rest == 0) &#123;        index = remainingK ~/ count2 - 1;        result.write(nums[index]);      &#125; else &#123;        index = (remainingK - rest) ~/ count2;        result.write(nums[index]);      &#125;      nums.removeAt(index);      remainingK -= count2 * index;    &#125;    return result.toString();  &#125;  int getCount(int n) =&gt; (n &lt; 2) ? n : n * getCount(n - 1);&#125;\n\n结果执行用时 : 284 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 144.84 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc getPermutation(n int, k int) string &#123;\tif n == 1 &amp;&amp; k == 1 &#123;\t\treturn &quot;1&quot;\t&#125;\tnums := make([]int, n)\tfor i := 0; i &lt; n; i++ &#123;\t\tnums[i] = i + 1\t&#125;\tvar result string\tremainingK := k\tfor i := n; i &gt; 0; i-- &#123;\t\tcount := getCount(i)\t\tcount2 := count / i\t\trest := remainingK % count2\t\tvar index int\t\tif rest == 0 &#123;\t\t\tindex = remainingK/count2 - 1\t\t\tresult += strconv.Itoa(nums[index])\t\t&#125; else &#123;\t\t\tindex = (remainingK - rest) / count2\t\t\tresult += strconv.Itoa(nums[index])\t\t&#125;\t\tnums = append(nums[:index], nums[index+1:]...)\t\tremainingK -= count2 * index\t&#125;\treturn result&#125;func getCount(n int) int &#123;\tif n &lt; 2 &#123;\t\treturn n\t&#125;\treturn n * getCount(n-1)&#125;\n\n结果执行用时 : 1 ms, 击败 46.62% 使用 Go 的用户\n内存消耗 : 1.91 MB, 击败 80.45% 使用 Go 的用户\n\nRuby# @param &#123;Integer&#125; n# @param &#123;Integer&#125; k# @return &#123;String&#125;def get_permutation(n, k)  return &#x27;1&#x27; if n == 1 &amp;&amp; k == 1  nums = (1..n).to_a  result = &#x27;&#x27;  remaining_k = k  (n.downto(1)).each do |i|    count = get_count(i)    count2 = count / i    rest = remaining_k % count2    index = 0    if rest.zero?      index = remaining_k / count2 - 1      result += nums[index].to_s    else      index = (remaining_k - rest) / count2      result += nums[index].to_s    end    nums.delete_at(index)    remaining_k -= count2 * index  end  resultenddef get_count(n)  n &lt; 2 ? n : n * get_count(n - 1)end\n\n结果执行用时 : 51 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.43 MB, 击败 100.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def getPermutation(n: Int, k: Int): String = &#123;    if (n == 1 &amp;&amp; k == 1) return &quot;1&quot;    var nums = (1 to n).toList    var remainingK = k    var result = &quot;&quot;    for (i &lt;- n to 1 by -1) &#123;      val count = getCount(i)      val count2 = count / i      val rest = remainingK % count2      var index = 0      if (rest == 0) &#123;        index = remainingK / count2 - 1        result += nums(index).toString      &#125; else &#123;        index = (remainingK - rest) / count2        result += nums(index).toString      &#125;      nums = nums.patch(index, Nil, 1)      remainingK -= count2 * index    &#125;    result  &#125;  def getCount(n: Int): Int = &#123;    if (n &lt; 2) n else n * getCount(n - 1)  &#125;&#125;\n\n结果执行用时 : 433 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 51.78 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn get_permutation(n: i32, k: i32) -&gt; String &#123;        if n == 1 &amp;&amp; k == 1 &#123;            return &quot;1&quot;.to_string();        &#125;        let mut nums: Vec&lt;i32&gt; = (1..=n).collect();        let mut remaining_k = k;        let mut result = String::new();        for i in (1..=n).rev() &#123;            let count = Solution::get_count(i);            let count2 = count / i;            let rest = remaining_k % count2;            let index: usize;            if rest == 0 &#123;                index = (remaining_k / count2 - 1) as usize;                result.push_str(&amp;nums[index].to_string());            &#125; else &#123;                index = ((remaining_k - rest) / count2) as usize;                result.push_str(&amp;nums[index].to_string());            &#125;            nums.remove(index);            remaining_k -= count2 * index as i32;        &#125;        result    &#125;    fn get_count(n: i32) -&gt; i32 &#123;        if n &lt; 2 &#123;            n        &#125; else &#123;            n * Solution::get_count(n - 1)        &#125;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 26.32% 使用 Rust 的用户\n内存消耗 : 2.01 MB, 击败 94.74% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixirdefmodule Solution do  @spec get_permutation(n :: integer, k :: integer) :: String.t  def get_permutation(n, k) when n == 1 and k == 1, do: &quot;1&quot;  def get_permutation(n, k) do    get_permutation(n, k, Enum.to_list(1..n), [])  end  defp get_permutation(0, _, _, result), do: Enum.join(result)  defp get_permutation(n, k, available, result) do    count = get_count(n)    count2 = div(count, n)    rest = rem(k, count2)    index =      if rest == 0, do: div(k, count2) - 1, else: div(k - rest, count2)    new_result = result ++ [Enum.at(available, index)]    new_available = List.delete_at(available, index)    get_permutation(n - 1, k - count2 * index, new_available, new_result)  end  defp get_count(n) when n &lt; 2, do: n  defp get_count(n), do: n * get_count(n - 1)end\n\n结果执行用时 : 270 ms, 击败 100.00% 使用 Elixir 的用户\n内存消耗 : 68.09 MB, 击败 100.00% 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00061.旋转链表","url":"/zh-CN/fbf6dc3802a5/","content":"\n题目描述给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n示例 1：\n\n\n输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2输出：[4,5,1,2,3]\n\n示例 2：\n\n\n输入：head &#x3D; [0,1,2], k &#x3D; 4输出：[2,0,1]\n\n提示：\n链表中节点的数目在范围 [0, 500] 内\n-100 &lt;&#x3D; Node.val &lt;&#x3D; 100\n$0 &lt;&#x3D; k &lt;&#x3D; 2 * 10^9$\n\n\n解决方法C++/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* rotateRight(ListNode* head, int k) &#123;        if (!head || k == 0) &#123;            return head;        &#125;        int length = 1;        ListNode *current = head;        while (current-&gt;next) &#123;            length++;            current = current-&gt;next;        &#125;        k = k % length;        if (k == 0) &#123;            return head;        &#125;        ListNode *fast = head;        ListNode *slow = head;        for (int i = 0; i &lt; k; i++) &#123;            fast = fast-&gt;next;        &#125;        while (fast-&gt;next) &#123;            fast = fast-&gt;next;            slow = slow-&gt;next;        &#125;        ListNode *new_head = slow-&gt;next;        slow-&gt;next = NULL;        fast-&gt;next = head;        return new_head;    &#125;&#125;;\n\n结果执行用时 : 5 ms, 击败 53.76% 使用 C++ 的用户\n内存消耗 : 14.91 MB, 击败 13.56% 使用 C++ 的用户\n\nJava/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode rotateRight(ListNode head, int k) &#123;        if (head == null || k == 0) &#123;            return head;        &#125;        int length = 1;        ListNode current = head;        while (current.next != null) &#123;            length++;            current = current.next;        &#125;        k = k % length;        if (k == 0) &#123;            return head;        &#125;        ListNode fast = head;        ListNode slow = head;        for (int i = 0; i &lt; k; i++) &#123;            fast = fast.next;        &#125;        while (fast.next != null) &#123;            fast = fast.next;            slow = slow.next;        &#125;        ListNode newHead = slow.next;        slow.next = null;        fast.next = head;        return newHead;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 41.34 MB, 击败 52.48% 使用 Java 的用户\n\nPython# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution(object):    def rotateRight(self, head, k):        &quot;&quot;&quot;        :type head: ListNode        :type k: int        :rtype: ListNode        &quot;&quot;&quot;        if not head or k == 0:            return head        length = 1        current = head        while current.next:            length += 1            current = current.next        k = k % length        if k == 0:            return head        fast = head        slow = head        for _ in range(k):            fast = fast.next        while fast.next:            fast = fast.next            slow = slow.next        new_head = slow.next        slow.next = None        fast.next = head        return new_head\n\n结果执行用时 : 23 ms, 击败 42.32% 使用 Python 的用户\n内存消耗 : 11.53 MB, 击败 71.87% 使用 Python 的用户\n\nPython3# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:        if not head or k == 0:            return head        length = 1        current = head        while current.next:            length += 1            current = current.next        k = k % length        if k == 0:            return head        fast = head        slow = head        for _ in range(k):            fast = fast.next        while fast.next:            fast = fast.next            slow = slow.next        new_head = slow.next        slow.next = None        fast.next = head        return new_head\n\n结果执行用时 : 46 ms, 击败 29.19% 使用 Python3 的用户\n内存消耗 : 16.41 MB, 击败 57.60% 使用 Python3 的用户\n\nC/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     struct ListNode *next; * &#125;; */struct ListNode* rotateRight(struct ListNode* head, int k) &#123;    if (!head || k == 0) &#123;        return head;    &#125;    int length = 1;    struct ListNode *current = head;    while (current-&gt;next) &#123;        length++;        current = current-&gt;next;    &#125;    k = k % length;    if (k == 0) &#123;        return head;    &#125;    struct ListNode *fast = head;    struct ListNode *slow = head;    for (int i = 0; i &lt; k; i++) &#123;        fast = fast-&gt;next;    &#125;    while (fast-&gt;next) &#123;        fast = fast-&gt;next;        slow = slow-&gt;next;    &#125;    struct ListNode *newHead = slow-&gt;next;    slow-&gt;next = NULL;    fast-&gt;next = head;    return newHead;&#125;\n\n结果执行用时 : 2 ms, 击败 74.04% 使用 C 的用户\n内存消耗 : 5.82 MB, 击败 91.17% 使用 C 的用户\n\nC#/** * Definition for singly-linked list. * public class ListNode &#123; *     public int val; *     public ListNode next; *     public ListNode(int val=0, ListNode next=null) &#123; *         this.val = val; *         this.next = next; *     &#125; * &#125; */public class Solution &#123;    public ListNode RotateRight(ListNode head, int k) &#123;        if (head == null || k == 0) &#123;            return head;        &#125;        int length = 1;        ListNode current = head;        while (current.next != null) &#123;            length++;            current = current.next;        &#125;        k = k % length;        if (k == 0) &#123;            return head;        &#125;        ListNode fast = head;        ListNode slow = head;        for (int i = 0; i &lt; k; i++) &#123;            fast = fast.next;        &#125;        while (fast.next != null) &#123;            fast = fast.next;            slow = slow.next;        &#125;        ListNode newHead = slow.next;        slow.next = null;        fast.next = head;        return newHead;    &#125;&#125;\n\n结果执行用时 : 64 ms, 击败 72.18% 使用 C# 的用户\n内存消耗 : 41.42 MB, 击败 27.07% 使用 C# 的用户\n\nJavaScript/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; k * @return &#123;ListNode&#125; */var rotateRight = function(head, k) &#123;    if (!head || k === 0) &#123;        return head;    &#125;    let length = 1;    let current = head;    while (current.next) &#123;        length++;        current = current.next;    &#125;    k = k % length;    if (k === 0) &#123;        return head;    &#125;    let fast = head;    let slow = head;    for (let i = 0; i &lt; k; i++) &#123;        fast = fast.next;    &#125;    while (fast.next) &#123;        fast = fast.next;        slow = slow.next;    &#125;    let newHead = slow.next;    slow.next = null;    fast.next = head;    return newHead;&#125;;\n\n结果执行用时 : 64 ms, 击败 81.59% 使用 JavaScript 的用户\n内存消耗 : 51.45 MB, 击败 13.45% 使用 JavaScript 的用户\n\nTypeScript/** * Definition for singly-linked list. * class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */function rotateRight(head: ListNode | null, k: number): ListNode | null &#123;    if (!head || k === 0) &#123;        return head;    &#125;    let length = 1;    let current = head;    while (current.next) &#123;        length++;        current = current.next;    &#125;    k = k % length;    if (k === 0) &#123;        return head;    &#125;    let fast: ListNode | null = head;    let slow: ListNode | null = head;    for (let i = 0; i &lt; k; i++) &#123;        if (fast) &#123;            fast = fast.next;        &#125;    &#125;    while (fast &amp;&amp; fast.next) &#123;        fast = fast.next;        slow = slow?.next || null;    &#125;    let newHead: ListNode | null = slow?.next || null;    if (slow) &#123;        slow.next = null;    &#125;    if (fast) &#123;        fast.next = head;    &#125;    return newHead;&#125;\n\n结果执行用时 : 68 ms, 击败 80.00% 使用 TypeScript 的用户\n内存消耗 : 52.75 MB, 击败 5.56% 使用 TypeScript 的用户\n\nPHP/** * Definition for a singly-linked list. * class ListNode &#123; *     public $val = 0; *     public $next = null; *     function __construct($val = 0, $next = null) &#123; *         $this-&gt;val = $val; *         $this-&gt;next = $next; *     &#125; * &#125; */class Solution &#123;    /**     * @param ListNode $head     * @param Integer $k     * @return ListNode     */    function rotateRight($head, $k) &#123;        if (!$head || $k === 0) &#123;            return $head;        &#125;        $length = 1;        $current = $head;        while ($current-&gt;next) &#123;            $length++;            $current = $current-&gt;next;        &#125;        $k = $k % $length;        if ($k === 0) &#123;            return $head;        &#125;        $fast = $head;        $slow = $head;        for ($i = 0; $i &lt; $k; $i++) &#123;            $fast = $fast-&gt;next;        &#125;        while ($fast-&gt;next) &#123;            $fast = $fast-&gt;next;            $slow = $slow-&gt;next;        &#125;        $newHead = $slow-&gt;next;        $slow-&gt;next = null;        $fast-&gt;next = $head;        return $newHead;    &#125;&#125;\n\n结果执行用时 : 12 ms, 击败 50.00% 使用 PHP 的用户\n内存消耗 : 20.07 MB, 击败 10.00% 使用 PHP 的用户\n\nSwift/** * Definition for singly-linked list. * public class ListNode &#123; *     public var val: Int *     public var next: ListNode? *     public init() &#123; self.val = 0; self.next = nil; &#125; *     public init(_ val: Int) &#123; self.val = val; self.next = nil; &#125; *     public init(_ val: Int, _ next: ListNode?) &#123; self.val = val; self.next = next; &#125; * &#125; */class Solution &#123;    func rotateRight(_ head: ListNode?, _ k: Int) -&gt; ListNode? &#123;        guard let head = head, k &gt; 0 else &#123;            return head        &#125;        var length = 1        var current = head        while current.next != nil &#123;            length += 1            current = current.next!        &#125;        let rotateSteps = k % length        if rotateSteps == 0 &#123;            return head        &#125;        var fast: ListNode? = head        var slow: ListNode? = head        for _ in 0..&lt;rotateSteps &#123;            fast = fast?.next        &#125;        while fast?.next != nil &#123;            fast = fast?.next            slow = slow?.next        &#125;        let newHead = slow?.next        slow?.next = nil        fast?.next = head        return newHead    &#125;&#125;\n\n结果执行用时 : 9 ms, 击败 70.89% 使用 Swift 的用户\n内存消耗 : 15.43 MB, 击败 11.39% 使用 Swift 的用户\n\nKotlin/** * Example: * var li = ListNode(5) * var v = li.`val` * Definition for singly-linked list. * class ListNode(var `val`: Int) &#123; *     var next: ListNode? = null * &#125; */class Solution &#123;    fun rotateRight(head: ListNode?, k: Int): ListNode? &#123;        if (head == null || k == 0) &#123;            return head        &#125;        var length = 1        var current = head        while (current?.next != null) &#123;            length++            current = current.next        &#125;        val rotateSteps = k % length        if (rotateSteps == 0) &#123;            return head        &#125;        var fast: ListNode? = head        var slow: ListNode? = head        repeat(rotateSteps) &#123;            fast = fast?.next        &#125;        while (fast?.next != null) &#123;            fast = fast?.next            slow = slow?.next        &#125;        val newHead = slow?.next        slow?.next = null        fast?.next = head        return newHead    &#125;&#125;\n\n结果执行用时 : 167 ms, 击败 90.70% 使用 Kotlin 的用户\n内存消耗 : 35.81 MB, 击败 30.23% 使用 Kotlin 的用户\n\nDart/** * Definition for singly-linked list. * class ListNode &#123; *   int val; *   ListNode? next; *   ListNode([this.val = 0, this.next]); * &#125; */class Solution &#123;  ListNode? rotateRight(ListNode? head, int k) &#123;      if (head == null || k == 0) &#123;    return head;    &#125;    int length = 1;    ListNode? current = head;    while (current?.next != null) &#123;        length++;        current = current?.next;    &#125;    k = k % length;    if (k == 0) &#123;        return head;    &#125;    ListNode? fast = head;    ListNode? slow = head;    for (int i = 0; i &lt; k; i++) &#123;        fast = fast?.next;    &#125;    while (fast?.next != null) &#123;        fast = fast?.next;        slow = slow?.next;    &#125;    ListNode? newHead = slow?.next;    slow?.next = null;    fast?.next = head;    return newHead;    &#125;&#125;\n\n结果执行用时 : 292 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 144.09 MB, 击败 100.00% 使用 Dart 的用户\n\nGo/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func rotateRight(head *ListNode, k int) *ListNode &#123;    if head == nil || k == 0 &#123;        return head    &#125;    length := 1    current := head    for current.Next != nil &#123;        length++        current = current.Next    &#125;    k = k % length    if k == 0 &#123;        return head    &#125;    fast, slow := head, head    for i := 0; i &lt; k; i++ &#123;        fast = fast.Next    &#125;    for fast.Next != nil &#123;        fast = fast.Next        slow = slow.Next    &#125;    newHead := slow.Next    slow.Next = nil    fast.Next = head    return newHead&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.36 MB, 击败 34.33% 使用 Go 的用户\n\nRuby# Definition for singly-linked list.# class ListNode#     attr_accessor :val, :next#     def initialize(val = 0, _next = nil)#         @val = val#         @next = _next#     end# end# @param &#123;ListNode&#125; head# @param &#123;Integer&#125; k# @return &#123;ListNode&#125;def rotate_right(head, k)  return head if head.nil? || k.zero?  length = 1  current = head  while current.next    length += 1    current = current.next  end  k = k % length  return head if k.zero?  fast = head  slow = head  k.times &#123; fast = fast.next &#125;  while fast.next    fast = fast.next    slow = slow.next  end  new_head = slow.next  slow.next = nil  fast.next = head  new_headend\n\n结果执行用时 : 64 ms, 击败 25.00% 使用 Ruby 的用户\n内存消耗 : 206.50 MB, 击败 50.00% 使用 Ruby 的用户\n\nScala/** * Definition for singly-linked list. * class ListNode(_x: Int = 0, _next: ListNode = null) &#123; *   var next: ListNode = _next *   var x: Int = _x * &#125; */object Solution &#123;  def rotateRight(head: ListNode, k: Int): ListNode = &#123;    if (head == null || k == 0) &#123;      return head    &#125;    var length = 1    var current = head    while (current.next != null) &#123;      length += 1      current = current.next    &#125;    val rotateSteps = k % length    if (rotateSteps == 0) &#123;      return head    &#125;    var fast: ListNode = head    var slow: ListNode = head    for (_ &lt;- 0 until rotateSteps) &#123;      fast = fast.next    &#125;    while (fast.next != null) &#123;      fast = fast.next      slow = slow.next    &#125;    val newHead: ListNode = slow.next    slow.next = null    fast.next = head    newHead  &#125;&#125;\n\n结果执行用时 : 513 ms, 击败 50.00% 使用 Scala 的用户\n内存消耗 : 56.80 MB, 击败 100.00% 使用 Scala 的用户\n\nRust// Definition for singly-linked list.// #[derive(PartialEq, Eq, Clone, Debug)]// pub struct ListNode &#123;//   pub val: i32,//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;// &#125;//// impl ListNode &#123;//   #[inline]//   fn new(val: i32) -&gt; Self &#123;//     ListNode &#123;//       next: None,//       val//     &#125;//   &#125;// &#125;impl Solution &#123;    pub fn rotate_right(mut head: Option&lt;Box&lt;ListNode&gt;&gt;, k: i32) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; &#123;        let mut len = 0;        let mut p = &amp;head;        while let Some(node) = p &#123;            len += 1;            p = &amp;node.next;        &#125;        if len &lt;= 1 &#123;            return head;        &#125;        let k = k % len;        if k == 0 &#123;            return head;        &#125;        let mut p = Self::get_last_nth(&amp;mut head, k);        let mut q = &amp;mut p;        while (*q).is_some() &amp;&amp; q.as_ref().unwrap().next.is_some() &#123;            q = &amp;mut q.as_mut().unwrap().next;        &#125;        q.as_mut().unwrap().next = head;        p    &#125;    fn get_last_nth(head: &amp;mut Option&lt;Box&lt;ListNode&gt;&gt;, n: i32) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; &#123;        unsafe &#123;            let mut slow = head as *mut Option&lt;Box&lt;ListNode&gt;&gt;;            let mut fast = head as *mut Option&lt;Box&lt;ListNode&gt;&gt;;            for _ in 0..n &#123;                fast = &amp;mut (*fast).as_mut().unwrap().next;            &#125;            while (*fast).is_some() &#123;                slow = &amp;mut (*slow).as_mut().unwrap().next;                fast = &amp;mut (*fast).as_mut().unwrap().next;            &#125;            (*slow).take()        &#125;    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 24.14% 使用 Rust 的用户\n内存消耗 : 2.13 MB, 击败 31.03% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00062.不同路径","url":"/zh-CN/2df7c1a929f8/","content":"\n题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n问总共有多少条不同的路径？\n示例 1：\n\n\n输入：m &#x3D; 3, n &#x3D; 7输出：28\n\n示例 2：\n输入：m &#x3D; 3, n &#x3D; 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。\n\n向右 -&gt; 向下 -&gt; 向下\n向下 -&gt; 向下 -&gt; 向右\n向下 -&gt; 向右 -&gt; 向下\n\n\n示例 3：\n输入：m &#x3D; 7, n &#x3D; 3输出：28\n\n示例 4：\n输入：m &#x3D; 3, n &#x3D; 3输出：6\n\n提示：\n1 &lt;&#x3D; m, n &lt;&#x3D; 100\n$题目数据保证答案小于等于 2 * 10^9$\n\n\n解决方法C++class Solution &#123;public:    int uniquePaths(int m, int n) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));        for (int i = 0; i &lt; m; ++i) &#123;            dp[i][0] = 1;        &#125;        for (int j = 0; j &lt; n; ++j) &#123;            dp[0][j] = 1;        &#125;        for (int i = 1; i &lt; m; ++i) &#123;            for (int j = 1; j &lt; n; ++j) &#123;                dp[i][j] = dp[i-1][j] + dp[i][j-1];            &#125;        &#125;        return dp[m-1][n-1];    &#125;&#125;;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C++ 的用户\n内存消耗 : 7.57 MB, 击败 12.32% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int uniquePaths(int m, int n) &#123;        int[][] dp = new int[m][n];        for (int i = 0; i &lt; m; i++) &#123;            dp[i][0] = 1;        &#125;        for (int j = 0; j &lt; n; j++) &#123;            dp[0][j] = 1;        &#125;        for (int i = 1; i &lt; m; i++) &#123;            for (int j = 1; j &lt; n; j++) &#123;                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];            &#125;        &#125;        return dp[m - 1][n - 1];    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 39.46 MB, 击败 21.94% 使用 Java 的用户\n\nPythonclass Solution(object):    def uniquePaths(self, m, n):        &quot;&quot;&quot;        :type m: int        :type n: int        :rtype: int        &quot;&quot;&quot;        dp = [[0] * n for _ in range(m)]        for i in range(m):            dp[i][0] = 1        for j in range(n):            dp[0][j] = 1        for i in range(1, m):            for j in range(1, n):                dp[i][j] = dp[i-1][j] + dp[i][j-1]        return dp[m-1][n-1]\n\n结果执行用时 : 18 ms, 击败 44.36% 使用 Python 的用户\n内存消耗 : 11.58 MB, 击败 67.39% 使用 Python 的用户\n\nPython3class Solution:    def uniquePaths(self, m: int, n: int) -&gt; int:        dp = [[0] * n for _ in range(m)]        for i in range(m):            dp[i][0] = 1        for j in range(n):            dp[0][j] = 1        for i in range(1, m):            for j in range(1, n):                dp[i][j] = dp[i-1][j] + dp[i][j-1]        return dp[m-1][n-1]\n\n结果执行用时 : 32 ms, 击败 92.96% 使用 Python3 的用户\n内存消耗 : 16.52 MB, 击败 32.54% 使用 Python3 的用户\n\nCint uniquePaths(int m, int n) &#123;    int** dp = (int**)malloc(m * sizeof(int*));    for (int i = 0; i &lt; m; ++i) &#123;        dp[i] = (int*)malloc(n * sizeof(int));    &#125;    for (int i = 0; i &lt; m; ++i) &#123;        dp[i][0] = 1;    &#125;    for (int j = 0; j &lt; n; ++j) &#123;        dp[0][j] = 1;    &#125;    for (int i = 1; i &lt; m; ++i) &#123;        for (int j = 1; j &lt; n; ++j) &#123;            dp[i][j] = dp[i-1][j] + dp[i][j-1];        &#125;    &#125;    int result = dp[m-1][n-1];    for (int i = 0; i &lt; m; ++i) &#123;        free(dp[i]);    &#125;    free(dp);    return result;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 5.87 MB, 击败 62.56% 使用 C 的用户\n\nC#public class Solution &#123;    public int UniquePaths(int m, int n) &#123;        int[,] dp = new int[m, n];        for (int i = 0; i &lt; m; i++) &#123;            dp[i, 0] = 1;        &#125;        for (int j = 0; j &lt; n; j++) &#123;            dp[0, j] = 1;        &#125;        for (int i = 1; i &lt; m; i++) &#123;            for (int j = 1; j &lt; n; j++) &#123;                dp[i, j] = dp[i - 1, j] + dp[i, j - 1];            &#125;        &#125;        return dp[m - 1, n - 1];    &#125;&#125;\n\n结果执行用时 : 15 ms, 击败 95.75% 使用 C# 的用户\n内存消耗 : 26.63 MB, 击败 33.02% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var uniquePaths = function(m, n) &#123;    const dp = Array.from(Array(m), () =&gt; Array(n).fill(0));    for (let i = 0; i &lt; m; i++) &#123;        dp[i][0] = 1;    &#125;    for (let j = 0; j &lt; n; j++) &#123;        dp[0][j] = 1;    &#125;    for (let i = 1; i &lt; m; i++) &#123;        for (let j = 1; j &lt; n; j++) &#123;            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];        &#125;    &#125;    return dp[m - 1][n - 1];&#125;;\n\n结果执行用时 : 61 ms, 击败 50.77% 使用 JavaScript 的用户\n内存消耗 : 49.11 MB, 击败 30.53% 使用 JavaScript 的用户\n\nTypeScriptfunction uniquePaths(m: number, n: number): number &#123;    const dp: number[][] = Array.from(Array(m), () =&gt; Array(n).fill(0));    for (let i = 0; i &lt; m; i++) &#123;        dp[i][0] = 1;    &#125;    for (let j = 0; j &lt; n; j++) &#123;        dp[0][j] = 1;    &#125;    for (let i = 1; i &lt; m; i++) &#123;        for (let j = 1; j &lt; n; j++) &#123;            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];        &#125;    &#125;    return dp[m - 1][n - 1];&#125;\n\n结果执行用时 : 67 ms, 击败 43.20% 使用 TypeScript 的用户\n内存消耗 : 51.82 MB, 击败 22.00% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer $m     * @param Integer $n     * @return Integer     */    function uniquePaths($m, $n) &#123;        $dp = array_fill(0, $m, array_fill(0, $n, 0));        for ($i = 0; $i &lt; $m; $i++) &#123;            $dp[$i][0] = 1;        &#125;        for ($j = 0; $j &lt; $n; $j++) &#123;            $dp[0][$j] = 1;        &#125;        for ($i = 1; $i &lt; $m; $i++) &#123;            for ($j = 1; $j &lt; $n; $j++) &#123;                $dp[$i][$j] = $dp[$i - 1][$j] + $dp[$i][$j - 1];            &#125;        &#125;        return $dp[$m - 1][$n - 1];    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 PHP 的用户\n内存消耗 : 20.29 MB, 击败 9.09% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func uniquePaths(_ m: Int, _ n: Int) -&gt; Int &#123;        var dp = Array(repeating: Array(repeating: 0, count: n), count: m)        for i in 0..&lt;m &#123;            dp[i][0] = 1        &#125;        for j in 0..&lt;n &#123;            dp[0][j] = 1        &#125;        for i in 1..&lt;m &#123;            for j in 1..&lt;n &#123;                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]            &#125;        &#125;        return dp[m - 1][n - 1]    &#125;&#125;\n\n结果执行用时 : 2 ms, 击败 55.56% 使用 Swift 的用户\n内存消耗 : 15.24 MB, 击败 6.17% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun uniquePaths(m: Int, n: Int): Int &#123;        val dp = Array(m) &#123; IntArray(n) &#123; 0 &#125; &#125;        for (i in 0 until m) &#123;            dp[i][0] = 1        &#125;        for (j in 0 until n) &#123;            dp[0][j] = 1        &#125;        for (i in 1 until m) &#123;            for (j in 1 until n) &#123;                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]            &#125;        &#125;        return dp[m - 1][n - 1]    &#125;&#125;\n\n结果执行用时 : 140 ms, 击败 27.59% 使用 Kotlin 的用户\n内存消耗 : 32.59 MB, 击败 34.48% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int uniquePaths(int m, int n) &#123;    List&lt;List&lt;int&gt;&gt; dp = List.generate(m, (index) =&gt; List&lt;int&gt;.filled(n, 0));    for (int i = 0; i &lt; m; i++) &#123;      dp[i][0] = 1;    &#125;    for (int j = 0; j &lt; n; j++) &#123;      dp[0][j] = 1;    &#125;    for (int i = 1; i &lt; m; i++) &#123;      for (int j = 1; j &lt; n; j++) &#123;        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];      &#125;    &#125;    return dp[m - 1][n - 1];  &#125;&#125;\n\n结果执行用时 : 286 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 146.46 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc uniquePaths(m int, n int) int &#123;    dp := make([][]int, m)    for i := 0; i &lt; m; i++ &#123;        dp[i] = make([]int, n)    &#125;    for i := 0; i &lt; m; i++ &#123;        dp[i][0] = 1    &#125;    for j := 0; j &lt; n; j++ &#123;        dp[0][j] = 1    &#125;    for i := 1; i &lt; m; i++ &#123;        for j := 1; j &lt; n; j++ &#123;            dp[i][j] = dp[i-1][j] + dp[i][j-1]        &#125;    &#125;    return dp[m-1][n-1]&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 1.95 MB, 击败 26.78% 使用 Go 的用户\n\nRuby# @param &#123;Integer&#125; m# @param &#123;Integer&#125; n# @return &#123;Integer&#125;def unique_paths(m, n)  dp = Array.new(m) &#123; Array.new(n, 0) &#125;  (0...m).each &#123; |i| dp[i][0] = 1 &#125;  (0...n).each &#123; |j| dp[0][j] = 1 &#125;  (1...m).each do |i|    (1...n).each do |j|      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]    end  end  dp[m - 1][n - 1]end\n\n结果执行用时 : 69 ms, 击败 -% 使用 Ruby 的用户\n内存消耗 : 206.30 MB, 击败 -% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def uniquePaths(m: Int, n: Int): Int = &#123;    val dp = Array.ofDim[Int](m, n)    for (i &lt;- 0 until m) &#123;      dp(i)(0) = 1    &#125;    for (j &lt;- 0 until n) &#123;      dp(0)(j) = 1    &#125;    for (i &lt;- 1 until m) &#123;      for (j &lt;- 1 until n) &#123;        dp(i)(j) = dp(i - 1)(j) + dp(i)(j - 1)      &#125;    &#125;    dp(m - 1)(n - 1)  &#125;&#125;\n\n结果执行用时 : 398 ms, 击败 100.00% 使用 Scala 的用户\n内存消耗 : 51.44 MB, 击败 33.33% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn unique_paths(m: i32, n: i32) -&gt; i32 &#123;        let mut dp = vec![vec![0; n as usize]; m as usize];        for i in 0..m as usize &#123;            dp[i][0] = 1;        &#125;        for j in 0..n as usize &#123;            dp[0][j] = 1;        &#125;        for i in 1..m as usize &#123;            for j in 1..n as usize &#123;                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];            &#125;        &#125;        dp[(m - 1) as usize][(n - 1) as usize]    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 1.98 MB, 击败 79.41% 使用 Rust 的用户\n\nRacket(define/contract (unique-paths m n)  (-&gt; exact-integer? exact-integer? exact-integer?)  (let ((dp (make-vector m (make-vector n 0))))    (for ([i (in-range m)])      (vector-set! (vector-ref dp i) 0 1))    (for ([j (in-range n)])      (vector-set! (vector-ref dp 0) j 1))    (for ([i (in-range 1 m)])      (for ([j (in-range 1 n)])        (vector-set! (vector-ref dp i) j (+ (vector-ref (vector-ref dp (sub1 i)) j)                                           (vector-ref (vector-ref dp i) (sub1 j))))))    (vector-ref (vector-ref dp (sub1 m)) (sub1 n))))\n\n结果执行用时 : 174 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 97.84 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"女超人 第五季 第十五集 现实字节","url":"/zh-CN/47f06c5203e8/","content":"\n剧情介绍　　尼娅的室友伊薇特遭到一名男子的攻击，这名男子针对梦者，因为他不喜欢梦者是跨性别者，并要求她放弃成为超级英雄。为了保护她的社区免受更多伤害，梦者坚定地拒绝屈服于威胁，并主动站出来与他对抗。女超人全力支持梦者，并向布雷尼寻求额外的帮助。与此同时，亚历克斯、琼恩和凯莉尝试营救被困在虚拟现实逃脱室中的一名男子。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第一季 第十五集 斩首示众","url":"/zh-CN/1597310fd268/","content":"\n剧情介绍　　当卡特赖特向凯特讲述一个扭曲的故事时，爱丽丝黑暗的过去更多地被揭露。与此同时，雅各布正在寻找他迷途的女儿。玛丽和卢克则追踪一条有关贝丝凶手的线索。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"超级马力欧 奥德赛","url":"/zh-CN/2f703a683557/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"马力欧卡丁车8 豪华版","url":"/zh-CN/3e3c772fb5a6/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"力扣00063.不同路径 II","url":"/zh-CN/0ee8edb4fd04/","content":"\n题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n网格中的障碍物和空位置分别用 1 和 0 来表示。\n示例 1：\n\n\n输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：\n\n向右 -&gt; 向右 -&gt; 向下 -&gt; 向下\n向下 -&gt; 向下 -&gt; 向右 -&gt; 向右\n\n\n示例 2：\n\n\n输入：obstacleGrid &#x3D; [[0,1],[0,0]]输出：1\n\n提示：\nm &#x3D;&#x3D; obstacleGrid.length\nn &#x3D;&#x3D; obstacleGrid[i].length\n1 &lt;&#x3D; m, n &lt;&#x3D; 100\nobstacleGrid[i][j] 为 0 或 1\n\n\n解决方法C++class Solution &#123;public:    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;        int m = obstacleGrid.size();        int n = obstacleGrid[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));        dp[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0;        for (int i = 1; i &lt; m; ++i) &#123;            dp[i][0] = obstacleGrid[i][0] == 0 ? dp[i-1][0] : 0;        &#125;        for (int j = 1; j &lt; n; ++j) &#123;            dp[0][j] = obstacleGrid[0][j] == 0 ? dp[0][j-1] : 0;        &#125;        for (int i = 1; i &lt; m; ++i) &#123;            for (int j = 1; j &lt; n; ++j) &#123;                if (obstacleGrid[i][j] == 0) &#123;                    dp[i][j] = dp[i-1][j] + dp[i][j-1];                &#125; else &#123;                    dp[i][j] = 0;                &#125;            &#125;        &#125;        return dp[m-1][n-1];    &#125;&#125;;\n\n结果执行用时 : 3 ms, 击败 61.23% 使用 C++ 的用户\n内存消耗 : 9.98 MB, 击败 24.67% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;        int m = obstacleGrid.length;        int n = obstacleGrid[0].length;        int[][] dp = new int[m][n];        dp[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0;        for (int i = 1; i &lt; m; ++i) &#123;            dp[i][0] = obstacleGrid[i][0] == 0 ? dp[i - 1][0] : 0;        &#125;        for (int j = 1; j &lt; n; ++j) &#123;            dp[0][j] = obstacleGrid[0][j] == 0 ? dp[0][j - 1] : 0;        &#125;        for (int i = 1; i &lt; m; ++i) &#123;            for (int j = 1; j &lt; n; ++j) &#123;                if (obstacleGrid[i][j] == 0) &#123;                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];                &#125; else &#123;                    dp[i][j] = 0;                &#125;            &#125;        &#125;        return dp[m - 1][n - 1];    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 40.91 MB, 击败 5.02% 使用 Java 的用户\n\nPythonclass Solution(object):    def uniquePathsWithObstacles(self, obstacleGrid):        &quot;&quot;&quot;        :type obstacleGrid: List[List[int]]        :rtype: int        &quot;&quot;&quot;        m, n = len(obstacleGrid), len(obstacleGrid[0])        dp = [[0] * n for _ in range(m)]        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0        for i in range(1, m):            dp[i][0] = dp[i - 1][0] if obstacleGrid[i][0] == 0 else 0        for j in range(1, n):            dp[0][j] = dp[0][j - 1] if obstacleGrid[0][j] == 0 else 0        for i in range(1, m):            for j in range(1, n):                if obstacleGrid[i][j] == 0:                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]                else:                    dp[i][j] = 0        return dp[-1][-1]\n\n结果执行用时 : 10 ms, 击败 95.03% 使用 Python 的用户\n内存消耗 : 11.41 MB, 击败 90.60% 使用 Python 的用户\n\nPython3class Solution:    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:        m, n = len(obstacleGrid), len(obstacleGrid[0])        dp = [[0] * n for _ in range(m)]        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0        for i in range(1, m):            dp[i][0] = dp[i - 1][0] if obstacleGrid[i][0] == 0 else 0        for j in range(1, n):            dp[0][j] = dp[0][j - 1] if obstacleGrid[0][j] == 0 else 0        for i in range(1, m):            for j in range(1, n):                if obstacleGrid[i][j] == 0:                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]                else:                    dp[i][j] = 0        return dp[-1][-1]\n\n结果执行用时 : 26 ms, 击败 99.27% 使用 Python3 的用户\n内存消耗 : 16.46 MB, 击败 60.61% 使用 Python3 的用户\n\nCint uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize) &#123;    int m = obstacleGridSize;    int n = obstacleGridColSize[0];    int dp[m][n];    dp[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0;    for (int i = 1; i &lt; m; ++i) &#123;        dp[i][0] = obstacleGrid[i][0] == 0 ? dp[i - 1][0] : 0;    &#125;    for (int j = 1; j &lt; n; ++j) &#123;        dp[0][j] = obstacleGrid[0][j] == 0 ? dp[0][j - 1] : 0;    &#125;    for (int i = 1; i &lt; m; ++i) &#123;        for (int j = 1; j &lt; n; ++j) &#123;            if (obstacleGrid[i][j] == 0) &#123;                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];            &#125; else &#123;                dp[i][j] = 0;            &#125;        &#125;    &#125;    return dp[m - 1][n - 1];&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 5.82 MB, 击败 78.57% 使用 C 的用户\n\nC#public class Solution &#123;    public int UniquePathsWithObstacles(int[][] obstacleGrid) &#123;        int m = obstacleGrid.Length;        int n = obstacleGrid[0].Length;        int[,] dp = new int[m, n];        dp[0, 0] = obstacleGrid[0][0] == 0 ? 1 : 0;        for (int i = 1; i &lt; m; ++i) &#123;            dp[i, 0] = obstacleGrid[i][0] == 0 ? dp[i - 1, 0] : 0;        &#125;        for (int j = 1; j &lt; n; ++j) &#123;            dp[0, j] = obstacleGrid[0][j] == 0 ? dp[0, j - 1] : 0;        &#125;        for (int i = 1; i &lt; m; ++i) &#123;            for (int j = 1; j &lt; n; ++j) &#123;                if (obstacleGrid[i][j] == 0) &#123;                    dp[i, j] = dp[i - 1, j] + dp[i, j - 1];                &#125; else &#123;                    dp[i, j] = 0;                &#125;            &#125;        &#125;        return dp[m - 1, n - 1];    &#125;&#125;\n\n结果执行用时 : 59 ms, 击败 79.63% 使用 C# 的用户\n内存消耗 : 40.20 MB, 击败 46.91% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[][]&#125; obstacleGrid * @return &#123;number&#125; */var uniquePathsWithObstacles = function(obstacleGrid) &#123;    const m = obstacleGrid.length;    const n = obstacleGrid[0].length;    const dp = new Array(m).fill(0).map(() =&gt; new Array(n).fill(0));    dp[0][0] = obstacleGrid[0][0] === 0 ? 1 : 0;    for (let i = 1; i &lt; m; ++i) &#123;        dp[i][0] = obstacleGrid[i][0] === 0 ? dp[i - 1][0] : 0;    &#125;    for (let j = 1; j &lt; n; ++j) &#123;        dp[0][j] = obstacleGrid[0][j] === 0 ? dp[0][j - 1] : 0;    &#125;    for (let i = 1; i &lt; m; ++i) &#123;        for (let j = 1; j &lt; n; ++j) &#123;            if (obstacleGrid[i][j] === 0) &#123;                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];            &#125; else &#123;                dp[i][j] = 0;            &#125;        &#125;    &#125;    return dp[m - 1][n - 1];&#125;;\n\n结果执行用时 : 57 ms, 击败 83.99% 使用 JavaScript 的用户\n内存消耗 : 50.55 MB, 击败 10.73% 使用 JavaScript 的用户\n\nTypeScriptfunction uniquePathsWithObstacles(obstacleGrid: number[][]): number &#123;    const m: number = obstacleGrid.length;    const n: number = obstacleGrid[0].length;    const dp: number[][] = Array.from(&#123; length: m &#125;, () =&gt; Array(n).fill(0));    dp[0][0] = obstacleGrid[0][0] === 0 ? 1 : 0;    for (let i = 1; i &lt; m; ++i) &#123;        dp[i][0] = obstacleGrid[i][0] === 0 ? dp[i - 1][0] : 0;    &#125;    for (let j = 1; j &lt; n; ++j) &#123;        dp[0][j] = obstacleGrid[0][j] === 0 ? dp[0][j - 1] : 0;    &#125;    for (let i = 1; i &lt; m; ++i) &#123;        for (let j = 1; j &lt; n; ++j) &#123;            if (obstacleGrid[i][j] === 0) &#123;                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];            &#125; else &#123;                dp[i][j] = 0;            &#125;        &#125;    &#125;    return dp[m - 1][n - 1];&#125;\n\n结果执行用时 : 67 ms, 击败 62.72% 使用 TypeScript 的用户\n内存消耗 : 52.36 MB, 击败 21.30% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[][] $obstacleGrid     * @return Integer     */    function uniquePathsWithObstacles($obstacleGrid) &#123;        $m = count($obstacleGrid);        $n = count($obstacleGrid[0]);        $dp = array_fill(0, $m, array_fill(0, $n, 0));        $dp[0][0] = $obstacleGrid[0][0] === 0 ? 1 : 0;        for ($i = 1; $i &lt; $m; ++$i) &#123;            $dp[$i][0] = $obstacleGrid[$i][0] === 0 ? $dp[$i - 1][0] : 0;        &#125;        for ($j = 1; $j &lt; $n; ++$j) &#123;            $dp[0][$j] = $obstacleGrid[0][$j] === 0 ? $dp[0][$j - 1] : 0;        &#125;        for ($i = 1; $i &lt; $m; ++$i) &#123;            for ($j = 1; $j &lt; $n; ++$j) &#123;                if ($obstacleGrid[$i][$j] === 0) &#123;                    $dp[$i][$j] = $dp[$i - 1][$j] + $dp[$i][$j - 1];                &#125; else &#123;                    $dp[$i][$j] = 0;                &#125;            &#125;        &#125;        return $dp[$m - 1][$n - 1];    &#125;&#125;\n\n结果执行用时 : 13 ms, 击败 14.29% 使用 PHP 的用户\n内存消耗 : 20.22 MB, 击败 14.29% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -&gt; Int &#123;        let m = obstacleGrid.count        let n = obstacleGrid[0].count        var dp = [[Int]](repeating: [Int](repeating: 0, count: n), count: m)        dp[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0        for i in 1..&lt;m &#123;            dp[i][0] = obstacleGrid[i][0] == 0 ? dp[i - 1][0] : 0        &#125;        for j in 1..&lt;n &#123;            dp[0][j] = obstacleGrid[0][j] == 0 ? dp[0][j - 1] : 0        &#125;        for i in 1..&lt;m &#123;            for j in 1..&lt;n &#123;                if obstacleGrid[i][j] == 0 &#123;                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]                &#125; else &#123;                    dp[i][j] = 0                &#125;            &#125;        &#125;        return dp[m - 1][n - 1]    &#125;&#125;\n\n结果执行用时 : 4 ms, 击败 92.41% 使用 Swift 的用户\n内存消耗 : 15.29 MB, 击败 40.51% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun uniquePathsWithObstacles(obstacleGrid: Array&lt;IntArray&gt;): Int &#123;        val m = obstacleGrid.size        val n = obstacleGrid[0].size        val dp = Array(m) &#123; IntArray(n) &#125;        dp[0][0] = if (obstacleGrid[0][0] == 0) 1 else 0        for (i in 1 until m) &#123;            dp[i][0] = if (obstacleGrid[i][0] == 0) dp[i - 1][0] else 0        &#125;        for (j in 1 until n) &#123;            dp[0][j] = if (obstacleGrid[0][j] == 0) dp[0][j - 1] else 0        &#125;        for (i in 1 until m) &#123;            for (j in 1 until n) &#123;                dp[i][j] = if (obstacleGrid[i][j] == 0) &#123;                    dp[i - 1][j] + dp[i][j - 1]                &#125; else &#123;                    0                &#125;            &#125;        &#125;        return dp[m - 1][n - 1]    &#125;&#125;\n\n结果执行用时 : 145 ms, 击败 89.29% 使用 Kotlin 的用户\n内存消耗 : 34.70 MB, 击败 100.00% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int uniquePathsWithObstacles(List&lt;List&lt;int&gt;&gt; obstacleGrid) &#123;    int m = obstacleGrid.length;    int n = obstacleGrid[0].length;    List&lt;List&lt;int&gt;&gt; dp = List.generate(m, (index) =&gt; List&lt;int&gt;.filled(n, 0));    dp[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0;    for (int i = 1; i &lt; m; ++i) &#123;      dp[i][0] = obstacleGrid[i][0] == 0 ? dp[i - 1][0] : 0;    &#125;    for (int j = 1; j &lt; n; ++j) &#123;      dp[0][j] = obstacleGrid[0][j] == 0 ? dp[0][j - 1] : 0;    &#125;    for (int i = 1; i &lt; m; ++i) &#123;      for (int j = 1; j &lt; n; ++j) &#123;        if (obstacleGrid[i][j] == 0) &#123;          dp[i][j] = dp[i - 1][j] + dp[i][j - 1];        &#125; else &#123;          dp[i][j] = 0;        &#125;      &#125;    &#125;    return dp[m - 1][n - 1];  &#125;&#125;\n\n结果执行用时 : 281 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 148.41 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc uniquePathsWithObstacles(obstacleGrid [][]int) int &#123;    m := len(obstacleGrid)    n := len(obstacleGrid[0])    dp := make([][]int, m)    for i := range dp &#123;        dp[i] = make([]int, n)    &#125;    dp[0][0] = 1 - obstacleGrid[0][0]    for i := 1; i &lt; m; i++ &#123;        if obstacleGrid[i][0] == 0 &#123;            dp[i][0] = dp[i-1][0]        &#125;    &#125;    for j := 1; j &lt; n; j++ &#123;        if obstacleGrid[0][j] == 0 &#123;            dp[0][j] = dp[0][j-1]        &#125;    &#125;    for i := 1; i &lt; m; i++ &#123;        for j := 1; j &lt; n; j++ &#123;            if obstacleGrid[i][j] == 0 &#123;                dp[i][j] = dp[i-1][j] + dp[i][j-1]            &#125;        &#125;    &#125;    return dp[m-1][n-1]&#125;\n\n结果执行用时 : 1 ms, 击败 34.05% 使用 Go 的用户\n内存消耗 : 2.28 MB, 击败 29.77% 使用 Go 的用户\n\nRuby# @param &#123;Integer[][]&#125; obstacle_grid# @return &#123;Integer&#125;def unique_paths_with_obstacles(obstacle_grid)    m = obstacle_grid.length    n = obstacle_grid[0].length    dp = Array.new(m) &#123; Array.new(n, 0) &#125;    dp[0][0] = 1 - obstacle_grid[0][0]    (1...m).each do |i|        dp[i][0] = dp[i-1][0] if obstacle_grid[i][0] == 0    end    (1...n).each do |j|        dp[0][j] = dp[0][j-1] if obstacle_grid[0][j] == 0    end    (1...m).each do |i|        (1...n).each do |j|            dp[i][j] = dp[i-1][j] + dp[i][j-1] if obstacle_grid[i][j] == 0        end    end    dp[m-1][n-1]end\n\n结果执行用时 : 35 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.51 MB, 击败 -% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def uniquePathsWithObstacles(obstacleGrid: Array[Array[Int]]): Int = &#123;    val m = obstacleGrid.length    val n = obstacleGrid(0).length    val dp = Array.ofDim[Int](m, n)    dp(0)(0) = 1 - obstacleGrid(0)(0)    for (i &lt;- 1 until m) &#123;      dp(i)(0) = if (obstacleGrid(i)(0) == 0) dp(i-1)(0) else 0    &#125;    for (j &lt;- 1 until n) &#123;      dp(0)(j) = if (obstacleGrid(0)(j) == 0) dp(0)(j-1) else 0    &#125;    for (i &lt;- 1 until m) &#123;      for (j &lt;- 1 until n) &#123;        dp(i)(j) = if (obstacleGrid(i)(j) == 0) dp(i-1)(j) + dp(i)(j-1) else 0      &#125;    &#125;    dp(m-1)(n-1)  &#125;&#125;\n\n结果执行用时 : 582 ms, 击败 -% 使用 Scala 的用户\n内存消耗 : 56.59 MB, 击败 -% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn unique_paths_with_obstacles(obstacle_grid: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 &#123;        let m = obstacle_grid.len();        let n = obstacle_grid[0].len();        let mut dp = vec![vec![0; n]; m];        dp[0][0] = 1 - obstacle_grid[0][0];        for i in 1..m &#123;            dp[i][0] = if obstacle_grid[i][0] == 0 &#123; dp[i - 1][0] &#125; else &#123; 0 &#125;;        &#125;        for j in 1..n &#123;            dp[0][j] = if obstacle_grid[0][j] == 0 &#123; dp[0][j - 1] &#125; else &#123; 0 &#125;;        &#125;        for i in 1..m &#123;            for j in 1..n &#123;                dp[i][j] = if obstacle_grid[i][j] == 0 &#123;                    dp[i - 1][j] + dp[i][j - 1]                &#125; else &#123;                    0                &#125;;            &#125;        &#125;        dp[m - 1][n - 1]    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.09 MB, 击败 50.00% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"闪电侠 第六季 第十五集 纳什·威尔斯的驱魔术","url":"/zh-CN/1c85fbc5a050/","content":"\n剧情介绍　　闪电侠和一个叫Sunshine的变种人对抗，西斯科着手帮助纳什。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00064.最小路径和","url":"/zh-CN/e5898f53c6e6/","content":"\n题目描述给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n说明：每次只能向下或者向右移动一步。\n示例 1：\n\n\n输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]输出：7解释：因为路径 1→3→1→1→1 的总和最小。\n\n示例 2：\n输入：grid &#x3D; [[1,2,3],[4,5,6]]输出：12\n\n提示：\nm &#x3D;&#x3D; grid.length\nn &#x3D;&#x3D; grid[i].length\n1 &lt;&#x3D; m, n &lt;&#x3D; 200\n0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 200\n\n\n解决方法C++class Solution &#123;public:    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int m = grid.size();        int n = grid[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));        dp[0][0] = grid[0][0];        for (int i = 1; i &lt; m; ++i) &#123;            dp[i][0] = dp[i-1][0] + grid[i][0];        &#125;        for (int j = 1; j &lt; n; ++j) &#123;            dp[0][j] = dp[0][j-1] + grid[0][j];        &#125;        for (int i = 1; i &lt; m; ++i) &#123;            for (int j = 1; j &lt; n; ++j) &#123;                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];            &#125;        &#125;        return dp[m-1][n-1];    &#125;&#125;;\n\n结果执行用时 : 6 ms, 击败 75.52% 使用 C++ 的用户\n内存消耗 : 12.29 MB, 击败 16.65% 使用 C++ 的用户\n\nJavapublic class Solution &#123;    public int minPathSum(int[][] grid) &#123;        int m = grid.length;        int n = grid[0].length;        int[][] dp = new int[m][n];        dp[0][0] = grid[0][0];        for (int i = 1; i &lt; m; ++i) &#123;            dp[i][0] = dp[i-1][0] + grid[i][0];        &#125;        for (int j = 1; j &lt; n; ++j) &#123;            dp[0][j] = dp[0][j-1] + grid[0][j];        &#125;        for (int i = 1; i &lt; m; ++i) &#123;            for (int j = 1; j &lt; n; ++j) &#123;                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];            &#125;        &#125;        return dp[m-1][n-1];    &#125;&#125;\n\n结果执行用时 : 2 ms, 击败 94.43% 使用 Java 的用户\n内存消耗 : 44.47 MB, 击败 22.64% 使用 Java 的用户\n\nPythonclass Solution(object):    def minPathSum(self, grid):        &quot;&quot;&quot;        :type grid: List[List[int]]        :rtype: int        &quot;&quot;&quot;        m, n = len(grid), len(grid[0])        dp = [[0] * n for _ in range(m)]        dp[0][0] = grid[0][0]        for i in range(1, m):            dp[i][0] = dp[i-1][0] + grid[i][0]        for j in range(1, n):            dp[0][j] = dp[0][j-1] + grid[0][j]        for i in range(1, m):            for j in range(1, n):                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]        return dp[m-1][n-1]\n\n结果执行用时 : 19 ms, 击败 94.35% 使用 Python 的用户\n内存消耗 : 12.98 MB, 击败 82.03% 使用 Python 的用户\n\nPython3class Solution:    def minPathSum(self, grid: List[List[int]]) -&gt; int:        m, n = len(grid), len(grid[0])        dp = [[0] * n for _ in range(m)]        dp[0][0] = grid[0][0]        for i in range(1, m):            dp[i][0] = dp[i-1][0] + grid[i][0]        for j in range(1, n):            dp[0][j] = dp[0][j-1] + grid[0][j]        for i in range(1, m):            for j in range(1, n):                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]        return dp[m-1][n-1]\n\n结果执行用时 : 46 ms, 击败 70.68% 使用 Python3 的用户\n内存消耗 : 18.70 MB, 击败 40.45% 使用 Python3 的用户\n\nCint min(int a, int b) &#123;    return a &lt; b ? a : b;&#125;int minPathSum(int** grid, int gridSize, int* gridColSize) &#123;    int m = gridSize;    int n = *gridColSize;    int** dp = (int**)malloc(m * sizeof(int*));    for (int i = 0; i &lt; m; ++i) &#123;        dp[i] = (int*)malloc(n * sizeof(int));    &#125;    dp[0][0] = grid[0][0];    for (int i = 1; i &lt; m; ++i) &#123;        dp[i][0] = dp[i-1][0] + grid[i][0];    &#125;    for (int j = 1; j &lt; n; ++j) &#123;        dp[0][j] = dp[0][j-1] + grid[0][j];    &#125;    for (int i = 1; i &lt; m; ++i) &#123;        for (int j = 1; j &lt; n; ++j) &#123;            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];        &#125;    &#125;    int result = dp[m-1][n-1];    for (int i = 0; i &lt; m; ++i) &#123;        free(dp[i]);    &#125;    free(dp);    return result;&#125;\n\n结果执行用时 : 9 ms, 击败 39.13% 使用 C 的用户\n内存消耗 : 7.18 MB, 击败 65.60% 使用 C 的用户\n\nC#public class Solution &#123;    public int MinPathSum(int[][] grid) &#123;        int m = grid.Length;        int n = grid[0].Length;        int[][] dp = new int[m][];        for (int i = 0; i &lt; m; ++i) &#123;            dp[i] = new int[n];        &#125;        dp[0][0] = grid[0][0];        for (int i = 1; i &lt; m; ++i) &#123;            dp[i][0] = dp[i-1][0] + grid[i][0];        &#125;        for (int j = 1; j &lt; n; ++j) &#123;            dp[0][j] = dp[0][j-1] + grid[0][j];        &#125;        for (int i = 1; i &lt; m; ++i) &#123;            for (int j = 1; j &lt; n; ++j) &#123;                dp[i][j] = Math.Min(dp[i-1][j], dp[i][j-1]) + grid[i][j];            &#125;        &#125;        return dp[m-1][n-1];    &#125;&#125;\n\n结果执行用时 : 76 ms, 击败 65.48% 使用 C# 的用户\n内存消耗 : 43.01 MB, 击败 20.84% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var minPathSum = function(grid) &#123;    const m = grid.length;    const n = grid[0].length;    const dp = new Array(m);    for (let i = 0; i &lt; m; ++i) &#123;        dp[i] = new Array(n);    &#125;    dp[0][0] = grid[0][0];    for (let i = 1; i &lt; m; ++i) &#123;        dp[i][0] = dp[i-1][0] + grid[i][0];    &#125;    for (let j = 1; j &lt; n; ++j) &#123;        dp[0][j] = dp[0][j-1] + grid[0][j];    &#125;    for (let i = 1; i &lt; m; ++i) &#123;        for (let j = 1; j &lt; n; ++j) &#123;            dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];        &#125;    &#125;    return dp[m-1][n-1];&#125;;\n\n结果执行用时 : 54 ms, 击败 95.33% 使用 JavaScript 的用户\n内存消耗 : 51.90 MB, 击败 18.70% 使用 JavaScript 的用户\n\nTypeScriptfunction minPathSum(grid: number[][]): number &#123;    const m = grid.length;    const n = grid[0].length;    const dp: number[][] = new Array(m);    for (let i = 0; i &lt; m; ++i) &#123;        dp[i] = new Array(n);    &#125;    dp[0][0] = grid[0][0];    for (let i = 1; i &lt; m; ++i) &#123;        dp[i][0] = dp[i-1][0] + grid[i][0];    &#125;    for (let j = 1; j &lt; n; ++j) &#123;        dp[0][j] = dp[0][j-1] + grid[0][j];    &#125;    for (let i = 1; i &lt; m; ++i) &#123;        for (let j = 1; j &lt; n; ++j) &#123;            dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];        &#125;    &#125;    return dp[m-1][n-1];&#125;\n\n结果执行用时 : 52 ms, 击败 99.50% 使用 TypeScript 的用户\n内存消耗 : 52.69 MB, 击败 16.42% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[][] $grid     * @return Integer     */    function minPathSum($grid) &#123;        $m = count($grid);        $n = count($grid[0]);        $dp = array();        for ($i = 0; $i &lt; $m; ++$i) &#123;            $dp[$i] = array();        &#125;        $dp[0][0] = $grid[0][0];        for ($i = 1; $i &lt; $m; ++$i) &#123;            $dp[$i][0] = $dp[$i-1][0] + $grid[$i][0];        &#125;        for ($j = 1; $j &lt; $n; ++$j) &#123;            $dp[0][$j] = $dp[0][$j-1] + $grid[0][$j];        &#125;        for ($i = 1; $i &lt; $m; ++$i) &#123;            for ($j = 1; $j &lt; $n; ++$j) &#123;                $dp[$i][$j] = min($dp[$i-1][$j], $dp[$i][$j-1]) + $grid[$i][$j];            &#125;        &#125;        return $dp[$m-1][$n-1];    &#125;&#125;\n\n结果执行用时 : 19 ms, 击败 90.00% 使用 PHP 的用户\n内存消耗 : 21.95 MB, 击败 20.00% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func minPathSum(_ grid: [[Int]]) -&gt; Int &#123;        let m = grid.count        let n = grid[0].count        var dp = Array(repeating: Array(repeating: 0, count: n), count: m)        dp[0][0] = grid[0][0]        for i in 1..&lt;m &#123;            dp[i][0] = dp[i-1][0] + grid[i][0]        &#125;        for j in 1..&lt;n &#123;            dp[0][j] = dp[0][j-1] + grid[0][j]        &#125;        for i in 1..&lt;m &#123;            for j in 1..&lt;n &#123;                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]            &#125;        &#125;        return dp[m-1][n-1]    &#125;&#125;\n\n结果执行用时 : 21 ms, 击败 85.23% 使用 Swift 的用户\n内存消耗 : 15.73 MB, 击败 21.59% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun minPathSum(grid: Array&lt;IntArray&gt;): Int &#123;        val m = grid.size        val n = grid[0].size        val dp = Array(m) &#123; IntArray(n) &#125;        dp[0][0] = grid[0][0]        for (i in 1 until m) &#123;            dp[i][0] = dp[i-1][0] + grid[i][0]        &#125;        for (j in 1 until n) &#123;            dp[0][j] = dp[0][j-1] + grid[0][j]        &#125;        for (i in 1 until m) &#123;            for (j in 1 until n) &#123;                dp[i][j] = minOf(dp[i-1][j], dp[i][j-1]) + grid[i][j]            &#125;        &#125;        return dp[m-1][n-1]    &#125;&#125;\n\n结果执行用时 : 167 ms, 击败 87.04% 使用 Kotlin 的用户\n内存消耗 : 36.41 MB, 击败 74.07% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  int minPathSum(List&lt;List&lt;int&gt;&gt; grid) &#123;    int m = grid.length;    int n = grid[0].length;    List&lt;List&lt;int&gt;&gt; dp = List.generate(m, (i) =&gt; List&lt;int&gt;.filled(n, 0));    dp[0][0] = grid[0][0];    for (int i = 1; i &lt; m; ++i) &#123;      dp[i][0] = dp[i - 1][0] + grid[i][0];    &#125;    for (int j = 1; j &lt; n; ++j) &#123;      dp[0][j] = dp[0][j - 1] + grid[0][j];    &#125;    for (int i = 1; i &lt; m; ++i) &#123;      for (int j = 1; j &lt; n; ++j) &#123;        dp[i][j] = grid[i][j] + (dp[i - 1][j] &lt; dp[i][j - 1] ? dp[i - 1][j] : dp[i][j - 1]);      &#125;    &#125;    return dp[m - 1][n - 1];  &#125;&#125;\n\n结果执行用时 : 294 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 148.70 MB, 击败 -% 使用 Dart 的用户\n\nGofunc minPathSum(grid [][]int) int &#123;    m := len(grid)    n := len(grid[0])    dp := make([][]int, m)    for i := range dp &#123;        dp[i] = make([]int, n)    &#125;    dp[0][0] = grid[0][0]    for i := 1; i &lt; m; i++ &#123;        dp[i][0] = dp[i-1][0] + grid[i][0]    &#125;    for j := 1; j &lt; n; j++ &#123;        dp[0][j] = dp[0][j-1] + grid[0][j]    &#125;    for i := 1; i &lt; m; i++ &#123;        for j := 1; j &lt; n; j++ &#123;            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]        &#125;    &#125;    return dp[m-1][n-1]&#125;\n\n结果执行用时 : 5 ms, 击败 43.61% 使用 Go 的用户\n内存消耗 : 3.74 MB, 击败 58.48% 使用 Go 的用户\n\nRuby# @param &#123;Integer[][]&#125; grid# @return &#123;Integer&#125;def min_path_sum(grid)  m = grid.length  n = grid[0].length  dp = Array.new(m) &#123; Array.new(n, 0) &#125;  dp[0][0] = grid[0][0]  (1...m).each &#123; |i| dp[i][0] = dp[i-1][0] + grid[i][0] &#125;  (1...n).each &#123; |j| dp[0][j] = dp[0][j-1] + grid[0][j] &#125;  (1...m).each do |i|    (1...n).each do |j|      dp[i][j] = [dp[i-1][j], dp[i][j-1]].min + grid[i][j]    end  end  dp[m-1][n-1]end\n\n结果执行用时 : 75 ms, 击败 66.67% 使用 Ruby 的用户\n内存消耗 : 207.84 MB, 击败 0.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def minPathSum(grid: Array[Array[Int]]): Int = &#123;    val m = grid.length    val n = grid(0).length    val dp = Array.ofDim[Int](m, n)    dp(0)(0) = grid(0)(0)    for (i &lt;- 1 until m) &#123;      dp(i)(0) = dp(i-1)(0) + grid(i)(0)    &#125;    for (j &lt;- 1 until n) &#123;      dp(0)(j) = dp(0)(j-1) + grid(0)(j)    &#125;    for (i &lt;- 1 until m) &#123;      for (j &lt;- 1 until n) &#123;        dp(i)(j) = math.min(dp(i-1)(j), dp(i)(j-1)) + grid(i)(j)      &#125;    &#125;    dp(m-1)(n-1)  &#125;&#125;\n\n结果执行用时 : 667 ms, 击败 14.29% 使用 Scala 的用户\n内存消耗 : 56.80 MB, 击败 100.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn min_path_sum(grid: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 &#123;        let m = grid.len();        let n = grid[0].len();        let mut dp = vec![vec![0; n]; m];        dp[0][0] = grid[0][0];        for i in 1..m &#123;            dp[i][0] = dp[i-1][0] + grid[i][0];        &#125;        for j in 1..n &#123;            dp[0][j] = dp[0][j-1] + grid[0][j];        &#125;        for i in 1..m &#123;            for j in 1..n &#123;                dp[i][j] = dp[i-1][j].min(dp[i][j-1]) + grid[i][j];            &#125;        &#125;        dp[m-1][n-1]    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.40 MB, 击败 65.57% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00065.有效数字","url":"/zh-CN/09a6b11a86b2/","content":"\n题目描述有效数字（按顺序）可以分成以下几个部分：\n\n一个 小数 或者 整数\n（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数\n\n小数（按顺序）可以分成以下几个部分：\n\n（可选）一个符号字符（’+’ 或 ‘-‘）\n下述格式之一：\n至少一位数字，后面跟着一个点 ‘.’\n至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字\n一个点 ‘.’ ，后面跟着至少一位数字\n\n\n\n整数（按顺序）可以分成以下几个部分：\n\n（可选）一个符号字符（’+’ 或 ‘-‘）\n至少一位数字\n\n部分有效数字列举如下：[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”]\n部分无效数字列举如下：[“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”]\n给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。\n示例 1：\n输入：s &#x3D; “0”输出：true\n\n示例 2：\n输入：s &#x3D; “e”输出：false\n\n示例 3：\n输入：s &#x3D; “.”输出：false\n\n提示：\n1 &lt;&#x3D; s.length &lt;&#x3D; 20\ns 仅含英文字母（大写和小写），数字（0-9），加号 ‘+’ ，减号 ‘-‘ ，或者点 ‘.’ 。\n\n\n解决方法C++class Solution &#123;public:    bool isNumber(string s) &#123;        if (s.length() &lt; 1 || s.length() &gt; 20) &#123;            return false;        &#125;        regex validNumberRegex(&quot;^[-+]?([0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)([eE][-+]?[0-9]+)?$&quot;);        return regex_match(s, validNumberRegex);    &#125;&#125;;\n\n结果执行用时 : 37 ms, 击败 8.95% 使用 C++ 的用户\n内存消耗 : 24.11 MB, 击败 7.88% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public boolean isNumber(String s) &#123;        Map&lt;State, Map&lt;CharType, State&gt;&gt; transfer = new HashMap&lt;State, Map&lt;CharType, State&gt;&gt;();        Map&lt;CharType, State&gt; initialMap = new HashMap&lt;CharType, State&gt;() &#123;&#123;            put(CharType.NUMBER, State.INTEGER);            put(CharType.POINTC, State.POINT_WITHOUT_INT);            put(CharType.SIGN, State.INT_SIGN);        &#125;&#125;;        transfer.put(State.INITIAL, initialMap);        Map&lt;CharType, State&gt; intSignMap = new HashMap&lt;CharType, State&gt;() &#123;&#123;            put(CharType.NUMBER, State.INTEGER);            put(CharType.POINTC, State.POINT_WITHOUT_INT);        &#125;&#125;;        transfer.put(State.INT_SIGN, intSignMap);        Map&lt;CharType, State&gt; integerMap = new HashMap&lt;CharType, State&gt;() &#123;&#123;            put(CharType.NUMBER, State.INTEGER);            put(CharType.EXPC, State.EXP);            put(CharType.POINTC, State.POINT);        &#125;&#125;;        transfer.put(State.INTEGER, integerMap);        Map&lt;CharType, State&gt; pointMap = new HashMap&lt;CharType, State&gt;() &#123;&#123;            put(CharType.NUMBER, State.FRACTION);            put(CharType.EXPC, State.EXP);        &#125;&#125;;        transfer.put(State.POINT, pointMap);        Map&lt;CharType, State&gt; pointWithoutIntMap = new HashMap&lt;CharType, State&gt;() &#123;&#123;            put(CharType.NUMBER, State.FRACTION);        &#125;&#125;;        transfer.put(State.POINT_WITHOUT_INT, pointWithoutIntMap);        Map&lt;CharType, State&gt; fractionMap = new HashMap&lt;CharType, State&gt;() &#123;&#123;            put(CharType.NUMBER, State.FRACTION);            put(CharType.EXPC, State.EXP);        &#125;&#125;;        transfer.put(State.FRACTION, fractionMap);        Map&lt;CharType, State&gt; expMap = new HashMap&lt;CharType, State&gt;() &#123;&#123;            put(CharType.NUMBER, State.EXP_NUMBER);            put(CharType.SIGN, State.EXP_SIGN);        &#125;&#125;;        transfer.put(State.EXP, expMap);        Map&lt;CharType, State&gt; expSignMap = new HashMap&lt;CharType, State&gt;() &#123;&#123;            put(CharType.NUMBER, State.EXP_NUMBER);        &#125;&#125;;        transfer.put(State.EXP_SIGN, expSignMap);        Map&lt;CharType, State&gt; expNumberMap = new HashMap&lt;CharType, State&gt;() &#123;&#123;            put(CharType.NUMBER, State.EXP_NUMBER);        &#125;&#125;;        transfer.put(State.EXP_NUMBER, expNumberMap);        int length = s.length();        State state = State.INITIAL;        for (int i = 0; i &lt; length; i++) &#123;            CharType type = toCharType(s.charAt(i));            if (!transfer.get(state).containsKey(type)) &#123;                return false;            &#125; else &#123;                state = transfer.get(state).get(type);            &#125;        &#125;        return state == State.INTEGER || state == State.POINT || state == State.FRACTION || state == State.EXP_NUMBER || state == State.END;    &#125;    public CharType toCharType(char ch) &#123;        if (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;            return CharType.NUMBER;        &#125; else if (ch == &#x27;e&#x27; || ch == &#x27;E&#x27;) &#123;            return CharType.EXPC;        &#125; else if (ch == &#x27;.&#x27;) &#123;            return CharType.POINTC;        &#125; else if (ch == &#x27;+&#x27; || ch == &#x27;-&#x27;) &#123;            return CharType.SIGN;        &#125; else &#123;            return CharType.ILLEGAL;        &#125;    &#125;    enum State &#123;        INITIAL,        INT_SIGN,        INTEGER,        POINT,        POINT_WITHOUT_INT,        FRACTION,        EXP,        EXP_SIGN,        EXP_NUMBER,        END    &#125;    enum CharType &#123;        NUMBER,        EXPC,        POINTC,        SIGN,        ILLEGAL    &#125;&#125;\n\n结果执行用时 : 5 ms, 击败 30.97% 使用 Java 的用户\n内存消耗 : 43.59 MB, 击败 16.79% 使用 Java 的用户\n\nPythonclass Solution(object):    def isNumber(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: bool        &quot;&quot;&quot;        transition = &#123;            State.INITIAL: &#123;CharType.NUMBER: State.INTEGER, CharType.POINTC: State.POINT_WITHOUT_INT, CharType.SIGN: State.INT_SIGN&#125;,            State.INT_SIGN: &#123;CharType.NUMBER: State.INTEGER, CharType.POINTC: State.POINT_WITHOUT_INT&#125;,            State.INTEGER: &#123;CharType.NUMBER: State.INTEGER, CharType.EXPC: State.EXP, CharType.POINTC: State.POINT&#125;,            State.POINT: &#123;CharType.NUMBER: State.FRACTION, CharType.EXPC: State.EXP&#125;,            State.POINT_WITHOUT_INT: &#123;CharType.NUMBER: State.FRACTION&#125;,            State.FRACTION: &#123;CharType.NUMBER: State.FRACTION, CharType.EXPC: State.EXP&#125;,            State.EXP: &#123;CharType.NUMBER: State.EXP_NUMBER, CharType.SIGN: State.EXP_SIGN&#125;,            State.EXP_SIGN: &#123;CharType.NUMBER: State.EXP_NUMBER&#125;,            State.EXP_NUMBER: &#123;CharType.NUMBER: State.EXP_NUMBER&#125;        &#125;        len_s = len(s)        state = State.INITIAL        for i in range(len_s):            char_type = self.get_char_type(s[i])            if char_type not in transition[state]:                return False            else:                state = transition[state][char_type]        return state in &#123;State.INTEGER, State.POINT, State.FRACTION, State.EXP_NUMBER, State.END&#125;    def get_char_type(self, ch):        if ch.isdigit():            return CharType.NUMBER        elif ch == &quot;.&quot;:            return CharType.POINTC        elif ch == &quot;+&quot; or ch == &quot;-&quot;:            return CharType.SIGN        elif ch.lower() == &quot;e&quot;:            return CharType.EXPC        else:            return CharType.ILLEGALclass State:    INITIAL = &quot;INITIAL&quot;    INT_SIGN = &quot;INT_SIGN&quot;    INTEGER = &quot;INTEGER&quot;    POINT = &quot;POINT&quot;    POINT_WITHOUT_INT = &quot;POINT_WITHOUT_INT&quot;    FRACTION = &quot;FRACTION&quot;    EXP = &quot;EXP&quot;    EXP_SIGN = &quot;EXP_SIGN&quot;    EXP_NUMBER = &quot;EXP_NUMBER&quot;    END = &quot;END&quot;class CharType:    NUMBER = &quot;NUMBER&quot;    EXPC = &quot;EXPC&quot;    POINTC = &quot;POINTC&quot;    SIGN = &quot;SIGN&quot;    ILLEGAL = &quot;ILLEGAL&quot;\n\n结果执行用时 : 26 ms, 击败 69.23% 使用 Python 的用户\n内存消耗 : 11.41 MB, 击败 76.92% 使用 Python 的用户\n\nPython3class Solution:    def isNumber(self, s: str) -&gt; bool:        transition = &#123;            State.INITIAL: &#123;CharType.NUMBER: State.INTEGER, CharType.POINTC: State.POINT_WITHOUT_INT, CharType.SIGN: State.INT_SIGN&#125;,            State.INT_SIGN: &#123;CharType.NUMBER: State.INTEGER, CharType.POINTC: State.POINT_WITHOUT_INT&#125;,            State.INTEGER: &#123;CharType.NUMBER: State.INTEGER, CharType.EXPC: State.EXP, CharType.POINTC: State.POINT&#125;,            State.POINT: &#123;CharType.NUMBER: State.FRACTION, CharType.EXPC: State.EXP&#125;,            State.POINT_WITHOUT_INT: &#123;CharType.NUMBER: State.FRACTION&#125;,            State.FRACTION: &#123;CharType.NUMBER: State.FRACTION, CharType.EXPC: State.EXP&#125;,            State.EXP: &#123;CharType.NUMBER: State.EXP_NUMBER, CharType.SIGN: State.EXP_SIGN&#125;,            State.EXP_SIGN: &#123;CharType.NUMBER: State.EXP_NUMBER&#125;,            State.EXP_NUMBER: &#123;CharType.NUMBER: State.EXP_NUMBER&#125;        &#125;        len_s = len(s)        state = State.INITIAL        for i in range(len_s):            char_type = self.get_char_type(s[i])            if char_type not in transition[state]:                return False            else:                state = transition[state][char_type]        return state in &#123;State.INTEGER, State.POINT, State.FRACTION, State.EXP_NUMBER, State.END&#125;    def get_char_type(self, ch):        if ch.isdigit():            return CharType.NUMBER        elif ch == &quot;.&quot;:            return CharType.POINTC        elif ch == &quot;+&quot; or ch == &quot;-&quot;:            return CharType.SIGN        elif ch.lower() == &quot;e&quot;:            return CharType.EXPC        else:            return CharType.ILLEGALclass State:    INITIAL = &quot;INITIAL&quot;    INT_SIGN = &quot;INT_SIGN&quot;    INTEGER = &quot;INTEGER&quot;    POINT = &quot;POINT&quot;    POINT_WITHOUT_INT = &quot;POINT_WITHOUT_INT&quot;    FRACTION = &quot;FRACTION&quot;    EXP = &quot;EXP&quot;    EXP_SIGN = &quot;EXP_SIGN&quot;    EXP_NUMBER = &quot;EXP_NUMBER&quot;    END = &quot;END&quot;class CharType:    NUMBER = &quot;NUMBER&quot;    EXPC = &quot;EXPC&quot;    POINTC = &quot;POINTC&quot;    SIGN = &quot;SIGN&quot;    ILLEGAL = &quot;ILLEGAL&quot;\n\n结果执行用时 : 37 ms, 击败 85.06% 使用 Python3 的用户\n内存消耗 : 16.50 MB, 击败 37.66% 使用 Python3 的用户\n\nCenum State &#123;    INITIAL,    INT_SIGN,    INTEGER,    POINT,    POINT_WITHOUT_INT,    FRACTION,    EXP,    EXP_SIGN,    EXP_NUMBER,    END,    ILLEGAL&#125;;enum CharType &#123;    NUMBER,    EXPC,    POINTC,    SIGN,    ILLEGALC&#125;;enum CharType getCharType(char ch) &#123;    if (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;        return NUMBER;    &#125; else if (ch == &#x27;e&#x27; || ch == &#x27;E&#x27;) &#123;        return EXPC;    &#125; else if (ch == &#x27;.&#x27;) &#123;        return POINTC;    &#125; else if (ch == &#x27;+&#x27; || ch == &#x27;-&#x27;) &#123;        return SIGN;    &#125; else &#123;        return ILLEGALC;    &#125;&#125;enum State transfer(enum State st, enum CharType typ) &#123;    switch (st) &#123;        case INITIAL: &#123;            switch (typ) &#123;                case NUMBER:                    return INTEGER;                case POINTC:                    return POINT_WITHOUT_INT;                case SIGN:                    return INT_SIGN;                default:                    return ILLEGAL;            &#125;        &#125;        case INT_SIGN: &#123;            switch (typ) &#123;                case NUMBER:                    return INTEGER;                case POINTC:                    return POINT_WITHOUT_INT;                default:                    return ILLEGAL;            &#125;        &#125;        case INTEGER: &#123;            switch (typ) &#123;                case NUMBER:                    return INTEGER;                case EXPC:                    return EXP;                case POINTC:                    return POINT;                default:                    return ILLEGAL;            &#125;        &#125;        case POINT: &#123;            switch (typ) &#123;                case NUMBER:                    return FRACTION;                case EXPC:                    return EXP;                default:                    return ILLEGAL;            &#125;        &#125;        case POINT_WITHOUT_INT: &#123;            switch (typ) &#123;                case NUMBER:                    return FRACTION;                default:                    return ILLEGAL;            &#125;        &#125;        case FRACTION: &#123;            switch (typ) &#123;                case NUMBER:                    return FRACTION;                case EXPC:                    return EXP;                default:                    return ILLEGAL;            &#125;        &#125;        case EXP: &#123;            switch (typ) &#123;                case NUMBER:                    return EXP_NUMBER;                case SIGN:                    return EXP_SIGN;                default:                    return ILLEGAL;            &#125;        &#125;        case EXP_SIGN: &#123;            switch (typ) &#123;                case NUMBER:                    return EXP_NUMBER;                default:                    return ILLEGAL;            &#125;        &#125;        case EXP_NUMBER: &#123;            switch (typ) &#123;                case NUMBER:                    return EXP_NUMBER;                default:                    return ILLEGAL;            &#125;        &#125;        default:            return ILLEGAL;    &#125;&#125;bool isNumber(char* s) &#123;    int len = strlen(s);    enum State st = INITIAL;    for (int i = 0; i &lt; len; i++) &#123;        enum CharType typ = getCharType(s[i]);        enum State nextState = transfer(st, typ);        if (nextState == ILLEGAL) return false;        st = nextState;    &#125;    return st == INTEGER || st == POINT || st == FRACTION || st == EXP_NUMBER || st == END;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 5.52 MB, 击败 89.66% 使用 C 的用户\n\nC#public class Solution &#123;    public bool IsNumber(string s) &#123;        Dictionary&lt;State, Dictionary&lt;CharType, State&gt;&gt; transfer = new Dictionary&lt;State, Dictionary&lt;CharType, State&gt;&gt;();        Dictionary&lt;CharType, State&gt; initialDictionary = new Dictionary&lt;CharType, State&gt; &#123;            &#123;CharType.NUMBER, State.INTEGER&#125;,            &#123;CharType.POINTC, State.POINT_WITHOUT_INT&#125;,            &#123;CharType.SIGN, State.INT_SIGN&#125;        &#125;;        transfer.Add(State.INITIAL, initialDictionary);        Dictionary&lt;CharType, State&gt; intSignDictionary = new Dictionary&lt;CharType, State&gt; &#123;            &#123;CharType.NUMBER, State.INTEGER&#125;,            &#123;CharType.POINTC, State.POINT_WITHOUT_INT&#125;        &#125;;        transfer.Add(State.INT_SIGN, intSignDictionary);        Dictionary&lt;CharType, State&gt; integerDictionary = new Dictionary&lt;CharType, State&gt; &#123;            &#123;CharType.NUMBER, State.INTEGER&#125;,            &#123;CharType.EXPC, State.EXP&#125;,            &#123;CharType.POINTC, State.POINT&#125;        &#125;;        transfer.Add(State.INTEGER, integerDictionary);        Dictionary&lt;CharType, State&gt; pointDictionary = new Dictionary&lt;CharType, State&gt; &#123;            &#123;CharType.NUMBER, State.FRACTION&#125;,            &#123;CharType.EXPC, State.EXP&#125;        &#125;;        transfer.Add(State.POINT, pointDictionary);        Dictionary&lt;CharType, State&gt; pointWithoutIntDictionary = new Dictionary&lt;CharType, State&gt; &#123;            &#123;CharType.NUMBER, State.FRACTION&#125;        &#125;;        transfer.Add(State.POINT_WITHOUT_INT, pointWithoutIntDictionary);        Dictionary&lt;CharType, State&gt; fractionDictionary = new Dictionary&lt;CharType, State&gt; &#123;            &#123;CharType.NUMBER, State.FRACTION&#125;,            &#123;CharType.EXPC, State.EXP&#125;        &#125;;        transfer.Add(State.FRACTION, fractionDictionary);        Dictionary&lt;CharType, State&gt; expDictionary = new Dictionary&lt;CharType, State&gt; &#123;            &#123;CharType.NUMBER, State.EXP_NUMBER&#125;,            &#123;CharType.SIGN, State.EXP_SIGN&#125;        &#125;;        transfer.Add(State.EXP, expDictionary);        Dictionary&lt;CharType, State&gt; expSignDictionary = new Dictionary&lt;CharType, State&gt; &#123;            &#123;CharType.NUMBER, State.EXP_NUMBER&#125;        &#125;;        transfer.Add(State.EXP_SIGN, expSignDictionary);        Dictionary&lt;CharType, State&gt; expNumberDictionary = new Dictionary&lt;CharType, State&gt; &#123;            &#123;CharType.NUMBER, State.EXP_NUMBER&#125;        &#125;;        transfer.Add(State.EXP_NUMBER, expNumberDictionary);        int length = s.Length;        State state = State.INITIAL;        for (int i = 0; i &lt; length; i++) &#123;            CharType type = GetCharType(s[i]);            if (!transfer[state].ContainsKey(type)) &#123;                return false;            &#125; else &#123;                state = transfer[state][type];            &#125;        &#125;        return state == State.INTEGER || state == State.POINT || state == State.FRACTION || state == State.EXP_NUMBER || state == State.END;    &#125;    private CharType GetCharType(char ch) &#123;        if (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;            return CharType.NUMBER;        &#125; else if (ch == &#x27;e&#x27; || ch == &#x27;E&#x27;) &#123;            return CharType.EXPC;        &#125; else if (ch == &#x27;.&#x27;) &#123;            return CharType.POINTC;        &#125; else if (ch == &#x27;+&#x27; || ch == &#x27;-&#x27;) &#123;            return CharType.SIGN;        &#125; else &#123;            return CharType.ILLEGAL;        &#125;    &#125;    private enum State &#123;        INITIAL,        INT_SIGN,        INTEGER,        POINT,        POINT_WITHOUT_INT,        FRACTION,        EXP,        EXP_SIGN,        EXP_NUMBER,        END    &#125;    private enum CharType &#123;        NUMBER,        EXPC,        POINTC,        SIGN,        ILLEGAL    &#125;&#125;\n\n结果执行用时 : 66 ms, 击败 50.00% 使用 C# 的用户\n内存消耗 : 46.64 MB, 击败 6.67% 使用 C# 的用户\n\nJavaScriptvar isNumber = function(s) &#123;    const State = &#123;        INITIAL: &#x27;INITIAL&#x27;,        INT_SIGN: &#x27;INT_SIGN&#x27;,        INTEGER: &#x27;INTEGER&#x27;,        POINT: &#x27;POINT&#x27;,        POINT_WITHOUT_INT: &#x27;POINT_WITHOUT_INT&#x27;,        FRACTION: &#x27;FRACTION&#x27;,        EXP: &#x27;EXP&#x27;,        EXP_SIGN: &#x27;EXP_SIGN&#x27;,        EXP_NUMBER: &#x27;EXP_NUMBER&#x27;,        END: &#x27;END&#x27;    &#125;;    const CharType = &#123;        NUMBER: &#x27;NUMBER&#x27;,        EXP: &#x27;EXP&#x27;,        POINT: &#x27;POINT&#x27;,        SIGN: &#x27;SIGN&#x27;,        ILLEGAL: &#x27;ILLEGAL&#x27;    &#125;;    const transition = &#123;        [State.INITIAL]: &#123;            [CharType.NUMBER]: State.INTEGER,            [CharType.POINT]: State.POINT_WITHOUT_INT,            [CharType.SIGN]: State.INT_SIGN        &#125;,        [State.INT_SIGN]: &#123;            [CharType.NUMBER]: State.INTEGER,            [CharType.POINT]: State.POINT_WITHOUT_INT        &#125;,        [State.INTEGER]: &#123;            [CharType.NUMBER]: State.INTEGER,            [CharType.EXP]: State.EXP,            [CharType.POINT]: State.POINT        &#125;,        [State.POINT]: &#123;            [CharType.NUMBER]: State.FRACTION,            [CharType.EXP]: State.EXP        &#125;,        [State.POINT_WITHOUT_INT]: &#123;            [CharType.NUMBER]: State.FRACTION        &#125;,        [State.FRACTION]: &#123;            [CharType.NUMBER]: State.FRACTION,            [CharType.EXP]: State.EXP        &#125;,        [State.EXP]: &#123;            [CharType.NUMBER]: State.EXP_NUMBER,            [CharType.SIGN]: State.EXP_SIGN        &#125;,        [State.EXP_SIGN]: &#123;            [CharType.NUMBER]: State.EXP_NUMBER        &#125;,        [State.EXP_NUMBER]: &#123;            [CharType.NUMBER]: State.EXP_NUMBER        &#125;    &#125;;    const getCharType = (ch) =&gt; &#123;        if (/\\d/.test(ch)) &#123;            return CharType.NUMBER;        &#125; else if (ch === &#x27;e&#x27; || ch === &#x27;E&#x27;) &#123;            return CharType.EXP;        &#125; else if (ch === &#x27;.&#x27;) &#123;            return CharType.POINT;        &#125; else if (ch === &#x27;+&#x27; || ch === &#x27;-&#x27;) &#123;            return CharType.SIGN;        &#125; else &#123;            return CharType.ILLEGAL;        &#125;    &#125;;    let state = State.INITIAL;    for (const char of s) &#123;        const charType = getCharType(char);        if (!transition[state][charType]) &#123;            return false;        &#125; else &#123;            state = transition[state][charType];        &#125;    &#125;    return state === State.INTEGER || state === State.POINT || state === State.FRACTION || state === State.EXP_NUMBER || state === State.END;&#125;;\n\n结果执行用时 : 97 ms, 击败 19.42% 使用 JavaScript 的用户\n内存消耗 : 54.57 MB, 击败 7.76% 使用 JavaScript 的用户\n\nTypeScriptfunction isNumber(s: string): boolean &#123;    if (s.length &lt; 1 || s.length &gt; 20) &#123;        return false;    &#125;    const validNumberRegex = /^[\\+\\-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][\\+\\-]?\\d+)?$/;    return validNumberRegex.test(s);&#125;\n\n结果执行用时 : 88 ms, 击败 57.14% 使用 TypeScript 的用户\n内存消耗 : 53.75 MB, 击败 66.67% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param String $s     * @return Boolean     */    function isNumber($s) &#123;        if (strlen($s) &lt; 1 || strlen($s) &gt; 20) &#123;            return false;        &#125;        $validNumberRegex = &#x27;/^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$/&#x27;;        return preg_match($validNumberRegex, $s) === 1;    &#125;&#125;\n\n结果执行用时 : 9 ms, 击败 100.00% 使用 PHP 的用户\n内存消耗 : 20.38 MB, 击败 100.00% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func isNumber(_ s: String) -&gt; Bool &#123;        if s.count &lt; 1 || s.count &gt; 20 &#123;            return false        &#125;        let validNumberRegex = #&quot;^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$&quot;#        return s.range(of: validNumberRegex, options: .regularExpression) != nil    &#125;&#125;\n\n结果执行用时 : 12 ms, 击败 100.00% 使用 Swift 的用户\n内存消耗 : 18.34 MB, 击败 -% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun isNumber(s: String): Boolean &#123;        if (s.length &lt; 1 || s.length &gt; 20) &#123;            return false        &#125;        val validNumberRegex = &quot;&quot;&quot;^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$&quot;&quot;&quot;.toRegex()        return validNumberRegex.matches(s)    &#125;&#125;\n\n结果执行用时 : 212 ms, 击败 -% 使用 Kotlin 的用户\n内存消耗 : 37.24 MB, 击败 -% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  bool isNumber(String s) &#123;    RegExp validNumberRegex = RegExp(r&#x27;^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$&#x27;);    return validNumberRegex.hasMatch(s);  &#125;&#125;\n\n结果执行用时 : 350 ms, 击败 100.00% 使用 Dart 的用户\n内存消耗 : 158.96 MB, 击败 100.00% 使用 Dart 的用户\n\nGofunc isNumber(s string) bool &#123;    validNumberRegex := regexp.MustCompile(`^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$`)    return validNumberRegex.MatchString(s)&#125;\n\n结果执行用时 : 19 ms, 击败 6.45% 使用 Go 的用户\n内存消耗 : 7.05 MB, 击败 6.45% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; s# @return &#123;Boolean&#125;def is_number(s)  valid_number_regex = /^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$/  !!(s =~ valid_number_regex)end\n\n结果执行用时 : 56 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 206.57 MB, 击败 100.00% 使用 Ruby 的用户\n\nScala暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Scala 的用户\n内存消耗 :  MB, 击败 % 使用 Scala 的用户\n\nRust暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixirdefmodule Solution do  @spec is_number(s :: String.t) :: boolean  def is_number(s) do    case Regex.match?(~r/^\\s*[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?\\s*$/, s) do      true -&gt; true      false -&gt; false    end  endend\n\n结果执行用时 : 371 ms, 击败 100.00% 使用 Elixir 的用户\n内存消耗 : 67.29 MB, 击败 100.00% 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"春分","url":"/zh-CN/0ae065f54d8a/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  春分\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","春分"]},{"title":"女超人 第五季 第十六集 仙境中的亚历克斯","url":"/zh-CN/0cd3b81da410/","content":"\n剧情介绍　　亚历克斯使用一副黑曜石隐形眼镜，进入一个虚拟的国家城市，并在那里扮演一个全新的角色。与此同时，凯莉协助威廉调查莱克斯。卡拉则面对一些令人难以接受的消息。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"MacBook Air 13 英寸（Intel，2020年）","url":"/zh-CN/6308c29551a0/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  MacBook Air\n  够轻，够轻快。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"蝙蝠女侠 第一季 第十六集 镜中奇遇","url":"/zh-CN/fe3c68e2bafb/","content":"\n剧情介绍　　凯特开始质疑自己的直觉，而卢克收到了一条令人不安的消息。爱丽丝寻求姐姐的帮助来完成一项特殊任务。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"力扣00066.加一","url":"/zh-CN/b4a1a4c15eb4/","content":"\n题目描述给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。\n最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。\n你可以假设除了整数 0 之外，这个整数不会以零开头。\n示例 1：\n输入：digits &#x3D; [1,2,3]输出：[1,2,4]解释：输入数组表示数字 123。\n\n示例 2：\n输入：digits &#x3D; [4,3,2,1]输出：[4,3,2,2]解释：输入数组表示数字 4321。\n\n示例 3：\n输入：digits &#x3D; [0]输出：[1]\n\n提示：\n1 &lt;&#x3D; digits.length &lt;&#x3D; 100\n0 &lt;&#x3D; digits[i] &lt;&#x3D; 9\n\n\n解决方法C++class Solution &#123;public:    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;        int n = digits.size();        int carry = 1;        for (int i = n - 1; i &gt;= 0; --i) &#123;            digits[i] += carry;            if (digits[i] &lt; 10) &#123;                return digits;            &#125; else &#123;                digits[i] = 0;                carry = 1;            &#125;        &#125;        digits.insert(digits.begin(), 1);        return digits;    &#125;&#125;;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C++ 的用户\n内存消耗 : 10.16 MB, 击败 8.56% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public int[] plusOne(int[] digits) &#123;        int n = digits.length;        int carry = 1;        for (int i = n - 1; i &gt;= 0; --i) &#123;            digits[i] += carry;            if (digits[i] &lt; 10) &#123;                return digits;            &#125; else &#123;                digits[i] = 0;                carry = 1;            &#125;        &#125;        int[] result = new int[n + 1];        result[0] = 1;        return result;    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Java 的用户\n内存消耗 : 40.90 MB, 击败 40.83% 使用 Java 的用户\n\nPythonclass Solution(object):    def plusOne(self, digits):        &quot;&quot;&quot;        :type digits: List[int]        :rtype: List[int]        &quot;&quot;&quot;        n = len(digits)        carry = 1        for i in range(n - 1, -1, -1):            digits[i] += carry            if digits[i] &lt; 10:                return digits            else:                digits[i] = 0                carry = 1        digits.insert(0, 1)        return digits\n\n结果执行用时 : 13 ms, 击败 72.54% 使用 Python 的用户\n内存消耗 : 11.50 MB, 击败 28.43% 使用 Python 的用户\n\nPython3class Solution:    def plusOne(self, digits: List[int]) -&gt; List[int]:        n = len(digits)        carry = 1        for i in range(n - 1, -1, -1):            digits[i] += carry            if digits[i] &lt; 10:                return digits            else:                digits[i] = 0                carry = 1        digits.insert(0, 1)        return digits\n\n结果执行用时 : 35 ms, 击败 73.11% 使用 Python3 的用户\n内存消耗 : 16.39 MB, 击败 57.88% 使用 Python3 的用户\n\nC/** * Note: The returned array must be malloced, assume caller calls free(). */int* plusOne(int* digits, int digitsSize, int* returnSize) &#123;    int carry = 1;    for (int i = digitsSize - 1; i &gt;= 0; --i) &#123;        digits[i] += carry;        if (digits[i] &lt; 10) &#123;            *returnSize = digitsSize;            return digits;        &#125; else &#123;            digits[i] = 0;            carry = 1;        &#125;    &#125;    int* result = (int*)malloc((digitsSize + 1) * sizeof(int));    result[0] = 1;    for (int i = 1; i &lt;= digitsSize; ++i) &#123;        result[i] = digits[i - 1];    &#125;    *returnSize = digitsSize + 1;    return result;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 C 的用户\n内存消耗 : 5.45 MB, 击败 95.55% 使用 C 的用户\n\nC#public class Solution &#123;    public int[] PlusOne(int[] digits) &#123;        int carry = 1;        for (int i = digits.Length - 1; i &gt;= 0; --i) &#123;            digits[i] += carry;            if (digits[i] &lt; 10) &#123;                return digits;            &#125; else &#123;                digits[i] = 0;                carry = 1;            &#125;        &#125;        int[] result = new int[digits.Length + 1];        result[0] = 1;        for (int i = 1; i &lt;= digits.Length; ++i) &#123;            result[i] = digits[i - 1];        &#125;        return result;    &#125;&#125;\n\n结果执行用时 : 80 ms, 击败 99.45% 使用 C# 的用户\n内存消耗 : 45.35 MB, 击败 40.55% 使用 C# 的用户\n\nJavaScript/** * @param &#123;number[]&#125; digits * @return &#123;number[]&#125; */var plusOne = function(digits) &#123;    let carry = 1;    for (let i = digits.length - 1; i &gt;= 0; i--) &#123;        digits[i] += carry;        if (digits[i] &lt; 10) &#123;            return digits;        &#125; else &#123;            digits[i] = 0;            carry = 1;        &#125;    &#125;    digits.unshift(1);    return digits;&#125;;\n\n结果执行用时 : 54 ms, 击败 78.42% 使用 JavaScript 的用户\n内存消耗 : 49.06 MB, 击败 62.42% 使用 JavaScript 的用户\n\nTypeScriptfunction plusOne(digits: number[]): number[] &#123;    let carry = 1;    for (let i = digits.length - 1; i &gt;= 0; i--) &#123;        digits[i] += carry;        if (digits[i] &lt; 10) &#123;            return digits;        &#125; else &#123;            digits[i] = 0;            carry = 1;        &#125;    &#125;    digits.unshift(1);    return digits;&#125;\n\n结果执行用时 : 58 ms, 击败 75.94% 使用 TypeScript 的用户\n内存消耗 : 51.56 MB, 击败 24.44% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;    /**     * @param Integer[] $digits     * @return Integer[]     */    function plusOne($digits) &#123;        $n = count($digits);        $carry = 1;        for ($i = $n - 1; $i &gt;= 0; $i--) &#123;            $digits[$i] += $carry;            if ($digits[$i] &lt; 10) &#123;                return $digits;            &#125; else &#123;                $digits[$i] = 0;                $carry = 1;            &#125;        &#125;        array_unshift($digits, 1);        return $digits;    &#125;&#125;\n\n结果执行用时 : 15 ms, 击败 7.69% 使用 PHP 的用户\n内存消耗 : 20.30 MB, 击败 5.77% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func plusOne(_ digits: [Int]) -&gt; [Int] &#123;        var digits = digits        var carry = 1        for i in (0..&lt;digits.count).reversed() &#123;            digits[i] += carry            if digits[i] &lt; 10 &#123;                return digits            &#125; else &#123;                digits[i] = 0                carry = 1            &#125;        &#125;        digits.insert(1, at: 0)        return digits    &#125;&#125;\n\n结果执行用时 : 5 ms, 击败 22.06% 使用 Swift 的用户\n内存消耗 : 15.71 MB, 击败 50.00% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun plusOne(digits: IntArray): IntArray &#123;        var carry = 1        for (i in digits.size - 1 downTo 0) &#123;            digits[i] += carry            if (digits[i] &lt; 10) &#123;                return digits            &#125; else &#123;                digits[i] = 0                carry = 1            &#125;        &#125;        val result = IntArray(digits.size + 1)        result[0] = 1        return result    &#125;&#125;\n\n结果执行用时 : 170 ms, 击败 38.64% 使用 Kotlin 的用户\n内存消耗 : 34.26 MB, 击败 65.91% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  List&lt;int&gt; plusOne(List&lt;int&gt; digits) &#123;    int carry = 1;    for (int i = digits.length - 1; i &gt;= 0; i--) &#123;      digits[i] += carry;      if (digits[i] &lt; 10) &#123;        return digits;      &#125; else &#123;        digits[i] = 0;        carry = 1;      &#125;    &#125;    digits.insert(0, 1);    return digits;  &#125;&#125;\n\n结果执行用时 : 305 ms, 击败 33.33% 使用 Dart 的用户\n内存消耗 : 147.55 MB, 击败 50.00% 使用 Dart 的用户\n\nGofunc plusOne(digits []int) []int &#123;    carry := 1    for i := len(digits) - 1; i &gt;= 0; i-- &#123;        digits[i] += carry        if digits[i] &lt; 10 &#123;            return digits        &#125; else &#123;            digits[i] = 0            carry = 1        &#125;    &#125;    digits = append([]int&#123;1&#125;, digits...)    return digits&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 2.11 MB, 击败 27.11% 使用 Go 的用户\n\nRuby# @param &#123;Integer[]&#125; digits# @return &#123;Integer[]&#125;def plus_one(digits)    carry = 1    (digits.length - 1).downto(0) do |i|        digits[i] += carry        if digits[i] &lt; 10            return digits        else            digits[i] = 0            carry = 1        end    end    digits.unshift(1)    return digitsend\n\n结果执行用时 : 51 ms, 击败 83.33% 使用 Ruby 的用户\n内存消耗 : 206.24 MB, 击败 100.00% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def plusOne(digits: Array[Int]): Array[Int] = &#123;    var carry = 1    var i = digits.length - 1    while (i &gt;= 0) &#123;      digits(i) += carry      if (digits(i) &lt; 10) &#123;        return digits      &#125; else &#123;        digits(i) = 0        carry = 1      &#125;      i -= 1    &#125;    val result = Array.ofDim[Int](digits.length + 1)    result(0) = 1    result  &#125;&#125;\n\n结果执行用时 : 609 ms, 击败 25.00% 使用 Scala 的用户\n内存消耗 : 57.99 MB, 击败 -% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn plus_one(digits: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123;        let mut digits = digits;        let mut carry = 1;        for i in (0..digits.len()).rev() &#123;            digits[i] += carry;            if digits[i] &lt; 10 &#123;                return digits;            &#125; else &#123;                digits[i] = 0;                carry = 1;            &#125;        &#125;        let mut result = vec![0; digits.len() + 1];        result[0] = 1;        result    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.18 MB, 击败 14.57% 使用 Rust 的用户\n\nRacket(define/contract (plus-one digits)  (-&gt; (listof exact-integer?) (listof exact-integer?))  (let ((carry 1)        (result &#x27;()))    (do ((i (- (length digits) 1) (- i 1))) ((&lt; i 0) (reverse result))      (let ((sum (+ (list-ref digits i) carry)))        (if (&lt; sum 10)            (set! carry 0)            (set! sum (- sum 10)))        (set! result (cons sum result))))    (if (= carry 1)        (cons 1 result)        result)))\n\n结果执行用时 : 173 ms, 击败 100.00% 使用 Racket 的用户\n内存消耗 : 97.84 MB, 击败 100.00% 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"罪恶黑名单 第七季 第十一集 维多利亚·费因堡","url":"/zh-CN/8a9208a47110/","content":"\n剧情介绍　　在特工小组的帮助下，雷德追踪到了一名才华横溢的艺术品伪造者，此人破坏了他出售被盗艺术品的计划。阿拉姆的感情生活变得越来越复杂。莉兹和雷斯勒则互相倾诉心事。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"力扣00068.文本左右对齐","url":"/zh-CN/ad3edc4de2db/","content":"\n题目描述给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。\n你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ‘ ‘ 填充，使得每行恰好有 maxWidth 个字符。\n要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。\n文本的最后一行应为左对齐，且单词之间不插入额外的空格。\n注意:\n\n单词是指由非空格字符组成的字符序列。\n每个单词的长度大于 0，小于等于 maxWidth。\n输入单词数组 words 至少包含一个单词。\n\n示例 1：\n输入: words &#x3D; [“This”, “is”, “an”, “example”, “of”, “text”, “justification.”], maxWidth &#x3D; 16输出:[  “This    is    an”,  “example  of text”,  “justification.  “]\n\n示例 2：\n输入:words &#x3D; [“What”,”must”,”be”,”acknowledgment”,”shall”,”be”], maxWidth &#x3D; 16输出:[ “What   must   be”, “acknowledgment  “, “shall be        “]解释: 注意最后一行的格式应为 “shall be    “ 而不是 “shall     be”,    因为最后一行应为左对齐，而不是左右两端对齐。    第二行同样为左对齐，这是因为这行只包含一个单词。\n\n示例 3：\n输入:words &#x3D; [“Science”,”is”,”what”,”we”,”understand”,”well”,”enough”,”to”,”explain”,”to”,”a”,”computer.”,”Art”,”is”,”everything”,”else”,”we”,”do”]，maxWidth &#x3D; 20输出:[ “Science  is  what we”, “understand      well”, “enough to explain to”, “a  computer.  Art is”, “everything  else  we”, “do                  “]\n\n提示：\n1 &lt;&#x3D; words.length &lt;&#x3D; 300\n1 &lt;&#x3D; words[i].length &lt;&#x3D; 20\nwords[i] 由小写英文字母和符号组成\n1 &lt;&#x3D; maxWidth &lt;&#x3D; 100\nwords[i].length &lt;&#x3D; maxWidth\n\n\n解决方法C++\n\n结果执行用时 :  ms, 击败 % 使用 C++ 的用户\n内存消耗 :  MB, 击败 % 使用 C++ 的用户\n\nJava\n\n结果执行用时 :  ms, 击败 % 使用 Java 的用户\n内存消耗 :  MB, 击败 % 使用 Java 的用户\n\nPython\n\n结果执行用时 :  ms, 击败 % 使用 Python 的用户\n内存消耗 :  MB, 击败 % 使用 Python 的用户\n\nPython3\n\n结果执行用时 :  ms, 击败 % 使用 Python3 的用户\n内存消耗 :  MB, 击败 % 使用 Python3 的用户\n\nC\n\n结果执行用时 :  ms, 击败 % 使用 C 的用户\n内存消耗 :  MB, 击败 % 使用 C 的用户\n\nC#\n\n结果执行用时 :  ms, 击败 % 使用 C# 的用户\n内存消耗 :  MB, 击败 % 使用 C# 的用户\n\nJavaScript\n\n结果执行用时 :  ms, 击败 % 使用 JavaScript 的用户\n内存消耗 :  MB, 击败 % 使用 JavaScript 的用户\n\nTypeScript\n\n结果执行用时 :  ms, 击败 % 使用 TypeScript 的用户\n内存消耗 :  MB, 击败 % 使用 TypeScript 的用户\n\nPHP\n\n结果执行用时 :  ms, 击败 % 使用 PHP 的用户\n内存消耗 :  MB, 击败 % 使用 PHP 的用户\n\nSwift\n\n结果执行用时 :  ms, 击败 % 使用 Swift 的用户\n内存消耗 :  MB, 击败 % 使用 Swift 的用户\n\nKotlin\n\n结果执行用时 :  ms, 击败 % 使用 Kotlin 的用户\n内存消耗 :  MB, 击败 % 使用 Kotlin 的用户\n\nDart\n\n结果执行用时 :  ms, 击败 % 使用 Dart 的用户\n内存消耗 :  MB, 击败 % 使用 Dart 的用户\n\nGo\n\n结果执行用时 :  ms, 击败 % 使用 Go 的用户\n内存消耗 :  MB, 击败 % 使用 Go 的用户\n\nRuby\n\n结果执行用时 :  ms, 击败 % 使用 Ruby 的用户\n内存消耗 :  MB, 击败 % 使用 Ruby 的用户\n\nScala\n\n结果执行用时 :  ms, 击败 % 使用 Scala 的用户\n内存消耗 :  MB, 击败 % 使用 Scala 的用户\n\nRust\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00067.二进制求和","url":"/zh-CN/921c8827c6e8/","content":"\n题目描述给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。\n示例 1：\n输入:a &#x3D; “11”, b &#x3D; “1”输出：”100”\n\n示例 2：\n输入：a &#x3D; “1010”, b &#x3D; “1011”输出：”10101”\n\n提示：\n$1 &lt;&#x3D; a.length, b.length &lt;&#x3D; 10^4$\na 和 b 仅由字符 ‘0’ 或 ‘1’ 组成\n字符串如果不是 “0” ，就不含前导零\n\n\n解决方法C++class Solution &#123;public:    string addBinary(string a, string b) &#123;        string result = &quot;&quot;;        int carry = 0;        int i = a.length() - 1, j = b.length() - 1;        while (i &gt;= 0 || j &gt;= 0) &#123;            int sum = carry;            if (i &gt;= 0) &#123;                sum += a[i] - &#x27;0&#x27;;                i--;            &#125;            if (j &gt;= 0) &#123;                sum += b[j] - &#x27;0&#x27;;                j--;            &#125;            result = to_string(sum % 2) + result;            carry = sum / 2;        &#125;        if (carry) &#123;            result = &quot;1&quot; + result;        &#125;        return result;    &#125;&#125;;\n\n结果执行用时 : 4 ms, 击败 39.00% 使用 C++ 的用户\n内存消耗 : 10.60 MB, 击败 9.70% 使用 C++ 的用户\n\nJavaclass Solution &#123;    public String addBinary(String a, String b) &#123;        StringBuilder result = new StringBuilder();        int carry = 0;        int i = a.length() - 1, j = b.length() - 1;        while (i &gt;= 0 || j &gt;= 0) &#123;            int sum = carry;            if (i &gt;= 0) &#123;                sum += a.charAt(i) - &#x27;0&#x27;;                i--;            &#125;            if (j &gt;= 0) &#123;                sum += b.charAt(j) - &#x27;0&#x27;;                j--;            &#125;            result.insert(0, sum % 2);            carry = sum / 2;        &#125;        if (carry != 0) &#123;            result.insert(0, &#x27;1&#x27;);        &#125;        return result.toString();    &#125;&#125;\n\n结果执行用时 : 1 ms, 击败 99.49% 使用 Java 的用户\n内存消耗 : 41.73 MB, 击败 22.66% 使用 Java 的用户\n\nPythonclass Solution(object):    def addBinary(self, a, b):        &quot;&quot;&quot;        :type a: str        :type b: str        :rtype: str        &quot;&quot;&quot;        result = &quot;&quot;        carry = 0        i, j = len(a) - 1, len(b) - 1        while i &gt;= 0 or j &gt;= 0:            sum = carry            if i &gt;= 0:                sum += int(a[i])                i -= 1            if j &gt;= 0:                sum += int(b[j])                j -= 1            result = str(sum % 2) + result            carry = sum // 2        if carry:            result = &quot;1&quot; + result        return result\n\n结果执行用时 : 26 ms, 击败 23.78% 使用 Python 的用户\n内存消耗 : 11.61 MB, 击败 25.55% 使用 Python 的用户\n\nPython3class Solution:    def addBinary(self, a: str, b: str) -&gt; str:        result = &quot;&quot;        carry = 0        i, j = len(a) - 1, len(b) - 1        while i &gt;= 0 or j &gt;= 0:            sum = carry            if i &gt;= 0:                sum += int(a[i])                i -= 1            if j &gt;= 0:                sum += int(b[j])                j -= 1            result = str(sum % 2) + result            carry = sum // 2        if carry:            result = &quot;1&quot; + result        return result\n\n结果执行用时 : 47 ms, 击败 13.36% 使用 Python3 的用户\n内存消耗 : 16.46 MB, 击败 33.28% 使用 Python3 的用户\n\nCchar* addBinary(char* a, char* b) &#123;    int lenA = strlen(a);    int lenB = strlen(b);    int lenResult = lenA &gt; lenB ? lenA + 2 : lenB + 2;    char* result = (char*)malloc(lenResult * sizeof(char));    int carry = 0;    int i = lenA - 1, j = lenB - 1;    int k = 0;    while (i &gt;= 0 || j &gt;= 0 || carry) &#123;        int sum = carry;        if (i &gt;= 0) &#123;            sum += a[i] - &#x27;0&#x27;;            i--;        &#125;        if (j &gt;= 0) &#123;            sum += b[j] - &#x27;0&#x27;;            j--;        &#125;        result[k++] = sum % 2 + &#x27;0&#x27;;        carry = sum / 2;    &#125;    for (int l = 0; l &lt; k / 2; l++) &#123;        char temp = result[l];        result[l] = result[k - l - 1];        result[k - l - 1] = temp;    &#125;    result[k] = &#x27;\\0&#x27;;    return result;&#125;\n\n结果执行用时 : 2 ms, 击败 47.77% 使用 C 的用户\n内存消耗 : 5.41 MB, 击败 93.22% 使用 C 的用户\n\nC#public class Solution &#123;    public string AddBinary(string a, string b) &#123;        StringBuilder result = new StringBuilder();        int carry = 0;        int i = a.Length - 1, j = b.Length - 1;        while (i &gt;= 0 || j &gt;= 0 || carry != 0) &#123;            int sum = carry;            if (i &gt;= 0) &#123;                sum += a[i] - &#x27;0&#x27;;                i--;            &#125;            if (j &gt;= 0) &#123;                sum += b[j] - &#x27;0&#x27;;                j--;            &#125;            result.Insert(0, sum % 2);            carry = sum / 2;        &#125;        return result.ToString();    &#125;&#125;\n\n结果执行用时 : 52 ms, 击败 74.50% 使用 C# 的用户\n内存消耗 : 40.38 MB, 击败 74.10% 使用 C# 的用户\n\nJavaScript/** * @param &#123;string&#125; a * @param &#123;string&#125; b * @return &#123;string&#125; */var addBinary = function(a, b) &#123;    let result = &quot;&quot;;    let carry = 0;    let i = a.length - 1;    let j = b.length - 1;    while (i &gt;= 0 || j &gt;= 0 || carry !== 0) &#123;        let sum = carry;        if (i &gt;= 0) &#123;            sum += parseInt(a[i]);            i--;        &#125;        if (j &gt;= 0) &#123;            sum += parseInt(b[j]);            j--;        &#125;        result = (sum % 2) + result;        carry = Math.floor(sum / 2);    &#125;    return result;&#125;;\n\n结果执行用时 : 64 ms, 击败 59.82% 使用 JavaScript 的用户\n内存消耗 : 51.32 MB, 击败 52.54% 使用 JavaScript 的用户\n\nTypeScriptfunction addBinary(a: string, b: string): string &#123;    let result = &quot;&quot;;    let carry = 0;    let i = a.length - 1;    let j = b.length - 1;    while (i &gt;= 0 || j &gt;= 0 || carry !== 0) &#123;        let sum = carry;        if (i &gt;= 0) &#123;            sum += parseInt(a[i]);            i--;        &#125;        if (j &gt;= 0) &#123;            sum += parseInt(b[j]);            j--;        &#125;        result = (sum % 2) + result;        carry = Math.floor(sum / 2);    &#125;    return result;&#125;\n\n结果执行用时 : 73 ms, 击败 30.34% 使用 TypeScript 的用户\n内存消耗 : 52.49 MB, 击败 37.64% 使用 TypeScript 的用户\n\nPHPclass Solution &#123;        /**     * @param String $a     * @param String $b     * @return String     */    function addBinary($a, $b) &#123;        $result = &quot;&quot;;        $carry = 0;        $i = strlen($a) - 1;        $j = strlen($b) - 1;        while ($i &gt;= 0 || $j &gt;= 0 || $carry !== 0) &#123;            $sum = $carry;            if ($i &gt;= 0) &#123;                $sum += intval($a[$i]);                $i--;            &#125;            if ($j &gt;= 0) &#123;                $sum += intval($b[$j]);                $j--;            &#125;            $result = ($sum % 2) . $result;            $carry = intval($sum / 2);        &#125;        return $result;    &#125;&#125;\n\n结果执行用时 : 7 ms, 击败 67.86% 使用 PHP 的用户\n内存消耗 : 20.33 MB, 击败 14.29% 使用 PHP 的用户\n\nSwiftclass Solution &#123;    func addBinary(_ a: String, _ b: String) -&gt; String &#123;        var result = &quot;&quot;        var carry = 0        var i = a.count - 1        var j = b.count - 1        let aChars = Array(a)        let bChars = Array(b)        while i &gt;= 0 || j &gt;= 0 || carry != 0 &#123;            var sum = carry            if i &gt;= 0 &#123;                sum += Int(String(aChars[i])) ?? 0                i -= 1            &#125;            if j &gt;= 0 &#123;                sum += Int(String(bChars[j])) ?? 0                j -= 1            &#125;            result = &quot;\\(sum % 2)&quot; + result            carry = sum / 2        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 8 ms, 击败 54.10% 使用 Swift 的用户\n内存消耗 : 16.30 MB, 击败 24.59% 使用 Swift 的用户\n\nKotlinclass Solution &#123;    fun addBinary(a: String, b: String): String &#123;        var result = &quot;&quot;        var carry = 0        var i = a.length - 1        var j = b.length - 1        while (i &gt;= 0 || j &gt;= 0 || carry != 0) &#123;            var sum = carry            if (i &gt;= 0) &#123;                sum += a[i] - &#x27;0&#x27;                i--            &#125;            if (j &gt;= 0) &#123;                sum += b[j] - &#x27;0&#x27;                j--            &#125;            result = (sum % 2).toString() + result            carry = sum / 2        &#125;        return result    &#125;&#125;\n\n结果执行用时 : 178 ms, 击败 35.00% 使用 Kotlin 的用户\n内存消耗 : 36.56 MB, 击败 30.00% 使用 Kotlin 的用户\n\nDartclass Solution &#123;  String addBinary(String a, String b) &#123;    StringBuffer result = StringBuffer();    int carry = 0;    int i = a.length - 1;    int j = b.length - 1;    while (i &gt;= 0 || j &gt;= 0 || carry != 0) &#123;      int sum = carry;      if (i &gt;= 0) &#123;        sum += int.parse(a[i]);        i--;      &#125;      if (j &gt;= 0) &#123;        sum += int.parse(b[j]);        j--;      &#125;      result.write(sum % 2);      carry = sum ~/ 2;    &#125;    return result.toString().split(&#x27;&#x27;).reversed.join();  &#125;&#125;\n\n结果执行用时 : 328 ms, 击败 66.67% 使用 Dart 的用户\n内存消耗 : 147.41 MB, 击败 66.67% 使用 Dart 的用户\n\nGofunc addBinary(a string, b string) string &#123;    result := &quot;&quot;    carry := 0    i, j := len(a) - 1, len(b) - 1    for i &gt;= 0 || j &gt;= 0 || carry != 0 &#123;        sum := carry        if i &gt;= 0 &#123;            sum += int(a[i] - &#x27;0&#x27;)            i--        &#125;        if j &gt;= 0 &#123;            sum += int(b[j] - &#x27;0&#x27;)            j--        &#125;        result = strconv.Itoa(sum % 2) + result        carry = sum / 2    &#125;    return result&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Go 的用户\n内存消耗 : 3.58 MB, 击败 20.85% 使用 Go 的用户\n\nRuby# @param &#123;String&#125; a# @param &#123;String&#125; b# @return &#123;String&#125;def add_binary(a, b)    result = &quot;&quot;    carry = 0    i = a.length - 1    j = b.length - 1    while i &gt;= 0 || j &gt;= 0 || carry != 0        sum = carry        sum += a[i].to_i if i &gt;= 0        sum += b[j].to_i if j &gt;= 0        result = (sum % 2).to_s + result        carry = sum / 2        i -= 1        j -= 1    end    resultend\n\n结果执行用时 : 60 ms, 击败 100.00% 使用 Ruby 的用户\n内存消耗 : 207.01 MB, 击败 33.33% 使用 Ruby 的用户\n\nScalaobject Solution &#123;  def addBinary(a: String, b: String): String = &#123;    val result = new StringBuilder()    var carry = 0    var i = a.length - 1    var j = b.length - 1    while (i &gt;= 0 || j &gt;= 0 || carry != 0) &#123;      var sum = carry      if (i &gt;= 0) &#123;        sum += a(i) - &#x27;0&#x27;        i -= 1      &#125;      if (j &gt;= 0) &#123;        sum += b(j) - &#x27;0&#x27;        j -= 1      &#125;      result.insert(0, sum % 2)      carry = sum / 2    &#125;    result.toString()  &#125;&#125;\n\n结果执行用时 : 636 ms, 击败 -% 使用 Scala 的用户\n内存消耗 : 57.54 MB, 击败 25.00% 使用 Scala 的用户\n\nRustimpl Solution &#123;    pub fn add_binary(a: String, b: String) -&gt; String &#123;        let mut result = String::new();        let mut carry = 0;        let mut i = a.len() as i32 - 1;        let mut j = b.len() as i32 - 1;        let a_chars: Vec&lt;char&gt; = a.chars().collect();        let b_chars: Vec&lt;char&gt; = b.chars().collect();        while i &gt;= 0 || j &gt;= 0 || carry != 0 &#123;            let mut sum = carry;            if i &gt;= 0 &#123;                sum += a_chars[i as usize].to_digit(10).unwrap();                i -= 1;            &#125;            if j &gt;= 0 &#123;                sum += b_chars[j as usize].to_digit(10).unwrap();                j -= 1;            &#125;            result.insert(0, std::char::from_digit(sum % 2, 10).unwrap());            carry = sum / 2;        &#125;        result    &#125;&#125;\n\n结果执行用时 : 0 ms, 击败 100.00% 使用 Rust 的用户\n内存消耗 : 2.09 MB, 击败 60.24% 使用 Rust 的用户\n\nRacket暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir暂时未解决\n\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"iPad Pro（A12Z，2020年）","url":"/zh-CN/58f37e646f96/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPad Pro\n  你的下一台电脑，何必是电脑。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPad"]},{"title":"力扣00069.x 的平方根","url":"/zh-CN/f90af5f455d0/","content":"\n题目描述给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例 1：\n输入：x &#x3D; 4输出：2\n\n示例 2：\n输入：x &#x3D; 8输出：2解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。\n\n提示：\n$0 &lt;&#x3D; x &lt;&#x3D; 2^{31} - 1$\n\n\n解决方法C++\n\n结果执行用时 :  ms, 击败 % 使用 C++ 的用户\n内存消耗 :  MB, 击败 % 使用 C++ 的用户\n\nJava\n\n结果执行用时 :  ms, 击败 % 使用 Java 的用户\n内存消耗 :  MB, 击败 % 使用 Java 的用户\n\nPython\n\n结果执行用时 :  ms, 击败 % 使用 Python 的用户\n内存消耗 :  MB, 击败 % 使用 Python 的用户\n\nPython3\n\n结果执行用时 :  ms, 击败 % 使用 Python3 的用户\n内存消耗 :  MB, 击败 % 使用 Python3 的用户\n\nC\n\n结果执行用时 :  ms, 击败 % 使用 C 的用户\n内存消耗 :  MB, 击败 % 使用 C 的用户\n\nC#\n\n结果执行用时 :  ms, 击败 % 使用 C# 的用户\n内存消耗 :  MB, 击败 % 使用 C# 的用户\n\nJavaScript\n\n结果执行用时 :  ms, 击败 % 使用 JavaScript 的用户\n内存消耗 :  MB, 击败 % 使用 JavaScript 的用户\n\nTypeScript\n\n结果执行用时 :  ms, 击败 % 使用 TypeScript 的用户\n内存消耗 :  MB, 击败 % 使用 TypeScript 的用户\n\nPHP\n\n结果执行用时 :  ms, 击败 % 使用 PHP 的用户\n内存消耗 :  MB, 击败 % 使用 PHP 的用户\n\nSwift\n\n结果执行用时 :  ms, 击败 % 使用 Swift 的用户\n内存消耗 :  MB, 击败 % 使用 Swift 的用户\n\nKotlin\n\n结果执行用时 :  ms, 击败 % 使用 Kotlin 的用户\n内存消耗 :  MB, 击败 % 使用 Kotlin 的用户\n\nDart\n\n结果执行用时 :  ms, 击败 % 使用 Dart 的用户\n内存消耗 :  MB, 击败 % 使用 Dart 的用户\n\nGo\n\n结果执行用时 :  ms, 击败 % 使用 Go 的用户\n内存消耗 :  MB, 击败 % 使用 Go 的用户\n\nRuby\n\n结果执行用时 :  ms, 击败 % 使用 Ruby 的用户\n内存消耗 :  MB, 击败 % 使用 Ruby 的用户\n\nScala\n\n结果执行用时 :  ms, 击败 % 使用 Scala 的用户\n内存消耗 :  MB, 击败 % 使用 Scala 的用户\n\nRust\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"罪恶黑名单 第七季 第十二集 科尼利厄斯·拉克","url":"/zh-CN/5c19be8081f6/","content":"\n剧情介绍　　隐居在一座私人岛屿上，雷德与一位旧情人和一群盗贼重逢，密谋通过盗窃艺术品赚取巨额财富。然而，计划很快被打乱，因为岛上的客人神秘地接连死亡。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"力扣00070.爬楼梯","url":"/zh-CN/36acf6f73101/","content":"\n题目描述假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n示例 1：\n输入：n &#x3D; 2输出：2解释：有两种方法可以爬到楼顶。\n\n1 阶 + 1 阶\n2 阶\n\n\n示例 2：\n输入：n &#x3D; 3输出：3解释：有三种方法可以爬到楼顶。\n\n1 阶 + 1 阶 + 1 阶\n1 阶 + 2 阶\n2 阶 + 1 阶\n\n\n提示：\n1 &lt;&#x3D; n &lt;&#x3D; 45\n\n\n解决方法C++\n\n结果执行用时 :  ms, 击败 % 使用 C++ 的用户\n内存消耗 :  MB, 击败 % 使用 C++ 的用户\n\nJava\n\n结果执行用时 :  ms, 击败 % 使用 Java 的用户\n内存消耗 :  MB, 击败 % 使用 Java 的用户\n\nPython\n\n结果执行用时 :  ms, 击败 % 使用 Python 的用户\n内存消耗 :  MB, 击败 % 使用 Python 的用户\n\nPython3\n\n结果执行用时 :  ms, 击败 % 使用 Python3 的用户\n内存消耗 :  MB, 击败 % 使用 Python3 的用户\n\nC\n\n结果执行用时 :  ms, 击败 % 使用 C 的用户\n内存消耗 :  MB, 击败 % 使用 C 的用户\n\nC#\n\n结果执行用时 :  ms, 击败 % 使用 C# 的用户\n内存消耗 :  MB, 击败 % 使用 C# 的用户\n\nJavaScript\n\n结果执行用时 :  ms, 击败 % 使用 JavaScript 的用户\n内存消耗 :  MB, 击败 % 使用 JavaScript 的用户\n\nTypeScript\n\n结果执行用时 :  ms, 击败 % 使用 TypeScript 的用户\n内存消耗 :  MB, 击败 % 使用 TypeScript 的用户\n\nPHP\n\n结果执行用时 :  ms, 击败 % 使用 PHP 的用户\n内存消耗 :  MB, 击败 % 使用 PHP 的用户\n\nSwift\n\n结果执行用时 :  ms, 击败 % 使用 Swift 的用户\n内存消耗 :  MB, 击败 % 使用 Swift 的用户\n\nKotlin\n\n结果执行用时 :  ms, 击败 % 使用 Kotlin 的用户\n内存消耗 :  MB, 击败 % 使用 Kotlin 的用户\n\nDart\n\n结果执行用时 :  ms, 击败 % 使用 Dart 的用户\n内存消耗 :  MB, 击败 % 使用 Dart 的用户\n\nGo\n\n结果执行用时 :  ms, 击败 % 使用 Go 的用户\n内存消耗 :  MB, 击败 % 使用 Go 的用户\n\nRuby\n\n结果执行用时 :  ms, 击败 % 使用 Ruby 的用户\n内存消耗 :  MB, 击败 % 使用 Ruby 的用户\n\nScala\n\n结果执行用时 :  ms, 击败 % 使用 Scala 的用户\n内存消耗 :  MB, 击败 % 使用 Scala 的用户\n\nRust\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00071.简化路径","url":"/zh-CN/4d1a4f424afb/","content":"\n题目描述给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘&#x2F;‘ 开头），请你将其转化为更加简洁的规范路径。\n在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’&#x2F;&#x2F;‘）都被视为单个斜杠 ‘&#x2F;‘ 。 对于此问题，任何其他格式的点（例如，’…’）均被视为文件&#x2F;目录名称。\n请注意，返回的 规范路径 必须遵循下述格式：\n\n始终以斜杠 ‘&#x2F;‘ 开头。\n两个目录名之间必须只有一个斜杠 ‘&#x2F;‘ 。\n最后一个目录名（如果存在）不能 以 ‘&#x2F;‘ 结尾。\n此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘..’）。\n\n返回简化后得到的 规范路径 。\n示例 1：\n输入：path &#x3D; “&#x2F;home&#x2F;“输出：”&#x2F;home”解释：注意，最后一个目录名后面没有斜杠。 \n\n示例 2：\n输入：path &#x3D; “&#x2F;..&#x2F;“输出：”&#x2F;“解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。\n\n示例 3：\n输入：path &#x3D; “&#x2F;home&#x2F;&#x2F;foo&#x2F;“输出：”&#x2F;home&#x2F;foo”解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。\n\n示例 4：\n输入：path &#x3D; “&#x2F;a&#x2F;.&#x2F;b&#x2F;..&#x2F;..&#x2F;c&#x2F;“输出：”&#x2F;c”\n\n提示：\n1 &lt;&#x3D; path.length &lt;&#x3D; 3000\npath 由英文字母，数字，’.’，’&#x2F;‘ 或 ‘_’ 组成。\npath 是一个有效的 Unix 风格绝对路径。\n\n\n解决方法C++\n\n结果执行用时 :  ms, 击败 % 使用 C++ 的用户\n内存消耗 :  MB, 击败 % 使用 C++ 的用户\n\nJava\n\n结果执行用时 :  ms, 击败 % 使用 Java 的用户\n内存消耗 :  MB, 击败 % 使用 Java 的用户\n\nPython\n\n结果执行用时 :  ms, 击败 % 使用 Python 的用户\n内存消耗 :  MB, 击败 % 使用 Python 的用户\n\nPython3\n\n结果执行用时 :  ms, 击败 % 使用 Python3 的用户\n内存消耗 :  MB, 击败 % 使用 Python3 的用户\n\nC\n\n结果执行用时 :  ms, 击败 % 使用 C 的用户\n内存消耗 :  MB, 击败 % 使用 C 的用户\n\nC#\n\n结果执行用时 :  ms, 击败 % 使用 C# 的用户\n内存消耗 :  MB, 击败 % 使用 C# 的用户\n\nJavaScript\n\n结果执行用时 :  ms, 击败 % 使用 JavaScript 的用户\n内存消耗 :  MB, 击败 % 使用 JavaScript 的用户\n\nTypeScript\n\n结果执行用时 :  ms, 击败 % 使用 TypeScript 的用户\n内存消耗 :  MB, 击败 % 使用 TypeScript 的用户\n\nPHP\n\n结果执行用时 :  ms, 击败 % 使用 PHP 的用户\n内存消耗 :  MB, 击败 % 使用 PHP 的用户\n\nSwift\n\n结果执行用时 :  ms, 击败 % 使用 Swift 的用户\n内存消耗 :  MB, 击败 % 使用 Swift 的用户\n\nKotlin\n\n结果执行用时 :  ms, 击败 % 使用 Kotlin 的用户\n内存消耗 :  MB, 击败 % 使用 Kotlin 的用户\n\nDart\n\n结果执行用时 :  ms, 击败 % 使用 Dart 的用户\n内存消耗 :  MB, 击败 % 使用 Dart 的用户\n\nGo\n\n结果执行用时 :  ms, 击败 % 使用 Go 的用户\n内存消耗 :  MB, 击败 % 使用 Go 的用户\n\nRuby\n\n结果执行用时 :  ms, 击败 % 使用 Ruby 的用户\n内存消耗 :  MB, 击败 % 使用 Ruby 的用户\n\nScala\n\n结果执行用时 :  ms, 击败 % 使用 Scala 的用户\n内存消耗 :  MB, 击败 % 使用 Scala 的用户\n\nRust\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00072.编辑距离","url":"/zh-CN/5e09154e62bd/","content":"\n题目描述给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。\n你可以对一个单词进行如下三种操作：\n\n插入一个字符\n删除一个字符\n替换一个字符\n\n示例 1：\n输入：word1 &#x3D; “horse”, word2 &#x3D; “ros”输出：3解释：horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)rorse -&gt; rose (删除 ‘r’)rose -&gt; ros (删除 ‘e’)\n\n示例 2：\n输入：word1 &#x3D; “intention”, word2 &#x3D; “execution”输出：5解释：intention -&gt; inention (删除 ‘t’)inention -&gt; enention (将 ‘i’ 替换为 ‘e’)enention -&gt; exention (将 ‘n’ 替换为 ‘x’)exention -&gt; exection (将 ‘n’ 替换为 ‘c’)exection -&gt; execution (插入 ‘u’)\n\n提示：\n0 &lt;&#x3D; word1.length, word2.length &lt;&#x3D; 500\nword1 和 word2 由小写英文字母组成\n\n\n解决方法C++\n\n结果执行用时 :  ms, 击败 % 使用 C++ 的用户\n内存消耗 :  MB, 击败 % 使用 C++ 的用户\n\nJava\n\n结果执行用时 :  ms, 击败 % 使用 Java 的用户\n内存消耗 :  MB, 击败 % 使用 Java 的用户\n\nPython\n\n结果执行用时 :  ms, 击败 % 使用 Python 的用户\n内存消耗 :  MB, 击败 % 使用 Python 的用户\n\nPython3\n\n结果执行用时 :  ms, 击败 % 使用 Python3 的用户\n内存消耗 :  MB, 击败 % 使用 Python3 的用户\n\nC\n\n结果执行用时 :  ms, 击败 % 使用 C 的用户\n内存消耗 :  MB, 击败 % 使用 C 的用户\n\nC#\n\n结果执行用时 :  ms, 击败 % 使用 C# 的用户\n内存消耗 :  MB, 击败 % 使用 C# 的用户\n\nJavaScript\n\n结果执行用时 :  ms, 击败 % 使用 JavaScript 的用户\n内存消耗 :  MB, 击败 % 使用 JavaScript 的用户\n\nTypeScript\n\n结果执行用时 :  ms, 击败 % 使用 TypeScript 的用户\n内存消耗 :  MB, 击败 % 使用 TypeScript 的用户\n\nPHP\n\n结果执行用时 :  ms, 击败 % 使用 PHP 的用户\n内存消耗 :  MB, 击败 % 使用 PHP 的用户\n\nSwift\n\n结果执行用时 :  ms, 击败 % 使用 Swift 的用户\n内存消耗 :  MB, 击败 % 使用 Swift 的用户\n\nKotlin\n\n结果执行用时 :  ms, 击败 % 使用 Kotlin 的用户\n内存消耗 :  MB, 击败 % 使用 Kotlin 的用户\n\nDart\n\n结果执行用时 :  ms, 击败 % 使用 Dart 的用户\n内存消耗 :  MB, 击败 % 使用 Dart 的用户\n\nGo\n\n结果执行用时 :  ms, 击败 % 使用 Go 的用户\n内存消耗 :  MB, 击败 % 使用 Go 的用户\n\nRuby\n\n结果执行用时 :  ms, 击败 % 使用 Ruby 的用户\n内存消耗 :  MB, 击败 % 使用 Ruby 的用户\n\nScala\n\n结果执行用时 :  ms, 击败 % 使用 Scala 的用户\n内存消耗 :  MB, 击败 % 使用 Scala 的用户\n\nRust\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00073.矩阵置零","url":"/zh-CN/b2a49fa22108/","content":"\n题目描述给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。\n示例 1：\n\n\n输入：matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]]输出：[[1,0,1],[0,0,0],[1,0,1]]\n\n示例 2：\n\n\n输入：matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]]输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\n提示：\nm &#x3D;&#x3D; matrix.length\nn &#x3D;&#x3D; matrix[0].length\n1 &lt;&#x3D; m, n &lt;&#x3D; 200\n$-2^{31} &lt;&#x3D; matrix[i][j] &lt;&#x3D; 2^{31} - 1$\n\n\n解决方法C++\n\n结果执行用时 :  ms, 击败 % 使用 C++ 的用户\n内存消耗 :  MB, 击败 % 使用 C++ 的用户\n\nJava\n\n结果执行用时 :  ms, 击败 % 使用 Java 的用户\n内存消耗 :  MB, 击败 % 使用 Java 的用户\n\nPython\n\n结果执行用时 :  ms, 击败 % 使用 Python 的用户\n内存消耗 :  MB, 击败 % 使用 Python 的用户\n\nPython3\n\n结果执行用时 :  ms, 击败 % 使用 Python3 的用户\n内存消耗 :  MB, 击败 % 使用 Python3 的用户\n\nC\n\n结果执行用时 :  ms, 击败 % 使用 C 的用户\n内存消耗 :  MB, 击败 % 使用 C 的用户\n\nC#\n\n结果执行用时 :  ms, 击败 % 使用 C# 的用户\n内存消耗 :  MB, 击败 % 使用 C# 的用户\n\nJavaScript\n\n结果执行用时 :  ms, 击败 % 使用 JavaScript 的用户\n内存消耗 :  MB, 击败 % 使用 JavaScript 的用户\n\nTypeScript\n\n结果执行用时 :  ms, 击败 % 使用 TypeScript 的用户\n内存消耗 :  MB, 击败 % 使用 TypeScript 的用户\n\nPHP\n\n结果执行用时 :  ms, 击败 % 使用 PHP 的用户\n内存消耗 :  MB, 击败 % 使用 PHP 的用户\n\nSwift\n\n结果执行用时 :  ms, 击败 % 使用 Swift 的用户\n内存消耗 :  MB, 击败 % 使用 Swift 的用户\n\nKotlin\n\n结果执行用时 :  ms, 击败 % 使用 Kotlin 的用户\n内存消耗 :  MB, 击败 % 使用 Kotlin 的用户\n\nDart\n\n结果执行用时 :  ms, 击败 % 使用 Dart 的用户\n内存消耗 :  MB, 击败 % 使用 Dart 的用户\n\nGo\n\n结果执行用时 :  ms, 击败 % 使用 Go 的用户\n内存消耗 :  MB, 击败 % 使用 Go 的用户\n\nRuby\n\n结果执行用时 :  ms, 击败 % 使用 Ruby 的用户\n内存消耗 :  MB, 击败 % 使用 Ruby 的用户\n\nScala\n\n结果执行用时 :  ms, 击败 % 使用 Scala 的用户\n内存消耗 :  MB, 击败 % 使用 Scala 的用户\n\nRust\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00074.搜索二维矩阵","url":"/zh-CN/c4a0be43fd2b/","content":"\n题目描述给你一个满足下述两条属性的 m x n 整数矩阵：\n\n每行中的整数从左到右按非严格递增顺序排列。\n每行的第一个整数大于前一行的最后一个整数。\n\n给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。\n示例 1：\n\n\n输入：matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 3输出：true\n\n示例 2：\n\n\n输入：matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 13输出：false\n\n提示：\nm &#x3D;&#x3D; matrix.length\nn &#x3D;&#x3D; matrix[i].length\n1 &lt;&#x3D; m, n &lt;&#x3D; 100\n$-10^4 &lt;&#x3D; matrix[i][j], target &lt;&#x3D; 10^4$\n\n\n解决方法C++\n\n结果执行用时 :  ms, 击败 % 使用 C++ 的用户\n内存消耗 :  MB, 击败 % 使用 C++ 的用户\n\nJava\n\n结果执行用时 :  ms, 击败 % 使用 Java 的用户\n内存消耗 :  MB, 击败 % 使用 Java 的用户\n\nPython\n\n结果执行用时 :  ms, 击败 % 使用 Python 的用户\n内存消耗 :  MB, 击败 % 使用 Python 的用户\n\nPython3\n\n结果执行用时 :  ms, 击败 % 使用 Python3 的用户\n内存消耗 :  MB, 击败 % 使用 Python3 的用户\n\nC\n\n结果执行用时 :  ms, 击败 % 使用 C 的用户\n内存消耗 :  MB, 击败 % 使用 C 的用户\n\nC#\n\n结果执行用时 :  ms, 击败 % 使用 C# 的用户\n内存消耗 :  MB, 击败 % 使用 C# 的用户\n\nJavaScript\n\n结果执行用时 :  ms, 击败 % 使用 JavaScript 的用户\n内存消耗 :  MB, 击败 % 使用 JavaScript 的用户\n\nTypeScript\n\n结果执行用时 :  ms, 击败 % 使用 TypeScript 的用户\n内存消耗 :  MB, 击败 % 使用 TypeScript 的用户\n\nPHP\n\n结果执行用时 :  ms, 击败 % 使用 PHP 的用户\n内存消耗 :  MB, 击败 % 使用 PHP 的用户\n\nSwift\n\n结果执行用时 :  ms, 击败 % 使用 Swift 的用户\n内存消耗 :  MB, 击败 % 使用 Swift 的用户\n\nKotlin\n\n结果执行用时 :  ms, 击败 % 使用 Kotlin 的用户\n内存消耗 :  MB, 击败 % 使用 Kotlin 的用户\n\nDart\n\n结果执行用时 :  ms, 击败 % 使用 Dart 的用户\n内存消耗 :  MB, 击败 % 使用 Dart 的用户\n\nGo\n\n结果执行用时 :  ms, 击败 % 使用 Go 的用户\n内存消耗 :  MB, 击败 % 使用 Go 的用户\n\nRuby\n\n结果执行用时 :  ms, 击败 % 使用 Ruby 的用户\n内存消耗 :  MB, 击败 % 使用 Ruby 的用户\n\nScala\n\n结果执行用时 :  ms, 击败 % 使用 Scala 的用户\n内存消耗 :  MB, 击败 % 使用 Scala 的用户\n\nRust\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"罪恶黑名单 第七季 第十三集 纽顿·普赛尔","url":"/zh-CN/d3453b41c324/","content":"\n剧情介绍　　特工小组调查了一系列针对数据中心的袭击事件，这些袭击由一名具有特殊病症的黑名单人物发动。而与此同时，莉兹则秘密展开了自己的调查。同时，格伦在一次运输事故后拼命试图向雷德证明自己的价值。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"清明","url":"/zh-CN/bbf714965230/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  清明\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","清明"]},{"title":"力扣00076.最小覆盖子串","url":"/zh-CN/34391e2ffab7/","content":"\n题目描述给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。\n注意：\n\n对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。\n如果 s 中存在这样的子串，我们保证它是唯一的答案。\n\n示例 1：\n输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”输出：”BANC”解释：最小覆盖子串 “BANC” 包含来自字符串 t 的 ‘A’、’B’ 和 ‘C’。\n\n示例 2：\n输入：s &#x3D; “a”, t &#x3D; “a”输出：”a”解释：整个字符串 s 是最小覆盖子串。\n\n示例 3：\n输入: s &#x3D; “a”, t &#x3D; “aa”输出: “”解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。\n\n提示：\nm &#x3D;&#x3D; s.length\nn &#x3D;&#x3D; t.length\n$1 &lt;&#x3D; m, n &lt;&#x3D; 10^5$\ns 和 t 由英文字母组成\n\n\n解决方法C++\n\n结果执行用时 :  ms, 击败 % 使用 C++ 的用户\n内存消耗 :  MB, 击败 % 使用 C++ 的用户\n\nJava\n\n结果执行用时 :  ms, 击败 % 使用 Java 的用户\n内存消耗 :  MB, 击败 % 使用 Java 的用户\n\nPython\n\n结果执行用时 :  ms, 击败 % 使用 Python 的用户\n内存消耗 :  MB, 击败 % 使用 Python 的用户\n\nPython3\n\n结果执行用时 :  ms, 击败 % 使用 Python3 的用户\n内存消耗 :  MB, 击败 % 使用 Python3 的用户\n\nC\n\n结果执行用时 :  ms, 击败 % 使用 C 的用户\n内存消耗 :  MB, 击败 % 使用 C 的用户\n\nC#\n\n结果执行用时 :  ms, 击败 % 使用 C# 的用户\n内存消耗 :  MB, 击败 % 使用 C# 的用户\n\nJavaScript\n\n结果执行用时 :  ms, 击败 % 使用 JavaScript 的用户\n内存消耗 :  MB, 击败 % 使用 JavaScript 的用户\n\nTypeScript\n\n结果执行用时 :  ms, 击败 % 使用 TypeScript 的用户\n内存消耗 :  MB, 击败 % 使用 TypeScript 的用户\n\nPHP\n\n结果执行用时 :  ms, 击败 % 使用 PHP 的用户\n内存消耗 :  MB, 击败 % 使用 PHP 的用户\n\nSwift\n\n结果执行用时 :  ms, 击败 % 使用 Swift 的用户\n内存消耗 :  MB, 击败 % 使用 Swift 的用户\n\nKotlin\n\n结果执行用时 :  ms, 击败 % 使用 Kotlin 的用户\n内存消耗 :  MB, 击败 % 使用 Kotlin 的用户\n\nDart\n\n结果执行用时 :  ms, 击败 % 使用 Dart 的用户\n内存消耗 :  MB, 击败 % 使用 Dart 的用户\n\nGo\n\n结果执行用时 :  ms, 击败 % 使用 Go 的用户\n内存消耗 :  MB, 击败 % 使用 Go 的用户\n\nRuby\n\n结果执行用时 :  ms, 击败 % 使用 Ruby 的用户\n内存消耗 :  MB, 击败 % 使用 Ruby 的用户\n\nScala\n\n结果执行用时 :  ms, 击败 % 使用 Scala 的用户\n内存消耗 :  MB, 击败 % 使用 Scala 的用户\n\nRust\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00075.颜色分类","url":"/zh-CN/cf0e5c843015/","content":"\n题目描述给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n必须在不使用库内置的 sort 函数的情况下解决这个问题。\n示例 1：\n输入：nums &#x3D; [2,0,2,1,1,0]输出：[0,0,1,1,2,2]\n\n示例 2：\n输入：nums &#x3D; [2,0,1]输出：[0,1,2]\n\n提示：\nn &#x3D;&#x3D; nums.length\n1 &lt;&#x3D; n &lt;&#x3D; 300\nnums[i] 为 0、1 或 2\n\n\n解决方法C++\n\n结果执行用时 :  ms, 击败 % 使用 C++ 的用户\n内存消耗 :  MB, 击败 % 使用 C++ 的用户\n\nJava\n\n结果执行用时 :  ms, 击败 % 使用 Java 的用户\n内存消耗 :  MB, 击败 % 使用 Java 的用户\n\nPython\n\n结果执行用时 :  ms, 击败 % 使用 Python 的用户\n内存消耗 :  MB, 击败 % 使用 Python 的用户\n\nPython3\n\n结果执行用时 :  ms, 击败 % 使用 Python3 的用户\n内存消耗 :  MB, 击败 % 使用 Python3 的用户\n\nC\n\n结果执行用时 :  ms, 击败 % 使用 C 的用户\n内存消耗 :  MB, 击败 % 使用 C 的用户\n\nC#\n\n结果执行用时 :  ms, 击败 % 使用 C# 的用户\n内存消耗 :  MB, 击败 % 使用 C# 的用户\n\nJavaScript\n\n结果执行用时 :  ms, 击败 % 使用 JavaScript 的用户\n内存消耗 :  MB, 击败 % 使用 JavaScript 的用户\n\nTypeScript\n\n结果执行用时 :  ms, 击败 % 使用 TypeScript 的用户\n内存消耗 :  MB, 击败 % 使用 TypeScript 的用户\n\nPHP\n\n结果执行用时 :  ms, 击败 % 使用 PHP 的用户\n内存消耗 :  MB, 击败 % 使用 PHP 的用户\n\nSwift\n\n结果执行用时 :  ms, 击败 % 使用 Swift 的用户\n内存消耗 :  MB, 击败 % 使用 Swift 的用户\n\nKotlin\n\n结果执行用时 :  ms, 击败 % 使用 Kotlin 的用户\n内存消耗 :  MB, 击败 % 使用 Kotlin 的用户\n\nDart\n\n结果执行用时 :  ms, 击败 % 使用 Dart 的用户\n内存消耗 :  MB, 击败 % 使用 Dart 的用户\n\nGo\n\n结果执行用时 :  ms, 击败 % 使用 Go 的用户\n内存消耗 :  MB, 击败 % 使用 Go 的用户\n\nRuby\n\n结果执行用时 :  ms, 击败 % 使用 Ruby 的用户\n内存消耗 :  MB, 击败 % 使用 Ruby 的用户\n\nScala\n\n结果执行用时 :  ms, 击败 % 使用 Scala 的用户\n内存消耗 :  MB, 击败 % 使用 Scala 的用户\n\nRust\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00077.组合","url":"/zh-CN/38bc9b1534e9/","content":"\n题目描述给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n你可以按 任何顺序 返回答案。\n示例 1：\n输入：n &#x3D; 4, k &#x3D; 2输出：[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],]\n\n示例 2：\n输入：n &#x3D; 1, k &#x3D; 1输出：[[1]]\n\n提示：\n1 &lt;&#x3D; n &lt;&#x3D; 20\n1 &lt;&#x3D; k &lt;&#x3D; n\n\n\n解决方法C++\n\n结果执行用时 :  ms, 击败 % 使用 C++ 的用户\n内存消耗 :  MB, 击败 % 使用 C++ 的用户\n\nJava\n\n结果执行用时 :  ms, 击败 % 使用 Java 的用户\n内存消耗 :  MB, 击败 % 使用 Java 的用户\n\nPython\n\n结果执行用时 :  ms, 击败 % 使用 Python 的用户\n内存消耗 :  MB, 击败 % 使用 Python 的用户\n\nPython3\n\n结果执行用时 :  ms, 击败 % 使用 Python3 的用户\n内存消耗 :  MB, 击败 % 使用 Python3 的用户\n\nC\n\n结果执行用时 :  ms, 击败 % 使用 C 的用户\n内存消耗 :  MB, 击败 % 使用 C 的用户\n\nC#\n\n结果执行用时 :  ms, 击败 % 使用 C# 的用户\n内存消耗 :  MB, 击败 % 使用 C# 的用户\n\nJavaScript\n\n结果执行用时 :  ms, 击败 % 使用 JavaScript 的用户\n内存消耗 :  MB, 击败 % 使用 JavaScript 的用户\n\nTypeScript\n\n结果执行用时 :  ms, 击败 % 使用 TypeScript 的用户\n内存消耗 :  MB, 击败 % 使用 TypeScript 的用户\n\nPHP\n\n结果执行用时 :  ms, 击败 % 使用 PHP 的用户\n内存消耗 :  MB, 击败 % 使用 PHP 的用户\n\nSwift\n\n结果执行用时 :  ms, 击败 % 使用 Swift 的用户\n内存消耗 :  MB, 击败 % 使用 Swift 的用户\n\nKotlin\n\n结果执行用时 :  ms, 击败 % 使用 Kotlin 的用户\n内存消耗 :  MB, 击败 % 使用 Kotlin 的用户\n\nDart\n\n结果执行用时 :  ms, 击败 % 使用 Dart 的用户\n内存消耗 :  MB, 击败 % 使用 Dart 的用户\n\nGo\n\n结果执行用时 :  ms, 击败 % 使用 Go 的用户\n内存消耗 :  MB, 击败 % 使用 Go 的用户\n\nRuby\n\n结果执行用时 :  ms, 击败 % 使用 Ruby 的用户\n内存消耗 :  MB, 击败 % 使用 Ruby 的用户\n\nScala\n\n结果执行用时 :  ms, 击败 % 使用 Scala 的用户\n内存消耗 :  MB, 击败 % 使用 Scala 的用户\n\nRust\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00078.子集","url":"/zh-CN/d47a41be6fcc/","content":"\n题目描述给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n示例 1：\n输入：nums &#x3D; [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n示例 2：\n输入：nums &#x3D; [0]输出：[[],[0]]\n\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 10\n-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10\nnums 中的所有元素 互不相同\n\n\n解决方法C++\n\n结果执行用时 :  ms, 击败 % 使用 C++ 的用户\n内存消耗 :  MB, 击败 % 使用 C++ 的用户\n\nJava\n\n结果执行用时 :  ms, 击败 % 使用 Java 的用户\n内存消耗 :  MB, 击败 % 使用 Java 的用户\n\nPython\n\n结果执行用时 :  ms, 击败 % 使用 Python 的用户\n内存消耗 :  MB, 击败 % 使用 Python 的用户\n\nPython3\n\n结果执行用时 :  ms, 击败 % 使用 Python3 的用户\n内存消耗 :  MB, 击败 % 使用 Python3 的用户\n\nC\n\n结果执行用时 :  ms, 击败 % 使用 C 的用户\n内存消耗 :  MB, 击败 % 使用 C 的用户\n\nC#\n\n结果执行用时 :  ms, 击败 % 使用 C# 的用户\n内存消耗 :  MB, 击败 % 使用 C# 的用户\n\nJavaScript\n\n结果执行用时 :  ms, 击败 % 使用 JavaScript 的用户\n内存消耗 :  MB, 击败 % 使用 JavaScript 的用户\n\nTypeScript\n\n结果执行用时 :  ms, 击败 % 使用 TypeScript 的用户\n内存消耗 :  MB, 击败 % 使用 TypeScript 的用户\n\nPHP\n\n结果执行用时 :  ms, 击败 % 使用 PHP 的用户\n内存消耗 :  MB, 击败 % 使用 PHP 的用户\n\nSwift\n\n结果执行用时 :  ms, 击败 % 使用 Swift 的用户\n内存消耗 :  MB, 击败 % 使用 Swift 的用户\n\nKotlin\n\n结果执行用时 :  ms, 击败 % 使用 Kotlin 的用户\n内存消耗 :  MB, 击败 % 使用 Kotlin 的用户\n\nDart\n\n结果执行用时 :  ms, 击败 % 使用 Dart 的用户\n内存消耗 :  MB, 击败 % 使用 Dart 的用户\n\nGo\n\n结果执行用时 :  ms, 击败 % 使用 Go 的用户\n内存消耗 :  MB, 击败 % 使用 Go 的用户\n\nRuby\n\n结果执行用时 :  ms, 击败 % 使用 Ruby 的用户\n内存消耗 :  MB, 击败 % 使用 Ruby 的用户\n\nScala\n\n结果执行用时 :  ms, 击败 % 使用 Scala 的用户\n内存消耗 :  MB, 击败 % 使用 Scala 的用户\n\nRust\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"食戟之灵 第五季 豪之皿 第一集 期末考试","url":"/zh-CN/402e093ecba5/","content":"\n剧情介绍　　季节是夏天！创真和他的朋友们度过了第二学年第一学期，现在迎来了期末考试。这次的测试是在游客众多的沙滩上经营一家“沙滩屋”，并在三天内实现300万日元的销售目标！创真和其他精英十杰成员本信心满满，直到他们发现这次考试的“陷阱”……给他们准备的餐馆居然只是一间几乎被废弃的破屋！创真和伙伴们能顺利通过这次期末考试吗？\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"罪恶黑名单 第七季 第十四集 塔米·乌鲁拉克","url":"/zh-CN/9ab4638dfc81/","content":"\n剧情介绍　　当团队调查阿拉斯加三角地带的一起神秘失踪案时，这起黑名单案件对帕克探员来说变得格外个人化。同时，阿拉姆寻求雷德的帮助，试图弄清楚埃洛迪丈夫真正发生了什么。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"力扣00079.单词搜索","url":"/zh-CN/18eae047ba75/","content":"\n题目描述给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n示例 1：\n\n\n输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCCED”输出：true\n\n示例 2：\n\n\n输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “SEE”输出：true\n\n示例 3：\n\n\n输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCB”输出：false\n\n提示：\nm &#x3D;&#x3D; board.length\nn &#x3D; board[i].length\n1 &lt;&#x3D; m, n &lt;&#x3D; 6\n1 &lt;&#x3D; word.length &lt;&#x3D; 15\nboard 和 word 仅由大小写英文字母组成\n\n\n解决方法C++\n\n结果执行用时 :  ms, 击败 % 使用 C++ 的用户\n内存消耗 :  MB, 击败 % 使用 C++ 的用户\n\nJava\n\n结果执行用时 :  ms, 击败 % 使用 Java 的用户\n内存消耗 :  MB, 击败 % 使用 Java 的用户\n\nPython\n\n结果执行用时 :  ms, 击败 % 使用 Python 的用户\n内存消耗 :  MB, 击败 % 使用 Python 的用户\n\nPython3\n\n结果执行用时 :  ms, 击败 % 使用 Python3 的用户\n内存消耗 :  MB, 击败 % 使用 Python3 的用户\n\nC\n\n结果执行用时 :  ms, 击败 % 使用 C 的用户\n内存消耗 :  MB, 击败 % 使用 C 的用户\n\nC#\n\n结果执行用时 :  ms, 击败 % 使用 C# 的用户\n内存消耗 :  MB, 击败 % 使用 C# 的用户\n\nJavaScript\n\n结果执行用时 :  ms, 击败 % 使用 JavaScript 的用户\n内存消耗 :  MB, 击败 % 使用 JavaScript 的用户\n\nTypeScript\n\n结果执行用时 :  ms, 击败 % 使用 TypeScript 的用户\n内存消耗 :  MB, 击败 % 使用 TypeScript 的用户\n\nPHP\n\n结果执行用时 :  ms, 击败 % 使用 PHP 的用户\n内存消耗 :  MB, 击败 % 使用 PHP 的用户\n\nSwift\n\n结果执行用时 :  ms, 击败 % 使用 Swift 的用户\n内存消耗 :  MB, 击败 % 使用 Swift 的用户\n\nKotlin\n\n结果执行用时 :  ms, 击败 % 使用 Kotlin 的用户\n内存消耗 :  MB, 击败 % 使用 Kotlin 的用户\n\nDart\n\n结果执行用时 :  ms, 击败 % 使用 Dart 的用户\n内存消耗 :  MB, 击败 % 使用 Dart 的用户\n\nGo\n\n结果执行用时 :  ms, 击败 % 使用 Go 的用户\n内存消耗 :  MB, 击败 % 使用 Go 的用户\n\nRuby\n\n结果执行用时 :  ms, 击败 % 使用 Ruby 的用户\n内存消耗 :  MB, 击败 % 使用 Ruby 的用户\n\nScala\n\n结果执行用时 :  ms, 击败 % 使用 Scala 的用户\n内存消耗 :  MB, 击败 % 使用 Scala 的用户\n\nRust\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\nErlang\n\n结果执行用时 :  ms, 击败 % 使用 Erlang 的用户\n内存消耗 :  MB, 击败 % 使用 Erlang 的用户\n\nElixir\n\n结果执行用时 :  ms, 击败 % 使用 Elixir 的用户\n内存消耗 :  MB, 击败 % 使用 Elixir 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket","Erlang","Elixir"]},{"title":"力扣00080.删除有序数组中的重复项 II","url":"/zh-CN/4b4d7abb670d/","content":"\n题目描述给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n说明：\n为什么返回数值是整数，但输出的答案是数组呢？\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n\n&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len &#x3D; removeDuplicates(nums);\n&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i &#x3D; 0; i &lt; len; i++) {   print(nums[i]);}\n\n示例 1：\n输入：nums &#x3D; [1,1,1,2,2,3]输出：5, nums &#x3D; [1,1,2,2,3]解释：函数应返回新长度 length &#x3D; 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。\n\n示例 2：\n输入：nums &#x3D; [0,0,1,1,1,1,2,3,3]输出：7, nums &#x3D; [0,0,1,1,2,3,3]解释：函数应返回新长度 length &#x3D; 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。\n\n提示：\n$1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 10^4$\n$-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4$\nnums 已按升序排列\n\n\n解决方法C++\n\n结果执行用时 :  ms, 击败 % 使用 C++ 的用户\n内存消耗 :  MB, 击败 % 使用 C++ 的用户\n\nJava\n\n结果执行用时 :  ms, 击败 % 使用 Java 的用户\n内存消耗 :  MB, 击败 % 使用 Java 的用户\n\nPython\n\n结果执行用时 :  ms, 击败 % 使用 Python 的用户\n内存消耗 :  MB, 击败 % 使用 Python 的用户\n\nPython3\n\n结果执行用时 :  ms, 击败 % 使用 Python3 的用户\n内存消耗 :  MB, 击败 % 使用 Python3 的用户\n\nC\n\n结果执行用时 :  ms, 击败 % 使用 C 的用户\n内存消耗 :  MB, 击败 % 使用 C 的用户\n\nC#\n\n结果执行用时 :  ms, 击败 % 使用 C# 的用户\n内存消耗 :  MB, 击败 % 使用 C# 的用户\n\nJavaScript\n\n结果执行用时 :  ms, 击败 % 使用 JavaScript 的用户\n内存消耗 :  MB, 击败 % 使用 JavaScript 的用户\n\nTypeScript\n\n结果执行用时 :  ms, 击败 % 使用 TypeScript 的用户\n内存消耗 :  MB, 击败 % 使用 TypeScript 的用户\n\nPHP\n\n结果执行用时 :  ms, 击败 % 使用 PHP 的用户\n内存消耗 :  MB, 击败 % 使用 PHP 的用户\n\nSwift\n\n结果执行用时 :  ms, 击败 % 使用 Swift 的用户\n内存消耗 :  MB, 击败 % 使用 Swift 的用户\n\nKotlin\n\n结果执行用时 :  ms, 击败 % 使用 Kotlin 的用户\n内存消耗 :  MB, 击败 % 使用 Kotlin 的用户\n\nDart\n\n结果执行用时 :  ms, 击败 % 使用 Dart 的用户\n内存消耗 :  MB, 击败 % 使用 Dart 的用户\n\nGo\n\n结果执行用时 :  ms, 击败 % 使用 Go 的用户\n内存消耗 :  MB, 击败 % 使用 Go 的用户\n\nRuby\n\n结果执行用时 :  ms, 击败 % 使用 Ruby 的用户\n内存消耗 :  MB, 击败 % 使用 Ruby 的用户\n\nScala\n\n结果执行用时 :  ms, 击败 % 使用 Scala 的用户\n内存消耗 :  MB, 击败 % 使用 Scala 的用户\n\nRust\n\n结果执行用时 :  ms, 击败 % 使用 Rust 的用户\n内存消耗 :  MB, 击败 % 使用 Rust 的用户\n\nRacket\n\n结果执行用时 :  ms, 击败 % 使用 Racket 的用户\n内存消耗 :  MB, 击败 % 使用 Racket 的用户\n\n","categories":["语言"],"tags":["算法","LeetCode","C++","Java","Python","Python3","C","C#","JavaScript","TypeScript","PHP","Swift","Kotlin","Dart","Go","Ruby","Scala","Rust","Racket"]},{"title":"食戟之灵 第五季 豪之皿 第二集 蓝色前哨战","url":"/zh-CN/7e787406d3da/","content":"\n剧情介绍　　一场世界级的烹饪比赛“THE BLUE”宣布举行。远月学院获得了三个参赛名额。为了争夺这个宝贵的名额，将举办一场面向全校学生的“蓝色前传”！所有学生都可以参加，因此很多人积极报名。最终，谁会成为由99位评委选出的前三名获胜者？围绕“汤品”主题的厨师大乱斗即将展开……！\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"谷雨","url":"/zh-CN/1505aeca79d6/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  谷雨\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","谷雨"]},{"title":"罪恶黑名单 第七季 第十五集 戈登·肯普","url":"/zh-CN/549d0f16fd8e/","content":"\n剧情介绍　　一桩黑名单案件迫使莉兹在雷德和特工小组之间做出选择。同时，雷德试图安抚惊慌失措的伊利亚·科斯洛夫，后者认为自己正被监视。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"闪电侠 第六季 第十六集 再见，晚安","url":"/zh-CN/e0de815f8015/","content":"\n剧情介绍　　在黑洞雇佣布娃娃杀死乔后，辛格建议他进入证人保护部门，但乔拒绝停止调查卡佛。在与西斯科一起调查卡佛时，拉尔夫遇到了苏。艾瑞斯开始怀疑伊娃。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"iPhone SE（A13，2020年）","url":"/zh-CN/2e753a1d6c75/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPhone SE\n  称心称手，超值入手。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPhone"]},{"title":"罪恶黑名单 第七季 第十六集 奈尔·哈奇","url":"/zh-CN/981d583c44b5/","content":"\n剧情介绍　　莉兹和特工小组接手了一桩可能出现新受害者的陈年旧案。同时，雷德试图帮助一位身陷危险的登贝朋友。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"蝙蝠女侠 第一季 第十七集 九死一生","url":"/zh-CN/14a92bb99467/","content":"\n剧情介绍　　蝙蝠女侠遇到了一项新的挑战，一位旧时反派的重新现身考验着哥谭市最正直市民的英雄气概。爱丽丝的极限也受到了考验。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第六季 第十七集 解放","url":"/zh-CN/32502bbb4569/","content":"\n剧情介绍　　在最近的事件之后，巴里仔细研究了他与艾里斯的生活。伊娃做出了一个大胆的举动。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第七季 第十七集 兄弟","url":"/zh-CN/b5c5c2b0f44c/","content":"\n剧情介绍　　当雷斯勒的哥哥带他回家执行一项危险任务时，雷斯勒被迫直面过去的创伤和家族秘密。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"女超人 第五季 第十七集 法律机器","url":"/zh-CN/9aad1a7817dc/","content":"\n剧情介绍　　莱克斯开始实施一个复杂的计划，旨在让莉娜更靠近自己，击败利维坦的最新攻击，并将女超人和她的团队引入与利维坦的对抗。同时，也揭示了莱克斯在“危机”事件后如何崛起并掌握权力的过程。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第一季 第十八集 心照不宣","url":"/zh-CN/f04acff1b570/","content":"\n剧情介绍　　蝙蝠女侠召集卢克和朱莉娅进行一项卧底任务，目的是从她表哥的武器库中找回一件极为重要的物品。与此同时，爱丽丝继续在阿卡姆墙内策划她的阴谋，然而她却意外地迎来了雅各布·凯恩的拜访，他需要她的帮助。与此同时，玛丽努力向凯特证明自己的价值。随着索菲与一位同事的关系日益亲近，凯特则与一位旧情人重聚。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"立夏","url":"/zh-CN/0413915a6189/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立夏\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立夏"]},{"title":"闪电侠 第六季 第十八集 付钱给吹笛人","url":"/zh-CN/90d7e0867fb6/","content":"\n剧情介绍　　当Godspeed回来时，Barry转向Hartley Rathaway寻求帮助。然而，在巴里意识到危机的变化之一是闪电侠和吹笛者现在是敌人之后，事情很快就变得紧张起来。与此同时，艾瑞斯试图逃离镜像宇宙。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"MacBook Pro 13 英寸（Intel，2020年）","url":"/zh-CN/3579ca123c8f/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  MacBook Pro\n  动力，行动力。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"罪恶黑名单 第七季 第十八集 罗伊·凯因","url":"/zh-CN/0d71a2b52078/","content":"\n剧情介绍　　在特工小组调查一起看似不可能完成的绑架案时，登贝陷入了一个危险境地。与此同时，一次最近的健康危机让雷德开始思考接班人问题。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"女超人 第五季 第十八集 缺失的环节","url":"/zh-CN/f3e492abcffc/","content":"\n剧情介绍　　女超人和团队正面对抗拉玛·汗和利维坦。同时，莉娜和莱克斯不得不联手，因为“非伤害计划”失败，令这对兄妹陷入严重危险之中。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第一季 第十九集 瞒天过海","url":"/zh-CN/d8255fea0f7b/","content":"\n剧情介绍　　当哥谭的知识分子开始神秘失踪时，凯恩指挥官、索菲和乌鸦小队开始寻找这个最新的杀人威胁。与此同时，凯特被某人的背叛所困扰，开始质疑身边每一个人的忠诚，恰逢她最需要他们的时候。于是，当卢克和朱莉娅失踪时，蝙蝠女侠不得不依赖玛丽和一位曾经的敌人来执行她的营救任务。与此同时，爱丽丝寻求托米·艾略特的帮助，来获取一件她的妹妹也在寻找的难以捉摸的物品。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第六季 第十九集 成功是有保证的","url":"/zh-CN/70b619558eaa/","content":"\n剧情介绍　　巴里考虑了一个冒险的计划，从镜像宇宙中拯救艾瑞斯。拉尔夫试图阻止苏犯一个可能毁掉她生活的严重错误。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第七季 第十九集 卡赞吉安兄弟","url":"/zh-CN/67f6c0af2a45/","content":"\n剧情介绍　　特工小组调查了一位为暴利犯罪分子工作的会计，目的是找出为其提供保护的暴力兄弟。与此同时，莉兹必须做出一个重大的决定。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"女超人 第五季 第十九集 不朽的快攻","url":"/zh-CN/8dc1bfe5c4e3/","content":"\n剧情介绍　　女超人意识到，要阻止莱克斯和利维坦，她必须与一个她从未想过会再次信任的人——莉娜——合作。尼娅不断梦见布雷尼，但却难以理解这些梦试图传递的信息。同时，布雷尼意识到阻止莱克斯只有一种方法。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第一季 第二十集 不徇私情","url":"/zh-CN/d39ad276b73b/","content":"\n剧情介绍　　当哥谭的一位前英雄回到老地方清算旧账时，蝙蝠女侠和凯恩指挥官都陷入了防守的局面。与此同时，爱丽丝发现了一个能够彻底击败蝙蝠女侠的秘密，但她正失去对手下鼠男和赫什的控制，这使她陷入了自己最邪恶的状态。卢克立刻专注于寻找保护蝙蝠女侠免受爱丽丝威胁的方法，而玛丽则有机会成为凯特一直需要的姐姐。新的信息浮出水面，迫使朱莉娅警告索菲有关背后操控一切的那个人。在最终的对峙中，当凯恩指挥官拒绝从与蝙蝠女侠的战争中撤退时，凯特可能会发现自己不仅因父亲的选择而心碎。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"小满","url":"/zh-CN/9c190b8ffab1/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小满\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小满"]},{"title":"适用于 iPad Pro 的妙控键盘（2020年）","url":"/zh-CN/57b901dd0afc/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPad Pro 的\n  全新妙控键盘，\n  可以入手了。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Magic Keyboard"]},{"title":"芒种","url":"/zh-CN/0bfe5b60239d/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  芒种\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","芒种"]},{"title":"夏至","url":"/zh-CN/f909991e16b2/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  夏至\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","夏至"]},{"title":"Apple 2020 全球开发者大会","url":"/zh-CN/43063c366637/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  全码力，走起。\n\n\n\n  \n\n\n\n  干货来了。\n\n\n\n  \n\n\n\n  前方高能，超在线。\n\n\n\n  \n\n\n\n","categories":["开发者大会"],"tags":["Apple","WWDC"]},{"title":"小暑","url":"/zh-CN/f8faa76c9012/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小暑"]},{"title":"Apple 三里屯","url":"/zh-CN/e60e66767404/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple 三里屯\n  一起来激荡灵感\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["零售店"],"tags":["Apple","Retail"]},{"title":"食戟之灵 第五季 豪之皿 第三集 深夜料理人","url":"/zh-CN/bbdafb5bc943/","content":"\n剧情介绍　　新来的讲师铃木向创真发起了挑战！这虽然不是一场正式的比赛，但铃木以自己的“秘密”作为赌注，而创真则以他的“厨刀”作为赌注。比赛的主题是“使用烹饪实验室冰箱里的食材制作料理”。创真做出了基于幸平创真家传技巧的炸猪排，而铃木则出乎意料地采取了不同的手法……比赛结束后，创真从铃木那里得知了一个令人震惊的事实。\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"大暑","url":"/zh-CN/52f023b239d8/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大暑"]},{"title":"Taylor Swift folklore：the long pond studio sessions (from the Disney+ special) [deluxe edition]","url":"/zh-CN/e96f9016716f/","content":"\n专辑介绍据上张专辑《Lover》推出仅 11 个月后，我们惊喜地迎来 Taylor Swift 未经宣发便上线的又一全长录音室专辑《folklore》。这 11 个月看似短暂，期间发生的种种，尤其是全球疫情的蔓延，却让人感慨良多，回想起来恍若隔世。Taylor 在居家隔离期间，主动提出要与自己的几位乐坛偶像在线联手创作：美国艺术摇滚领军乐队 The National 的吉他手 Aaron Dessner，隐身于独立民谣乐队 Bon Iver 背后的 Justin Vernon，以及 Taylor 的长期合作对象 Jack Antonoff。他们共同打造了一场如羊毛衫般舒适熨帖，却值得深思回味的沉浸式听觉体验。\n这张专辑与前作大相径庭。《the 1》以一句“我最近过的还好 &#x2F; 正在着手新鲜事（I’m doing good &#x2F; I’m on some new shit）”开场，你若以为这是她在汇报居家隔离的动态，或是交代最近满溢的敏感思绪，那也无可厚非。但事实上，Swift 近期将能量全盘倾注在歌曲写作上，它们化作一篇篇短篇小说和人物速写。其中既有普鲁斯特式的意识流闪回（《cardigan》有 Lana Del Rey 的影子），也描摹为社会所背弃的寡妇形象（《the last great american dynasty》），与 Bon Iver 合作的深沉二重唱《exile》则描绘了一段注定走向毁灭的爱情。这张专辑肌理丰富，充满想象。她在《seven》中唱道：“你长长的辫子像一枚神秘的图案 &#x2F; 对你的爱直至月球和土星亦不分离（Your braids like a pattern&#x2F;Love you to the moon and to Saturn）。”这是在讲述一则两位朋友策划一场逃亡的童话：“爱会像民谣被传唱下去一般 &#x2F; 生生不息（Passed down like folk songs &#x2F; the love lasts so long）。”这位优秀的唱作人，即便时刻生活在公众视线下，亦能挖掘出如此丰富的生活素材，这只能说明，Taylor Swift 的确在隔离期间获得了灵感和热望。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","Taylor Swift"]},{"title":"食戟之灵 第五季 豪之皿 第四集 最后的晚餐","url":"/zh-CN/ec91607bdaa7/","content":"\n剧情介绍　　“THE BLUE”的第一天到来了。会场上聚集了许多年轻的天才厨师，包括由朝阳领导的“黑色厨师团”（Les Cuisiniers Noirs）。烹饪大赛正式开始，创真、惠、塔克米和绘里奈前往指定的赛场。创真面临的第一个挑战是“最后的晚餐”！？他将如何应对这一任务！？\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"多力特的奇幻冒险","url":"/zh-CN/28e6913473a2/","content":"\n剧情介绍　　故事发生在英国维多利亚女王（杰西·巴克利 Jessie Buckley 饰）统治时期，多力特（小罗伯特·唐尼 Robert Downey Jr. 饰）拥有着能够和动物交谈的特殊能力，和妻子一起在老家经营着一家动物医院。\n　　一场意外夺走了多力特妻子的生命，这巨大的打击让多力特封闭起了心门，拒绝和任何人类接触。一天，一个名叫汤姆（哈里·科莱特 Harry Collett 饰）的男孩闯入了多力特的家，带来了一只受伤的松鼠，希望多力特能够救它。与此同时，维多利亚女王患上了一种怪病，于是派出了侍女萝丝（卡梅尔·拉尼亚多 Carmel Laniado 饰）去拜访多力特，请他出山。多力特所拥有的动物庄园归属于女王的名下，如果女王去世了，那么多力特将失去他和动物们这唯一的乐园。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"食戟之灵 第五季 豪之皿 第五集 便利店之战","url":"/zh-CN/39f43cdaf4a2/","content":"\n剧情介绍　　完成了第一个挑战后，创真前往了第二个赛场。在那里，他遇到了一个意想不到的人物。第二个挑战开始了，主题是“用便利店出售的食材做出价值超过100美元的菜肴”！创真对这个主题充满信心，然而，他呈现的每一道菜都被评委拒绝了！究竟是什么原因导致他的料理被拒绝呢！？\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"よねづ けんし STRAY SHEEP","url":"/zh-CN/226310e668ca/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","よねづ けんし"]},{"title":"iMac 27 英寸（Intel，2020年）","url":"/zh-CN/91d7fcaf4665/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  实力满满在一身。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"立秋","url":"/zh-CN/b355090de589/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立秋\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立秋"]},{"title":"食戟之灵 第五季 豪之皿 第六集 盛夏的圣诞节","url":"/zh-CN/b739c9c93894/","content":"\n剧情介绍　　当创真到达第三个挑战的赛场时，THE BLUE的组织者——同时也是世界烹饪组织（WGO）的顶尖人物，告诉他们，她对像创真这样的普通厨师没有任何期望。接下来，地下厨师们将展示他们的烹饪技巧，证明他们的强大。一位被选中的地下厨师拿出了一件烹饪工具，竟然是一把电链锯！？创真和其他人亲眼目睹了地下厨师们那些异乎寻常却无可否认的技艺。难道有办法应对这些“怪物”般的厨师吗！？\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"食戟之灵 第五季 豪之皿 第七集 交错之刃","url":"/zh-CN/14eab7b2a4a6/","content":"\n剧情介绍　　创真将迎战一位地下厨师——萨奇，这场挑战的主题是圣诞蛋糕。创真的蛋糕和其中隐藏的巧妙设计能否足以对抗萨奇令人垂涎的“集群炸弹蛋糕”？究竟谁会赢得这场较量！？与此同时，司瑛士的第一次战斗也开始了。他将与朝阳·西巴展开对决！这场战斗将是曾经远月学院的第一名学生与地下厨师的领袖之间的较量！\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"食戟之灵 第五季 豪之皿 第八集 欠缺的半月","url":"/zh-CN/d8cc34185d34/","content":"\n剧情介绍　　塔克米将与地下厨师成员唐·卡尔玛展开对决！这场战斗的主题是团队合作制作开胃小菜。然而，本应帮助塔克米的伊佐米却没有出现在赛场上。原来他被唐·卡尔玛的手下绑架了。塔克米陷入困境，关键时刻，创真意外出现，能否帮助塔克米扭转局面？\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"处暑","url":"/zh-CN/5e31e0bf157e/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  处暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","处暑"]},{"title":"食戟之灵 第五季 豪之皿 第九集 神之舌的绝望","url":"/zh-CN/4b277f3cf994/","content":"\n剧情介绍　　创真意识到绘里奈正面临比其他人更加严苛的任务。他们决定前往比赛的组织者处提出抗议。然而，他们却发现了一个惊人的真相！在最终选拔的第二轮，惠将与朝阳对决，而塔克米则将与绘里奈展开对决！这场生死攸关的战斗即将开始！\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"健身环大冒险","url":"/zh-CN/cd6788297380/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"信条","url":"/zh-CN/6c81a30cebec/","content":"\n剧情简介　　乌克兰基辅国家歌剧院，一伙蒙面歹徒突然闯入演出大厅，挟持在场数百名音乐家和观众。未过多久，乌克兰特警部队迅速赶到，并按照既定战术突入进去。与此同时，几名神秘之人换上特警部队肩章，趁乱潜入歌剧院，救出被困的美国大使。神秘人之一的男主“无名”（约翰·大卫·华盛顿 John David Washington 饰）虽然一度顺利完成任务，却身不由己置身死地。当他再度醒来，则被告知失去原有身份，此后将加入一个名为“信条”的秘密组织，去执行一项阻止世界毁灭的重大任务。早在歌剧院时，他便见识了一次逆转子弹的奇怪现象。而如今着手的任务，似乎正与逆转的子弹乃至逆转的时间息息相关。\n　　注定发生的必然会发生，所种何因，便结何果……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"食戟之灵 第五季 豪之皿 第十集 超越老爸","url":"/zh-CN/b229045564a3/","content":"\n剧情介绍　　创真稳步晋级，即将与朝阳展开下一场对决！与此同时，绘里奈对母亲的担忧让她开始认为，也许如果朝阳赢得比赛，对大家来说会更好。她对“神之舌”的人所隐藏的秘密，是她产生疑虑的原因。与此同时，城一郎回到了日本，并向堂岛透露了他如何遇见创真的母亲，并与朝阳产生了牵连的经过。\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"白露","url":"/zh-CN/293a2e02859c/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  白露\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","白露"]},{"title":"潘玮柏 节奏先生","url":"/zh-CN/078d63ee1bc6/","content":"\n专辑介绍演艺圈风风火火的多栖发展，未曾让潘玮柏偏移过音乐本心。在综艺主持、影视剧和潮牌生意多个领域均走得风生水起的同时，他依旧稳定保持着两三年为一个周期的节奏推出录音室专辑，和制作团队以高作品完成度回馈了粉丝坚定不移的支持。2017 年发行专辑《异类》时，正值潘玮柏首次以导师（制作人）身份登上综艺节目《中国有嘻哈》，在嘻哈文化随这档节目热播而呈现复兴之势的同时，他也顺势从流行外衣和多变“异类”的色彩中，逐渐强调“节奏先生”的嘻哈本色。\n和《异类》呼应封面的“多彩”概念不同，这张专辑在整体听感上似乎没再延续欧美流行、更“电”的主气质，这也或许因为操刀制作专辑的幕后阵容中有 K-Pop 经验丰富的制作人 Hyuk Shin。专辑从名称开始便带着文字游戏的巧思，将“R&amp;B”的原意“Rhythm &amp; Blues”（节奏蓝调）重定义为“Rhythm &amp; Beats”，双重强调了它偏重节奏感的音乐底色，而传奇经典的 808 电子鼓机也被选为专辑编曲上的不二主角。同名主打歌《节奏先生》中大量运用了“燃烧”的意象（“把恶意全都烧成灰”、“不断燃烧黑暗小宇宙”），在重拍节奏的反复烘托之下，制造出一种烈焰升腾的感受，一如专辑封面设计，预示了想要达到“烫耳”的听感。随后无论是在融合 Future Bass 的《第二顺位》中呈现付出得不到回报的心酸狼狈，还是在复古舞曲《Kisses》中演绎因暧昧而爱得愈发疯狂，无不随着电子节拍的添薪加柴快速升温，袒露出生活之火和爱欲情热。\n此外，潘玮柏也邀来流行好手与杰出新秀一同“燃烧”：在《中国新说唱》舞台上与黄旭、肖恩恩合作的《爱你 3000》、与袁娅维合唱的《Moonlight》都被收录进新专辑里，一动一静，铺开生活和追梦路上的心情画卷。潘玮柏重填中文词的《Moonlight》隐藏在专辑尾声，不单单只是文本的转译，也是对几年前创作这首歌时心境的重返。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","潘玮柏"]},{"title":"食戟之灵 第五季 豪之皿 第十一集 失败的味道","url":"/zh-CN/3e18d64383e9/","content":"\n剧情介绍　　创真与朝阳的战斗开始了！这场战斗的主题是做出一款融合了世界五大菜系元素的料理。比赛局势似乎对朝阳有利，他使用十字刀技率先完成了自己的料理。然而，创真做出的菜肴竟然是一道“餐馆食品”！？他的菜肴能否与被“神之舌”认可的精致菜品相匹敌？\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"花木兰","url":"/zh-CN/9db7696a528f/","content":"\n剧情介绍　　迪士尼影业荣誉出品《花木兰》由备受赞誉的电影导演妮基·卡罗执导，将中国传奇战士的史诗故事全新呈现。影片讲述了一位无所畏惧的年轻女子义无反顾为家国而战，成为中国史上最著名的伟大勇士之一。当皇帝下令境内每个家庭必须有一位男丁应召出征，抵御北方来犯者入侵，出身军戎之家的长女花木兰，挺身而出，替病痛缠身的父亲应征入伍。她女扮男装化名“花军”，一路历经磨练，驾驭自己内心的力量，激发真正的潜能。通过这段传奇历程，她将成为一名光荣的勇士，不仅赢得国家的认可，更博得父亲的骄傲。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"Apple 特别活动","url":"/zh-CN/356f4b5adf57/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  时间这就到了。\n\n\n\n  一点走起，轻一点。\n\n\n\n  \n\n\n\n  回顾时间到。\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["发布会"],"tags":["Apple","Apple Event"]},{"title":"食戟之灵 第五季 豪之皿 第十二集 最上等的璞石们","url":"/zh-CN/b50b84b00a38/","content":"\n剧情介绍　　像朝阳的料理一样，创真的菜肴也激发了场馆内玛娜的“赠予”能力。究竟谁将赢得比赛，晋级下一轮？创真与朝阳的战斗终于结束！与此同时，薙切蓟拜访了玛娜，二人之间的过去首次被揭露……\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"Apple Watch Series 6（S6，2020年）和 Apple Watch SE 1（S5，2020年）","url":"/zh-CN/e2ae6cf883ed/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple Watch Series 6\n  健康的未来，\n  现在戴上。\n\n\n\n  \n\n\n\n  Apple Watch SE\n  事事拿手，\n  轻松入手。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Watch"]},{"title":"iPad（A12，2020年）","url":"/zh-CN/b57b4ae6eaa7/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPad\n  特有本事，特超值。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPad"]},{"title":"秋分","url":"/zh-CN/78460c80d838/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  秋分\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","秋分"]},{"title":"食戟之灵 第五季 豪之皿 第十三集 食戟之灵","url":"/zh-CN/2699b7209ed6/","content":"\n剧情介绍　　THE BLUE迎来了高潮，创真与绘里奈的最终对决！然而，绘里奈由于过于焦虑于拯救玛娜的任务，心神不宁。于是，创真决定为绘里奈做一道料理，而不是继续与她对决！这场“战斗”将会如何发展呢！？\n\n","categories":["剧集"],"tags":["日常","TBS"]},{"title":"田馥甄 无人知晓","url":"/zh-CN/66aba2befa4a/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","田馥甄"]},{"title":"寒露","url":"/zh-CN/6a439557bba8/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  寒露\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","寒露"]},{"title":"Apple 特别活动","url":"/zh-CN/0370ba4194b1/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["发布会"],"tags":["Apple","Apple Event"]},{"title":"霜降","url":"/zh-CN/a53086a7da4e/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  霜降\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","霜降"]},{"title":"iPhone 12 Pro（A14，2020年）和 iPhone 12（A14，2020年）","url":"/zh-CN/1d01b5c1d56f/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPhone 12 Pro\n  自我再飞跃。\n\n\n\n  \n\n\n\n  iPhone 12\n  升维大提速。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPhone"]},{"title":"曼达洛人 第二季 第一集 首领","url":"/zh-CN/7e08da228e6a/","content":"\n剧情介绍　　曼达洛人被吸引到外环地带，寻找与他同类的人。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"杨丞琳 LIKE A STAR","url":"/zh-CN/5a6d73415abb/","content":"\n专辑介绍除了自身的才华外，明星在舞台上的闪耀离不开整个团队的梦想与歌迷的支持。在意义非凡的出道 20 周年之际，杨丞琳用《LIKE A STAR》怀念了美好的少女时代，更多的是对未来发出挑战自己的宣言。以她此前的演艺生涯为构想，新歌呼应了她的歌手、演员、舞者等多重身份，将她的唱、演特质融入到了每一首新作品中。\n若前作《删·拾 以后》是翻越年龄关口后对未来人生的感慨，那么《LIKE A STAR》则是杨丞琳在出道二十年总结之上的一次重新出发。阔别少女偶像身份多年的她在新专辑中再次释放出唱跳能量。《BAD LADY》的电子 Trap 重拍之外，充满活力的 Funk 律动也响起在她和王心凌两位“甜蜜教主”合作的《女孩们》之中。由米奇林与许哲珮共谱的 R&amp;B 小品《SINGING IN THE RAIN》衬托出杨丞琳声线中的一丝迷幻感，如昨日般触碰柔软的抒情与前卫、活力的新曲风交错贯穿了整张专辑。此外，李荣浩操刀了专辑核心单曲《像是一颗星星》，同时还有 ØZI、剃刀蒋等多位优秀音乐人参与到这张专辑的制作中，在这个特别的时刻，助力杨丞琳的才华与心愿。\n展示正面侧面背面\n","categories":["音乐"],"tags":["杨丞琳","Apple Music"]},{"title":"曼达洛人 第二季 第二集 乘客","url":"/zh-CN/5d47f67e894d/","content":"\n剧情介绍　　曼达洛人必须护送一名携带珍贵货物的乘客完成一段危险旅程。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"立冬","url":"/zh-CN/922aa34a3c34/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立冬\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立冬"]},{"title":"Apple 特别活动","url":"/zh-CN/a6fe6e2c94a4/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["发布会"],"tags":["Apple","Apple Event"]},{"title":"曼达洛人 第二季 第三集 女继承人","url":"/zh-CN/734c0b016839/","content":"\n剧情介绍　　曼达洛人冒险涉足高海域，并遇到意想不到的盟友。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"周杰伦 黑胶唱片","url":"/zh-CN/357b0e6daabc/","content":"\n专辑介绍JAY[2000.11.06]千禧年世纪更迭之际，R&amp;B 在华语乐坛逐日兴起，众多歌手共同推动着中文流行乐风的悄然改变。此时此刻，一张名为《杰伦》的专辑也从台湾阿尔发唱片横空出世，那些在第一时间买下专辑的听众，有幸目睹了乐坛揭开“唱作新世代”的大幕。专辑中十首歌不落窠臼，诸多新鲜音乐元素和歌词主题，凸显出这位首发新人独特的个人印记。“周杰伦”这个名字也随着作品的新鲜感和冲击力，闯入了大众视线。\n1997 年，18 岁的他被吴宗宪慧眼识英，从选秀舞台转身进入唱片公司做助理，开始三年幕后历练。童年时代的钢琴练习和高中时期的音乐学习，加上从国内外所爱艺人身上汲取的营养，让周杰伦创作起流行乐来得心应手。\n在《杰伦》诞生期间，他在阿尔发录音棚内潜心闭关创作。在结识了同样怀揣才华，却还没有开始大展拳脚的方文山后，两人碰撞出了许多灵感火花。《杰伦》为未来两人亲密无间的合作打下第一块基石，而两位鬼才搭档也开始创作出大量“反常规”的华语流行歌：把打篮球写出内心戏、充满 battle 感的嘻哈单曲《斗牛》，主题颇有异趣、酸性爵士风的《印地安老斑鸠》，这些新鲜声音为乐坛划下不同寻常的光亮弧线。而周杰伦的古典乐素养，也从飘逸着巴洛克美学的弦乐和大键琴旋律中向外展现。\n和他的许多经典曲目一样，古风文化、嘻哈功夫与创新，时空穿梭感，招牌情歌，这几大特色从首专《杰伦》中都已开始铺垫。其中的《娘子》完美体现了周杰伦对中文说唱的独到理解——不仅在那个年代就创作出了中文旋律说唱，更突破了中文声调对说唱表现的限制，影响力绵延至今。而《娘子》中满满的古风意境，也是他与方文山二人标志性“中国风”的开场，在周杰伦以传统文化为主线的创作分支上有着开宗立派的非凡意义。另外，从情歌这条创作脉络上看，这张专辑的成绩也让人感到非常惊艳。与徐若瑄合作的《可爱女人》《龙卷风》都成为传唱最广的中文单曲之一。\n机缘加上多年历练，让《杰伦》一出手便成为了启发华语乐坛创意的重要作品，在当时乐坛还处于“后知后觉”的时候，专辑封面上这位腼腆的卷发男孩，已在酝酿更大的精彩，朝着未来一代新“天王”的模样疾速成长。\n范特西[2001.09.14]回溯时代潮流，《范特西》出世前，新时代的 R&amp;B 和嘻哈音乐早已席卷全球，华语乐坛也有诸如陶喆、王力宏等歌手加入这波浪潮。周杰伦也乘着这股势头而起，却更胜一筹地以国语、台语、日语交织穿梭，嘻哈、R&amp;B、古典、摇滚，你方唱罢我登场，大胆而丰富的想象轮番上演，让《范特西》至今听来依然是一套集创造力之大成、难以望其项背的流行幻想组曲。\n既以“幻想”之名，必有幻想之境。《范特西》中的每一首歌就是一颗镜头，以听觉塑造画面，带人走入古今中外的各色影像：《爱在西元前》融合 R&amp;B 与嘻哈，用老式唱机的效果处理前奏，开启时空漩涡，穿越到三千七百多年前的古巴比伦；以五声音阶谱写的《上海一九四三》，民国时老上海的气息扑面而来，斑驳的岁月浮现在眼前；只用一个和弦完成的《忍者》，透过周杰伦特有的含混念白和日式意象营造音乐的临场感；而诡谲迷离的《威廉古堡》以管风琴演奏和声小调音乐，让人仿佛置身中世纪欧洲，探访吸血鬼的生活。这一切，由方文山的词、周杰伦的曲，以及林迈可、洪敬尧、钟兴民领衔的编曲实现，三者缺一不可。\n如果说首张专辑中的《娘子》是中国风加上说唱的先声，那么破天荒将重金属、古典钢琴、嘻哈、Funk 等多种元素融合而成的《双截棍》，则直接将“中国风说唱”化为独属于周杰伦的音乐流派，一句怪诞的“哼哼哈兮”至今仍是人们眼中时代经典的呐喊。而《双截棍》对中国功夫的致敬、《爸我回来了》对家庭暴力的控诉，在天真烂漫的《简单爱》和钢琴主打的《安静》为代表的传统华语抒情歌之外，大大丰富了专辑的表达层次，也让专辑的文化内涵更上一层楼。\n2000 年后，沉睡的华语乐坛能说是被《杰伦》惊醒，再被《范特西》拉着狂奔至新的次元，大家逐渐认识到多元题材的可能，而这一切都源自于周杰伦喷薄而出的才情和天马行空的创作。对周杰伦本人而言，《范特西》开启了他创作的范式，一套成熟的方法论就此确立。如今看来，这张专辑绝对是周杰伦音乐生涯里的高峰，也成为无数音乐人相继模仿，却难以逾越的时代标杆之作。\n八度空间[2002.07.18]歌曲可以拥有与电影媲美的叙事性吗？在短短四分钟左右的歌曲里，43 分钟的专辑《八度空间》中，周杰伦用旺盛的创作力和狂想尝试构建出这样的“空间”。“八度空间”意指西方的八度音阶，在看似局限的音乐空间中，周杰伦用他平时从电影和 MV 得来的灵感，给每首歌曲赋予了情节，打造没有维度限制的音乐异想世界。\n在发行第三张专辑《八度空间》之前，周杰伦已经在音乐市场红出了一片天地，他在《八度空间》中大量使用前两张专辑成功的公式，曲目选用的音乐手法与《范特西》十分类似，而这一时期的周杰伦对于旋律、题材以及各类曲风元素的驾驭也更加炉火纯青。虽是爆红后的又一张专辑，但他依旧以创作者的身份在专辑创作中占了大量篇幅，包揽每首歌曲的作曲和制作，并搭档方文山、许世昌等词人在主题上进行了又一轮自我探索。“爷爷泡的茶，有一种味道叫做家”，这句话反复出现在《爷爷泡的茶》中，将视角从“茶”切到“家”，穿插着中国历史典故，“爷爷说的话”似乎在耳边回响。闽南语的《火车叨位去》则搭载了他的寻根之旅，如此强的乡土意识在此之前从未出现过，对比周杰伦后期的专辑主题，这些乡土情怀十分难能可贵。\n专辑开篇的《半兽人》来自《魔兽争霸III》的游戏内容，采样游戏里行军步伐与机枪的音效，管弦乐与说唱同频率燃起“兽族”之魂，刻下了那个年代特有的印记。主打曲《半岛铁盒》借物抒情，以原声吉他和铙钹为主的乐器勾勒出简单而浪漫的旋律，与清新深情的《暗号》《回到过去》共同成为走入人心的“周氏”抒情经典。结合说唱、摇滚的《龙拳》，是继《娘子》《双节棍》之后的又一首染指中国风的创意作品，以中国功夫为灵感，糅合中国文化的唱词配合强有力的“宫廷式鼓点”，来势汹汹。《米兰的小铁匠》则将叙事画面从中国转移至意大利，用异国情调的中快板音符勾勒出一段东欧的童话故事。\n家庭、家乡、爱情、中国功夫、游戏故事，这些主题一一走过后，周杰伦最后落脚在了“友谊”，《最后的战役》就是为纪念他与刘畊宏之间的友谊而创作。周杰伦和方文山将兄弟情的阵地放在战场，MV 也还原出他脑中的战争场面，长达 14 分钟的微电影版 MV 预演了他未来的电影梦，而在当时，没有人这样拍 MV。为了还原他心中的故事画面，周杰伦一行专程赶到欧洲拍摄，分别在意大利、捷克和法国等国拍摄了专辑中四支单曲的 MV。\n《八度空间》总体上延续了前两张专辑中奠定的编曲基调，个人作品风格也愈加成熟，令周杰伦再度势如破竹，拿下多项大奖，缔造华语乐坛新纪录的同时，也以销量给当年饱受盗版之苦的唱片行业带来希望。而先前的“杰”出成绩，更让《八度空间》得到了主流流行乐的宣发待遇，得以进一步跨出台湾，影响世界各地的听众。\n叶惠美[2003.07.31]从“以父之名”判决罪恶的杀手，到等待“晴天”的短暂爱恋，再到奏响一曲“东风破”以纪念离人……周杰伦穿梭时空之间，将复古与现代巧妙融合，创造出时下流行乐不曾有的新元素。以最敬爱的母亲姓名命名专辑，主打歌《以父之名》又与之诙谐呼应，但实则其是以电影《教父》为灵感，探讨教父荣耀背后的孤独，复古的音乐钢琴辅以意大利念白，加之融入歌剧元素，塑造出的黑暗哥特曲风一度冲击着主流的流行乐，而新兴鬼才黄俊郎的词作更是锦上添花。禁毒主题的《懦夫》中，“周式”说唱搭配重金属摇滚风格，则再次突围流行乐的风格边界。方文山作词的《东风破》以唐诗宋词入歌，配上二胡与琵琶弹奏的古曲小调，缱绻的旋律扣人心弦，这一首创的中国风歌曲在流行乐领域开凿先河，至今仍是中国风歌曲难以逾越的标杆。\n七里香[2004.08.03]“溪水急着要流向海洋，浪潮却渴望重回土地。”或许是受到席慕蓉的诗集《七里香》影响，周杰伦才决定在这张专辑中选择以“说书人”的身份讲述一个个故事。对无邪童年、纯情青春的回溯，对虚伪成人世界、战争之恶的叛逃，对老人日常生活的浪漫化描述与对亲情的呼唤，在这些故事中交替出现，让整张专辑的立意显得饱满而厚重。周杰伦肆意挥洒才情，在不同曲风的混搭中将故事性填充得更加完满。《困兽之斗》阴暗的重金属旋律、《外婆》悠扬的笛声、《止战之殇》萧瑟如秋风的钢琴、《七里香》满是柔情的弦乐，契合情境又别出心裁，给人以强烈的实感。周杰伦天马行空的想象力，以及方文山等作词人精妙的笔触，让这张专辑在多年后听来，带给人的触动仍久久无法弥散。\n11月的萧邦[2005.11.01]2005 年，原本固定在夏天带来新作的周杰伦，罕见延至多愁善感的 11 月推出这张专辑。继承他崇敬的古典音乐家——波兰“钢琴诗人”萧邦的浪漫与感性，幻化为伫立于寒风中的音乐诗人“11 月的萧邦”，序幕《夜曲》飘散寒意与忧伤的前奏响起，专辑即布下浓浓的秋凉色调。\n《夜曲》虽然并非以钢琴为主旋律，但与萧邦充满浪漫色彩的同名钢琴曲体裁不谋而合。方文山动用了“嗜血”“幽冥”等充满冷调画面的词汇，逝去的爱情在心中怅然回响，呼应了这张专辑发布的季节。不止这首主打歌，整张专辑的流行架构中埋入了许多古典音乐的动机：在《蓝色风暴》格里高利咏叹调和新金属的华丽转接中，周杰伦又一次乘坐上时空穿梭的机器；《逆鳞》的硬核气息底部铺陈的是钟兴民恢弘磅礴的弦乐，颇显人性的沉重和命运的荒诞。\n专辑发行的同一年，周杰伦踏出了歌手、演员双栖发展的第一步。为首部主演的电影《头文字 D》创作的主题曲和插曲《飘移》和《一路向北》双双收录于《11月的萧邦》，无论是前者说唱嫁接凤阳花鼓副歌唱腔，还是后者在英式摇滚的首尾叠加赛车发动声采样的做法，都丰富了专辑的创意。对影像创作产生兴趣的周杰伦，在这张专辑的制作过程中亲自掌镜，拍摄了《发如雪》那支色调浓郁的 MV，与歌曲幽深古典的中国风氛围完美契合。《11月的萧邦》带给周杰伦的执导经验，以及对深厚古典音乐素养的再一次激活，某种程度上都为不久之后他首部自导自演的电影《不能说的·秘密》的诞生打下了基础。\n连续五张引领乐坛的杰作，周杰伦至此已经确立天王地位。在风格强烈，映射与狗仔队摩擦的《四面楚歌》中，其中一句“我始终还是我，谁都改变不了我”，呼应了当年在《外婆》中唱道的“我没输，不需要改变”，已经登上华语乐坛高峰的周杰伦，以此证明保持本色便足够出色。\n依然范特西[2006.09.05]急促的打字机声响拉开《夜的第七章》里侦探游戏的序幕，画面一转又来到了《千里之外》载满离别的舞榭歌台，再带着歌迷踏进《迷迭香》里的小酒馆，品尝爵士乐的悠闲与慵懒。“想像依然无限大，感觉依然说不完，音乐依然范特西。”正如第 7 张录音室专辑《依然范特西》的宣传语所说，周杰伦以专辑标题呼应着 2001 年的经典专辑《范特西》，继续用创作才华为人们带来一场流行佳宴。\n出道一年后的第二张专辑《范特西》造出轰动式成功，往后每当推出新作依然反响强烈——但这也让他在创新与突破之路上更为艰难。经历古典与流行的交织实验、说唱推进，五年后推出的《依然范特西》，便是回头将这些时日成果实践到底，也是一次他对自己写歌招式的延续性探索。延续《范特西》极强的画面感与叙事感，由黄俊郎填词的开篇序曲《夜的第七章》，能从中听到自《威廉古堡》《以父之名》和《夜曲》一脉相承的暗风格，如出一辙的说唱风格与冷峻色调，但舞台搬到了英国伦敦，演绎一出福尔摩斯式的探案剧集，而带有戏剧色彩的男女对唱、古典融合嘻哈的音乐形式，更是新颖非常。音乐主题上，《听妈妈的话》歌颂母爱，与收录于《范特西》中控诉暴力的《爸我回来了》的家庭主题相对应，也让人联想到他以母亲名字为题的第四张专辑《叶惠美》，以及其中《三年二班》与青少年对话的主题。首度尝试 Bossa Nova 风的《迷迭香》大量使用爵士和声，展现出暧昧色彩，却是献给年轻时爱跳舞的外婆的温情之作。由钢琴主奏的《退后》与运用大量弦乐的《白色风车》，同时继承了《范特西》中《开不了口》以及《11 月的肖邦》中《枫》的纯情底色。\n这张专辑则继续对中国风进行探索与突破。主打歌《千里之外》延续《东风破》式的 R&amp;B 曲风，并邀来费玉清合唱，带领这股风潮攀上新高峰，成为中国风发展一路以来绕不开的经典。嘻哈加电子乐打造《本草纲目》，继续展现解构传统文化的精妙。作为专辑结尾的《菊花台》，古风注入流行曲的流畅中，配合着管弦乐，演绎得字正腔圆。连续三首中国风作品，也印证了周杰伦在个人音乐概念上的日臻成熟。\n在那个还不重视 beat 制作者的年代，与《本草纲目》一同将 beat 做得尤为出彩的，还有《红模仿》。周杰伦在其中总结自己的“中国风”心路历程，给模仿他的后辈们唱出忠告，“我常常在想 &#x2F; 宇宙只有一颗太阳 &#x2F; 为什么我的影子这么多这么像”，戏谑口吻讽刺乐坛走不出的“周杰伦现象”。周杰伦在影坛的探索也使得他对镜头产生了浓厚兴趣，专辑 10 首歌曲的音乐视频均由他本人导演，展现了他在影视方面的才华，也为他之后执导电影长片打下了坚实基础。作为周杰伦在阿尔发时代的最后一张专辑，这既是结束，也是开始，他仍在继续用源源不断的灵感继续带给人们惊喜。\n我很忙[2007.11.02]《我很忙》是周杰伦经亲自担纲作曲与监制，并由他组建的杰威尔唱片公司发行的首张专辑。以“西部复古”的影像灵感进行了专辑的概念创作，词作由周杰伦与老搭挡方文山、黄俊郎共同书写，掀起了那年的西部牛仔风。甜美流行、阳光励志、中国古风与美国乡村，周杰伦在众多风格间来回跳跃，上演十分写意的“我很忙”，并以此斩获第 19 届台湾金曲奖最佳国语专辑奖。《青花瓷》的古典意象和中国传统乐器编织出熟悉的中国风，成为当年的年度主打。《彩虹》的旋律来自电影《不能说的秘密》的插曲《First Kiss》，求而不得的苦涩心事蔓延至许多听者的数个年头。不过还好还好，俏皮快速的《牛仔很忙》，甜蜜温馨的《甜甜的》等歌曲，治愈地平衡了这张专辑的“甜咸差”，声音背后，还是那个能让你笑中带泪的杰伦。\n魔杰座[2008.10.15]辑名称《魔杰座》中的“魔”代表着他音乐创作中的奇幻与创新，而“杰座”则象征着周杰伦在华语流行音乐界的地位和影响力。这张专辑的内容涵盖了多种音乐元素，从摇滚到电子、从古典到流行，展现了周杰伦的多才多艺和不拘一格的创作风格。《稻香》通过清新的旋律与质朴的歌词传递了对家乡与简单生活的怀念，成为许多人心中的经典；《魔术先生》则是融合了周杰伦对魔术的热爱和音乐的巧妙结合，呈现出一首具有浓厚故事性的作品。\n跨时代[2010.05.18]从一个只会在录音室创作的男孩，到成长为引领华语流行乐坛的重要人物，杰伦希望自己的音乐可以永远流传，在每次迈出下一步时，可以跨越自己也跨越世代。首波主打《超人不会飞》写下周杰伦出道十年的心路历程：在大众的眼中，就该是专辑拿冠军，电影要大卖，面对这个过度八卦和批判、不易满足的时代里，就算是刀枪不入的超人，也会觉得疲惫。虽然是批判性的说唱，但诙谐口语式的歌词，在温暖的旋律下缓缓唱出，让人还是觉得杰伦拥有温和的亲近感。同名曲《跨时代》融合古典元素的重摇滚电子曲风，华美诡谲的 MV 以中世纪吸血鬼为背景，霸道说着自己的音乐，如吸血鬼般永远不老的宣言。杰伦坚持音乐与梦想的初心不曾随岁月改变，真情流露的他无论是否完美，相信都可以打动乐迷的心。\n惊叹号[2011.11.11]随着专辑同名曲《惊叹号》中乘风破浪的强音开场，周杰伦化身船长，开足马力驾“惊叹号”航船朝 2011 年驶来。正当歌迷期待这次会听到怎样的“周氏”情歌或中国风歌曲，接下来《迷魂曲》开场的电子音效却出乎所有人的意料，也难怪让彼时乐坛不断发出“周杰伦变了”的惊呼。\n电子乐成分的大幅提升可以说是《惊叹号》的最大特点，继上张专辑以同名曲《跨时代》对电子音乐及 Auto-Tune 技术小试牛刀后，周杰伦在这张专辑中开始大展拳脚，不仅于《疗伤烧肉粽》《超跑女神》加入彼时尚未席卷华语市场的 EDM 拍点，更是在《迷魂曲》和《Mine Mine》中再度以 Auto-Tune 强化人声表现力，使之成为巧妙交融国语、台语的有力武器。\n尽管《说了再见》《明明就》等情绪大开大合的“周氏”情歌，或《青花瓷》《发如雪》等标志性中国风作品在这张专辑中存在感有所减少，但深厚的古典乐素养和创作上的巧思，让周杰伦继续探索流行与古典的融合：《琴伤》大玩钢琴、电子乐、说唱、美声，呼应专辑“水手”的主题概念，重新解读了柴可夫斯基经典的《六月船歌》，还在间奏中嵌套了莫扎特的《土耳其进行曲》；《水手怕水》更是诙谐混搭爵士钢琴段落与说唱，带给人热闹缤纷的享受。\n即便放诸周杰伦整个音乐生涯，《惊叹号》的“玩心”都显得足够大胆。而不断向前看的同时，周杰伦其实也从过往的专辑中萃取新鲜的灵感：《公主病》延续了《阳光宅男》的爽朗词曲；俏皮搞怪的《水手怕水》则让人迅速联想至《牛仔很忙》；《世界未末日》以大气又充满希望感的英式摇滚风一举驱散了早期创作《世界末日》的绝望。\n从专辑发行的年份、歌曲数量皆以数字“1”指代“惊叹号”做文章，破天荒以美式漫画风格为专辑封面，再到“船舱它是我的家，大海是我嘘嘘的地方”“烧肉粽，如果你想吃不需要等到端午节”这些充满童趣任性的歌词，我们仿佛能看到不甘循规蹈矩的周杰伦穿着水手服、拿着望远镜，狡黠眨眼的模样。而如今，“变了”的惊呼早已平息，再次细听《惊叹号》收录的十一首歌曲才明白，周杰伦创作生涯的这次掌舵急转并非迷航，而是望见新大陆的一次惊叹和探索。\n十二新作[2012.12.28]或许是前作的电音尝试过于大胆且突然，又或是标志性中国风和抒情歌的缺失让熟悉周杰伦的人一时之间难以释怀，《惊叹号》的发行给周杰伦带来了极大的市场争议和评价。而在出道第 12 年的第 12 个月，周杰伦用“12”这一象征“圆满”的数字，推出《十二新作》，既是成全自己和乐迷的一次圆满，也为自己“一年一专”的音乐事业画上一个分号。\n为了完成这张充满仪式感的专辑，周杰伦跑去苏格兰，换上一头金发，一身中世纪骑士打扮，在当地完成 MV 的拍摄，并将看到的景象分享给方文山，两人在你来我往的通话中将海鸥、风笛、中世纪城堡写进歌里，完成了专辑中歌曲《明明就》的创作，这首歌正是以苏格兰的凄美景色为引，表现身处地球两端的恋人无法触碰而输给距离的挣扎与无奈。\n同样的悲欢离合，从中世纪古堡飘回清朝，《红尘客栈》以古筝与巴乌为辅奏讲述侠客美人故事，周杰伦罕见地在此类作品中以钢琴作为主角，更是继 2006 年《依然范特西》的《千里之外》后再次被选为首波主打的中国风歌曲。专辑中最跳 tone 的讽喻小品《公公偏头痛》，亦是脍炙人口的中西合璧。\n吸取《惊叹号》的教训，贯穿前作的电子乐在《十二新作》中迅速收紧，仅在开篇的《四季列车》和《手语》中有所体现，铜管乐器混搭电音声响、人声 Auto-Tune 演唱仿佛是周杰伦有意设的一个幌子，但前者酣畅淋漓的快节奏嘻哈、后者深情婉转的 R&amp;B 抒情，仍保留着典型的周氏内核。而继续往下听，歌迷们期盼已久的“周氏”情歌其实在这张专辑里已然成了不可忽视的主角。尽管承袭他一贯的柔情中板，流畅的钢琴与弦乐让四周空气都满溢着甜蜜和温情，但他也想出办法让人耳目一新：《傻笑》邀来师妹袁咏琳深情对唱，《比较大的大提琴》与南拳妈妈成员杨瑞代、梁心颐合唱，大玩流行乐圈少见的大量爵士乐元素，这是自 2005 年的《珊瑚海》后再次于专辑中加入合唱作品。\n除此之外，专辑的填词多半依然交由方文山操刀，但也有两首歌曲交给新生代作词人，展现出截然不同的味道：《爱你没差》由写出耳熟能详的《花海》的词作者黄凌嘉执笔；励志金曲《梦想启动》则由马拉松运动员林义杰填词、国际钢琴巨星郎朗贡献核心钢琴旋律所共谱，这首歌还被棒球手陈伟殷作为伤后复出球赛的进场指定曲，创下美国职棒大联盟史上首度以华语歌曲作为开场曲的纪录。\n自这张专辑后，周杰伦放慢了音乐创作的脚步。尽管《十二新作》最终只获得金曲奖入围，在许多人看来或许是当年的金曲遗珠，但“十二新作”之名不只代表这张专辑有十二首全新创作，更是从概念、创作等各方面，在熟悉的杰伦风格中寻找不同以往的新意。\n哎呦，不错哦[2014.12.26]周杰伦之所以能成为华语乐坛十多年来的标杆，除了独一无二的个人风格对流行音乐审美的革新之外，另一个重要的原因就是稳定且多产的发片频率。曾经很长一段时间里，他都保持着一年一专的惯例向歌迷致以感谢和诚意，但其中也有破例的时候。2010 年的《跨时代》带着出道十周年的重要意义酝酿两年，而在周杰伦处于人生重要转折期的 2014 年，第 13 张专辑《哎呦，不错哦》也用两年的创作时间，仔仔细细归纳了他生活、事业和人生态度的种种跨越。\n除了演艺事业之外，对周杰伦来说人生中最重要的时刻之一莫过于 2014 年与妻子昆凌步入婚姻殿堂的那一天。然而，与浪漫而庄严的婚礼一同进入周杰伦生活中的这张新专辑，却充满了令人意外的轻快生活感。周董招牌口头禅命名的标题给专辑定下了轻松幽默的基调，而那几年闯荡好莱坞和百老汇的经验，令他萌发出创造一个“喜剧演员”的全新音乐人设。首支主打歌《鞋子特大号》吸纳了从喜剧泰斗卓别林身上得到的灵感，以谐仿默片配乐的爵士乐风格搭配周杰伦喜感十足的唱腔，给人以耳目一新的听感。而从《阳光宅男》《公主病》等作品中延续下来的那种朴实而热血的生活激情，也在和好友杨瑞代合作的《我要夏天》中再一次得到激活。两个已过而立之年的大男人，依旧在夏日骄阳般的摇滚节奏中，诠释男孩的热情和幽默。\n有别于早期的《简单爱》《晴天》等满眼都是少年热恋和青春往事的爱情歌曲，这张专辑里的《算什么男人》和《听爸爸的话》选择用更内敛的抒情吐露男人内心的情感波澜，“周氏”情歌也随着周杰伦年龄的成长和人生阅历的丰富变得愈发成熟。而原本由女歌手魏如昀在 2013 年方文山执导的同名电影中演唱的主题曲《听见下雨的声音》，在时隔一年后收入了这张专辑的尾声，带着诚意与敬意，周杰伦尝试用他充满力量感的演绎方式，赋予原版中女性那大雨滂沱般的情感新的生命力。\n周杰伦的床边故事[2016.06.24]从青涩少年成长为成熟男人，一路走来，周杰伦一直用他最擅长的方式诠释他最珍视的亲情与爱情。而如今已是一家之主的他，又因女儿海瑟薇的降生多了一层父亲身份。从前面对镜头耍酷卖萌，现在他已经无条件地将自己童真烂漫的一面留给女儿。初为人父的心情，从周杰伦的第 14 张专辑《周杰伦的床边故事》的标题就可略知一二。\n“女儿是爸爸前世的情人”，这说法虽然俗套，却也足以形容周杰伦的爱女之情。女儿四个月大即兴弹奏的一段旋律，被他当作《前世情人》的动机，编织出一套浪漫幻想：这段旋律来自女儿前世的记忆，而来到这一世后，她依然不忘弹给他听。这份父爱的满足和深情，应证着周杰伦此前从未曾有过的生活状态。而过去在《麦芽糖》等歌曲中展露的天真和童心，来到这一张专辑中也变得格外贴切真实。《床边故事》宛如童趣探险版的《威廉古堡》，在魔幻的氛围中拉开一场暗夜童心大冒险。古典与电子音符华丽并行，书写成一本浓浓周氏风格的另类“床边故事”。\n虽已为人父，但有关爱情的想象，却依然没有离开周杰伦的音乐世界。标准的“周氏”甜歌《告白气球》用轻松写意的姿态，挥洒法式浪漫情怀，犹如置身阳光明媚的塞纳河畔。继《珊瑚海》之后，《不该》成为周杰伦另一首大热的男女对唱情歌，抒情的摇滚底蕴搭配琅琅上口的歌词，使之成为后期的“周氏”情歌中颇具传唱度的佳作。\n继承曾经《半兽人》的电玩精神，为《英雄联盟》创作的主题曲《英雄》开启了周杰伦另一篇热血篇章，令人感受到周杰伦依旧保有的一颗赤子少年心。由他亲手把控编曲的《土耳其冰淇淋》中同样充分展露着他的玩心，在亚细亚风情的主基调之上，蓝调、爵士、电子乐元素色彩纷呈，每个段落自成一体，透过听觉联动却又形成一种奇妙的和谐。《周杰伦的床边故事》是变与不变的交集，身份和心境转变的同时，周杰伦在音乐上创新探索的精神与活力，却始终如一。\n展示正面侧面背面\n","categories":["音乐"],"tags":["周杰伦","黑胶"]},{"title":"iPhone 12 Pro Max（A14，2020年）和 iPhone 12 mini（A14，2020年）","url":"/zh-CN/0745e9b09803/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  iPhone 12 Pro Max\n  自我再飞跃。\n\n\n\n  \n\n\n\n  iPhone 12 mini\n  升维大提速。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPhone"]},{"title":"罪恶黑名单 第八季 第一集 罗诺克","url":"/zh-CN/3624703d451a/","content":"\n剧情介绍　　雷德指示特工小组调查罗阿诺克，这是一名擅长策划复杂撤离行动的传奇罪犯。与此同时，莉兹与母亲卡塔莉娜·罗斯托娃密谋制定一个秘密计划。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"31岁生日快乐","url":"/zh-CN/8acba439516e/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  生日快乐\n\n\n\n  \n    \n  \n\n\n\n","categories":["纪念日"],"tags":["日常","生日"]},{"title":"MacBook Air 13 英寸（M1，2020年）、MacBook Pro 13 英寸（M1，2020年）和 Mac mini（M1，2020年）","url":"/zh-CN/9fdddcb07933/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  MacBook Air\n  实力，来得轻巧。\n\n\n\n  \n\n\n\n  MacBook Pro\n  一 Pro 到位。\n\n\n\n  \n\n\n\n  Mac mini\n  平添内力，更霸气。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"曼达洛人 第二季 第四集 围困","url":"/zh-CN/907290c1ac2c/","content":"\n剧情介绍　　曼达洛人重新与旧日盟友合作，执行新的任务。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"罪恶黑名单 第八季 第二集 卡特琳娜·罗斯托娃（二）","url":"/zh-CN/c10d88bd7e3f/","content":"\n剧情介绍　　当莉兹向一个线人逼问答案时，雷德和特工小组不得不应对她行动带来的影响。紧张局势不断升级，一项激烈的行动随之展开，这将永远改变雷德和莉兹的关系。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"小雪","url":"/zh-CN/b44c75fa8786/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小雪\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小雪"]},{"title":"曼达洛人 第二季 第五集 绝地","url":"/zh-CN/4e01d88679e4/","content":"\n剧情介绍　　曼达洛人来到一个由残酷的执政官统治的世界，这名执政官树立了一个强大的敌人。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"曼达洛人 第二季 第六集 不幸","url":"/zh-CN/3a548a88880c/","content":"\n剧情介绍　　曼达洛人和孩子前往一处古老的地点。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"大雪","url":"/zh-CN/0707a3890785/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大雪\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大雪"]},{"title":"HomePod mini（2020年）","url":"/zh-CN/cb19daafbd99/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  HomePod mini\n  小宇宙爆发。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","HomePod"]},{"title":"Taylor Swift evermore（deluxe version）","url":"/zh-CN/8f36bdaeb925/","content":"\n专辑介绍在全球陷入瘫痪的疫情期间，出人意料地推出足以重新定义音乐生涯的专辑，无疑叫人钦佩；但在短短五个月后就又做了一次同样的事，Taylor Swift 借此举大胆展现出的自信心与专注力，可以说是令人自惭形秽。和《folklore》一样，Taylor Swift 与 Aaron Dessner、Jack Antonoff 与 Justin Vernon 合作完成了《evermore》。在充分利用家庭录音室舒适氛围的情况下，他们写出更为坦诚的歌词，采用更加简单的编曲，使得歌曲既轻松温馨，又有层次丰富的叙事。\n新专辑的嘉宾阵容更加强大：HAIM 出现在《no body, no crime》里，Este Haim 似乎成了一场小镇谋杀案的核心人物；Dessner 的乐队队友在《coney island》中出场，他们没有偏离专辑的整体节奏，反而顺利地将自己代入歌曲的情绪。（更何况，如果把打击乐贯穿始终的《long story short》放进过去十年间任何一张 The National 的专辑，都不会显得违和。）此外，《’tis the damn season》是一首讲述“回家过节”的哀怨情歌，触动了我们这一年的纷乱心绪。如果说《folklore》让大部分人惊叹的点在于 Swift 在特殊时期解锁了新风格，那么这张《evermore》唯一真正令人意外的其实是它发行的时机。而且，大家因《folklore》而建立起的期待并未落空，因为《evermore》延续了上一张专辑的魅力。《evermore》并非特殊情况催生的新奇作品，而是 Taylor Swift 碰巧会做、而且做得很好的一件事。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","Taylor Swift"]},{"title":"AirPods Max（H1，2020年）","url":"/zh-CN/c65f9e318a13/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  AirPods Max\n  将音质提升到新境界。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","AirPods"]},{"title":"神奇女侠1984","url":"/zh-CN/44015c468560/","content":"\n剧情介绍　　当危机降临时，她是力大无穷、魅力四射的神奇女侠，当岁月静好之际，她又是集知性和美丽于一身的博物馆员，她就是神奇女侠戴安娜·普林斯（盖尔·加朵 Gal Gadot 饰）。戴安娜和同事们偶然发现一个神奇的水晶，据说水晶能够帮助他们实现一个愿望。半信半疑的戴安娜默默许愿，谁曾想因故去世的男友竟然真得回还人间。眼见如此人间奇迹，戴安娜貌不惊人的同事芭芭拉·密涅瓦（克里斯汀·韦格 Kristen Wiig 饰）也许下变美的愿望，谁知却化身力大无穷的豹女。\n　　然而，更大危机紧随私欲之后……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"曼达洛人 第二季 第八集 营救","url":"/zh-CN/99460bcb2817/","content":"\n剧情介绍　　曼达洛人和他的盟友尝试一场大胆的营救行动。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"冬至","url":"/zh-CN/15b79b50a19a/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  冬至\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","冬至"]},{"title":"舞力全开","url":"/zh-CN/4f9cd846a90d/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"元旦","url":"/zh-CN/9b982f965373/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  元旦快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","元旦"]},{"title":"小寒","url":"/zh-CN/4a7062c8ba09/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小寒\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小寒"]},{"title":"YOASOBI THE BOOK","url":"/zh-CN/da7a817b76f3/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","YOASOBI"]},{"title":"AirPods Pro 牛年限量款","url":"/zh-CN/80787ff9277f/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","AirPods"]},{"title":"马力欧网球 王牌","url":"/zh-CN/b4611f56e52c/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"蝙蝠女侠 第二季 第一集 凯特·凯恩到底在哪？","url":"/zh-CN/c935570b4545/","content":"\n剧情介绍　　一名25岁的无家可归者瑞安·怀尔德偶然发现了凯特的蝙蝠战衣。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"大寒","url":"/zh-CN/804da8b16b8f/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大寒\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大寒"]},{"title":"罪恶黑名单 第八季 第三集 16 盎司","url":"/zh-CN/5ccfe0e29c09/","content":"\n剧情介绍　　被背叛激怒的伊丽莎白·基恩决心向雷丁顿复仇。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"蝙蝠女侠 第二季 第二集 犯罪前科","url":"/zh-CN/051d8b001154/","content":"\n剧情介绍　　在短暂穿上蝙蝠装备后，瑞安·怀尔德再次回到自己的日常生活中，面对着生活中的各种挑战。与此同时，爱丽丝制定了一个新的邪恶计划，试图引起哥谭市和萨菲雅的注意。凯特依然失踪，城市陷入暴动，卢克和玛丽急于找到替代者。在紧急关头，瑞安再次穿上战衣，首次与爱丽丝面对面。与此同时，在乌鸦总部，索菲和凯恩指挥官试图揭开谁可能对凯特怀有仇恨。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第八季 第四集 伊丽莎白·基恩","url":"/zh-CN/b5603204113c/","content":"\n剧情介绍　　当雷德和特工小组寻找莉兹时，莉兹启动了一项新计划，却引发了灾难性的后果。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"蝙蝠女侠 第二季 第三集 重装上阵","url":"/zh-CN/1bbaccc6bbe2/","content":"\n剧情介绍　　随着瑞安·怀尔德继续证明自己作为蝙蝠女侠的能力，她面临着每个超级英雄都会遇到的挑战——过着双重生活。与此同时，维克多·萨兹正在哥谭街头肆意杀戮，而凯恩指挥官则指挥乌鸦小队试图阻止蛇毒在哥谭市的蔓延。萨菲雅注意到了爱丽丝的行为，而索菲则发现自己身处意想不到的境地。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"立春","url":"/zh-CN/6127032f7948/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立春\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立春"]},{"title":"罪恶黑名单 第八季 第五集 弗里堡信任团","url":"/zh-CN/a5d89f4081e0/","content":"\n剧情介绍　　特工小组调查了一个专门从其他罪犯手中抢劫的银行劫匪组织。同时，一起旧的黑名单案件再次浮出水面。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"除夕","url":"/zh-CN/de7687800f5d/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  除夕快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","除夕"]},{"title":"黑闪电 第四季 第一集 重建之书：第一章：鱼池之殃","url":"/zh-CN/4bb74c2b011e/","content":"\n剧情介绍　　在布雷尼亚克试图阻止莱克斯后奄奄一息时，女超人和团队冲上前救杰斐逊·皮尔斯仍在为长期朋友、侦探亨德森的去世而哀悼。与此同时，甘比面临一个有趣的机会。最后，琳恩和杰斐逊依然无法达成共识。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第八季 第六集 威尔斯通公司","url":"/zh-CN/b4d5887fca97/","content":"\n剧情介绍　　雷德和登贝不惜一切代价履行一位挚友的临终遗愿。阿拉姆伪装成翻译员潜入一家为罪犯提供服务的公司，而帕克则帮助了一位陷入困境的朋友。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"蝙蝠女侠 第二季 第四集 寻人启事","url":"/zh-CN/b3ecb764aa52/","content":"\n剧情介绍　　在蝙蝠女侠努力阻止蛇毒在哥谭市的蔓延时，一次偶然的遭遇迫使她回顾自己痛苦的过去。瑞安·怀尔德在新角色的驱使下，决心确保像她一样的人不会被忽视。与此同时，凯特最亲近的人得到了一些有力的证据，证明她仍然活着，这促使了意外的联盟和背叛。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"唐人街探案3","url":"/zh-CN/0088983b8984/","content":"\n剧情介绍　　为了争夺东京新唐人街的开发权，东南亚帮派与日本黑帮组织黑龙会纷争不断。为了避免冲突升级，合作共赢，东南亚商会会长苏察维邀请黑龙会头目渡边胜（三浦友和 饰）谈判。谈判地点设在四面环水的日式茶室，室内只有双方头目而已。谁知谈判开始没多久，室内就传来惨叫声。众人涌入后发现，苏察维被打碎的屏风玻璃杀害，而躺在一旁的渡边胜则满手鲜血。突发意外将双方敌意再度拉至顶点，为了证明清白，渡边通过侦探野田昊（妻木夫聪 饰）找来了秦风（刘昊然 饰）和唐仁（王宝强 饰），试图揭开密实杀人案的真相。\n　　危机四伏的东京街头，这三个绝命侦探抽丝剥茧发现了令人难以置信的事实……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"曼达洛人 第二季 第七集 忠义之士","url":"/zh-CN/dd03c70bca68/","content":"\n剧情介绍　　为了对抗帝国，曼达洛人需要一位旧敌的帮助。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"黑闪电 第四季 第二集 重建之书：第二章：不堪折损","url":"/zh-CN/f0fda8bdbc42/","content":"\n剧情介绍　　100帮和科布拉卡特尔之间的战争愈演愈烈。与此同时，琳恩继续担心杰斐逊的情况，而珍妮弗对学校里一个新男生产生了兴趣。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"雨水","url":"/zh-CN/258265ef5192/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  雨水\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","雨水"]},{"title":"罪恶黑名单 第八季 第七集 化学玛丽","url":"/zh-CN/ea32b326b8b7/","content":"\n剧情介绍　　特工小组必须争分夺秒阻止两名黑名单人物带来的双重威胁。库珀则向一位国会议员寻求情报。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"蝙蝠女侠 第二季 第五集 染血油画","url":"/zh-CN/fd017e095911/","content":"\n剧情介绍　　蝙蝠女侠被凯恩指挥官和摩尔探员找上，希望她偷取一件著名的艺术品，这件艺术品揭示了通往科里亚纳的道路——以及凯特的下落。尽管瑞安有些顾虑，卢克和玛丽说服她接受这个任务，导致蝙蝠团队内部的紧张局势升级。与此同时，爱丽丝在试图完成萨菲雅邪恶要求的过程中，慢慢发现自己可能并不完全记得她在科里亚纳的经历。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"黑闪电 第四季 第三集 重建之书：第三章：十倍奉还","url":"/zh-CN/e70eec59a444/","content":"\n剧情介绍　　杰斐逊在一次令人沮丧的治疗过程中感到更加迷茫。与此同时，安妮莎继续照顾仍处于昏迷状态的格蕾丝。最后，琳恩取得了突破性进展。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"元宵节","url":"/zh-CN/a219135f340f/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  元宵节快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","元宵节"]},{"title":"罪恶黑名单 第八季 第八集 奥格登·格林利","url":"/zh-CN/00dada5ba23b/","content":"\n剧情介绍　　特工小组调查了一起国防承包商疑似失踪的案件。库珀收到了一份意想不到的提议，而雷德则建立了一个新联系。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"蝙蝠女侠 第二季 第六集 拒绝救治","url":"/zh-CN/c9e799805319/","content":"\n剧情介绍　　随着瑞安·怀尔德的氪石伤口变得越来越严重，这影响了蝙蝠女侠保护哥谭的能力。爱丽丝与一位科里亚纳居民的重逢带来了意想不到的复杂局面。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"黑闪电 第四季 第四集 重建之书：第四章：黑鸟诞生","url":"/zh-CN/de30028a3cfc/","content":"\n剧情介绍　　杰斐逊拜访了托拜厄斯，并警告他远离自己的家人。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第七季 第一集 全都好","url":"/zh-CN/3b7e24591e41/","content":"\n剧情介绍　　当拯救巴里速度的实验适得其反时，纳什·威尔斯寻找拯救闪电侠的方法，并提出了一个危险的计划。与此同时，艾瑞斯在镜宇宙中惊奇地意识到，塞西尔与罗莎·狄龙对峙。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"惊蛰","url":"/zh-CN/65af671c6583/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  惊蛰\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","惊蛰"]},{"title":"罪恶黑名单 第八季 第九集 影子替身","url":"/zh-CN/22caf92e9c73/","content":"\n剧情介绍　　特工小组遇到一个邪恶的企业，该企业为罪犯提供替身，这让他们措手不及。雷德急忙采取行动，试图应对莉兹的大胆举动。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"黑闪电 第四季 第五集 摧毁之书：第一章：收拾残局","url":"/zh-CN/742205bf45a6/","content":"\n剧情介绍　　甘比支持黑闪电执行一项特殊任务。与此同时，格蕾丝试图说服安妮莎放下戒备，敞开心扉。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第七季 第二集 思维的速度","url":"/zh-CN/1e3e59482322/","content":"\n剧情介绍　　当巴里突然获得快速思维的力量时，他试图利用他的新天赋来拯救艾瑞斯。虽然巴里对他的新能力感到兴奋，但西斯科对信任它犹豫不决。与此同时，伊娃必须面对一个令人震惊的事实。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第八季 第十集 莱肯·佩里洛斯医生（一）","url":"/zh-CN/2cacd1addad4/","content":"\n剧情介绍　　当汤森派出一名使用非常规方法拷问受害者的酷刑专家时，雷德和登贝陷入了危险之中。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"阿凡达","url":"/zh-CN/ca6518d813f5/","content":"\n剧情介绍　　战斗中负伤而下身瘫痪的前海军战士杰克·萨利（萨姆·沃辛顿 Sam Worthington 饰）决定替死去的同胞哥哥来到潘多拉星操纵格蕾丝博士（西格妮·韦弗 Sigourney Weaver 饰）用人类基因与当地纳美部族基因结合创造出的 “阿凡达” 混血生物。杰克的目的是打入纳美部落，外交说服他们自愿离开世代居住的家园，从而SecFor公司可砍伐殆尽该地区的原始森林，开采地下昂贵的“不可得”矿。在探索潘多拉星的过程中，杰克遇到了纳美部落的公主娜蒂瑞（佐伊·索尔达娜 Zoe Saldana 饰），向她学习了纳美人的生存技能与对待自然的态度。与此同时，SecFor公司的经理和军方代表上校迈尔斯（史蒂芬·朗 Stephen Lang 饰）逐渐丧失耐心，决定诉诸武力驱赶纳美人……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"蝙蝠女侠 第二季 第七集 悬崖勒马","url":"/zh-CN/78854556e4ba/","content":"\n剧情介绍　　随着瑞安的状况恶化，她开始质疑蝙蝠女侠的“不能杀戮”准则，因为她意识到复仇母亲的机会正在逐渐失去。塔蒂亚娜为爱丽丝填补了她在科里亚纳的过去和与海洋的历史的空白。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第七季 第三集 母亲","url":"/zh-CN/6316ba3f294a/","content":"\n剧情介绍　　随着伊娃变得越来越强大，巴里和团队必须找到阻止她的方法。当一位老朋友——苏·迪尔邦冒着生命危险提供帮助时，他们感到震惊。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"黑闪电 第四季 第六集 摧毁之书：第二章：忒修斯之船","url":"/zh-CN/098ccb0fc226/","content":"\n剧情介绍　　杰斐逊与琳恩的关系越过了一条界限。安妮莎分享了一些重要的消息。托拜厄斯做出了一个出人意料的举动。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"春分","url":"/zh-CN/341380836ef5/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  春分\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","春分"]},{"title":"蝙蝠女侠 第二季 第八集 历经万难","url":"/zh-CN/2f8c33f68da9/","content":"\n剧情介绍　　蝙蝠女侠的能力遭遇前所未有的考验，而爱丽丝继续寻找凯特。索菲和雅各布将目光投向科里亚纳，卢克和玛丽则应对一位意想不到的来访者。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第八季 第十一集 基德船长","url":"/zh-CN/6ac69623736c/","content":"\n剧情介绍　　特工小组试图通过寻找一位“藏宝人”来阻止一起绑架案，这位藏宝人利用地理缓存技术隐藏非法物品，并促进不同犯罪派系之间的交易。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"闪电侠 第七季 第四集 中心城强大","url":"/zh-CN/2731e3ff3796/","content":"\n剧情介绍　　闪电侠必须应对阿布拉·卡达布拉突然回到中心城。反派带着复仇和成绩回来了。与此同时，阿莱格拉处理了一个棘手的情况，凯特琳怀疑弗罗斯特出了什么问题。艾瑞斯被迫审视她过去的黑暗时刻。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"哥斯拉大战金刚","url":"/zh-CN/c7398107665f/","content":"\n剧情介绍　　这两位宛如神衹一般强大的对手于一场壮观的战争中相遇，彼时世界命运正悬于一线。为了找到真正的家园，金刚与他的保护者们踏上了一次艰难的旅程。与他们一道前行的还有一个年轻的孤儿女孩——吉雅，这个女孩与金刚之间存在着一种独特而强大的紧密联系。但意想不到的是，他们在前行的航道上与愤怒的哥斯拉狭路相逢，也由此在全球引起了一系列破坏。一股无形的力量造成了这两只巨兽之间的巨大冲突，深藏在地心深处的奥秘也由此揭开。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"蝙蝠女侠 第二季 第九集 首要规则","url":"/zh-CN/a5c3926f4536/","content":"\n剧情介绍　　蝙蝠女侠与哥谭市最大的敌人展开对抗，而新的信息迫使凯特最亲近的人做出一些艰难的决定。瑞安对安吉丽克的感情使她与卢克和玛丽的合作关系面临风险，同时，爱丽丝则踏上了一条扭曲的回忆之路。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第七季 第五集 畏惧我","url":"/zh-CN/50855ab73279/","content":"\n剧情介绍　　当一个强大的新反派Psych引导并放大每个人的恐惧以对中心城市造成严重破坏时，巴里意识到，在塞西尔的帮助下，他必须面对自己最大的恐惧才能击败这个新的威胁。与此同时，当州长市后勤委员会的克里斯汀·克莱默（Kristen Kramer）来到CCPD访问时，乔感到惊讶。艾瑞斯警告她的父亲要更深入地挖掘克里斯汀为什么真的在那里。凯特琳和弗罗斯特争论如何过他们的生活。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"女超人 第六季 第一集 浴火重生","url":"/zh-CN/5990737c63b8/","content":"\n剧情介绍　　在布雷尼亚克试图阻止莱克斯后奄奄一息时，女超人和团队冲上前救他，并与加美尼展开了一场史诗般的战斗。击败利维坦后，女超人将注意力转向莱克斯，发现他利用黑曜石平台洗脑了全球一半的人，让他们无条件地爱他并追随他，无论他做出多少可怕的事情。莉娜意识到这让莱克斯变得更加危险，于是召集了整个团队——亚历克斯、琼恩、梦者、凯莉和布雷尼亚克——来帮助她。然而，女超人意识到，唯一能够真正阻止莱克斯的方式，就是做出自我牺牲。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第八季 第十二集 拉基丁","url":"/zh-CN/10facf674fc9/","content":"\n剧情介绍　　特工小组决心查明美国政府中的一名俄罗斯间谍，这使得库珀和雷丁顿陷入了越来越危险的境地。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"清明","url":"/zh-CN/d32fe502d949/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  清明\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","清明"]},{"title":"闪电侠 第七季 第六集 那个九十年代","url":"/zh-CN/58411acc1ceb/","content":"\n剧情介绍　　西斯科和切斯特回到过去，被困在1998年，一遍又一遍地重复同一天。回家的关键是在切斯特童年的家，但他拒绝探望。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"女超人 第六季 第二集 少数女强人","url":"/zh-CN/3981bee36d4e/","content":"\n剧情介绍　　随着与莱克斯的对抗升级，莉娜必须决定为了阻止她的兄弟，她愿意走多远。与此同时，女超人和团队面临着前所未有的挑战，这个挑战将亚历克斯逼到了崩溃的边缘。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"Taylor Swift Fearless（Taylor's Version）","url":"/zh-CN/03127ce1811e/","content":"\n专辑介绍2019 年，Taylor Swift 与之前所属的唱片公司 Big Machine 陷入母带版权纠纷，由此她决定重新录制前六张专辑，以重掌对旧作的控制权，而打头阵的就是于 2008 年发行的第二张创作专辑《Fearless》。Taylor Swift 凭借此张专辑在乡村流行音乐领域取得巨大成功，拿下第 52 届格莱美“年度专辑”和“最佳乡村专辑”奖，并创下当时最年轻得奖者纪录。而今，她再次与《folklore》《evermore》 的制作人 Aaron Dessner、Jack Antonoff 携手，用成熟、坚定的歌声诠释二十岁的勇往直前。专辑加入旧版未收录的六首新歌，Taylor Swift 心中的《Fearless》完整版本终于得以问世。\n《Fearless (Taylor’s Version)》在最大程度保留旧版原貌的基础上，无论是专辑制作上的把控，还是 Taylor Swift 嗓音的表现力，都更具力量感。将同名曲《Fearless》提到专辑开篇，某种程度上体现了 Taylor Swift 抛开纷扰旧事，一往无前的无悔无惧。班卓琴的演奏却轻易拨开了我们的怀旧思绪，大热单曲《Love Story》和《You Belong With Me》，让关于青涩爱恋的回忆又一次变得清晰而鲜活。六首此前未公开过的作品被命名为“From The Vault”系列，同样创作于 Swift 的青春时期：Maren Morris 为《You All Over Me》贡献美妙和声，澳洲民谣一哥 Keith Urban 则与 Swift 合唱《That’s When》，《Mr. Perfectly Fine》极尽优美的旋律和 Swift 标志性的过门后副歌转调，将时光的指针悄悄拨回 13 年前。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","Taylor Swift"]},{"title":"蝙蝠女侠 第二季 第十集 戴罪立功","url":"/zh-CN/4ff4c0806742/","content":"\n剧情介绍　　随着蝙蝠女侠将更多精力集中在打击黑面具上，一位新敌人出现，将蝙蝠团队的注意力转移到哥谭市的一个令人不安的问题上。雅各布在不断被过去的错误困扰之下，走上了一条危险的道路，试图消除这些错误。爱丽丝和朱莉娅发现她们有一个共同的敌人。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"黑闪电 第四季 第七集 恐惧杀手","url":"/zh-CN/1be16345d490/","content":"\n剧情介绍　　在试图埋葬自己性格中黑暗而致命的“恐惧杀手”一面后，卡利尔·佩恩选择远离他熟悉和深爱的所有人，来到一座名为阿卡西克谷的新城市寻求内心的平静……但对于像“恐惧杀手”这样拥有复杂过去的人来说，平静从来都不是那么容易得到的。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第七季 第七集 成长的痛苦","url":"/zh-CN/6f44417de32c/","content":"\n剧情介绍　　当一个神秘的冰系敌人陷害弗罗斯特犯下残酷的罪行时，她必须想办法洗清自己的名字;巴里和艾瑞斯有一个惊喜的房客，乔继续与克里斯汀克莱默打交道。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"女超人 第六季 第三集 魅影危机","url":"/zh-CN/2579fc2e76f2/","content":"\n剧情介绍　　女超人结交了新的盟友。莉娜和莱克斯展开了激烈的斗争，争夺卢瑟公司（Luthor Corp）的控制权。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第八季 第十三集 安","url":"/zh-CN/a8466f87db06/","content":"\n剧情介绍　　雷德在美国乡村的一位朋友家里享受了一次宁静的拜访。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"蝙蝠女侠 第二季 第十一集 玩命关头","url":"/zh-CN/8be7812d8e8a/","content":"\n剧情介绍　　蝙蝠女侠和乌鸦小队各自紧追虚假面具社团的线索，但她们的努力发生冲突，紧张局势升级。爱丽丝寻求谜语人的帮助，而索菲和瑞安则找到了某些共同点。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"谷雨","url":"/zh-CN/25d2a40b3a75/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  谷雨\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","谷雨"]},{"title":"黑闪电 第四季 第八集 摧毁之书：第三章：分崩离析","url":"/zh-CN/77bcfdf4c9b4/","content":"\n剧情介绍　　联邦调查局拜访了杰斐逊。与此同时，安妮莎给格蕾丝带来了一个惊喜。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"Apple 特别活动","url":"/zh-CN/6aa7df628148/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  踏春而来\n\n\n\n  一点开眼\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["发布会"],"tags":["Apple","Apple Event"]},{"title":"女超人 第六季 第四集 失落之魂","url":"/zh-CN/ee5dc70210bf/","content":"\n剧情介绍　　女超人找到了逃脱幻影区的机会，但这个机会伴随着一些危险的条件。与此同时，莉娜加入超级朋友们的任务，但她对他们针对幻影怪物的行动计划产生了分歧，并开始怀疑自己是否真的准备好成为团队的一员。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"林俊杰 Like You Do","url":"/zh-CN/ebe7e547f397/","content":"\n专辑介绍有光就有暗，有白昼就有黑夜，概念双 EP 上篇《幸存者》与本篇《Like You Do》恰恰呈现为这样的对应关系。《幸存者》用弦乐和钢琴的抒情气质编写明亮温暖的人生旋律，同时交代了时空和命运的宏大背景。而当 EP 封面由黄金原野幻化为《Like You Do》的暗夜弧光，“平行时空”的另一重人生也逐渐揭开。冰冷科技感的视觉呈现，Synth-Pop、EDM、R&amp;B 构建的暗潮，以及全英文原创歌曲的首次挑战，拼合成双 EP 下篇的概念主轴——通篇以“你”为叙事主语，每首歌都反映出林俊杰“内心深处某个曾不可触及的一面”。\n林俊杰与 Apple Music 分享关于平行宇宙的畅想：上篇《幸存者》中，林俊杰扮演的角色是大家熟悉的华语歌手，而平行世界里的林俊杰却是位英文歌手，在 EP《Like You Do》发行的那一天现身。借此机会，他也想换上新的面貌，从零开始当一个乐坛新人，回归初心。大家不会怀着过往的刻板印象审视他，他无需考虑自己该做什么类型的音乐，或是歌迷喜欢什么，音乐上升为一种纯粹的乐趣。\n林俊杰告诉我们，他希望自己的音乐能够像电影一样。而在各种类型当中，科幻电影深得他的喜爱。从早期歌曲《编号 89757》《一千年以后》，到近年《圣所》《Wonderland》，科幻题材一直都是林俊杰创作中的重要元素。这次 EP 开场曲《While I Can》，以谐音方式为《Wonderland》重新填词，借此作为两个“平行时空”的交汇点。整张 EP 不避讳袒露脆弱暗面：《All In Your Mind》把内心的破碎写得分外伤神：“我面带微笑却心如死灰”（It’s smiling on my face&#x2F;but inside I’m dying here）；《Like You Do》唱着摄人心魄、让人卑微沦陷的“你的眼神”；《Heads On》则是灵魂遇见爱恋后的失速、坠落与冲撞……林俊杰试图“通过自我剖白来学习拥抱自己的不完美”。\n发行时间上最后登场的第七首歌《Bedroom》，林俊杰邀请英国歌手 Anne-Marie 共同演唱。他听到 Anne-Marie 录制的 demo 时，第一反应就是惊艳。他认为，整张由他独唱的 EP 配上这首二重唱，才呈现出最完美的状态。而邀请志趣相投的 Steve Aoki 混音《Not Tonight》，以及与 Garibay、Tushar Apte 等国际知名制作人共同打磨欧美化的电气氛围，不只为林俊杰的生涯开启了新道路，也证明他在音乐上还有诸多未实现的可能。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","林俊杰"]},{"title":"罪恶黑名单 第八季 第十四集 不幸","url":"/zh-CN/0aa5dcc1298b/","content":"\n剧情介绍　　在回顾关键转折点的过程中，重温了导致伊丽莎白·基恩与一位强大敌人结盟的步骤。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"黑闪电 第四季 第九集 摧毁之书：第四章：郁郁寡欢","url":"/zh-CN/1a72b8f146ab/","content":"\n剧情介绍　　甘比警告皮尔斯一家，一场可能的危机正在逼近。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"女超人 第六季 第五集 舞会之夜","url":"/zh-CN/657c07608b77/","content":"\n剧情介绍　　尼娅和布雷尼试图通过时间旅行回到2009年，拯救被困在幻影区的女超人。尽管布雷尼决心获取帮助女超人所需的物品，但他对保持低调非常担忧，以避免改变未来的时间线。然而，当他们的飞船在到达时发生坠毁时，年轻的卡拉·丹弗斯是第一个出现在现场的人。与此同时，一位名叫凯特·格兰特的年轻记者将目光投向了米德维尔，她怀疑这个小镇藏有一桩大新闻。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"iPhone 12（A14，紫色，2021年）和 iPhone 12 mini（A14，紫色，2021年）","url":"/zh-CN/d9ab46104602/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  iPhone 12 | iPhone 12 mini\n  紫色到位。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPhone"]},{"title":"罪恶黑名单 第八季 第十五集 俄罗斯结","url":"/zh-CN/1e12f9225c6a/","content":"\n剧情介绍　　特工小组制定了一个计划，准备盗取一台苏联时代的密码机，用以解密加密信息。汤森考验莉兹的忠诚。雷德和登贝被召唤参加一个意外的会议。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"蝙蝠女侠 第二季 第十二集 自我毁灭","url":"/zh-CN/af7fe5c3c0f5/","content":"\n剧情介绍　　瑞安面临一个艰难的决定，这个决定可能会暴露她是蝙蝠女侠，从而在蝙蝠团队内部制造裂痕。与此同时，黑面具对凯特·凯恩的计划开始展开。爱丽丝与过去的一位人物重聚，而索菲必须决定她的忠诚所在。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"黑闪电 第四季 第十集 重聚之书：第一章：真相大白","url":"/zh-CN/8077841f9066/","content":"\n剧情介绍　　黑闪电向甘比发送了一条求救信号。与此同时，琳恩深陷严重的麻烦之中。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第七季 第八集 冰霜杀手","url":"/zh-CN/8bbfffc451d4/","content":"\n剧情介绍　　由于弗罗斯特因过去的罪行而面临不公正的惩罚，凯特琳竭尽全力拯救她的妹妹。与此同时，巴里保护速度部队诺拉的努力导致了一个令人震惊的发现。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"女超人 第六季 第六集 舞会风波","url":"/zh-CN/d6402919d179/","content":"\n剧情介绍　　回忆篇的第二部分接着之前的情节展开——年轻的卡拉第一次接触到氪石，尼娅和布雷尼被入侵的外星人困住，而年轻的凯特·格兰特可能是导致超级少女永远无法脱离幻影区的关键原因。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"立夏","url":"/zh-CN/751c67cf5bb3/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立夏\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立夏"]},{"title":"罪恶黑名单 第八季 第十六集 尼古拉斯·奥本雷德","url":"/zh-CN/86b313e45133/","content":"\n剧情介绍　　莉兹和特工小组在调查N-13时跟踪新的线索，而雷德则采取行动，渗透进汤森的犯罪组织。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"蝙蝠女侠 第二季 第十三集 顺藤摸瓜","url":"/zh-CN/7889760c15b6/","content":"\n剧情介绍　　当索菲不得不面对来自她乌鸦小队新人时期的敌人时，瑞安、玛丽和卢克也被卷入了这个反派的游戏。与此同时，爱丽丝在陷入困境时局势发生了逆转，而雅各布则继续回顾过去。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"黑闪电 第四季 第十一集 重聚之书：第二章：重振旗鼓","url":"/zh-CN/afd75cd03fb9/","content":"\n剧情介绍　　杰斐逊接受了卡利尔的提议寻求帮助。与此同时，琳恩面临着可能是她人生中最重要的抉择。最后，托拜厄斯坚定地跟随自己的直觉采取行动。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"超级 马力欧派对","url":"/zh-CN/ebe490600fc8/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"闪电侠 第七季 第九集 永恒","url":"/zh-CN/d7dd06148aed/","content":"\n剧情介绍　　在一次毁灭性的背叛之后，巴里转向永恒之井寻求帮助。与此同时，艾瑞斯带领公民队走上了一条危险的道路，寻找答案，西斯科向卡米拉吐露了他最大的恐惧。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"女超人 第六季 第七集 无所畏惧","url":"/zh-CN/4eb2db108f5e/","content":"\n剧情介绍　　在超级朋友们勇敢地进入幻影区，试图带回女超人时，团队中的每个成员都被他们最深的恐惧幻象所困扰。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第八季 第十七集 伊万·斯特潘诺夫","url":"/zh-CN/21d3d2fa208d/","content":"\n剧情介绍　　雷德不惜一切代价试图营救一位老朋友，而莉兹和汤森则进行了一次审讯。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"SONY 次世代 PlayStation 上市","url":"/zh-CN/bb25d802021a/","content":"\n主机介绍PlayStation 5 国行（官方缩写：PS5国行）是索尼互动娱乐于 2021 年 05 月 15 日上市的家用电子游戏机。本机为 PlayStation 4（PS4）的后续机型，在硬件上比前代 PS4 大幅提升，使用 PCIe 4.0 规格的高速定制固态硬盘和 AMD 的定制处理器。PS5 与 Xbox Series X&#x2F;S 游戏机是第九世代游戏机之一。手柄控制器名为 DualSense，使用自适应扳机，支持阻力感应。光盘驱动器版本支持 4K 蓝光播放功能。新的安装方式允许用户仅安装游戏部分内容，如仅安装多人模式；不启动游戏也可以查看可加入的多人游戏服务器和可参与的活动。PS5 采用定制的 AMD 图形处理器，具有光线追踪、4K 分辨率、每秒显示帧数达 120，3D 音效，且可向下兼容 PS4 和 PlayStation VR 的游戏。\n展示\n\n\n","categories":["游戏"],"tags":["主机","国行","SONY","PlayStation"]},{"title":"蝙蝠女侠 第二季 第十四集 伸张正义","url":"/zh-CN/b93fb326c7a3/","content":"\n剧情介绍　　蝙蝠女侠面临新的挑战，当哥谭的蛇毒成瘾者变得贪婪，不仅仅是渴望下一剂毒品时，局势变得更加复杂。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"黑闪电 第四季 第十二集 重生之书：第一章：交叉路口","url":"/zh-CN/3cd71a3e8596/","content":"\n剧情介绍　　杰斐逊意识到，有时候承认自己的弱点反而是一种力量的展现。与此同时，托拜厄斯则专注于自己的最终计划。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第七季 第十集 家庭事务（1）","url":"/zh-CN/04247c6d2f6e/","content":"\n剧情介绍　　艾瑞斯在试图揭开关于通灵者的神秘真相时被推到了极限;巴里启动了一个新的训练系统，这可能会适得其反，带来毁灭性的后果;乔和西斯科做出了改变人生的决定。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"速度与激情9","url":"/zh-CN/9c3720ee65a9/","content":"\n剧情介绍　　“唐老大”多姆·托莱多（范·迪塞尔 饰）与莱蒂（米歇尔·罗德里格兹 饰）和他的儿子小布莱恩，过上了远离纷扰的平静生活。然而他们也知道，安宁之下总潜藏着危机。这一次，为了保护他所爱的人，唐老大不得不直面过去。他和伙伴们面临的是一场足以引起世界动荡的阴谋，以及一个前所未遇的一流杀手和高能车手。而这个名叫雅各布（约翰·塞纳 饰）的人，恰巧是多姆遗落在外的亲弟弟。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"小满","url":"/zh-CN/61ca52967788/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小满\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小满"]},{"title":"iMac 24 英寸（M1，2021年）","url":"/zh-CN/76dada2aeda9/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iMac\n  新开篇\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"罪恶黑名单 第八季 第十八集 普罗透斯","url":"/zh-CN/096116cd46f7/","content":"\n剧情介绍　　特工小组迅速行动，试图阻止一名追踪莉兹的难以捉摸的刺客。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"黑闪电 第四季 第十三集 重生之书：第二章：终结","url":"/zh-CN/7c2ccc774973/","content":"\n剧情介绍　　经过四季的精彩演绎，这部具有变革性、深具现实意义且扣人心弦的剧集迎来了大结局。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第七季 第十一集 家庭事务（2）","url":"/zh-CN/385669dce857/","content":"\n剧情介绍　　巴里和艾瑞斯齐聚一堂，试图阻止一股危险势力摧毁中心城。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"寂静之地2","url":"/zh-CN/41461118404a/","content":"\n剧情介绍　　故事紧承上一部展开。在丈夫为保护家人牺牲后，伊芙琳（艾米莉·布朗特 饰）不得不独自带着孩子们（米莉森·西蒙斯、诺亚·尤佩 饰）面对全新的生存挑战。他们将被迫离开家园，踏上一段未知的旅途。在无声的世界里，除了要躲避“猎声怪物”的捕杀，铺满细沙的道路尽头还暗藏着新的危机。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"罪恶黑名单 第八季 第十九集 巴尔萨泽·比诺·贝克","url":"/zh-CN/1ede49a08085/","content":"\n剧情介绍　　为了悄无声息地转移一批珍贵货物，雷德寻求了一位专门通过地下网络运输物品的强硬分子的帮助。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"罪恶黑名单 第八季 第二十集 古德温·佩奇","url":"/zh-CN/c37d23e393cc/","content":"\n剧情介绍　　莉兹、雷德和登贝被迫合作，以应对汤森的攻击。库珀和特工小组则努力采取措施，试图缓解对所有人日益增加的危险。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"芒种","url":"/zh-CN/a94366ff8714/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  芒种\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","芒种"]},{"title":"蝙蝠女侠 第二季 第十五集 一触即发","url":"/zh-CN/b231df627f1a/","content":"\n剧情介绍　　随着卢克·福克斯的生命岌岌可危，这一毁灭性事件的后果成为了促使周围人做出改变人生决定的催化剂。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第七季 第十二集 再见振动","url":"/zh-CN/946a5733bc5a/","content":"\n剧情介绍　　西斯科和卡米拉告诉团队他们将离开中央城。然而，巴里、艾瑞斯和凯特琳没有太多时间消化这个消息，因为新的彩虹突袭者罢工和OG闪电战队必须最后一次联合起来拯救这座城市。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"Apple 2021 全球开发者大会","url":"/zh-CN/c498475a65d6/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大看点，眼看就来。\n\n\n\n  \n\n\n\n  就在眼前\n\n\n\n  \n\n\n\n  一点，说好。\n\n\n\n  \n\n\n\n","categories":["开发者大会"],"tags":["Apple","WWDC"]},{"title":"Microsoft 次世代 XBOX 上市","url":"/zh-CN/35108fd9c8b1/","content":"\n主机介绍Xbox Series X 配有特殊定制的 AMD 全新 Zen 2 处理器以及 RDNA 2 架构。凭借高达 12 Teraflops 的GPU 处理能力，Xbox Series X 能够为玩家提供4K 高清逼真、沉浸式游戏体验，并最高支持 8K 分辨率的输出，为玩家带来 2 倍于 Xbox One X，8 倍于初代 Xbox One 的强劲性能。通过实现更高帧率的顶尖技术、更广阔复杂的游戏世界，Xbox Series X 将为玩家带来跨时代的图像处理及性能，以及更好的沉浸式游戏体验。\nXbox Series S同样为玩家带来定义了 Xbox Series X 的新世代处理速度和性能表现。借助与 Xbox Series X 性能相近的 CPU 以及完全一致的 I&#x2F;O 性能表现，Xbox Series S 让开发者可以在 1440P 的分辨率下为玩家带来同样优异的游戏表现。Xbox Series S 的处理能力是 Xbox One 的 4 倍，借助可变速率着色技术（VRS）以及硬件加速的 DirectX 光线追踪技术，Xbox Series S 同样将为玩家带来沉浸、灵动的新世代游戏体验。另外，在 Xbox 快速架构的助力之下，Xbox Series S 512GB 的定制化 SSD 将带来 40 倍于 Xbox One 的 I&#x2F;O 带宽，并带来更快速的游戏加载、更稳定的帧率，以及支持在多个游戏之间切换的快速唤醒功能（Quick Resume）。\nXbox Series S 与 Xbox Series X 最显著的不同在于对分辨率的支持。Xbox Series S 的 GPU 性能是 Xbox One 的 3 倍，支持 1440p 分辨率下以 60 FPS 畅玩游戏，帧率支持最高可达 120 FPS。\n展示\n\n\n","categories":["游戏"],"tags":["主机","国行","Microsoft","XBOX"]},{"title":"蝙蝠女侠 第二季 第十六集 浴火重生","url":"/zh-CN/882fae26d1c0/","content":"\n剧情介绍　　当一位熟悉的敌人降临哥谭时，蝙蝠女侠和玛丽发现她们比以往任何时候都更加需要相互依赖。爱丽丝有了一个新任务，并且得到了一个意想不到的盟友加入她的阵营。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第七季 第十三集 掩藏","url":"/zh-CN/aebba7a26474/","content":"\n剧情介绍　　塞西尔被迫面对自己的过去，以摆脱精神监狱。与此同时，切斯特接替了西斯科，但犯了一个错误，使巴里处于严重的危险之中。乔调查了克里斯汀·克莱默的旧军事关系，发现了一个令人不安的真相。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第八季 第二十一集 开端","url":"/zh-CN/e820ddc9c977/","content":"\n剧情介绍　　当雷德带莉兹前往他帝国的神秘中心时，他们共同的过去浮出水面，长久埋藏的秘密也被揭露。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"夏至","url":"/zh-CN/5c95e7ec72fb/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  夏至\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","夏至"]},{"title":"闪电侠 第七季 第十四集 闪电","url":"/zh-CN/6eabcb4e7632/","content":"\n剧情介绍　　当紫外线回到中心城时，阿莱格拉决心找到她的表妹并改变她的心。与此同时，乔发现了克里斯汀·克莱默可能不是她看起来的好警察的证据。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第二季 第十七集 如假包换","url":"/zh-CN/95e3c0f0470f/","content":"\n剧情介绍　　蝙蝠女侠陷入困境，黑面具继续加大威胁，而西尔西作为他的爪牙参与其中。爱丽丝和萨菲雅再次交汇，带来了新的冲突。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第八季 第二十二集 结束","url":"/zh-CN/3da9dba26cd3/","content":"\n剧情介绍　　雷德向莉兹提出一个令人不安的要求，以换取有关他身份的真相。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"蝙蝠女侠 第二季 第十八集 力量","url":"/zh-CN/e9ba37e8e904/","content":"\n剧情介绍　　瑞安开始质疑自己作为城市英雄的位置，当黑面具在哥谭街头制造混乱时，她、卢克、玛丽和索菲必须联手应对。与此同时，爱丽丝试图营救她的妹妹，这意味着她将再次与西尔西遭遇。在一场史诗般的对决中，意外的联盟和变革将彻底颠覆我们所知的哥谭。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第七季 第十五集 门口的敌人","url":"/zh-CN/605ef6ec9015/","content":"\n剧情介绍　　当速度之神大军进攻中心城时，巴里和艾瑞斯必须搁置他们的家庭计划，专注于他们家园的最新威胁。与此同时，Chillblaine从监狱获释并声称要改过自新，但Frost有她的怀疑。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第七季 第十六集 终极考验","url":"/zh-CN/a61fdb277070/","content":"\n剧情介绍　　约翰·迪格尔带着武器来到中心城，帮助巴里阻止速度之神战争。与此同时，Allegra 和 Ultraviolet 的新纽带受到了终极考验，而 Joe 和 Kristen Kramer 则被她的前同事追捕。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"小暑","url":"/zh-CN/ed3af3522ddd/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小暑"]},{"title":"耀西的手工世界","url":"/zh-CN/fd101784e4d3/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"闪电侠 第七季 第十七集 物质的核心（1）","url":"/zh-CN/76509a640547/","content":"\n剧情介绍　　巴里和艾瑞斯迎接他们未来的孩子XS和巴特，只是为了一个令人震惊的秘密威胁到他们新的家庭和谐。与此同时，速度之神战争愈演愈烈，并威胁要摧毁中心城。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"孤独的美食家 第九季 第二集 来自神奈川县那珂郡二之宫的水煮鲷鱼和五郎的原味圣代","url":"/zh-CN/0b3b78fdbd63/","content":"\n剧情介绍　　五郎因公到神奈川县二宫站，在商务会议之前还有时间，所以他决定在一家咖啡店准备一下。 在该店的菜单上，有一种原创的圣代居然可以自由组合！这令五郎难以抉择并无法继续专注工作。于是他向店主要了一张纸，决定用某种策略来选择圣代。享用完圣代后，五郎离开咖啡店，前去参加会议。在结束与生意伙伴南（松尾聪）的商务会议后，五郎发现自己完全饿了。他决定寻找一个吃饭的地方，但他找不到，所以他决定回到他先前所在的咖啡馆。就在这时，在他前面很远的地方，五郎看到一个标志，上面写着 “炖金目”。在好奇心的驱使下，五郎决定前往建在海边的 “鱼餐馆”，在这里，五郎开发了一种新的饮食方式……！\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"飞儿乐团 钻石之心","url":"/zh-CN/1a7b4bb4da35/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","飞儿乐团"]},{"title":"梁心颐 来者何人n！","url":"/zh-CN/df3f86ad8e69/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["梁心颐","CD"]},{"title":"孤独的美食家 第九季 第一集 神奈川县川崎市宫山平的菲力牛排和海鲜奶油煎饼","url":"/zh-CN/ddfc808e2612/","content":"\n剧情介绍　　井之头五郎（松重丰饰）时隔多年来到横滨·白乐见自己的朋友，顺便填饱了自己的肚子。吃饱喝足后，五郎来到了位于神奈川县的宫前平，拜访泷山给他介绍的咨询对象·村井美咲（凉 饰）。在两人对话的过程中，村井突然说“泷山先生说的果然没错”并开始向单身的五郎表示自己也单身。五郎礼貌微笑努力打太极，并终于顺利结束了本次咨询。时至傍晚，五郎又踏上了寻找餐厅的路。努力走完一条长长的上坡路后出现在五郎眼前的是一家“猪排店”，入店后五郎面临了一个艰难的抉择，到底是吃炸里脊还是炸菲力……\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"闪电侠 第七季 第十八集 物质的核心（2）","url":"/zh-CN/f28b4b475c8f/","content":"\n剧情介绍　　闪电侠招募了许多极速者盟友，包括艾瑞斯和他来自未来的孩子们——巴特和诺拉·韦斯特-艾伦——结束了极速者战争并击败了一个致命的新对手：邪恶的速度之神。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"孤独的美食家 第九季 第三集 东京港区东麻布的Moussaka和Dolmades餐厅","url":"/zh-CN/165752056421/","content":"\n剧情介绍　　井之头五郎携带着一个大包裹来到东麻布的 “巴拿马大使馆”。与大使馆工作人员（原幸惠）进行商务会议。离开大使馆之后， 五郎在坐在一个大公园里，手里拿着一罐咖啡，发现自己又饿了。 为了寻找一个吃饭的地方，他来到了 “东京塔与东麻布商业街”，商业街吸引五郎目光的是 “希腊食品”。 这让他非常着迷，于是踏入了希腊餐厅……\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"大暑","url":"/zh-CN/c4784dc2fe91/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大暑"]},{"title":"孤独的美食家 第九季 第四集 东京府中市新町的炙烤鳗鱼和辣味牡蛎韭菜炒饭","url":"/zh-CN/4973636788c3/","content":"\n剧情介绍　　井之头五郎到国分寺车站办事。他与商业伙伴小谷武夫开始了一个商业会谈。然而，随着谈话的进行，小谷决定下次再决定。 漫长的会议之后，五郎离开咖啡馆，他不想一路饿着肚子去车站，所以他决定去吃他能找到的第一家店。 然而，在商业街中寻找后，他没能找到满意的店。 正当他想回到车站时，一个 “中国餐馆 “的招牌出现在他面前。 毫不犹豫地，五郎决定去吃一顿快餐，但菜单上的200多道菜让他陷入了困境……\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"疯狂兔子：奇遇派对","url":"/zh-CN/b3b00d2820ae/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"孤独的美食家 第九季 第五集 静冈县伊藤市宇佐美的牛肉烧和猪肉烧","url":"/zh-CN/adb5121a7351/","content":"\n剧情介绍　　井之头五郎第一次来到静冈县的河津镇，在享受了一碗正宗的芥末之后，五郎前往伊藤市的宇佐美车站附近与美发师横山绫香开展一个业务会议。会议后， 当五郎品味着宇佐美干净的空气，望向大海时，他发现自己饿了。五郎决定在宇佐美的海边寻找一家好的鱼餐馆。然而，这里连一家餐馆都找不到。在五郎筋疲力尽的时候，他发现了一个 “烧肉 “的标志。五郎很高兴看到一个接一个的烤肉店……\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"立秋","url":"/zh-CN/62413645f027/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立秋\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立秋"]},{"title":"孤独的美食家 第九季 第六集 东京都丰岛区南长崎的酱油炒肉、茄子套餐和炸鸡","url":"/zh-CN/938440b58267/","content":"\n剧情介绍　　井之头五郎来到南长崎与一家应用开发公司的CEO森本商谈需求。 但是五郎跟不上时髦新词和复杂的界面，所以会谈没有结果。 会议结束时，五郎已经筋疲力尽，饥肠辘辘。 因此，五郎决定用不被新概念和语言所欺骗的传统正餐来满足他的饥饿感。 当他在巷子里徘徊时，出现在他面前的再也不是开发公司的KPI，也不是DAU，而是 “日本料理”和”套餐”！五郎感觉回到了现实，他毫不犹豫地走进餐厅，他知道自己已经找到了他要找的那顿饭。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"麻布仔大冒险","url":"/zh-CN/99704c6d5289/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","实体","SONY","PlayStation","光盘"]},{"title":"孤独的美食家 第九季 第七集 东京都葛饰区新小岩，贵州家常回锅肉和纳豆火锅","url":"/zh-CN/f34de403d286/","content":"\n剧情介绍　　井之头五郎刚刚结束了在小岩的会议。 他已经很久没有去附近的珍珍餐馆了，但门上的牌子说它只在下午5点到晚上8点营业。他决定步行到下一个车站去参加下一个会议。 然而，距离比五郎想象的要远，当他成功地到达了他的商业伙伴武田（佐野学）所在的健身馆时，没想到武田让他体验馆里的步行机… 当他结束会议时，五郎完全饿了。\n　　在寻找一家餐厅来满足他的饥饿感时，五郎面对的是一家 “麻辣火锅”! 五郎决定尝试一下，但是……\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"处暑","url":"/zh-CN/b6ea35de6be1/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  处暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","处暑"]},{"title":"女超人 第六季 第八集 欢迎归来","url":"/zh-CN/16e2e78adf53/","content":"\n剧情介绍　　当女超人和佐尔-艾尔重返国家城市时，他们决心将幻影区的阴影抛在身后，一起享受作为超级英雄的时光。然而，他们过于急切的努力反而适得其反，带来了一个全新的威胁，危及国家城市。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"孤独的美食家 第九季 第八集 群马县高崎市的 \"Omusubi\" 和烤鲶鱼","url":"/zh-CN/5d378d2ea09c/","content":"\n剧情介绍　　井之头五郎坐在群马县高崎市的一家 “烤馒头”店里， 在用凤尾鱼填饱肚子后，五郎前往办公室，他的商业伙伴藤山正在那里等待。 五郎将西式糖果作为纪念品送给与藤山在一起的店员白川。\n　　早些时候吃过饭的五郎此时仍然想吃烧饼馒头。 他决定去找一家餐馆。 五郎发现了一家名为 “饭团餐厅”的饭馆，他决定进来探查一番，但是……\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"看见 第二季 第一集 兄弟姐妹","url":"/zh-CN/c87f01569d35/","content":"\n剧情介绍　　巴巴冒险进入敌对领地寻找哈尼瓦。凯恩女王为新的帕扬都城举行祝圣仪式，并发布了一个令人意外的公告。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"失控玩家","url":"/zh-CN/6edb99247070/","content":"\n剧情介绍　　银行出纳员盖（瑞安·雷诺兹 饰）发现自己其实是开放世界电子游戏中的背景角色，于是决定成为英雄，并改写自己的故事。现在，在一个没有限制的世界里，他决心以自己的方式拯救他的世界，以免为时过晚。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"女超人 第六季 第九集 筑梦大师","url":"/zh-CN/70d138b381ab/","content":"\n剧情介绍　　凯莉遇到了乔伊，一个年轻的外星孤儿男孩，他在寄养家庭中表现出问题行为，因为他担心自己被监禁的哥哥奥兰多出了问题。凯莉请求卡拉帮忙调查，二人发现了监狱中的虐待行为。与此同时，尼克斯莉闯入了尼娅的一个梦境，请求她的帮助。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"孤独的美食家 第九季 第九集 福岛县郡山市前木町汽车旅馆式烤肉套餐","url":"/zh-CN/462b414f99d2/","content":"\n剧情介绍　　井之头五郎因公抵达福岛县的郡山市，他的生意伙伴木村在郡山车站接他，木村开车把他送到了一个民间工艺作坊。会议结束后，他们到了木村在前木町的父母家。木村问五郎是否愿意与他共进午餐，但五郎拒绝了，他说他一会儿要去宇都宫工作，目前不饿。\n　　离开木村的父母家后，五郎来到了车站。之前他拒绝了木村的邀请，说他不饿，但他真的很饿，然而，车站前没有吃东西的店，所以他向国家公路走去。然后，五郎看到了 “汽车旅馆”这个词！他走到入口处，看到里面正在营业，他毫不犹豫地进入商店……\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"看见 第二季 第二集 永远","url":"/zh-CN/25895051c93c/","content":"\n剧情介绍　　一个旧敌人与巴巴面对面相遇。杰拉马雷尔艰难地接受失明的生活。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"Apple 长沙","url":"/zh-CN/ed25105ec54b/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple 长沙\n  胡来胡有理\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["零售店"],"tags":["Apple","Retail"]},{"title":"白露","url":"/zh-CN/e5951e6bf1f3/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  白露\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","白露"]},{"title":"女超人 第六季 第十集 屹立不倒","url":"/zh-CN/ae05c167b3b5/","content":"\n剧情介绍　　女超人介入了一个危机，原本为低收入住房预留的高地区建筑突然面临被卖给一家大公司。女超人招募了奥兰多来帮助她争取城市居民的支持，但当尼克斯莉现身时，事情变得复杂。与此同时，尼娅开始与她的母亲进行训练。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"孤独的美食家 第九季 第十集 枥木县宇都宫市的炖猪排和火腿排","url":"/zh-CN/7fa4986c94b5/","content":"\n剧情介绍　　在郡山的一次商务会议后，井之头五郎来到宇都宫与商业伙伴小坂里美开展另一次商务会议。小坂非常热情，说 “这是我被委托的第一个项目，所以我想不惜一切代价使它获得成功”，并为五郎想出了一系列的主意。完成了商务会议后，五郎饿了，决定去找一家餐馆。 这时出现了带红灯笼的居酒屋。 这让五郎想起很久以前去过的门前仲町居酒屋，他感到有一种命中注定的感觉。虽然很久没有吃过了，但五郎还是进入了居酒屋，并对居酒屋的菜单感到兴奋……\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"看见 第二季 第三集 指路人","url":"/zh-CN/7cf0730f6489/","content":"\n剧情介绍　　埃多的领导地位受到质疑。巴巴和哈尼瓦遇到了一支名为“指路人”的秘密战士部落。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"梁心颐 来者何人{}","url":"/zh-CN/8ea6e09bf0a7/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["梁心颐","CD"]},{"title":"Apple 特别活动","url":"/zh-CN/e23e144a9aab/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["发布会"],"tags":["Apple","Apple Event"]},{"title":"女超人 第六季 第十一集 针锋相对","url":"/zh-CN/e33ddf2aba93/","content":"\n剧情介绍　　女超人和团队必须阻止尼克斯莉从女超人的过去中消除一个熟悉的面孔——米奇（Mr. Mxyzptlk）。米奇回归，并用他最擅长的方式——以歌曲的形式，向超级团队解释尼克斯莉的黑暗历史。与此同时，莉娜前往新芬兰岛，探访母亲的故乡，渴望挖掘她的过去，但却被这个小镇冷漠的接待方式震惊。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"孤独的美食家 第九季 第十一集 东京都丰岛区菅口的盐煮羊肉骨和羊肉炸酱面","url":"/zh-CN/298812ac1e27/","content":"\n剧情介绍　　在一家咖啡馆里，脸上表情严肃的五郎正在与12岁的女孩绫波下棋，在思考了很久之后轻松地输了。与绫波父亲野川的商务会谈结束后，五郎感到很饿。他回到车站附近寻找吃饭的地方，一个印有马和羊的菜单牌子出现在五郎的眼前。他想起之前下棋时绫波的话：”与其防守，不如进攻”，于是进入商店……\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"鱼丁糸 池堂怪谈","url":"/zh-CN/5dd55a00ed02/","content":"\n专辑介绍听完这张专辑，你对“鱼丁糸”这几个字的陌生感会被完全打消。“鱼丁糸”拆解自团名“蘇打綠”（“苏打绿”的繁体）的偏旁部首，而这个名字早在他们创团初期、为报名音乐节而寄送的 demo 上就使用过。拍板后，乐队干脆将计就计，团员索性拆字换名，阿福改为“可田”、青峰是“日出”、家凯是“豕豆”、小威是“八女”、阿龚是“金八”、馨仪是“香我”。而歌迷昵称为“浮萍”，歌迷会则是“池堂”，颇有一种让行外人摸不着的内部笑话的意味。\n但是，你可能也需要一些时间，来消化鱼丁糸首张录音室专辑的任性放飞。《池堂怪谈》随心所欲地搭载各种怪诞音色，对音乐片段进行随意组合与裁剪，摇滚、不插电、管弦乐、Synthwave 纷飞。钢琴开场曲《起点终点》释放鱼丁糸的搞怪幽默本性，无缝衔接的《我就奇怪》也将这样的特质发挥到极致，穿插歌剧唱法，拼贴各式曲风。产生这样的变化是因为，专辑中有六首歌曲由一名以上的团员合体创作，而五年间的种种经历——青峰荣膺金曲奖“最佳国语男歌手”，阿龚推出演奏专辑、举办多场个人音乐会，团长阿福化身策展人，馨仪升格成为母亲，家凯前往伯克利求学，小威则举办了个人摄影展——都包含在他们重聚首的团队协作里，诉说着他们对这个世界的看法、对不同事物感受。\n同样，相比以往的缱绻，《池堂怪谈》的词作更为戏谑和直接。《在世界的尽头大声地说我恨你》“有恨不藏”的宣泄字句与强烈的节拍相互应和，《先说先赢》也让人闻到猛烈炮火的烟硝味，“走到尽头／赢家绝不会是你”似乎是团员这些日子以来的有感而发。但那些看似锋利的字眼，更像是化悲愤为幽默的解脱。于是，散发花草梦幻气味的《蜂蜜人参》与轻盈明亮的《脑波弱》分别出现了以下的词句：“无论过与不及／就选择做自己／先让我睡到自然醒”“一切啰唆／一切需求／等我睡醒再说”，尝过苦辣怪奇的生活况味之后，才懂风雨来袭之时不如先选择善待自己。引用网络热梗的贝斯手自黑之作《我就是个朴实无华的Bass手》，则更让人确信鱼丁糸这回“玩心很重”。\n光在音乐上搞怪还不够，为了更直观地呈现鱼丁糸式“美学”，乐队邀来导演程伟豪合作。他们用剧集的方式呈现一个完整的故事，加入平行时空的科幻元素和黑色幽默，十分契合专辑的另类与怪诞风格。无畏拥抱光怪陆离的人生百态，笑看过往，鱼丁糸就如他们在《星月花火》中唱的“当太阳升起后／我们就要一起走过”那般坚韧。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","鱼丁糸"]},{"title":"看见 第二季 第四集 猎巫者","url":"/zh-CN/0ac00c3fbd77/","content":"\n剧情介绍　　科芬和托德刚到彭萨，玛格拉就做出了一个改变命运的决定。巴巴、巴黎和哈尼瓦遇到了一位值得信赖的朋友。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"女超人 第六季 第十二集 盲点","url":"/zh-CN/98ce3132f11a/","content":"\n剧情介绍　　凯莉在奥姆费尔大厦崩塌后感到震惊，许多人受伤，包括乔伊。她的震惊很快转化为沮丧，因为她意识到医院人满为患，病人越来越多，而没人来帮忙——包括女超人，她正忙于与尼克斯莉作战。在意识到自己能够有所作为后，凯莉拥抱了自己的力量，完全接受了作为守护者（Guardian）的角色。女超人、亚历克斯、迪格尔和团队加入她的行列，共同带领社区恢复正义。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"秋分","url":"/zh-CN/7581941c4f10/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  秋分\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","秋分"]},{"title":"孤独的美食家 第九季 第十二集 神奈川县伊势崎町的芝士汉堡排和姜汁牛柳","url":"/zh-CN/2c1f817234b1/","content":"\n剧情介绍　　井之头五郎因公来到伊势崎町。 穿过古老的街道来到伊藤亮介开的一家米店，与他进行了一次商务会谈。之后，五郎因为众所周知的原因开始寻找一家满意的餐馆。 在他面前，他看到了 “意大利面和比萨 “以及 “家庭餐馆 “的字样。 起初他不知道该怎么做，但头版上的午餐菜单吸引了他……\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"看见 第二季 第五集 晚宴","url":"/zh-CN/efb052665681/","content":"\n剧情介绍　　巴巴和他的家人终于团聚，但当他得知女王的计划时，喜悦很快被打断。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"iPhone 13 Pro（A15，2021年）和 iPhone 13（A15，2021年）","url":"/zh-CN/049d1e8f1997/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  iPhone 13 Pro Max | iPhone 13 Pro\n  强得很\n\n\n\n  \n\n\n\n  iPhone 13 | iPhone 13 mini\n  解锁超能力\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPhone"]},{"title":"iPad mini（A15，2021年）和 iPad（A13，2021年）","url":"/zh-CN/1168bb0bea1b/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPad mini\n  小写的大\n\n\n\n  \n\n\n\n  iPad\n  事事玩得转\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPad"]},{"title":"女超人 第六季 第十三集 勇往直前","url":"/zh-CN/5d3770969408/","content":"\n剧情介绍　　女超人和团队与尼克斯莉争夺一块能掌控勇气的魔法图腾。女超人和尼克斯莉展开激烈对决，最终各自得到了图腾的一部分，但她们也得知，第一个通过勇气考验的人将获得整个图腾的控制权。与此同时，莉娜依然在努力理解自己新获得的能力。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"哆啦A梦 牧场物语","url":"/zh-CN/52c0d463bcd4/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"看见 第二季 第六集 独角兽的真相","url":"/zh-CN/625b37a03f3c/","content":"\n剧情介绍　　玛格拉、哈兰大人和巴巴前往和平峰会。哈尼瓦警告他们要注意巴黎的预言。女王和科芬一起度过了一天。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"女超人 第六季 第十四集 奇思妙想","url":"/zh-CN/28808a10ec73/","content":"\n剧情介绍　　莉娜对是否使用自己的魔法能力来帮助女超人从尼克斯莉那里夺回第二块图腾感到犹豫不决。威廉在为超级朋友们写一篇报道时感到困惑，因为他很难让既能让英雄们满意，又能取悦安德烈亚。与此同时，凯莉为艾斯梅找到了新家而感到欣慰，但事情却出乎意料地发生了变化，小女孩的未来陷入了危险。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"看见 第二季 第七集 女王的演讲","url":"/zh-CN/381796a545d5/","content":"\n剧情介绍　　凯恩女王的背叛迫使玛格拉不得不采取行动。科芬得到了令人不安的消息。哈尼瓦向芦苇做出最后的恳求，希望争取和平。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"寒露","url":"/zh-CN/a070e7df8591/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  寒露\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","寒露"]},{"title":"女超人 第六季 第十五集 明日希望","url":"/zh-CN/73df4b5e4c75/","content":"\n剧情介绍　　女超人继续与尼克斯莉争夺剩余的图腾，但在尼克斯莉绑架了威廉后，女超人意识到她需要采取更加主动的措施来保护国家城市的安全。与此同时，亚历克斯面临着人生中最大的挑战。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第三季 第一集 疯帽子","url":"/zh-CN/d46477184686/","content":"\n剧情介绍　　随着蝙蝠女侠继续保护哥谭街头的安全，蝙蝠翼也加入了战斗，但卢克很快意识到他还没有完全掌握战衣的使用。当瑞安拜访爱丽丝，询问她透露的重大消息时，瑞安必须决定是否要深入探寻自己过去的秘密。随着玛丽准备终于从医学院毕业，她比以往任何时候都更加感受到家庭的缺席。当一位爱丽丝的崇拜者偶然发现了失踪的蝙蝠奖杯时，哥谭和蝙蝠团队陷入混乱，最终迎来一场令人震惊的血腥毕业典礼……以及一个同样令人震惊的新联盟。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"看见 第二季 第八集 摇啊摇","url":"/zh-CN/b01b26f1f9b1/","content":"\n剧情介绍　　巴巴和埃多各自率领军队展开一场史诗般的战斗，最终兄弟之间迎来了一场激烈的对决。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"Apple Watch Series 7（S7，2021年）","url":"/zh-CN/133ddec1b6f5/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple Watch Series 7\n  全屏先手\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Watch"]},{"title":"Apple 特别活动","url":"/zh-CN/75d8544fed29/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["发布会"],"tags":["Apple","Apple Event"]},{"title":"女超人 第六季 第十六集 恶梦之城","url":"/zh-CN/3f599e029934/","content":"\n剧情介绍　　卡拉终于得到了她在CatCo的梦想故事，但就在她接受采访时，城市突然遭到一个噩梦怪物的攻击。面对这一局面，卡拉被迫认真审视自己的生活，思考是否还能继续以卡拉和女超人两种身份生活。与此同时，梦者在寻找梦图腾的任务中担任领导角色，这块图腾能够消灭在国家城市肆虐的噩梦怪物。她意识到，自己需要向妹妹梅芙寻求帮助。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第三季 第二集 牙齿松动","url":"/zh-CN/85ae03247407/","content":"\n剧情介绍　　当哥谭新一代的沼泽区凶残杀手鳄鱼现身并开始增加尸体数量时，蝙蝠女侠和爱丽丝的首次联手面临考验。但爱丽丝并不是唯一一个闯入瑞安生活的人，贾达·杰特出现在韦恩企业，坚持要见公司新任首席执行官。卢克和玛丽的关系因卢克隐瞒的秘密而变得紧张，而索菲发现自己逐渐成为瑞安的内圈成员。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第九季 第一集 剥皮者（一）","url":"/zh-CN/32e2dcf08f21/","content":"\n剧情介绍　　在伊丽莎白·基恩去世后的两年里，雷蒙德·雷丁顿和FBI特工小组的成员各奔东西，雷丁顿的行踪成谜。然而，当其中一名成员在执行任务时受伤，特工小组再次聚集起来，着手摧毁一个可能威胁全球安全的阴谋。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"沙丘","url":"/zh-CN/8517d0488f32/","content":"\n剧情介绍　　电影《沙丘》为观众呈现了一段神秘而感人至深的英雄之旅。天赋异禀的少年保罗·厄崔迪被命运指引，为了保卫自己的家族和人民，决心前往浩瀚宇宙间最危险的星球，开启一场惊心动魄的冒险。与此同时，各路势力为了抢夺这颗星球上一种能够释放人类最大潜力的珍贵资源而纷纷加入战场。最终，唯有那些能够战胜内心恐惧的人才能生存下去。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"霜降","url":"/zh-CN/d0a2fd762c95/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  霜降\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","霜降"]},{"title":"MacBook Pro（M1 Pro，M1 Max，2021年）和 AirPods 3（H1，2021年）","url":"/zh-CN/4fbfe6953d46/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  MacBook Pro\n  强者的强\n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac","AirPods"]},{"title":"女超人 第六季 第十七集 我相信爱的力量","url":"/zh-CN/bbde764aa8e5/","content":"\n剧情介绍　　当莱克斯·卢瑟出现在尼克斯莉身边时，女超人和团队必须应对同时面对他们两个最大敌人所带来的情感冲击。亚历克斯为凯莉准备了一个完美的求婚计划，但工作上的事务不断干扰她的安排。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第三季 第三集 冻结","url":"/zh-CN/87a28eac2e75/","content":"\n剧情介绍　　哥谭市中心发生了一起不幸事件，提醒了蝙蝠女侠和蝙蝠团队，另一个失踪的奖杯已经落入了错误之手。与此同时，杰特家族的一位新成员登场，马奎斯·杰特以一种不太隐蔽的方式出现，打断了瑞安和贾达之间的一个非常私人的时刻。蝙蝠翼必须决定自己是否准备好再次穿上战衣，而希波克拉底誓言则迫使爱丽丝和玛丽之间出现了一个紧张的姐妹时刻。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"007：无暇赴死","url":"/zh-CN/0d771aaad8bf/","content":"\n剧情介绍　　世界局势波诡云谲，再度出山的邦德（丹尼尔·克雷格 饰）面临有史以来空前的危机，传奇特工007的故事在本片中达到高潮。新老角色集结亮相，蕾雅·赛杜回归，二度饰演邦女郎玛德琳。系列最恐怖反派萨芬（拉米·马雷克 饰）重磅登场，毫不留情地展示了自己狠辣的一面，不仅揭开了玛德琳身上隐藏的秘密，还酝酿着危及数百万人性命的阴谋，幽灵党的身影也似乎再次浮出水面。半路杀出的新00号特工（拉什纳·林奇 饰）与神秘女子（安娜·德·阿玛斯 饰）看似与邦德同阵作战，但其真实目的依然成谜。关乎邦德生死的新仇旧怨接踵而至，暗潮汹涌之下他能否拯救世界？\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"罪恶黑名单 第九季 第二集 剥皮者（二）","url":"/zh-CN/3bbc14998bc7/","content":"\n剧情介绍　　一起绑架案对特工小组的能力提出了挑战，他们必须应对一个神秘的海盗组织。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"女超人 第六季 第十八集 难言之隐","url":"/zh-CN/9187584e78fc/","content":"\n剧情介绍　　女超人决心保护每个人免受莱克斯和尼克斯莉的威胁，因此她加倍加强巡逻，尤其是在亚历克斯和凯莉的单身派对即将到来之际。亚历克斯在职责和享受新家庭时光之间感到矛盾。布雷尼收到令人心碎的消息，而威廉与安德烈亚就她最近对莱克斯的报道发生冲突。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第三季 第四集 防冻液","url":"/zh-CN/838bfd7537f7/","content":"\n剧情介绍　　当瑞安入选哥谭的“30位30岁以下”名单时，卢克担心马奎斯在瑞安作为韦恩企业代理首席执行官逐渐崭露头角过程中所扮演的角色会让贾达感到不满。玛丽从一次深夜外出归来时，感觉自己有些不对劲，而爱丽丝的幻觉也变得越来越强烈。与此同时，当索菲的妹妹乔丹失踪时，她和蝙蝠团队迅速意识到，冰冻人失踪的武器并没有完全被控制住。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第九季 第三集 SPK","url":"/zh-CN/cecfd976df53/","content":"\n剧情介绍　　一起涉及被盗文物的新案件让雷德与一位曾经的黑名单人物再次相遇。阿拉姆则面临一个艰难的抉择。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"立冬","url":"/zh-CN/254481de13a9/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立冬\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立冬"]},{"title":"女超人 第六季 第十九集 最后一关","url":"/zh-CN/a3db3f9a7eed/","content":"\n剧情介绍　　当一个亲人被尼克斯莉和莱克斯绑架时，女超人和超级朋友们采取了果断的行动。就在此时，一位意想不到的盟友挺身而出，帮助团队解决危机。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"女超人 第六季 第二十集 卡拉","url":"/zh-CN/5908545cef6d/","content":"\n剧情介绍　　女超人与过去的熟悉面孔联手，决定彻底阻止莱克斯和尼克斯莉的阴谋。同时，亚历克斯和凯莉准备步入婚姻的殿堂。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第三季 第五集 来自皮格教授的教训","url":"/zh-CN/d8b430d05012/","content":"\n剧情介绍　　瑞安请求索菲陪她一起去贾达家参加晚宴，调查她疏远的母亲对韦恩企业的了解，但当一位不速之客突然闯入这场私人聚会时，晚宴发生了意想不到的转折。在这场令人恐惧的夜晚中，瑞安目睹了马奎斯和她母亲的另一面。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第九季 第四集 复仇天使","url":"/zh-CN/9c8c9aad13a5/","content":"\n剧情介绍　　特工小组争分夺秒寻找一名黑名单人物，此人不择手段夺回被不公正盗取的物品。雷斯勒向帕克提出了一个请求，而库珀试图拼凑起一段自己毫无记忆的事件。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"YOASOBI E-SIDE","url":"/zh-CN/54509432fe7a/","content":"\n专辑介绍全英文演唱旧作新曲，当红双人组“小说音乐化”之后，奔向“J-Pop 国际化”。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","YOASOBI"]},{"title":"Taylor Swift Red（Taylor's Version）[+ A Message From Taylor]","url":"/zh-CN/4ce1ef088d17/","content":"\n专辑介绍或许每个人都可能在二十多岁经历一段充满矛盾的情感生活，对于 Taylor Swift 来说，那是一种红色般炙热、鲜活的青春记忆。她曾把复杂的情感体验浇灌在第四张创作专辑《Red》中——有迷茫也有冲动，有孤独但也自由，折磨、找回自我和甜蜜并存。这是一张令人伤感，但同时也充溢着不羁情绪的专辑，从舞台摇滚、英伦摇滚、流行舞曲到 Dubstep，异彩纷呈的风格中傲然绽放着生命力，让 Taylor 一举突破乡村乐的框架，走进更开阔的音乐天地。时隔九年，这张《Red》继《Fearless》之后，被 Taylor 选为重新录制系列的第二张专辑。\n我们在《We Are Never Ever Getting Back Together》能听到游刃有余的演唱，让原曲那份青春分手宣言多了淡然和成熟。《All Too Well》曾经以细腻歌词、动人叙事获得共鸣，在重制版本中则让被粉丝期待许久的十分钟版本问世，保留滋养她的乡村乐元素同时，呈现了更完整的故事。这次，不仅 Taylor 本人重新录唱，Ed Sheeran 也一起合作了曲目《Everything Has Changed》和收录的未曝光作品《Run》。在这张作品发行前，Taylor 曾在社交媒体分享：“在音乐和歌词上，《Red》像是一个心碎的人。”而重录不仅是音乐上的一种新生，也是多年后再次进入这些情绪，以新姿态回抚当年碎落的心。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","Taylor Swift"]},{"title":"32岁生日快乐","url":"/zh-CN/fb893564d7e7/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  生日快乐\n\n\n\n  \n    \n  \n\n\n\n","categories":["纪念日"],"tags":["日常","生日"]},{"title":"蝙蝠女侠 第三季 第六集 你的花园是怎样生长的？","url":"/zh-CN/cc897934080b/","content":"\n剧情介绍　　在一个花园棚屋里的不安发现让雷内·蒙托亚急忙找到瑞安，确保城市保持高度警觉。她令人恐惧的理论是——一个蝙蝠奖杯已经纠缠上了一个新宿主，而它的危险影响正悄悄渗透到哥谭。爱丽丝异常急切地表示愿意帮助蝙蝠团队，而索菲则寻求为她妹妹遭遇的事件复仇。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第八季 第一集 世界末日（1）","url":"/zh-CN/f10c3e7a250b/","content":"\n剧情介绍　　当一个强大的外星威胁在神秘的情况下抵达地球时，巴里、艾瑞斯和闪电战队的其他成员在一场拯救世界的绝望战斗中被推到了极限。但随着时间的流逝和人类的命运岌岌可危，如果善良的力量要占上风，闪电侠和他的同伴也需要寻求一些老朋友的帮助。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第九季 第五集 本杰明·奥卡拉","url":"/zh-CN/25fe2e300d3e/","content":"\n剧情介绍　　登贝担任FBI探员的身份给雷德带来了麻烦，而特工小组则在处理一起涉及军事技术的案件。与此同时，库珀和帕克各自的个人生活也变得愈发复杂。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"小雪","url":"/zh-CN/b48ab01111f2/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小雪\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小雪"]},{"title":"闪电侠 第八季 第二集 世界末日（2）","url":"/zh-CN/1565d4abbe3d/","content":"\n剧情介绍　　德斯佩罗警告闪电侠，巨大的悲剧将降临到飞车手身上，并导致他失去理智。一旦发生这种情况，世界末日将开始。巴里决心证明德斯佩罗是错的，他加倍努力证明自己的清白，但来自艾瑞斯的毁灭性启示将他推向了边缘，并派他向黑色闪电寻求建议。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"蝙蝠女侠 第三季 第七集 选择你的毒药","url":"/zh-CN/6d20ade8e4c7/","content":"\n剧情介绍　　随着瑞安的家庭关系变得更加复杂，她也发现自己陷入了蝙蝠团队内部的对峙，卢克和玛丽之间的冲突让她左右为难。与此同时，爱丽丝找到了一个新的跟班来为她效命。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第八季 第三集 世界末日（3）","url":"/zh-CN/54ce2ef87664/","content":"\n剧情介绍　　巴里在正义大厅遇到了黑色闪电，在与德斯佩罗发生可怕的转折后。艾瑞斯怀疑德斯佩罗对未来的愿景有些不对劲，所以她向一个强大的盟友寻求帮助。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"YOASOBI THE BOOK 2","url":"/zh-CN/68024a5360e2/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","YOASOBI"]},{"title":"大雪","url":"/zh-CN/3c2d26305f34/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大雪\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大雪"]},{"title":"闪电侠 第八季 第四集 世界末日（4）","url":"/zh-CN/3b6a3f95bb3d/","content":"\n剧情介绍　　当Eobard Thawne以最意想不到的方式回归并与亲人结婚时，巴里感到震惊。Damien Darhk向Barry提供了建议，但有一个问题。一场史诗般的战斗开始于逆闪与闪电侠、闪电侠团队、蝙蝠女侠、哨兵和瑞恩·崔的对决。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第九季 第六集 罗贝塔·桑德医生","url":"/zh-CN/f87417aff433/","content":"\n剧情介绍　　特工小组调查了一名可能是一个有组织犯罪家族复兴关键的治疗师，而雷德则展开了自己的调查。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"闪电侠 第八季 第五集 世界末日（5）","url":"/zh-CN/d33919b0c893/","content":"\n剧情介绍　　闪电侠有机会永远结束他与逆闪的终生战斗，但代价对于巴里和团队来说可能太多了。与此同时，米娅·奎因（Mia Queen）从未来来到这里，希望拯救失去的亲人，她不会让任何事情阻碍她。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"HomePod mini（多彩，2021年）","url":"/zh-CN/ba6c33631c3e/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  HomePod mini\n  给你点颜色听听\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","HomePod"]},{"title":"冬至","url":"/zh-CN/2a76f7bdcb22/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  冬至\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","冬至"]},{"title":"元旦","url":"/zh-CN/d608fc129257/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  元旦快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","元旦"]},{"title":"AirPods Pro 虎年限量款","url":"/zh-CN/3b22efa0d7a9/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","AirPods"]},{"title":"小寒","url":"/zh-CN/525855ccdfa8/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小寒\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小寒"]},{"title":"罪恶黑名单 第九季 第七集 半梦半醒","url":"/zh-CN/0e5200beeaef/","content":"\n剧情介绍　　在一系列闪回中，雷斯勒回忆了伊丽莎白·基恩去世后自己的行为。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"腾讯引进Nintendo Switch（OLED版）上市","url":"/zh-CN/311167b3d55a/","content":"\n主机介绍Nintendo Switch（OLED版）是Nintendo Switch的全新款式，配置更新包括：色彩更艳丽的7.0寸OLED屏幕、角度调节更自由宽广的转轴式支架、全新扬声器、增至64GB的主机内存、独有的时尚配色和外观设计等。无论在何时、何地、与何人一起，Nintendo Switch（OLED版）都能满足用户的多重娱乐需求。\n展示\n\n\n","categories":["游戏"],"tags":["主机","国行","Nintendo","Switch"]},{"title":"蝙蝠女侠 第三季 第八集 相信命运","url":"/zh-CN/0fa8d3090250/","content":"\n剧情介绍　　在玛丽和爱丽丝继续加深姐妹情谊的同时，瑞安、卢克和索菲绝望至极，几乎愿意做任何事情来阻止她们。雷内被迫重新面对她令人心碎的过去。与此同时，马奎斯变得更加疯狂，并在韦恩大厦举办了一场极为阴险的盛会……而且每个人都被邀请了。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"苏打绿 同名专辑（苏打绿版）","url":"/zh-CN/4fb536a12e3c/","content":"\n专辑介绍复刻计划全新“糸”列 Vol.1:  苏打绿时期出道曲、首专重录。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","苏打绿"]},{"title":"罪恶黑名单 第九季 第八集 拉兹米克·迈尔医生","url":"/zh-CN/c75c8ea61301/","content":"\n剧情介绍　　一名职业网球选手的死亡将特工小组引向一名医生，此人可能在为一个大型体育博彩集团操控比赛结果。雷德进一步挖掘登贝的背叛，而雷斯勒则在与戒瘾斗争中挣扎。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"蝙蝠女侠 第三季 第九集 见见你的造物主","url":"/zh-CN/af8e11e2dfb7/","content":"\n剧情介绍　　瑞安、索菲和卢克试图追踪原版毒藤女，当所有迹象都指向帕梅拉·艾斯利将在哥谭市现身时。与此同时，玛丽感受到一种强大的吸引力，而爱丽丝突然变得非常保护她的继姐妹。与此同时，贾达并没有放弃挽救马奎斯，寻求一位旧朋友的帮助。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"大寒","url":"/zh-CN/98b89008919d/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大寒\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大寒"]},{"title":"罪恶黑名单 第九季 第九集 布克曼·巴蒂斯特","url":"/zh-CN/bdf3831bd492/","content":"\n剧情介绍　　一系列针对雷德手下的协调攻击让登贝陷入迫在眉睫的危险之中，这迫使他回忆起两年前加入FBI的经历。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"蝙蝠女侠 第三季 第十集 有毒","url":"/zh-CN/65df2e3a11f1/","content":"\n剧情介绍　　蝙蝠女侠忙得不可开交，她一边应对贾达的要求，一边面对玛丽日益增长的力量以及一段新的感情纠葛。在与时间赛跑以再次拯救城市和身边最亲近的人时，忠诚受到考验，动机也被质疑。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"除夕","url":"/zh-CN/e8de4aae5fc5/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  除夕快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","除夕"]},{"title":"蝙蝠女侠 第三季 第十一集 破损的玩具","url":"/zh-CN/4c037b0f65f9/","content":"\n剧情介绍　　就在事情看似无法更糟时……蝙蝠女侠的身份再次面临暴露的风险，而哥谭最恶名昭著的反派们开始联合起来。索菲与卢克携手执行一项任务，而爱丽丝则试图操控玛丽的思想。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"立春","url":"/zh-CN/ff2605a22b87/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立春\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立春"]},{"title":"元宵节","url":"/zh-CN/fe3b83c404ce/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  元宵节快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","元宵节"]},{"title":"马力欧疯狂兔子：王国之战","url":"/zh-CN/1d02b9d3b405/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"苏打绿 小宇宙（苏打绿版）","url":"/zh-CN/878abce9a0bd/","content":"\n专辑介绍鱼丁糸复刻计划，来到第二张专辑《小宇宙》。当年苏打绿在《小宇宙》里，逐渐褪去首张同名专辑的那股青涩学生气，走入了初闯成人社会的挣扎与犹疑；专辑本身却是一张地道的“熟成”之作，帮助乐队从独立音乐圈突入主流观众的视野。凭借这张专辑，苏打绿一举入围七项金曲奖，最终拿下“最佳乐团奖”；为吴青峰赢得“最佳作曲人奖”的《小情歌》，也成为传唱不衰的经典爱情颂歌。\n复刻计划以“拿回自己创作作品的母带”为目标，但进行到《小宇宙》，其意义已远超简单的“复刻还原”。正如青峰在微博所写：“这次怀着好多爱在唱，心境已经都不一样了。”《小宇宙（鱼版）》分为上下两张，Disc 1 收录《小宇宙》所有歌曲的重制版，由鱼丁糸的六位团员共同担任制作人。“鱼版”的《小情歌》少了一分年少的天真烂漫，多了一分念旧情愫；编曲改动最大的《小宇宙》拿掉了缓慢温情的前奏，加进强劲鼓点、弦乐，躁动不安贯彻全曲，以末尾尖锐的吉他噪音发出独属于他们的回响；为专辑收尾的《无言歌》，保留了原版戏剧性的编排，但仍能听出更成熟的演奏、演唱和录音。从首张专辑开始便一直默默在幕后陪伴苏打绿的徐千秀和吴青峰一同制作 Disc 2，收录 2016 年苏打绿在休团前最后一次“In Summer”演出中现场翻唱的歌曲，还原这份旧日感动。选曲从张雨生的《我的未来不是梦》开始，到四分卫的《起来》曲终，为未来道路赋予坚定勇气。弥足珍贵的 Live 声音记忆，为这次重返小宇宙的旅途画下延展无尽想象的省略号。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","苏打绿"]},{"title":"雨水","url":"/zh-CN/2754a7d161fd/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  雨水\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","雨水"]},{"title":"蝙蝠女侠 第三季 第十二集 我们都很疯狂","url":"/zh-CN/613f22520c20/","content":"\n剧情介绍　　瑞安、索菲和贾达联手制定计划，以阻止马奎斯，而玛丽则试图弥补她作为毒藤女所造成的伤害。与此同时，爱丽丝继续失控，与她内心的恶魔作斗争。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第九季 第十集 奥秘无线","url":"/zh-CN/db285ddd9688/","content":"\n剧情介绍　　特工小组对犯罪分子使用的不可追踪通信网络“Arcane Wireless”的调查导致了意想不到的后果。雷德争分夺秒试图帮助一位同事摆脱困境。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"蝙蝠女侠 第三季 第十三集 我们玩得开心吗？","url":"/zh-CN/96992d105b34/","content":"\n剧情介绍　　蝙蝠女侠与贾达联手，蝙蝠团队在恐慌中不得不与时间赛跑，因为马奎斯的邪恶计划膨胀成了哥谭市从未预料到的威胁……并且无法预见的灾难。与此同时，爱丽丝达到了崩溃的临界点，充满同情的玛丽再次为她的姐姐求情，寻求小丑的电击器，但每个人都在疑问——爱丽丝是否已经无法挽回？\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第九季 第十一集 砾石","url":"/zh-CN/1b9b171a90a8/","content":"\n剧情介绍　　特工小组调查了“集团”——一个由前政府支持的刺客组成的组织，但当他们发现其中一名成员可能与该组织有联系时，情况变得复杂。雷德进一步挖掘导致莉兹死亡的事件真相。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"惊蛰","url":"/zh-CN/ec4857c46c4e/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  惊蛰\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","惊蛰"]},{"title":"Apple 特别活动","url":"/zh-CN/25756b923d69/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  高能传送\n\n\n\n  传送门\n  两点开启\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["发布会"],"tags":["Apple","Apple Event"]},{"title":"闪电侠 第八季 第六集 冲动性过度紊乱","url":"/zh-CN/1bcca8e01567/","content":"\n剧情介绍　　在探望父母的挚爱誓言后，巴特和诺拉很快意识到事情并不像他们离开时那样。两人竞相修复时间线中的任何裂缝，并将一切恢复到应有的状态。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"(G)I-DLE I NEVER DIE","url":"/zh-CN/531261cc01b4/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","(G)I-DLE"]},{"title":"闪电侠 第八季 第七集 锁定","url":"/zh-CN/7ef42675a5b9/","content":"\n剧情介绍　　当罪犯入侵CCPD时，巴里和克莱默必须相互信任和依赖，才能安全脱身。与此同时，凯特琳在与斯诺和马克一起外出时学到了宝贵的一课。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"iPhone 13 Pro（A15，苍岭绿，2022年）、iPhone 13（A15，苍岭绿，2022年）和 iPhone SE（A15，2022年）","url":"/zh-CN/378d27599a02/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPhone 13 Pro Max | iPhone 13 Pro\n  强得很\n\n\n\n  \n\n\n\n  iPhone 13 | iPhone 13 mini\n  解锁超能力\n\n\n\n  \n\n\n\n  iPhone SE\n  重磅实力，\n  轻松入手。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPhone"]},{"title":"罪恶黑名单 第九季 第十二集 主席","url":"/zh-CN/f484eb17d9dc/","content":"\n剧情介绍　　特工小组追踪他们的最新目标“主席”，此人通过暗网股市交易犯罪组织的股份。雷德采取极端手段寻找一个跟踪装置，这让雷斯勒陷入低谷。库珀与他的勒索者取得了联系。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"春分","url":"/zh-CN/2289cda8a8f5/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  春分\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","春分"]},{"title":"iPad Air（M1，2022年）","url":"/zh-CN/0c94bc236de1/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPad Air\n  轻，靓，重量级。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPad"]},{"title":"Mac Studio（M1 Max，M1 Ultra，2022年）和 Studio Display（2022年）","url":"/zh-CN/944ce6edf027/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Mac Studio | Studio Display\n  欢迎登陆\n\n\n\n  \n\n\n\n  Mac Studio\n  造梦引擎\n\n\n\n  \n\n\n\n  Studio Display\n  眼界全开\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac","Display"]},{"title":"闪电侠 第八季 第八集 下次的火灾","url":"/zh-CN/0adc005f149d/","content":"\n剧情介绍　　巴里在谋杀案调查中相信自己的直觉，相信嫌疑人，尽管有压倒性的证据对他不利，同时艾瑞斯给了阿莱格拉一个成为导师的机会。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第九季 第十三集 真实模特公司","url":"/zh-CN/626d4f5bac25/","content":"\n剧情介绍　　当一个看似提供陪侍服务的机构的富有客户接连死亡时，特工小组追踪到一个不同寻常的嫌疑人。雷德与一位朋友在参加另一位朋友的追悼会时联手试图找回一件物品。库珀前往亚特兰大，追踪关于勒索者的新线索。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"罪恶黑名单 第九季 第十四集 爱娃·梅森","url":"/zh-CN/5d051d0bc323/","content":"\n剧情介绍　　在寻找参议员帕纳贝克失踪的儿媳时，特工小组发现可能存在更大规模的绑架模式。雷德继续拼凑关于莉兹死亡的谜团。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"清明","url":"/zh-CN/442386e42b67/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  清明\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","清明"]},{"title":"闪电侠 第八季 第十集 鲁莽","url":"/zh-CN/303bfb0b776a/","content":"\n剧情介绍　　当弗罗斯特鲁莽地寻求危险时，巴里对保护闪电侠团队安全的愿望受到了考验，因为她试图阻止“黑焰”，与此同时，艾瑞斯试图帮助一个十几岁的女孩与她的母亲团聚，但没想到弄巧成拙。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第八季 第九集 幻影","url":"/zh-CN/e8bf56d8566e/","content":"\n剧情介绍　　巴里和闪电侠小队越来越接近弄清楚火风暴，但没有找到他，与此同时，需要分散注意力的艾瑞斯跟随一个故事来到海岸城。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第九季 第十五集 安德鲁·肯尼森","url":"/zh-CN/c547e5cf31cc/","content":"\n剧情介绍　　当库珀寻找勒索者的调查与特工小组的最新黑名单案件发生交集时，紧张局势加剧。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"闪电侠 第八季 第十一集 复活","url":"/zh-CN/165223fedf47/","content":"\n剧情介绍　　巴里和切斯特可能已经找到了阻止“黑焰”伤害其他人的方法，与此同时，凯特琳决定自己处理这种情况，可能会让更多无辜的生命处于危险之中。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第九季 第十六集 海伦·马格希","url":"/zh-CN/5c62c9fd115c/","content":"\n剧情介绍　　雷德追踪一条线索，这条线索可能揭示莉兹的死因和库珀被勒索的真相。当特工小组的一名成员被拘捕时，团队经历了一次重大动荡。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"谷雨","url":"/zh-CN/2b6c9b564cd4/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  谷雨\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","谷雨"]},{"title":"罪恶黑名单 第九季 第十七集 兔子","url":"/zh-CN/5a2a1d8b3f72/","content":"\n剧情介绍　　当特工小组的一名成员被一个贩毒集团的首领俘虏时，他们求助于雷德的指导。雷德则调查了一起看似不可能的盗窃案。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"闪电侠 第八季 第十二集 死亡上升","url":"/zh-CN/df6a5ce06fec/","content":"\n剧情介绍　　随着一个新的变种人恐吓城市，乔向地方当局伸出援手，与此同时，巴里得到了塞西尔的帮助来追踪大屠杀凶手。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第九季 第十八集 拉斯洛·杨科维奇","url":"/zh-CN/c1f52068eb0e/","content":"\n剧情介绍　　雷德追问一位前合伙人的下落。特工小组追捕一名非法贩卖致幻剂的罪犯。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"闪电侠 第八季 第十三集 死亡降临","url":"/zh-CN/a866be6c9e80/","content":"\n剧情介绍　　闪电侠小队受到攻击，每个人都必须战斗，不仅要拯救自己，还要拯救彼此。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"立夏","url":"/zh-CN/c9ba9c64a795/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立夏\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立夏"]},{"title":"闪电侠 第八季 第十四集 朋友的葬礼","url":"/zh-CN/dea2dcc78cc9/","content":"\n剧情介绍　　闪电战队利用银行抢劫变种人的分心来减轻失去他们所爱的人的悲伤。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第九季 第十九集 熊头面具","url":"/zh-CN/7fd186488308/","content":"\n剧情介绍　　面对近期的巨大压力，阿拉姆通过一种不同寻常的方式寻求释放。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"罪恶黑名单 第九季 第二十集 雕具银行","url":"/zh-CN/bd1539bfda6a/","content":"\n剧情介绍　　为了揭露真正的敌人，雷德请特工小组协助迫降一座“飞行堡垒”银行。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"闪电侠 第八季 第十五集 进入静滞力","url":"/zh-CN/e5a476eea200/","content":"\n剧情介绍　　闪电侠从XS获得帮助。与此同时，CCPD在犯罪现场发现神秘装置时寻求切斯特的帮助。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第九季 第二十一集 马尔文·杰拉德（二）","url":"/zh-CN/6add822ef807/","content":"\n剧情介绍　　在发现背叛他们的人后，雷德和特工小组迅速展开行动。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"小满","url":"/zh-CN/c099b233a1ee/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小满\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小满"]},{"title":"Apple 武汉","url":"/zh-CN/6d2438d67da7/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple 武汉\n  创意江湖请来闯\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["零售店"],"tags":["Apple","Retail"]},{"title":"闪电侠 第八季 第十六集 巴里·艾伦奇事","url":"/zh-CN/9747fc368ac3/","content":"\n剧情介绍　　闪电侠被冲击波炸毁，迫使他的身体过早衰老。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第九季 第二十二集 马尔文·杰拉德（三）","url":"/zh-CN/1741ca1e25ac/","content":"\n剧情介绍　　雷德和库珀在如何处理共同的叛徒问题上意见不合。一个关于特工小组的重要秘密落入了不该得到的人手中。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"芒种","url":"/zh-CN/1c84b1cc764f/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  芒种\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","芒种"]},{"title":"Apple 2022 全球开发者大会","url":"/zh-CN/e98d17284046/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["开发者大会"],"tags":["Apple","WWDC"]},{"title":"闪电侠 第八季 第十七集 保持黑暗","url":"/zh-CN/e1b45e5a5183/","content":"\n剧情介绍　　闪电侠离开电网，寻找关于镇上新变种人的答案。与此同时，Allegra 在 CC Citizen Media 竭尽全力，以保护消息来源和朋友。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第八季 第十八集 黄领带的男人","url":"/zh-CN/d5c245dea823/","content":"\n剧情介绍　　随着镇上新的极速者的到来，闪电侠得到的比他商讨的要多得多，与此同时，塞西尔的力量经历了突飞猛进的增长，让她能够在完全不同的层面上帮助闪电侠队。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"夏至","url":"/zh-CN/5712be0b7e13/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  夏至\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","夏至"]},{"title":"闪电侠 第八季 第十九集 负极（1）","url":"/zh-CN/fcc6f831b8d4/","content":"\n剧情介绍　　闪电侠和团队正在为他们的生命而战，与此同时，艾瑞斯发现了她病的原因\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"MacBook Pro 13 英寸（M2，2022年）","url":"/zh-CN/f3ae6b0ad31d/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  MacBook Pro\n  超机动，硬实力。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"闪电侠 第八季 第二十集 负极（2）","url":"/zh-CN/0acd8c0c502a/","content":"\n剧情介绍　　由于闪电侠仍然对刚刚发生的一切感到震惊，团队的其他成员在他最需要的时候团结起来支持他。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"小暑","url":"/zh-CN/c3571fbfb1e5/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小暑"]},{"title":"周杰伦 最伟大的作品","url":"/zh-CN/0ed3b75282e5/","content":"\n专辑介绍在 1920 年代巴黎的莎玛丽丹百货公司里，一架老式钢琴奏出《Secret》的旋律（电影《不能说的秘密》插曲），一场穿越时空的旅行由此开启。多位当代绘画、文学艺术大师在杰伦的魔术桥段中逐一登场，……睽违六年，这位华语乐坛的超级明星，用这支 MV 宣告了第十五张专辑《最伟大的作品》的诞生。\n专辑主题单曲《最伟大的作品》通过词曲和 MV 唤醒了大众对古典乐与艺术永恒的致敬，而杰伦个人风格鲜明的律动和说唱，也让歌迷得以“重温”《夜的第七章》《夜曲》等汲取古典乐元素的流行旧作。MV 中，他和郎朗“斗琴”的段落，对曾自导自演的电影《不能说的秘密》做出了有趣回应。这首曲子在几年前早有构想，拍好 MV 之后才有了相应歌词，为了能全面体现复古，杰伦更是跑到巴黎歌剧院录制了人声。\n在新专辑中，杰伦延续了情歌创作分量，如民谣色彩的《等你下课》，流行摇滚的《错过的烟火》，以及 R&amp;B 风格的《倒影》，如同一张“周氏情歌”歌单的增补，续写出青春爱恋的种种滋味。而在整体的音乐上，这张专辑并没有呼应或试图改写当下潮流，做出曲风上的标新立异，但曾经引领乐坛的“周杰伦语言”，依然有腔调并我行我素：《还在流浪》回溯《上海一九四三》，适当的 Auto-tune 和《跨时代》手法类似，方文山在 R&amp;B 结合东方意境的《红颜如霜》以梨园名剧《凤求凰》作背景写词，和杰伦完成了久违的“中国风”新作。\n这张被期待多年的作品终于没有再“鸽”大家，在今年如期发行，在单曲速食时代，周杰伦的音乐制作团队仍然打造出多支明丽的 MV，希望帮大家扫去疫情下的阴霾。他还为歌迷埋下不少彩蛋：轻松幽默的《粉色海洋》有儿子 Romeo 的“登场”，五月天阿信合作的《说好不哭》，MV 也呼应到《晴天》《不能说的秘密》的一些经典镜头。\n这次专辑发布，难免也让不少老歌迷感叹 20 年时间已匆匆过。2000 年代初，周杰伦以颠覆者的姿态闯入华语乐坛，打开了无数唱作人想象力的大门。之后他在唱片公司、电竞、潮牌等不同领域游走的同时，仍在不断推出新专辑，完成自我强调或迭代。今天，在短视频社交平台，新世代歌迷还能不自觉地爱上这位划时代歌手许多年前写下的歌。当“千禧年”已成为一代人遥远的记忆，《最伟大的作品》也无需再颠覆时代，它是周杰伦对自己音乐动机的流畅呈现——无论喜欢与否，它依然很“周杰伦”。\n新专发布之际，周杰伦应邀与 Apple Music 分享了关于创作的故事，以及他对于当下华语乐坛的一些看法。\n距上一次发片有六年了，是你生涯里最长的发片间距，有什么感想？“这几年其实陆续都有单曲发表，在《Mojito》单曲发了之后，就想说接下来应该要出专辑了，这张《最伟大的作品》专辑也把之前只有数位发行的几首单曲收录进去，希望歌迷朋友喜欢。”\n专辑中有各种经典的“周杰伦元素”，哪些歌最代表你现在的创作心境？“我童年的记忆里，妈妈一边作画，我一边弹钢琴的画面是我小时候的美好回忆，还记得妈妈和我讲述了许多艺术家的故事，原来妈妈对我在艺术方面的影响从小就开始了！把绘画、文学这些艺术跟音乐结合在一起，是我近来很想创作的主题，《最伟大的作品》这首歌还有 MV 其实是大概 5 年前就有的构想，透过穿越时空和以前的艺术家相遇…这样不是很 cool 吗？”\n跟阿信合作《说好不哭》后你们的交流与舞台合作也变得频繁，目前还有没有和更多艺人合作的计划？“我喜欢给歌迷惊喜，就像和阿信的合作，从配唱、制作、到日本拍 MV，都是保密到家的，我记得当时我在 IG 预告要推出新歌，阿信还假装帮我加油，果然最后让大家都相当惊喜！反正就好玩！我很少跟不同唱片公司的人合作，之前有费玉清，当然未来很多事都说不定的。”\n你掀起过中国风热潮，但近年中国风的创作相对减少，这张专辑收录了《红颜如霜》，你现在对中国风有什么新想法吗？“还记得很多年前，要发《11月的萧邦》那张专辑时，当时很多人跟着很喜欢写中国风的歌曲，那我就想说这张就不要放进东方元素的歌吧！但是方文山跟我极力建议，甚至把《发如雪》的歌词都写好了，我转念一想，还是应该坚持自我风格，希望是自己影响别人，而不要被别人所影响！所以我们一直作自己想作的音乐。”\n很多人说你在家庭美满和事业成功的当下，少了一点挣扎和矛盾，怎么看待这样的说法呢？“创作未必都是音乐人自身的经历或故事，有时候常常会从身边友人的故事做一些灵感的延伸，像我和弹头一起写的《不爱我就拉倒》表达的是男生心里很难过，但遇到没有办法扭转的感情还是帅气面对。文山写词的《说好不哭》写的是一首关于’成全’的情歌，为了成全男生的梦想，女生微笑放手。所以创作里还是有很多不同故事的。”\n2000 年代的周杰伦可以说是“破坏性”创新，带来说唱、中国风、周氏情歌等新鲜元素。到了 2010 年代延续“周杰伦特色”的同时，你也有新的尝试，如电子化的《跨时代》《惊叹号》，你会怎么形容 2020 年代的自己呢？“其实自己并不觉得自己创作上有什么时期上的归类，或者说并不会去做一个分野，一直以来都还蛮坚持自己的音乐风格的，一路走来当然还是会加进一些新的元素，透过音乐本身到视觉的呈现，都希望与乐迷们分享。”\n短视频平台的兴起，改变了写歌生态，很多创作人追求简短、洗脑，这与你经历过的写作环境很不同，对此有什么看法？“最近我也有用自己的新歌来制作短视频，畊宏也有用我的歌曲去带动大家对运动的喜爱，不管是用完整的歌曲再去做精华的展现，或者是一开始就为了短视频而做的音乐，都是音乐人的创作心血。所以也许出发点不同，但都是‘创作’，我们都允以尊重。”\n每次推出新专辑，免不了有很多歌迷会拿你以前的作品来做比较，甚至会说还是旧歌好听，你自己是怎么看待的？“很多人喜欢老歌，有一种韵味在，毕竟加了当时听歌时的情感，经过岁月的累积，就像穿越、瞬间回到过去，所以不管写什么新歌，都敌不过以前听过的旧歌。我有个想法是，现在的新歌是写给你小孩听的，世世代代，不管是新歌好，还是旧歌好，我写的歌都好。”\n《粉色海洋》这首歌有 Romeo 的 OS，给粉丝很大的惊喜！为什么想到收录他的声音？“我想前奏有他的开头会很好玩！我就叫他多讲一些，再剪接。他的笑声也是很自然的。”\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","周杰伦","黑胶","CD"]},{"title":"MacBook Air 13 英寸（M2，2022年）","url":"/zh-CN/38241dcfd889/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  MacBook Air\n  别看轻，别轻看。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"大暑","url":"/zh-CN/755f5a282a01/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大暑"]},{"title":"立秋","url":"/zh-CN/e928fb7a887a/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立秋\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立秋"]},{"title":"处暑","url":"/zh-CN/4976640695a0/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  处暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","处暑"]},{"title":"看见 第三季 第一集 欲戴王冠，必承其重","url":"/zh-CN/0bb9dd6ae98b/","content":"\n剧情介绍　　巴巴在山中安然生活，而彭萨对有视力者的仇恨日益加深。一位特里凡提亚科学家研发出了一种可怕的新型武器。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"看见 第三季 第二集 小心恶人","url":"/zh-CN/a577fcde1de7/","content":"\n剧情介绍　　在经历了一次毁灭性的失败后，巴巴前往彭萨警告家人。玛格拉对猎巫者的命运展开了激烈的辩论。芦苇策划了一次大胆的逃脱。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"看见 第三季 第三集 这是你的土地","url":"/zh-CN/c43668f3f02a/","content":"\n剧情介绍　　芦苇抵达彭萨，并分享了有关托尔马达计划的信息。塔马克蒂·琼再次尝试镇压猎巫者的叛乱。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"看见 第三季 第四集 风暴","url":"/zh-CN/ce603697e3d8/","content":"\n剧情介绍　　托尔马达向三角联盟展示了他的新武器，而巴巴带领一队人前往启蒙之家，企图摧毁托尔马达的军火库。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"Apple 特别活动","url":"/zh-CN/5c6677a45b3c/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["发布会"],"tags":["Apple","Apple Event"]},{"title":"iPhone 14 Pro（A16，2022年）和 iPhone 14（A15，2022年）","url":"/zh-CN/a15ffa511574/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPhone 14 Pro Max | iPhone 14 Pro\n  强力出圈\n\n\n\n  \n\n\n\n  iPhone 14\n  玩大玩超大\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPhone"]},{"title":"Apple Watch Series 8（S8，2022年）和 Apple Watch SE 2（S8，2022年）","url":"/zh-CN/713651b77387/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple Watch Series 8\n  健康的一大步\n\n\n\n  \n\n\n\n  Apple Watch SE\n  超值超有料\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Watch"]},{"title":"白露","url":"/zh-CN/50501afc6ee0/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  白露\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","白露"]},{"title":"看见 第三季 第五集 启蒙之屋","url":"/zh-CN/184364cd6167/","content":"\n剧情介绍　　在启蒙之屋发生对峙，最终爆发了一场血腥的围城战，巴巴一方与托尔马达的士兵展开激烈厮杀。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"AirPods Pro（H2，2022年）","url":"/zh-CN/dc4df9d8af8d/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  AirPods Pro\n  重塑新声\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","AirPods"]},{"title":"秋分","url":"/zh-CN/9d8d9a3da959/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  秋分\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","秋分"]},{"title":"Apple Watch Ultra（S8，2022年）","url":"/zh-CN/b685932a611a/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple Watch Ultra\n  越野越心驰\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Watch"]},{"title":"马力欧卡丁车8 豪华版 新增赛道通行证","url":"/zh-CN/6937a3b26841/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"看见 第三季 第六集 低地","url":"/zh-CN/fd142a8e9564/","content":"\n剧情介绍　　巴巴和他的队伍通过低地的一个危险捷径赶往彭萨。玛格拉和塔马克蒂·琼发现了一件骇人的事情。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"暗影火炬城","url":"/zh-CN/42cc0660bc83/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","实体","SONY","PlayStation","光盘"]},{"title":"孤独的美食家 第十季 第一集 神奈川县相模原市桥本 精力炒牛肉与葱花蛋","url":"/zh-CN/50d275366ac9/","content":"\n剧情介绍\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"看见 第三季 第七集 雷霆之神","url":"/zh-CN/807e5ee68f6e/","content":"\n剧情介绍　　托尔马达和西贝斯对彭萨发起了猛烈攻击，将玛格拉和城市居民置于极大危险之中。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"iPhone 14 Plus（A15，2022年）","url":"/zh-CN/4b35bb2dcad0/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  iPhone 14 Plus\n  玩的超大\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPhone"]},{"title":"寒露","url":"/zh-CN/78b75a612655/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  寒露\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","寒露"]},{"title":"孤独的美食家 第十季 第二集 东京都港区白金台 仁当牛与印尼炒饭","url":"/zh-CN/92e50f5087fb/","content":"\n剧情介绍\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"梁文音 好好对待她","url":"/zh-CN/b909377d4829/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","梁文音"]},{"title":"看见 第三季 第八集 我看见你","url":"/zh-CN/8b2b561d2ae8/","content":"\n剧情介绍　　巴巴和游侠潜入西贝斯的营地，决心一劳永逸地阻止她和托尔马达。\n\n","categories":["剧集"],"tags":["日常","Apple Plus"]},{"title":"孤独的美食家 第十季 第三集 神奈川县横滨市樱木町 香煎真鲷排佐曙光酱与生拌鲔鱼盖饭","url":"/zh-CN/2605be4a6ab3/","content":"\n剧情介绍\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"Taylor Swift Midnights（The Til Dawn Edition）","url":"/zh-CN/75e0489954e3/","content":"\n专辑介绍《Midnights》加长版新增三首歌曲，通过空间音频聆听。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","Taylor Swift"]},{"title":"iPad Pro（M2，2022年）和 iPad（A14，2022年）","url":"/zh-CN/28da358b5b75/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPad Pro\n  由 M2 强势驱动\n\n\n\n  \n\n\n\n  iPad Pro\n  由 M2 强势驱动\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPad"]},{"title":"霜降","url":"/zh-CN/f9c9de496a2f/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  霜降\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","霜降"]},{"title":"孤独的美食家 第十季 第五集 千叶县柏市鹫野谷 青葱炒猪肝与鸡皮煎饺","url":"/zh-CN/3fcd174fc28b/","content":"\n剧情介绍\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"孤独的美食家 第十季 第四集 东京都练马区大泉学园 普罗旺斯风蕈菇海螺与炖牛舌蛋包饭","url":"/zh-CN/bcc55f98985b/","content":"\n剧情介绍\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"孤独的美食家 第十季 第六集 岐阜县下吕市 猪仔鸡仔","url":"/zh-CN/925128945cc7/","content":"\n剧情介绍\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"立冬","url":"/zh-CN/0d29c3a1584c/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立冬\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立冬"]},{"title":"孤独的美食家 第十季 第七集 东京都涩谷区笹冢 冲绳炒面麸与番茄咖哩沾面","url":"/zh-CN/af2a33dd82d8/","content":"\n剧情介绍\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"33岁生日快乐","url":"/zh-CN/8f62366d9586/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  生日快乐\n\n\n\n  \n    \n  \n\n\n\n","categories":["纪念日"],"tags":["日常","生日"]},{"title":"YOASOBI E-SIDE 2","url":"/zh-CN/22282fdb1645/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","YOASOBI"]},{"title":"小雪","url":"/zh-CN/2e7e584da713/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小雪\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小雪"]},{"title":"孤独的美食家 第十季 第九集 东京都荒川区日暮里 糖醋肉和炸酱海鲜双拼面","url":"/zh-CN/403a1ee31229/","content":"\n剧情介绍\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"孤独的美食家 第十季 第八集 富山县富山市 蟹面关东煮和海鲜山药泥饭","url":"/zh-CN/d62287eff6d0/","content":"\n剧情介绍\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"孤独的美食家 第十季 第十集 神奈川县川川崎市中原区 猪肉肠粉与云吞面","url":"/zh-CN/bd27a50eeee3/","content":"\n剧情介绍\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"大雪","url":"/zh-CN/b2ead9bdaa9a/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大雪\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大雪"]},{"title":"孤独的美食家 第十季 第十一集 千叶县旭市 香煎猪里脊佐盐味山葵","url":"/zh-CN/3f970c70ef15/","content":"\n剧情介绍\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"阿凡达：水之道","url":"/zh-CN/240d6c0ae009/","content":"\n剧情介绍　　影片设定在《阿凡达》的剧情落幕十余年后，讲述了萨利一家（杰克、奈蒂莉和孩子们）的故事：危机未曾消散，一家人拼尽全力彼此守护、奋力求生，并历经艰险磨难。\n　　杰克和奈蒂莉组建了家庭，他们的孩子也逐渐成长，为这个家庭带来了许多欢乐。然而危机未曾消散，萨利一家拼尽全力彼此守护、奋力求生，最终来到潘多拉星球临海的岛礁族寻求庇护。岛礁族首领特诺瓦里与罗娜尔为萨利一家提供了庇护所，这个部族的成员都是天生的潜水好手，也和海洋中的各种生物建立了密切联系。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"元旦","url":"/zh-CN/e369a584c73c/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  元旦快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","元旦"]},{"title":"冬至","url":"/zh-CN/ecf57f3bc74b/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  冬至\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","冬至"]},{"title":"孤独的美食家 第十季 第十二集 东京都千代田区曲町 意大利食堂烘肉卷","url":"/zh-CN/8772ed8ee3be/","content":"\n剧情介绍\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"小寒","url":"/zh-CN/2f79f99f12e6/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小寒\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小寒"]},{"title":"AirPods Pro 兔年限量款","url":"/zh-CN/44209dc0ff14/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","AirPods"]},{"title":"大寒","url":"/zh-CN/dda3c75c02b9/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大寒\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大寒"]},{"title":"除夕","url":"/zh-CN/257783e267a9/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  除夕快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","除夕"]},{"title":"苏打绿 无与伦比的美丽（苏打绿版）","url":"/zh-CN/2cecd9d42fda/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","苏打绿"]},{"title":"MacBook Pro（M2 Pro，M2 Max，2023年）","url":"/zh-CN/92c12610404b/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  MacBook Pro\n  行走的突破力\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"HomePod（2023年）","url":"/zh-CN/40720b10eed0/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  HomePod\n  声声有天地\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","HomePod"]},{"title":"立春","url":"/zh-CN/cee5d57e9a5a/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立春\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立春"]},{"title":"元宵节","url":"/zh-CN/fb75f64c9487/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  元宵节快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","元宵节"]},{"title":"Mac mini（M2，M2 Pro，2023年）","url":"/zh-CN/150776840846/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Mac mini\n  涨内力，添迅猛。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"黑豹2","url":"/zh-CN/cd5a956d6e1d/","content":"\n剧情介绍　　曾经肩负种族繁盛使命的一代明君“黑豹”特查拉国王猝然离世，当人民还沉浸在悲伤之中时，拉曼达女王（安吉拉·贝塞特 Angela Bassett 饰）和特查拉年轻的苏睿（利蒂希娅·赖特 Letitia Wright 饰）不得不肩负起千斤重担，为了瓦坎达的存续而不断努力。与此同时，生活在大洋深处的亚特兰蒂斯一族宁静的生活被打破，而这一切源于贪婪的人类对振金的无限渴求。愤怒的亚特兰蒂斯王子纳摩（特诺切·韦尔塔 Tenoch Huerta 饰）将矛头指向了瓦坎达。新的危机扑面而来，针对瓦坎达的阴谋也旋即展开。\n　　陆地与海洋、现代与古文明的战争一触即发，无人能免……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"闪电侠 第九季 第一集 反复的星期三","url":"/zh-CN/d2a5ae62e06a/","content":"\n剧情介绍　　巴里制作了一本地图书来指导他和爱丽丝的未来，以确保她的安全，但结果并不是他所期望的，相反，他们一次又一次地重温了同一天。乔和塞西尔交心。一个新的大坏蛋被引入闪电小队，新老朋友和敌人开始袭击中心城。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"闪电侠 第九季 第二集 听不见邪恶","url":"/zh-CN/7db98e7b7a6b/","content":"\n剧情介绍　　巴里对凯特琳的遭遇感到内疚，马克提出了一个让所有人都怀疑的计划。与此同时，红死病在中心城区隐约可见，并告诉人们失败是不可能的。乔要求塞西尔做出选择，让塞西尔思考更大的好处。阿莱格拉和切斯特朝着新的方向迈出了一步。最后，老朋友们不期而遇地参观了星城实验室。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"苏打绿 陪我歌唱（苏打绿版）","url":"/zh-CN/d79d9d526909/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","苏打绿"]},{"title":"雨水","url":"/zh-CN/fe9d2aa0ca49/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  雨水\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","雨水"]},{"title":"闪电侠 第九季 第三集 无赖的战争","url":"/zh-CN/b206226008f7/","content":"\n剧情介绍　　巴里和艾瑞斯开始把中心城发生的事情拼凑起来，相信他们知道盗贼们在追求什么。闪电小队齐心协力，招募了一些不太可能的盟友来帮助，但计划并没有达到闪电小队的预期。与此同时，阿莱格拉尽力避免与切斯特交谈。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第十季 第一集 猫头鹰","url":"/zh-CN/80ca85f0776d/","content":"\n剧情介绍　　在吴京从拘押中逃脱六个月后，雷丁顿神秘地在曼哈顿一场爆炸中现身。当一名曾上过黑名单的人物被发现与现场有关时，特工小组开始调查更大的阴谋。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"蚁人与黄蜂女：量子狂潮","url":"/zh-CN/5c507b306568/","content":"\n剧情介绍　　在与灭霸的终极决战结束后，“蚁人”斯科特·朗（保罗·路德 Paul Rudd 饰）和“黄蜂女”霍普·凡·戴恩（伊万杰琳·莉莉 Evangeline Lilly 饰）一家迎来了分外难得的平静生活，当然两个人作为救世主也得到周遭人的喜爱和敬仰。可是短暂的安逸之后，新的危机突然袭来。斯科特的女儿凯茜（凯瑟琳·纽 顿 Kathryn Newton 饰）一次失误操作，将父母以及外公外婆重新带回量子世界。在那个光怪陆离的世界里，珍妮特（米歇尔·菲佛 Michelle Pfeiffer）与老友重逢，斯科特等也结识新的朋友。与此同时，他们发现曾在量子世界得到珍妮特帮助的征服者康（乔纳森·梅杰斯 Jonathan Majors 饰）已经建立起一个强大的帝国。\n　　而这个号称宇宙最强存在的反派，正意图逃离这个禁缚他许久的量子世界……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"曼达洛人 第三季 第一集 变节者","url":"/zh-CN/ec3e82542611/","content":"\n剧情介绍　　曼达洛人开始了一段重要的旅程。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"闪电侠 第九季 第四集 红色死神的面具（1）","url":"/zh-CN/681e144bdbc9/","content":"\n剧情介绍　　闪电侠被迫做出一个不可能的选择。城市停电后，闪电小队在一位老朋友拜访艾瑞斯时，向盗贼小队求助。乔和塞西尔努力寻找平衡。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第十季 第二集 捕鲸人","url":"/zh-CN/948a8e4ca941/","content":"\n剧情介绍　　特工小组试图通过新成员西亚·马利克的帮助渗透一场与吴京有关的高赌注扑克游戏。雷德和库珀在应对阿格尼丝在学校遭欺凌的问题上采取了截然不同的策略。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"惊蛰","url":"/zh-CN/1357008c12ac/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  惊蛰\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","惊蛰"]},{"title":"曼达洛人 第三季 第二集 曼达洛矿井","url":"/zh-CN/16d4ee47800f/","content":"\n剧情介绍　　曼达洛人和格罗古探索一颗被毁灭星球的遗迹。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"闪电侠 第九季 第五集 红色死神的面具（2）","url":"/zh-CN/bd8080314c40/","content":"\n剧情介绍　　当红死病肆虐中心城时，巴里和艾瑞斯想出了一个计划，并向塞西尔寻求帮助。巴里面临着他认为是他最大的错误和红死病最大的成功。希奥恩想帮助闪电队，但巴里不能冒险失去她。乔给巴里做了一次急需的激励演讲。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第十季 第三集 四支枪","url":"/zh-CN/214c7628d02f/","content":"\n剧情介绍　　对参议员帕纳贝克的刺杀企图将特工小组引向一个臭名昭著的扒手团伙。雷德向一位被拘留的老朋友送去了一份危险的“礼物”。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"iPhone 14 Plus（A15，明黄，2023年）和 iPhone 14（A15，明黄，2023年）","url":"/zh-CN/4b23784b0d56/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPhone 14 Plus | iPhone 14\n  一抹明黄新入列。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPhone"]},{"title":"曼达洛人 第三季 第三集 归顺者","url":"/zh-CN/44d9db76b378/","content":"\n剧情介绍　　在科洛桑，前帝国成员在新共和国中寻求庇护。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"闪电侠 第九季 第六集 好的，坏的，还有幸运的","url":"/zh-CN/cd259bd0da97/","content":"\n剧情介绍　　当巴里和艾瑞斯准备迎接新生活时，中心城的人的运气发生了变化。塞西尔在阿莱格拉的帮助下处理了一个案件，涉及一系列不幸的、非常意外的事件。与此同时，切斯特和他的团队与希奥内一起研究她的能力。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"雷霆沙赞！众神之怒","url":"/zh-CN/042b95a210ca/","content":"\n剧情介绍　　比利·巴特森和其他孩子们虽然获得了超凡的神力和成人的外表，但仍处在青春期的他们还在学习如何平衡内心与外在的不同。但是当阿特拉斯的女儿——复仇三女神来到地球，寻找很久以前被偷走的神力时，比利·巴特森和家人们将为了守护他们的超能力、生命以及整个世界的命运而展开一场激战。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"罪恶黑名单 第十季 第四集 鬣狗","url":"/zh-CN/cb67adde2c77/","content":"\n剧情介绍　　雷德试图解锁一位已故金融家的遗产，这笔财富被一系列复杂线索所保护。当一名致命刺客追逐这笔财富时，特工小组团结一致保护遗产的合法继承人。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"春分","url":"/zh-CN/f16c580852da/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  春分\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","春分"]},{"title":"曼达洛人 第三季 第四集 遗孤","url":"/zh-CN/f58f66d540b2/","content":"\n剧情介绍　　丁·贾林回到隐藏的曼达洛人集会所。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"闪电侠 第九季 第七集 狂野之梦","url":"/zh-CN/a7f027dfe0c4/","content":"\n剧情介绍　　Nia Nal 拜访了艾瑞斯，因为她需要艾瑞斯的帮助。当艾瑞斯和 Nia 陷入狂热的梦想并探索他们生活的不同可能性时，Barry、Chester、Allegra 和 Cecile 拼命想帮助他们。与此同时，Mark 招待 Khione，但他们对什么是有趣有不同的看法，让 Khione 觉得 Mark 试图让她成为她不喜欢的东西。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"曼达洛人 第三季 第五集 强盗","url":"/zh-CN/382f45d3ddf4/","content":"\n剧情介绍　　尼瓦罗的居民需要保护以抵御猖獗的海盗袭击。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"罪恶黑名单 第十季 第五集  多克里案件","url":"/zh-CN/f28794a6b6a0/","content":"\n剧情介绍　　围绕一名法官被谋杀的调查揭示了一起未解案件的新线索。当雷德与FBI的合作关系曝光时，他与一位值得信赖的同事的关系陷入险境。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"龙与地下城：侠盗荣耀","url":"/zh-CN/72b4dd9faff1/","content":"\n剧情介绍　　艾德金（克里斯·派恩 Chris Pine 饰）是一名吟游诗人，在一次盗宝行动中，他的贪婪导致了妻子的死亡。之后，野蛮人霍尔盖（米歇尔·罗德里格兹 Michelle Rodriguez 饰）出现在了颓废的艾德金身边，和他共同抚养女儿琪拉（克洛伊·科尔曼 Chloe Coleman 饰）。\n　　琪拉长大之后，艾德金、霍尔盖带着琪拉和她的舅舅福奇（休·格兰特 Hugh Grant 饰）等人组成了一支盗宝团队，哪知道在一次行动之中失手了，最终，艾德金和霍尔盖锒铛入狱。一晃眼多年过去，艾德金和霍尔盖联手越狱，并且决定夺回他们当年未得手的宝物，为了达成目的，他们还吸纳了菜鸟术士西蒙（贾斯蒂斯·史密斯 Justice Smith 饰）和德鲁伊女孩多立克（索菲娅·莉莉丝 Sophia Lillis 饰）。就在艾德金一行人离宝物越来越近之际，当年带着琪拉逃跑的福奇，他的真面目也渐渐的展露了出来。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"罪恶黑名单 第十季 第六集 莱肯·佩里洛斯医生（二）","url":"/zh-CN/4478cb211829/","content":"\n剧情介绍　　当拉肯·佩里洛斯博士重现并加入吴京对抗雷德的行动时，特工小组的一名成员陷入危险之中。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"曼达洛人 第三季 第六集 雇佣枪手","url":"/zh-CN/7c251dd83365/","content":"\n剧情介绍　　曼达洛人访问了一个奢华的世界。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"清明","url":"/zh-CN/70cecb228caa/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  清明\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","清明"]},{"title":"超级马力欧兄弟大电影","url":"/zh-CN/a0e7b3af8243/","content":"\n剧情介绍　　马力欧（克里斯·帕拉特 Chris Pratt 配音）和路易吉（查理·戴 Charlie Day 饰）是生活在布鲁克林的两名水管工，他们刚刚成立了自己的小公司，但很显然，他们的家人并不完全支持兄弟两人的这份事业。某日，在工作中，马力欧和路易吉被水管吸入到了一个光怪陆离的世界之中，两人在旅途中被迫分开，马力欧来到了由碧姬公主（安雅·泰勒-乔伊 Anya Taylor-Joy 配音）统治的蘑菇王国，而路易吉则不幸的被传送到了由酷霸王（杰克·布莱克 Jack Black 配音）统治的库巴王国。\n　　此时，酷霸王正准备大举进攻蘑菇国，掳走公主并和她结婚，在这个节骨眼上，马力欧的出现带给了碧姬公主希望，她带着马力欧来到了丛林王国，请求那里的国王和王子（塞斯·罗根 Seth Aaron Rogen 饰）的支援。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"闪电侠 第九季 第八集 时间的伴侣","url":"/zh-CN/7e879d7092b2/","content":"\n剧情介绍　　星城实验室看似简单的模具检查实验室会导致意想不到的时间异常。巴里和艾瑞斯试图弄清困惑，并想办法回到现实。 Chester向Allegra坦白了一个秘密，这让两人的关系变得尴尬，而Allegra则依靠Cecile充当缓冲。与此同时，Khione 会见了闪电小队的一位老朋友。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"曼达洛人 第三季 第七集 探察者","url":"/zh-CN/12dc3ab96f0c/","content":"\n剧情介绍　　幸存者们从隐匿中走出。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"罪恶黑名单 第十季 第七集 自由职业者（二）","url":"/zh-CN/f50b27a07b6c/","content":"\n剧情介绍　　 “自由职业者”的回归揭示了一个涉及本地摄影师的阴谋。雷斯勒达成了一个个人里程碑。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"罪恶黑名单 第十季 第八集 喷子农夫（二）","url":"/zh-CN/2f741cd80b55/","content":"\n剧情介绍　　特工小组调查了一系列通过社交媒体模拟危险公众攻击的阴谋。当一项绝密政府计划被盗时，团队试图揭开“巨魔农场”的参与真相。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"曼达洛人 第三季 第八集 回归","url":"/zh-CN/1bb0e8668bb1/","content":"\n剧情介绍　　曼达洛人和他的盟友对抗他们的敌人。\n\n","categories":["剧集"],"tags":["日常","Disney Plus"]},{"title":"阿凡达：水之道","url":"/zh-CN/26cc5e745a46/","content":"\n剧情介绍　　这一天，身材高大，对篮球有着无限执着的赤木刚宪（三宅健太 配音）、从高一起就担任球队主力的超级新星流川枫（神尾晋一郎 配音）、初中时代曾获得MVP荣誉，在高中时代重新拾起了对篮球的热情的三井寿（笠间淳 配音）、身材矮小却拥有着惊人的速度和高超的运球技巧的宫城良田（仲村宗悟 配音），以及高中时代才开始接触篮球，却拥有着强大的爆发力和无限潜力的樱木花道（木村昴 配音），湘北篮球队的这五人终于站上了全国大赛的赛场，他们所要面对的，是日本最强球队山王工业。\n　　和激烈的篮球赛同时叙述的，是宫城良田的一生，他从哥哥那里继承了对篮球的激情和信念，却一直都活在优秀的哥哥的阴影之下。该动画电影由漫画《灌篮高手》的原作者井上雄彦亲自操刀，为所有人的青春画下浓墨重彩的句点。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"林俊杰 重拾_快乐","url":"/zh-CN/7ef6f9d14e95/","content":"\n专辑介绍廿年明星路，赢够金曲名。2003 年，钢琴敲响《冻结》饱蘸回忆的前奏，十年后，《修炼爱情》的琴声与弦乐交织成一片磅礴。如今出道 20 周年的林俊杰，在新专辑《重拾_快乐》里，再次诠释常伴他音乐生涯的慢板抒情风格。《一时的选择》《如果我还剩一件事情可以做》几首典型的抒情歌仍是他个人擅长风格的担当，瞬间拉满怀旧情愫。《愿与愁》中极致的钢琴编曲，简洁并如流水般进行的音符，加上带有古风的歌词，很容易让人联想起旧歌《关键词》。包含 20 周年纪念作品《7千3百多天》在内，专辑多处可见对过往人与事的致敬，如《谢幕》中的“圈圈圆圆圈圈”虽让人“梦回”《江南》，但这首歌并未着眼在痴情小爱，它被献给音乐上的老师、台湾词人林秋离，以此缅怀英雄的“谢幕”。\n回望初心的同时，林俊杰对声响的探索仍在持续，《逆光白》明亮的合成器音色、贴近 Synth-Pop 的风格，颇有邀请歌迷一起大声高唱的势头。 与方文山合作写词的《梦不凌乱》意料之外地“不走”中国风路线，而是在 Trap 重拍上点缀以电吉他和 Autotune 音效，即使是 JJ 的死忠歌迷都能为之惊喜。 此前与格莱美奖常胜将军 Anderson .Paak 合作的《In The Joy》，以国语独唱版《你都在》收录进专辑，终曲《Castle in the Air》则与开篇曲《愿与愁》形成映照，就像过去的《害怕》&#x2F;《Endless Road》、《伟大的渺小》&#x2F;《Until The Day》等作品，再一次展现了他双语创作的功力。\n20 周年并不是一条简单的路，林俊杰的《重拾_快乐》苦乐参半，有心碎、别离、有省思也有欢愉。接下来，有请林俊杰为 Apple Music 用户亲自讲述。\n“重拾_快乐”指什么，英文专辑名称“Happily, Painfully After”又指什么？现阶段进入录音室做专辑，最快乐、最有挑战的又是什么？“我发现 ‘快乐’ 在我们生活的过程中，是会被重新定义的。专辑中的  ‘重拾’ 代表的比较是一种进行式，而非过去式。出道 20 年，我认为是一个圆满，也是一种重启，而这个重启对我来说，是往什么方向，还是个未知数，所以才会在重拾之后加一个’_’。我认为， ‘Happy’ 跟 ‘Pain’ 在所有人的生命中是必然共存的，但不是所有人都意识到这是现实生活中必须承担的。其实我们越能够坦然面对完整的自己，就越接近真正的快乐。\n在录音室里，最快乐的事就是能够天马行空地把想表达的情感和故事投放到歌里面。”\n《逆光白》《梦不凌乱》和《7千3百多天》带来新鲜的声音，比如合成器与弦乐的配合，Trap 感觉的节奏等，这两年你有什么喜欢的音乐人与制作人，又在钻研什么呢？“近几年，我一直沉浸在 Urban、Funk、Old School 的音乐风格，而这次围绕着 JJ20、20 周年的主题，一直在强调 80s 的 sound palette。我希望让无论是演唱会的视觉或专辑的编曲和音色都可以走比较 retro 的味道。而 The Weeknd、Post Malone、Harry Styles 是我认为在近几年把这类风格驾驭的非常到位的几位在线音乐人，我非常欣赏并从中得到音乐素质的养分。”\n乐迷非常喜爱你的慢板情歌，在做专辑时，你会不会特别考虑大众喜欢的风格？“慢板情歌一向来都是我认为最适合自己的音乐风格，也能让我在唱方面最直达内心深处。与其说为了照顾大众的喜好，更像是我认为慢板情歌是华语音乐最具代表性的音乐风格。过程当中当然也希望能带给听众新颖但不刻意的元素、以真实情感的表达来带入更深切的听觉飨宴。”\n专辑中还有哪首歌有特别的意义或故事呢？“《Castle In The Air》。很多人或许会认为这是《愿与愁》的英文版。但在我心中，这首歌才是整张专辑最接近我内心的歌曲。而我是先写了《Castle In The Air》，然后才花了不少心思和时间，试了几个不同老师们的不同版本词，最后才有了中文版小寒的《愿与愁》。\n专辑其实有一个小巧思，就是我设计的曲序其实是呼应着专辑封面的循环概念。而我的“隐藏版曲序”，其实是从第11首开始，到叙述往第一首的方向听。”\n出道 20 周年，有什么想对乐迷说的话？亦或这张专辑是给自己的一个交待？“这张专辑是一张写给20年来的听众和歌迷的一封长信，也是我纪念这个过程的一张音乐作品。以往，每一次完成一张专辑之后，我都会开始想，下一次要怎么延续这次的故事。但这次在整个制作过程反而回归一种纯粹，回到一种 ‘做音乐可以很快乐’ 这件事；不需要迎合什么、不需要交代什么。我把这次的专辑当作是最后一次在做，不留遗憾，把想说的尽量不透过任何滤镜，写进歌里。”\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","林俊杰"]},{"title":"罪恶黑名单 第十季 第九集 喷子农夫（三）","url":"/zh-CN/9d9a6a8e870b/","content":"\n剧情介绍　　特工小组争分夺秒寻找被盗的美国政府重要资产。雷德策划了一项计划，帮助追踪肇事者。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"谷雨","url":"/zh-CN/2eb7f6a31a08/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  谷雨\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","谷雨"]},{"title":"闪电侠 第九季 第九集 我的派对我想死就死","url":"/zh-CN/070bc698313e/","content":"\n剧情介绍　　闪电小队为巴里举办了一场惊喜生日派对，但拉姆齐·罗索破坏了庆祝活动，事情变得非常糟糕。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"Apple 深圳万象城","url":"/zh-CN/9e9932511beb/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple 深圳万象城\n  欢迎每个开放的心\n\n\n\n  \n\n\n\n","categories":["零售店"],"tags":["Apple","Retail"]},{"title":"罪恶黑名单 第十季 第十集 邮差","url":"/zh-CN/c9e47be5ef4e/","content":"\n剧情介绍　　在一座高度安全的监狱中，一名囚犯开火后，特工小组调查了一个名为“邮差”的走私者。库珀重新审视了自己与嫌疑人的过往关系。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"闪电侠 第九季 第十集 新世界（1）","url":"/zh-CN/2ab09b74a6ed/","content":"\n剧情介绍　　当艾瑞斯收到职业里程碑的消息时，巴里突然不知所踪。在试图回家的过程中，巴里遇到了许多熟悉的面孔。 Khione 继续探索她的力量，Chester 为 Allegra 制作套装。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"立夏","url":"/zh-CN/919333424693/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立夏\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立夏"]},{"title":"银河护卫队3","url":"/zh-CN/17b1b23e5a34/","content":"\n剧情介绍　　历经磨难与考验，银河护卫队总算在虚无之地暂时安顿下来。可就在某一天，不速之客亚当术士（威尔·保尔特 Will Poulter 饰）的闯入不仅打破了这里的安宁与祥和，更将一场生死危机带到这群好朋友中间。战斗中，火箭浣熊（布莱德利·库珀 Bradley Cooper 配音）身负重伤，奄奄一息。为了拯救好友的生命，星爵（克里斯·帕拉特 Chris Pratt 饰）和星云（凯伦·吉兰 Karen Gillan 饰）、毁灭者（戴夫·巴蒂斯塔 Dave Bautista 饰）、螳螂女（庞·克莱门捷夫 Pom Klementieff 饰）、格鲁特（范·迪塞尔 Vin Diesel 配音）卡魔拉（佐伊·索尔达娜 Zoe Saldana 饰）前往创造了火箭的奥果公司寻找起死回生的办法。\n　　然而在那个诡异的世界，他们意外发现了火箭浣熊不为人知的悲惨过往……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"罪恶黑名单 第十季 第十一集 戴帽子的男人","url":"/zh-CN/48308ad98abe/","content":"\n剧情介绍　　当雷德被认为可能在费城一家熟食店抢劫案中沦为人质时，登贝和雷斯勒迅速采取行动。在华盛顿，帕纳贝克参议员评估特工小组与雷德的合作，而西亚则深入挖掘母亲的过去。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"罪恶黑名单 第十季 第十二集 迈克尔·阿巴尼医生","url":"/zh-CN/3631f014b273/","content":"\n剧情介绍　　登贝在接到一通来自旧日联系的令人担忧的电话后，回顾了自己复杂的过去。一名有抱负的国会议员开始质疑特工小组的运作。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"闪电侠 第九季 第十一集 新世界（2）","url":"/zh-CN/963b4f5b9c16/","content":"\n剧情介绍　　艾瑞斯对巴里的失踪感到震惊，Cecile 向她保证一切都会好起来的，但她真的知道这一点吗？闪电小队受到一种神秘物质的影响，喀俄涅对她能控制和不能控制的事情有了更好的理解。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"速度与激情10","url":"/zh-CN/4b4aae8c3474/","content":"\n剧情介绍　　在完成了无数任务，克服了各种不可能的困难之后，唐老大（范·迪塞尔 Vin Diesel 饰）和他的家族以智慧、勇气和速度过五关斩六将，打败了一路上的所有敌人。如今，他们面对的是一名危险至极的对手：这个从过往阴影中浮出水面的具有致命威胁的人物，誓要报偿血海深仇，决心破坏这个家族，彻底摧毁唐老大所热爱的一切及其至亲至爱之人。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"闪电侠 第九季 第十二集 新世界（3）","url":"/zh-CN/b4f27b3672d0/","content":"\n剧情介绍　　闪电小队齐心协力想办法保护巴里，同时非常小心他们所信任的人。一次不成功的尝试后，塞西尔对该计划持怀疑态度。 喀俄涅对 Chester 的信心使他能够说服 Cecile 再试一次。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"梁静茹 麋鹿","url":"/zh-CN/7b7c5a027f5f/","content":"\n专辑介绍从初尝人生酸甜的《迷路》，到历经岁月磨练后化身自由的“麋鹿”，巧妙的谐音联系起了新歌和旧作。听这张专辑时，容易在脑海中想象出一个疗愈系的成长故事：1999 年，一个女生背井离乡茕茕一人到台湾发展，在首张专辑《一夜长大》中的清新民谣《迷路》中，失恋的她还在怯懦地找寻着自我。时隔多年，那个曾在李宗盛羽翼下试声的女孩，已接过叙事的主导，比起当年在纯情中进退，现在的梁静茹酣畅淋漓，她在合成器推进的高亢氛围底色中，抒发迷路后积淀起来的自信和自由，无畏无惧。\n时间的积淀让梁静茹不断推翻和验证“长大”的概念。年少时她体会过李宗盛笔下女孩因为爱而“一夜长大”的阵痛感，而如今由周兴哲和姚若龙为她执笔创作的《大人》，则将长大重新诠释为一个漫长的过程。怀旧这种情绪会随着人越长大而越发明显，歌手在作品中的自我致敬也无可厚非，但梁静茹并不是要通过《麋鹿》走一条贩卖情怀的捷径，专辑在音乐性上的推陈出新正是对“成长感”生动的体现。当《天气预报》低调纯净的吉他召回过去李宗盛妙手下的清新质朴，我们听到的并不是对往昔的复刻，而是在无华的卧室絮语中对成熟女性日常生活化一面的诠释。\n反其道而行之，《关于爱，别人说的都不算》借力大编制管弦乐团，用繁复的声色渲染情绪，让跳跃的琴键说出“每一次受伤会让我更勇敢”。无论是《来日不方长》借箫声蔓延人生的沧桑和通透，还是在韦礼安创作的《误读》中尝试潇洒自如的摇滚，都让梁静茹搭乘上风格迥异、疾缓不同的音乐顺风车，描绘出她内心那一头或悠然或欢欣的麋鹿。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","梁静茹"]},{"title":"小满","url":"/zh-CN/4f0fa9eccecc/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小满\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小满"]},{"title":"闪电侠 第九季 第十三集 新世界（4）","url":"/zh-CN/0f4db8756ce3/","content":"\n剧情介绍　　闪电侠是世上跑得最快的人，他肩负着迄今为止最大的挑战，即拯救时间线和拯救存在。新老朋友齐聚一堂，为拯救中心城展开一场史诗般的战斗，这是最后一次。\n\n","categories":["剧集"],"tags":["日常","The CW"]},{"title":"罪恶黑名单 第十季 第十三集 西西里邮票异色版","url":"/zh-CN/d4f73b3e12d5/","content":"\n剧情介绍　　在陪伴雷德完成一系列不寻常任务时，西亚更多地了解了米拉的过去。哈德森议员试图说服一位强大的朋友加入他反对特工小组的行动。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"罪恶黑名单 第十季 第十四集 流浪新娘","url":"/zh-CN/d3024162410f/","content":"\n剧情介绍　　特工小组调查一名失踪的新婚人士的下落。雷德向一位强大的贩毒集团领导提供帮助。西亚拜访了一位与她母亲过去有关的联系人。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"罪恶黑名单 第十季 第十五集 帽子戏法","url":"/zh-CN/18a5ee574967/","content":"\n剧情介绍　　为了向哈德森议员证明自己的价值，雷德为特工小组提供了三个深藏秘密的犯罪案件。雷斯勒帮助一位朋友和解。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"罪恶黑名单 第十季 第十六集 布莱尔·福斯特","url":"/zh-CN/6b387e123315/","content":"\n剧情介绍　　当一名腐败律师被发现与一系列企业掩盖丑闻有关时，雷德协助团队调查她的运营；帕纳贝克参议员和库珀等待法官对特工小组未来的裁定。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"Apple 2023 全球开发者大会","url":"/zh-CN/1572e1d905a0/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  飞码来报\n\n\n\n  \n\n\n\n  码出新宇宙\n\n\n\n  快码加鞭，一点到。\n\n\n\n  \n\n\n\n  快码加鞭，一点到。\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["开发者大会"],"tags":["Apple","WWDC"]},{"title":"变形金刚：超能勇士崛起","url":"/zh-CN/1ac8a4fcec1a/","content":"\n剧情介绍　　1994年，美国纽约。退役军人诺亚·迪亚兹（安东尼·拉莫斯 Anthony Ramos 饰）为了给弟弟治病而四处求职，却不断碰壁，情急之下他铤而走险，打算偷车销赃赚钱。谁曾想第一单就偷了变成汽车形态的博派战士幻影（皮特·戴维森 Pete Davidson 配音），随即卷入宇宙层级的大战争中。原来宇宙中游弋着被称为灭世邪神的恐怖之王宇宙大帝（科尔曼·多明戈 Colman Domingo 配音），它靠不断吞噬其他能源富足的星球补充能量，为此急需要能够折叠空间的“超曲速钥匙”来满足贪欲。此前数千年，被宇宙大帝灭亡家园的擎天圣（朗·普尔曼 Ron Perlman 配音）带着钥匙逃到地球，而他们的踪迹终于被宇宙大帝及其爪牙天灾（彼特·丁拉基 Peter Dinklage 配音）发现。\n　　于是，地球人、汽车人、巨无霸联合起来，与来犯的强敌展开对抗……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"芒种","url":"/zh-CN/ec4aa3299640/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  芒种\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","芒种"]},{"title":"MacBook Air 15 英寸（M2，2023年）","url":"/zh-CN/882bb9739c24/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  MacBook Air\n  巨给力，\n  巨纤薄。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"Mac Studio（M2 Max，M2 Ultra，2023年）和 Mac Pro（M2 Ultra，2023年）","url":"/zh-CN/c9b9ab2ccbc2/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Mac Studio\n  动力动真格\n\n\n\n  \n\n\n\n  Mac Pro\n  由 Apple 芯片重塑\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"罪恶黑名单 第十季 第十七集 摩佳纳物流公司","url":"/zh-CN/22b7c4054edd/","content":"\n剧情介绍　　特工小组发现了一个全球范围内运送违禁品的虚假公司网络。哈德森议员的调查升级，他从FBI内部招募了帮助者。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"闪电侠","url":"/zh-CN/cdf9d101e2db/","content":"\n剧情介绍　　自从成为正义联盟中的一员，闪电侠巴里（埃兹拉·米勒 Ezra Miller 饰）便成为一个日夜忙碌的超级英雄。可是虽然他已经具备了拯救世人的非凡能力，却依旧对自己既定的命运束手无策。父亲弑妻案（朗·里维斯顿 Ron Livingston 饰）复审在即，关键证据又无法有效 佐证。由于之前对战荒原狼时曾短暂超越光速穿越时空，巴里不顾蝙蝠侠（迈克尔·基顿 Michael Keaton 饰）的劝阻，一路穿越到母亲遇害的那一天。他原本以为通过不起眼的小动作能够拯救母亲，却不曾想宇宙因为这个意外转折而发生蝴蝶效应。当巴里回到自己变成闪电侠的前夕，他发现父母健康快乐的生活，而海王、钢骨、戴安娜等超级战士似乎缺席了这个时代。\n　　更糟糕的是，追杀超人的佐德将军（迈克尔·珊农 Michael Shannon 饰）降临地球，他将在毫无阻碍的情况下毁灭世界……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"夏至","url":"/zh-CN/9da1a4624b9a/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  夏至\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","夏至"]},{"title":"罪恶黑名单 第十季 第十八集 蒿草拉斯洛·杨科维奇","url":"/zh-CN/42b63d231724/","content":"\n剧情介绍　　雷德试图调解两个敌对家族之间的会面，但事态急转直下，酿成惨剧。当一名难以捉摸的罪犯与事件有关时，特工小组争分夺秒拯救雷德及其同伴。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"神都不良探","url":"/zh-CN/61e8f1bed470/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","实体","SONY","PlayStation","光盘"]},{"title":"罪恶黑名单 第十季 第十九集 417 号房","url":"/zh-CN/f96e63a84e03/","content":"\n剧情介绍　　雷德的一个神秘线索引导特工小组发现了美国政府内部的安全漏洞。哈德森议员采取重大行动，试图揭开特工小组的内部运作。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"罪恶黑名单 第十季 第二十集  亚瑟·哈德森","url":"/zh-CN/d75aca64338d/","content":"\n剧情介绍　　库珀在被司法部长召唤时陷入防守姿态。雷德探望了一些挚友。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"Taylor Swift Speak Now（Taylor's Version）","url":"/zh-CN/a0ffebd2e3c5/","content":"\n专辑介绍“你知道，现实生活总是很有意思的。”Taylor Swift 在 2010 年专辑《Speak Now》的唱片内页里写道。《Speak Now》是她的第三张专辑，也是她多年后为了收回母带所有权而选择重录的第三部作品。“有时候你得保持沉默，有时候你得等待机会。但如果你已经明白自己的感受、清楚地知道自己需要表达什么，你肯定能感觉到时机的来临。”\nSwift 独自包揽了专辑《Speak Now》的歌曲创作，成稿于巡演期间。彼时她刚过 20 岁，还在摸索如何从成年人的视角与艺术家的身份出发，找到自己的音乐风格。这一次录制新版专辑时，Swift 选择忠于原版专辑，也忠于年轻时的自己。她与 Fall Out Boy 和 Paramore 主唱 Hayley Williams 分别合作了“From the Vault”系列曲目《Electric Touch》《Castles Crumbling》，向这两组影响自己早期创作的音乐人致敬。虽然她将新版专辑的制作人从纳什维尔的 Nathan Chapman 换成了近期经常合作的 Jack Antonoff 和 Aaron Dessner，但编曲继承了温暖清澈的风格，而且比原版更加质朴，亦兼具她日后杂糅多元曲风的流行视野。如今，我们都知道 2012 年的《Red》对 Swift 来说意味着什么，但回顾《Speak Now》的歌曲，我们其实已经可以预见她日后的发展。\n《Speak Now》的美妙之处在于用简洁的歌曲道出复杂的情感。Swift 诚实地展现了自己脆弱的一面，她同时也充满力量（《Mean》）；她依然天真，但也知道什么时候该负起责任（《Dear John》）；她明智地承认错误（《Back to December》），也葆有发现他人闪光点的一面（《Innocent》）；当然，她渴望成长和独立（《Speak Now》），但她独自搬进新公寓时仍然会哭泣——不仅是因为想念儿时的家，也是因为知道自己永远无法再回到那个时候了（《Never Grow Up》）。\n这张专辑曲风大气，同时也有许多值得玩味的细节。比如在流行朋克风的《Better Than Revenge》当中，她写道情敌觉得她疯了，因为 Swift 喜欢用她的名字押韵。Swift 作品中这种大与小、简明与晦涩的平衡，让她在众多当代流行创作人中脱颖而出，成为初涉成人生活的同龄人们厘清复杂情感的指路明灯。\n当然，能与她产生共鸣的不仅是懵懂少年。Swift 之所以特别，就是因为她本能地知道所有人都会经历她所写的伤痛。在专辑《Fearless》的内页里，她表明自己相信白马王子以及永远幸福的童话能够带给自己的力量；而在《Speak Now》里，大部分的“白马王子”徒有其表，她也终于明白，真正让人永远幸福的是爱过这些人之后，你所获得的智慧与坚韧。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","Taylor Swift"]},{"title":"小暑","url":"/zh-CN/a6419bb0b148/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小暑"]},{"title":"罪恶黑名单 第十季 第二十一集 雷蒙德·雷丁顿（一）","url":"/zh-CN/b2f85e6600e6/","content":"\n剧情介绍　　特工小组与哈德森及其手下的对峙升级，他们追捕总是领先一步的雷德。而祖玛的越轨行为被摄像头记录下来。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"罪恶黑名单 第十季 第二十二集 雷蒙德·雷丁顿（二）","url":"/zh-CN/155b7a2fe05c/","content":"\n剧情介绍　　FBI雷丁顿特工小组的未来被最终决定。\n\n","categories":["剧集"],"tags":["日常","NBC"]},{"title":"大暑","url":"/zh-CN/1b61cb0dd118/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大暑"]},{"title":"妖怪手表4强化之章","url":"/zh-CN/5bc00ef20f83/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"立秋","url":"/zh-CN/8f5a374dfe0d/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立秋\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立秋"]},{"title":"处暑","url":"/zh-CN/ad4140f4637d/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  处暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","处暑"]},{"title":"奥本海默","url":"/zh-CN/1355d39bdeef/","content":"\n剧情介绍　　当我们为权力金钱焦虑、兴奋与愤怒时，却根本想象不到“他们”在谈论着怎样更重要的事情。\n　　随着战争阴云笼罩世界上空，各国紧锣密鼓抓紧军事竞赛。为了抢占先机，美国陆军中将莱斯利·格罗夫斯（马特·达蒙 Matt Damon 饰）找到量子力学与核物理学领域的扛鼎人物罗伯特·奥本海默（基里安·墨菲 Cillian Murphy 饰），力荐其担任曼哈顿计划的首席科学家以及洛斯阿拉莫斯国家实验室的总负责人。经过两年争分夺秒的研发，硕大的蘑菇云终于在荒原的上空腾起，也宣告着绞肉机一般的二战即将落下帷幕。奥本海默有如将火种带到人间的普罗米修斯，可是对人性的参悟和对未来的担忧迫使他走向与政府相悖的道路。更可悲的是，凡人钟情的物欲也将一世天才裹挟至炼狱之中，永世燃烧……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"Microsoft 次世代 XBOX（黑色）上市","url":"/zh-CN/72897b5724f7/","content":"\n主机介绍这款 Xbox Series S 磨砂黑除了颜色的变化外，还升级了存储，由原来的 512GB 提升至 1TB，与 Xbox Series X 是一样的。\nXbox Series S 搭载了台积电 7nm 工艺制造的 AMD 定制芯片，采用了 8 核心 16 线程的 Zen 2 架构 CPU，频率为 3.6 GHz，以及采用了 RDNA 2 架构的 GPU，CU 数量分别为 20 个，频率为 1.565 GHz，对应的 GDDR6 内存为 10GB，搭载的 PCIe 4.0 SSD 容量为 512GB 或 1TB，支持 HDMI 2.1 输出。作为次时代家用游戏机，Xbox Series S 支持众多新特性，包括硬件级加速光线追踪、DirectML 机器学习、VRS 可变速率着色、可变刷新率、向后兼容性等。\n展示\n\n\n","categories":["游戏"],"tags":["主机","国行","Microsoft","XBOX"]},{"title":"白露","url":"/zh-CN/40da7810c11f/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  白露\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","白露"]},{"title":"Apple 特别活动","url":"/zh-CN/c98c2227e90c/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["发布会"],"tags":["Apple","Apple Event"]},{"title":"iPhone 15 Pro（A17 Pro，2023年）、iPhone 15（A16，2023年）和 AirPods Pro（H2，USB-C，2023年）","url":"/zh-CN/30b9399c65f3/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  iPhone 15 Pro Max | iPhone 15 Pro\n  钛金属\n\n\n\n  \n\n\n\n  iPhone 15 Plus | iPhone 15\n  开新的，超开心。\n\n\n\n  \n\n\n\n  AirPods Pro\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPhone","AirPods"]},{"title":"秋分","url":"/zh-CN/f029169ea5af/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  秋分\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","秋分"]},{"title":"Apple Watch Ultra 2（S9，2023年）和 Apple Watch Series 9（S9，2023年）","url":"/zh-CN/226154f3f057/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple Watch Ultra 2\n  野出新维度\n\n\n\n  \n\n\n\n  Apple Watch Series 9\n  智能加成，\n  加亮加实力。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Watch"]},{"title":"YOASOBI THE BOOK 3","url":"/zh-CN/c2c6d8212f33/","content":"\n专辑介绍延续着一贯戏剧张力满满的曲风，日本组合 YOASOBI 的第三张 EP《THE BOOK 3》仍旧带有他们的个性标签：鲜活明快的节奏、琅琅上口的旋律，让这张 EP 中的歌曲富有辨识度和记忆度。在本作中，YOASOBI 继续实践组合初创时“将小说音乐化”的初衷，与直木奖（日本顶尖大众文学奖项）获奖作家展开合作：《海のまにまに》灵感源于辻村深月的作品，主歌中干净、极简的编排，铺展开一幅少女离家出走至海边的孤独画面。《セブンティーン》改编自宫部美雪的小说，以金属核音乐表现家庭关系中的扭曲和拉扯。除小说外，YOASOBI 的音乐也与动漫相得益彰，《アイドル》受到漫画、动画作品《【我推的孩子】》的启发，他们以福音合唱，宏伟的管弦乐、昂扬的 rap 烘托粉丝的狂热心境和欲望、偶像的狂妄与野心，批判偶像文化中的乱象。同时，这张 EP 也复刻了“电光石火”演唱会上的场景——《Interlude “Awakening”》排列在《祝福》之前，《Interlude “Worship”》排列在《アイドル》之前，分别无缝衔接，重现了演唱会现场的高昂气氛。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","YOASOBI"]},{"title":"寒露","url":"/zh-CN/be8f694470f6/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  寒露\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","寒露"]},{"title":"霜降","url":"/zh-CN/6e140f0f7331/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  霜降\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","霜降"]},{"title":"Taylor Swift 1989（Taylor's Version）[Deluxe]","url":"/zh-CN/c51b004bda3e/","content":"\n专辑介绍《1989 (Taylor’s Version)》终于快要问世时，Taylor Swift 提到，在她为夺回版权精心重录的所有专辑中，这一张有着特别的意义。“从各个层面上来说，《1989》改变了我的人生。”她在社交媒体上写道，“说实话，这是我最喜欢的重录专辑，因为这里面的 5 首‘From The Vault’（未发行版）歌曲是真的好听，我简直不敢相信当初它们竟然未被收录进专辑。”\n从唱着“我不必假装喜欢迷幻摇滚&#x2F;假装喜欢和那群满脑子要事的大人物一起&#x2F;待在豪华游艇上”（I don’t have to pretend I like acid rock&#x2F;Or that I’d like to be on a mega-yacht&#x2F;With important men who think important thoughts）的《Now That We Don’t Talk》，到《Say Don’t Go》和《Is It Over Now?》，我们可以真切体会到，Swift 在创作这 5 首歌曲时不仅专注、犀利，而且是在考虑新的受众这件事的。它们不仅完全值得入选最初的专辑，巩固 Taylor 身为“创作者”的角色，而且在这些从前被视为无关紧要，实则华丽精致的蒙太奇式作品里，Swift 表现得如此游刃有余，如同一位流行乐老匠人。\n距离原版专辑诞生已过将近十年，Swift 如今已是一举一动都能影响流行文化动向的巨星。而回首 2014 年，我们似乎很容易忽略，当时的 Swift 正迎来（或者说是“筹划”）自己生活和事业的转折点，野心勃勃地把刚满 24 岁的自己一步步塑造成我们今天熟悉的超级巨星。在 2010 年的《Speak Now》和 2012 年的《Red》里，她已经开始调整专辑中乡村乐和流行乐的比重，并在后一张专辑里和瑞典超级制作人 Max Martin 与 Shellback 搭档。到了《1989》，她也不再去特地思考“比重”了，想做什么就做什么，在流行音乐的道路上一往无前。她不仅拥抱了强劲节拍和华丽制作，更在专辑中欣然注入了轻松活泼的感觉。\n《1989》不只埋藏着 Swift 转型的野心。如果说《Speak Now》和 2008 年的《Fearless》内含莎翁戏剧般的张力，那么《1989》的 Swift 就是张扬的、自信的，她大口呼吸着自由的空气（《Style》），也尽情狂想（《Wildest Dreams》），年轻时的她还做不到如此从容。《Welcome to New York》是鎏金的欲望叙事，她决心在这座潜藏无尽可能性的城市里让自己重获生机——“灯光如此明亮，但从未让我失明”（The lights are so bright&#x2F;But they never blind me,me）。Swift 借这首歌向大家宣布，她至少目前要挥别纳什维尔和乡村乐，也脱离了它们为她的形象和风格带来的桎梏。Swift 迈步的姿态昂首挺胸——《Shake It Off》里的她对过去的恩怨一笑置之，心态成熟而自在；甚至在《Blank Space》里，她调侃起自己来了，要知道这几乎曾是个“不可说”的话题啊。\n《1989》与 Shania Twain 的《Come On Over》、Bob Dylan 的《Bringing It All Back Home》类似，也是艺人故意跟众人期待反着来，最终仍然获得成功的范例。正如标题所示，出生在 80 年代末的 Swift 并不是听着 80 年代的合成器风格流行乐长大的，不过在 Martin、Shellback、Ryan Tedder 和后来的好搭档 Jack Antonoff 的帮助下，80 年代风格在这张专辑里还是处处可循。正如她在早期专辑里颠覆了乡村乐的传统和定式，Swift 没有把充满怀旧气息的《1989》用来回顾过去，而是以之为起点，大步向前。\n2014 年，Taylor Swift 站在事业转型的十字路口，年仅 24 岁的她，正是从那时开始，一步步将自己打造成了我们今天熟悉的超级巨星。在 2010 年的《Speak Now》和 2012 年与瑞典超级制作人 Max Martin、Shellback 合作的《Red》里，她已经开始调整乡村乐和流行乐的比例。而在这张《1989》里，Swift 彻底将“比例”的问题抛到了九霄云外，放手拥抱流行风格。\n正如《Come On Over》之于 Shania Twain、《Bringing It All Back Home》之于 Bob Dylan，《1989》也是反抗预设且大获成功的典范之作。正如标题所示，出生于 80 年代末的 Swift 并不是听着 80 年代合成器音乐长大的，但在制作人 Martin、Shellback、Ryan Tedder，以及后来成为她挚友的 Jack Antonoff 的帮助下，专辑弥漫着 80 年代风情。Taylor Swift 曾在早期专辑里颠覆了乡村乐传统，这张《1989》也同样如此：怀旧的风格并不是为了用来回顾过去，而是推动自己大步向前。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","Taylor Swift"]},{"title":"Apple 特别活动","url":"/zh-CN/a42c6e69a462/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["发布会"],"tags":["Apple","Apple Event"]},{"title":"Apple Pencil（2023年）","url":"/zh-CN/23ae4f944577/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple Pencil\n  \n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Pencil"]},{"title":"Apple 温州万象城","url":"/zh-CN/2a07d4b2225a/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple 温州万象城\n  初来温州问声好\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["零售店"],"tags":["Apple","Retail"]},{"title":"MacBook Pro（M3，M3 Pro，M3 Max，2023年）","url":"/zh-CN/cd05740540ae/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  MacBook Pro\n  狠角色，很绝色。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"立冬","url":"/zh-CN/7ced53955af4/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立冬\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立冬"]},{"title":"iMac 24 英寸（M3，2023年）","url":"/zh-CN/4156dbfa0445/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iMac\n  超能力暴涨\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"小雪","url":"/zh-CN/e27580628c9b/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小雪\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小雪"]},{"title":"SONY 次世代 PlayStation（轻薄版）上市","url":"/zh-CN/b5b44f2ba419/","content":"\n主机介绍与前机型相比，PlayStation 5（轻薄版）体积减少了30% 以上，重量也分别减轻了18% 和24%。主机盖分成四片独立面板，顶部采用亮面外观，底部则仍保持雾面设计。如购买PlayStation 5（轻薄版）数字版，可在日后加购专用超高清蓝光光驱。\n展示\n\n\n","categories":["游戏"],"tags":["主机","国行","SONY","PlayStation"]},{"title":"有氧拳击2拳力舞动","url":"/zh-CN/e2e1ce6f0d2f/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"大雪","url":"/zh-CN/72df4cbe56ee/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大雪\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大雪"]},{"title":"34岁生日快乐","url":"/zh-CN/7843c5508c23/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  生日快乐\n\n\n\n  \n    \n  \n\n\n\n","categories":["纪念日"],"tags":["日常","生日"]},{"title":"灵活脑学校","url":"/zh-CN/20ea00df21c1/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"冬至","url":"/zh-CN/657ef2df3431/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  冬至\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","冬至"]},{"title":"元旦","url":"/zh-CN/871903fbb6c0/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  元旦快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","元旦"]},{"title":"小寒","url":"/zh-CN/d210a6f59098/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小寒\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小寒"]},{"title":"拳皇15","url":"/zh-CN/256236e70a64/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","实体","SONY","PlayStation","光盘"]},{"title":"大寒","url":"/zh-CN/db3708133acc/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大寒\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大寒"]},{"title":"AirPods Pro 龙年限量款","url":"/zh-CN/98c067d90a0c/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","AirPods"]},{"title":"苏打绿 十年一刻（苏打绿版）","url":"/zh-CN/b8008968540d/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","苏打绿"]},{"title":"苏打绿 你在烦恼什么（苏打绿版）","url":"/zh-CN/e744b7d79084/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","苏打绿"]},{"title":"(G)I-DLE 2","url":"/zh-CN/34d42eac390b/","content":"\n专辑介绍《TOMBOY》向性别表现发声提问，《Nxde》直接挑战物化女体的低俗眼光，《Queencard》则歌颂展现自我的自信，K-Pop 团体 (G)I-DLE 一次又一次地为全世界女性发声。2024 年，第二张正规专辑《2》的主打歌《Super Lady》，则以强烈的电子音色和狂飙的高音音域，开宗明义地展示女性的力量与潜能。\n《2》发行之前，先公开的歌曲《Wife》已通过 MV 中五位成员复制人般的造型引起话题，歌词也对女性在婚姻中扮演的妻子角色提出幽默讽刺。这张专辑再次由创作首脑小娟操刀，Minnie、雨琦也各自贡献两首创作。《Doll》拥有不逊于主打歌的流行旋律和洗脑段落，《Vision》转以冷调电子乐诉说对自我的追寻，《7Days》则是讨喜复古的 Synth-Pop。整体来说，《2》延续了 2022 年的《I NEVER DIE》发行之后 (G)I-DLE 迎来的巅峰，在贯彻女性议题的同时，她们也试图拿捏韩国乐坛与全球市场的音乐喜好差异，不停进行尝试与挑战。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","(G)I-DLE"]},{"title":"立春","url":"/zh-CN/cf1616a458e7/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立春\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立春"]},{"title":"除夕","url":"/zh-CN/ab6f79b7a3ac/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  除夕快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","除夕"]},{"title":"雨水","url":"/zh-CN/8c033faee8a9/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  雨水\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","雨水"]},{"title":"元宵节","url":"/zh-CN/40802232cfec/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  元宵节快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","元宵节"]},{"title":"惊蛰","url":"/zh-CN/e5534d63cff3/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  惊蛰\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","惊蛰"]},{"title":"MacBook Air（M3，2024年）","url":"/zh-CN/6e7fd57eea89/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  MacBook Air\n  轻装重拳 M3\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"沙丘2","url":"/zh-CN/a360f65478ef/","content":"\n剧情介绍　　《沙丘2》将探索保罗·厄崔迪（提莫西·查拉梅 Timothée Chalamet 饰）的传奇之旅，他与契妮（赞达亚 Zendaya 饰）和弗雷曼人联手，踏上对致其家毁人亡的阴谋者的复仇之路。当面对一生挚爱和已知宇宙命运之间的抉择时，他必须努力阻止只有他能预见的可怕的未来。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"春分","url":"/zh-CN/441df4525591/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  春分\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","春分"]},{"title":"地平线 西之绝境","url":"/zh-CN/42ce955d2ea7/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","实体","SONY","PlayStation","光盘"]},{"title":"Apple 静安","url":"/zh-CN/dbfcbdf0aea6/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple 静安\n  花见花开一道来\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["零售店"],"tags":["Apple","Retail"]},{"title":"清明","url":"/zh-CN/a2cf4f584d04/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  清明\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","春分"]},{"title":"哥斯拉大战金刚2：帝国崛起","url":"/zh-CN/5419a2e0b421/","content":"\n剧情介绍　　继上一次的怪兽高燃对战之后，金刚和哥斯拉将再度联手对抗一个潜伏在世界中的巨大威胁，并逐步探索这些巨兽们的起源以及骷髅岛等地的奥秘。同时，上古之战的面纱也将会被揭晓，而正是那场战斗创造出了这些超凡的生物，并深刻影响了人类世界的命运。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"YOASOBI E-SIDE 3","url":"/zh-CN/b84ddece01cd/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","YOASOBI"]},{"title":"瑞奇与叮当：时空跳转","url":"/zh-CN/51733d83da1d/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","实体","SONY","PlayStation","光盘"]},{"title":"Taylor Swift THE TORTURED POETS DEPARTMENT THE ANTHOLOGY","url":"/zh-CN/6c8d701b0989/","content":"\n专辑介绍“苦难诗社”耕耘两年，启封时而幽默、时而心碎的旷野人生。\n发布《Midnights》后的 18 个月里， Taylor 经常给人一种无所不能的感觉：《The Eras Tour》巡演屡破纪录，票房冲破 10 亿美元大关，演唱会电影也创下同类影片的影史票房纪录；她的巡演，所到之处万人空巷媒体轰动，甚至带动当地经济发展。2023 年，Taylor 曾被《时代》杂志评为年度人物，同时当选 Apple Music 的年度艺人。\n今日已经站在世界之巅，这位炙热明星写的歌还能否打动人心？新闻刚一爆出她和 Joe Alwyn 低调的六年恋情告终，粉丝们就开始了“推理”，很快一段视频出现在社交媒体：Eras 巡演初期，Swift 在演唱《champagne problems》时泪洒舞台——那是她和 Alwyn 一起写的歌。尽管现在的 Taylor 浑身散发出超级英雄般的光彩，但她仍然和我们一样会受伤和心痛，不同的是，她把痛苦变成了精彩的流行创作。2024 年初，在又一次荣获格莱美奖时，她宣布自己即将发布第 11 张录音室专辑，这都不让人感到意外。“我需要做这张专辑。”几周后，在澳大利亚墨尔本，Taylor 面对 96,000 名观众介绍《THE TORTURED POETS DEPARTMENT》时说。“我从没像写《TORTURED POETS》这般渴望创作。”这次她依然和老朋友 Jack Antonoff 与 Aaron Dessner 搭档，又回到了《Midnights》那种温柔、舒适的音乐之中，但她倾注的东西比上次要多得多。与其说这是一张分手专辑，不如说它是对 Taylor 一切感受的深度探索，是对情感残骸的一次深海潜航。\n《But Daddy I Love Him》的弦乐和吉他让人依稀想起她的乡村乐根源，在这首歌里，Taylor 痛斥了自己从出道起就被强加的审视和期待，副歌听来格外酣畅痛快：“我宁愿把人生付之一炬&#x2F;也不想再多听一秒这些挖苦和抱怨”（I’ll tell you something right now&#x2F;I’d rather burn my whole life down&#x2F;Than listen to one more second of all this bitching and moaning），在《Florida!!!》里，她和 Florence + the Machine 像电影《末路狂花》中的主角一样共赴逃亡之旅，来到佛罗里达，希望带着新身份重启生活。这张名字全部大写的专辑，用极端的语言和意象探索了极端的情感，时而令人捧腹，时而催人泪下——爱来时让人如饮美酒，爱去时又让人如遭重击。她和 Post Malone 合作的开场曲《Fortnight》里交织着黑色幽默：“你的妻子在给花浇水&#x2F;我真想杀了她”（Your wife waters flowers&#x2F;I wanna kill her）。在自暴自弃的《Down Bad》里，Swift 尝试科幻题材，将恋爱的温暖比作被外星人绑架，最后落得“一无所有&#x2F;回到家乡小镇的空场上”（leave me here naked and alone, in a field in my same old town）的结局。听专辑时，你可能会觉得在读 Taylor 没发出去的邮件，或者旁听到她和别人的对话。专辑歌词中的信息密度、情感强度，把 2012 年的《All Too Well》也比下去了。“你发过誓说你爱我&#x2F;但线索在哪里&#x2F;我等待着证明&#x2F;在圣坛上死去”（You swore that you loved me, but where were the clues? I died on the altar waiting for the proof），她在令人心碎的《So Long, London》里唱道。《loml》中，Taylor 独坐钢琴边，设计急转直下的剧情，告诉某个视她为一生挚爱的人，对方是她一生的遗憾。而专辑的新故事到这儿还没结束：我们在《The Alchemy》的歌词“这种事要几世才会发生一次&#x2F;这些化学反应让我如饮美酒”（This happens once every few lifetimes&#x2F;These chemicals hit me like white wine）中瞥见了新的开始。在《I Can Do It With a Broken Heart》电影闪回式的合成器声景中，她精疲力尽倒在地上，“人们高喊&#x2F;‘继续啊！’”（All the pieces of me shattered as the crowd was chanting, “More!”），而她则用尽全力，喊出“因为我是个坚强的孩子&#x2F;我能管好自己的事”（’Cause I’m a real tough kid and I can handle my shit），这是胜利的意味，与新的和解与接纳一样，都源自 Taylor 发现了看待事物的新视角。\n新专辑标准版的最后一首歌《Clara Bow》，得名于 1920 年代从默片进入有声电影时代的影星 Clara Bow，它站在“永远在期待下一位巨星诞生”的唱片工业角度，审视了小镇女孩一路成长为超级巨星的历程。歌曲中，Taylor 共情“风流韵事”被拿来审视的 Clara Bow，共情从大风大浪里走过的 Stevie Nicks，当她拿第三人称波澜不惊地称呼自己的时候，我们却惊出一身冷汗：原来，无时无刻不站在聚光灯下的 Taylor，永远比场外操心的观众更有自知。嘲讽和污名，通通被她的先发制人化解：“你在这种光线下看起来就像 Taylor Swift&#x2F;我们很满意&#x2F;你有她没有的优势&#x2F;未来一片光明&#x2F;让人目眩”（You look like Taylor Swift in this light, we’re loving it&#x2F;You’ve got edge she never did&#x2F;The future’s bright, dazzling）。她率先从《彗星美人》式的造星工业轮回里跳脱出来，以彻底抽离的姿态，与可怕的清醒，赢得了我们的尊重。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","Taylor Swift"]},{"title":"立夏","url":"/zh-CN/edb29b54c07e/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立夏\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立夏"]},{"title":"谷雨","url":"/zh-CN/9e62306b0840/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  谷雨\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","谷雨"]},{"title":"Apple 特别活动","url":"/zh-CN/e810a54df4bd/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["发布会"],"tags":["Apple","Apple Event"]},{"title":"iPad Pro（M4，2024年）、iPad Air（M2，2024年）和 Apple Pencil Pro（2024年）","url":"/zh-CN/9fe6afc99abd/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPad Pro\n  磅礴的薄\n\n\n\n  \n\n\n\n  iPad Air\n  好轻新\n\n\n\n  \n\n\n\n  Apple Pencil Pro\n  随心想起，随笔记下。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPad","Pencil"]},{"title":"小满","url":"/zh-CN/79c204341dd3/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小满\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小满"]},{"title":"星之卡比 新星同盟","url":"/zh-CN/fcc859e25816/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"苏打绿 春・日光（苏打绿版）","url":"/zh-CN/947c04a21ded/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","苏打绿"]},{"title":"芒种","url":"/zh-CN/3efe98474ba1/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  芒种\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","芒种"]},{"title":"疯狂的麦克斯：狂暴女神","url":"/zh-CN/c6b7bc5f611a/","content":"\n剧情介绍　　影片讲述了复仇女神弗瑞奥萨（安雅·泰勒-乔伊 Anya Taylor-Joy 饰）惊心动魄的成长史。年轻的弗瑞奥萨从原本的家园被掠走，落入军阀狄门特斯（克里斯·海姆斯沃斯 Chris Hemsworth 饰）领导的帮派手中，在穿过荒原时，他们来到不死老乔（拉黑·休姆 Lachy Hulme 饰）所掌管的堡垒。在两位暴君争夺统治地位的同时，弗瑞奥萨必须在重重考验中活下来，并想方设法寻找回家的路；她也逐渐成长为利落酷飒的狂暴女神。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"Apple 2024 全球开发者大会","url":"/zh-CN/a713b0a3179e/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["开发者大会"],"tags":["Apple","WWDC"]},{"title":"夏至","url":"/zh-CN/e79f405773f9/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  夏至\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","夏至"]},{"title":"Apple Vision Pro（M2，2024年）","url":"/zh-CN/4938e565082c/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple Vision Pro\n  欢迎来到空间计算时代\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Vision"]},{"title":"小暑","url":"/zh-CN/3291d7dc7e47/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小暑"]},{"title":"新宝可梦随乐拍","url":"/zh-CN/cbd69ac5f8b0/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","Nintendo","Switch","实体","卡带"]},{"title":"HomePod mini（午夜色，2024年）","url":"/zh-CN/fd857e31eb41/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  HomePod mini\n  \n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","HomePod"]},{"title":"大暑","url":"/zh-CN/f92a647e8111/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大暑"]},{"title":"死侍与金刚狼","url":"/zh-CN/4c14d0d73ebf/","content":"\n剧情介绍　　史上最另类超级英雄、语不惊人死不休的死侍（瑞安·雷诺兹 Ryan Reynolds 饰）睽违六年终于万众瞩目重返大银幕，更首度加入漫威电影宇宙！除了与老搭档钢力士、负音波少年弹头和雪绪再度聚首，更将与睽别15年的金钢狼（休·杰克曼 Hugh Jackman 饰）二度并肩作战再续兄弟情，时间管理局找上门带走他也从容不迫，并自认只有自己能当漫威救世主，改写漫威电影宇宙！\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"立秋","url":"/zh-CN/6b10bce7c730/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立秋\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立秋"]},{"title":"异形：夺命舰","url":"/zh-CN/09b6f6c4ad0d/","content":"\n剧情介绍　　影片时间线设定在1979年第一部《异形》与1986年的续集《异形2》之间，围绕一群年轻而勇敢的太空殖民者展开。讲述他们为逃离外星采矿殖民地的沉闷生活，在冒险探索一座废弃的太空站时，意外遭遇了宇宙中最可怕的生命体——异形。狭窄幽暗、危机四伏的空间站中，大逃杀的序幕已经被无情拉开，人类再次成为异形生物捕猎的目标。在无尽的黑暗与死亡威胁的笼罩之下，太空探险队员们能否在每一次心跳的瞬间，察觉到未知生物潜伏的丝丝寒意？在这场你死我活的追逐战中，他们将直面怎样的信任挑战和道德挣扎？当一个又一个同伴被残忍吞噬，求救无门的他们究竟能否在这场太空杀戮中寻得一线生机？\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"よねづ けんし LOST CORNER","url":"/zh-CN/260568756766/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","よねづ けんし"]},{"title":"处暑","url":"/zh-CN/5824a6d0dc49/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  处暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","处暑"]},{"title":"苏打绿 夏/狂热（苏打绿版）","url":"/zh-CN/3c840e902b0a/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","苏打绿"]},{"title":"白露","url":"/zh-CN/4e58d8f441a7/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  白露\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","白露"]},{"title":"Apple 特别活动","url":"/zh-CN/23f264a0603c/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["发布会"],"tags":["Apple","Apple Event"]},{"title":"渡神纪 芬尼斯崛起","url":"/zh-CN/6c0f9f82701e/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","实体","SONY","PlayStation","光盘"]},{"title":"iPhone 16 Pro（A18 Pro，2024年）和 iPhone 16（A18，2024年）","url":"/zh-CN/4d0d20cd8b79/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  iPhone 16 Pro Max | iPhone 16 Pro\n\n\n\n  \n\n\n\n  iPhone 16 Plus | iPhone 16\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPhone"]},{"title":"秋分","url":"/zh-CN/5ab9a104c539/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  秋分\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","秋分"]},{"title":"Apple Watch Ultra 2（S9，黑色，2024年）和 Apple Watch Series 10（S10，2024年）","url":"/zh-CN/c1367bc481a2/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple Watch Ultra 2\n  野出新一面\n\n\n\n  \n\n\n\n  Apple Watch Series 10\n  薄爆表\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Watch"]},{"title":"变形金刚：起源","url":"/zh-CN/0b5605b3f907/","content":"\n剧情介绍　　故事发生在变形金刚的母星塞伯坦，聚焦变形金刚的青年时代，讲述汽车人领袖擎天柱（克里斯·海姆斯沃斯 Chris Hemsworth 配音）与霸天虎领袖威震天（布莱恩·泰里·亨利 Brian Tyree Henry 配音）从手足走向反目的故事，打响旷日持久的塞伯坦之战。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"孤独的美食家 第十一季 第一集 东京荒川区町屋的虾仁炒饭和海鲜春卷","url":"/zh-CN/c8fcf38f1bec/","content":"\n剧情介绍　　早上结束工作后，井之头五郎时隔一段时间第一次来到河边捡石子、排水。中餐馆老板也不甘示弱，试图将水排干，但是……最终，五郎饿了，在荒川区町屋的一条老式商店街找到了一家中餐馆充饥。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"寒露","url":"/zh-CN/7375503d874e/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  寒露\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","寒露"]},{"title":"AirPods Max（H1，USB-C，2024年）和 AirPods 4（H2，2024年）","url":"/zh-CN/bf85371569cf/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  AirPods Max\n  澎湃贯耳\n\n\n\n  \n\n\n\n  AirPods 4\n  耳上经典，音质再进化\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","AirPods"]},{"title":"孤独的美食家 第十一季 第二集 足立区谷西池的自助餐厅","url":"/zh-CN/464f10deadb0/","content":"\n剧情介绍　　出租车司机森信一郎因乘客的臭味和长途驾驶而疲惫不堪，他决定在一家熟悉的餐馆吃早餐，然后在夜班结束后回家。与此同时，为客户工作了一整夜的井之头五郎也来到了同一家餐厅寻找早餐。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"哈利·波特与魔法石","url":"/zh-CN/e894f9e1fcbd/","content":"\n剧情介绍　　哈利波特是一个孤儿，从小寄养在姨妈家，受尽欺凌。但就在哈利11岁生日的时候，他意外收到了霍格沃茨学院的入学通知书。哈利从该学院派来接他的巨人海格口中得知，这是一间魔法学院，并得知了自己的身世，原来哈利的父母都是伟大的魔法师，在对付伏地魔的战斗中双双献身，唯有哈利幸免于难。　　哈利进入霍格沃茨后，表现出了超乎想象的飞行天赋，得到麦格教授的推荐进入了格兰芬多的魁地奇球队。另一方面，哈利发现霍格沃茨学院内有一股黑暗势力似乎在暗暗滋长，揭开谜团的关键就在有凶恶的三头犬守护的房间内。　　哈利、罗恩和赫敏三个好朋友决定探个究竟。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"梁文音 情歌比情人还懂","url":"/zh-CN/02251e6bab81/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","梁文音"]},{"title":"小丑2：双重妄想","url":"/zh-CN/137bcd54b021/","content":"\n剧情介绍　　影片延续前作剧情，故事从“小丑”亚瑟（华金·菲尼克斯 饰）被捕后展开，他在狱中等待着审判日的到来。然而，就在亚瑟与自己的双重人格缠斗之时，他不仅偶遇真爱，甚至还释放出一直潜藏在内心的旋律。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"孤独的美食家 第十一季 第三集 东京都千代田区神保町","url":"/zh-CN/6fb58e0263fb/","content":"\n剧情介绍　　护士高垣晴美小姐在夜班结束后决定去一家烤肉店吃饭。另一边，为了与客户谈业务而寻找午餐地点的井之头五郎也来到了同一家店。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"哈利·波特与密室","url":"/zh-CN/4292d601fcc1/","content":"\n剧情介绍　　哈利波特（丹尼尔•雷德克里夫 Daniel Radcliffe 饰）结束了假期，即将回到霍格沃兹继续学习魔法。一个叫多比的家养小精灵警告哈利不要回到霍格沃兹，否则会陷入极大的危险。哈利没有听从多比的劝告，回到了霍格沃兹。很快，霍格沃兹发生了一连窜怪事:接二连三出现学生被石化，一直找不出原因。而哈利总能听到一种奇怪的声音，从墙壁里传出来。　　传说，霍格沃兹有一个密室，里面记录着伏地魔年轻时的秘密，只有斯莱特林的人才能打开密室。哈利偶然发现自己能听懂蛇说话，一时传闻是哈利打开了密室。难道多比所指的危险就隐藏在密室。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"霜降","url":"/zh-CN/0570bd87b942/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  霜降\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","霜降"]},{"title":"iPad mini（A17 Pro，2024年）","url":"/zh-CN/6e7cf20ea028/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPad mini\n  单手炫大招\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPad"]},{"title":"毒液：最后一舞","url":"/zh-CN/c31eb32e2e33/","content":"\n剧情介绍　　毒液和埃迪（汤姆·哈迪 Tom Hardy 饰）迎来至暗时刻。一边是人类神秘组织的穷追猛打，一边是外星共生体大军入侵地球，他们一心同体，花式解锁海陆空作战新形态。面对两边的疯狂追捕，这对亡命搭档将被迫做出毁灭性决定，为他们的最后一舞拉下帷幕。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"孤独的美食家 第十一季 第四集 埼玉县川口市荷包蛋汉堡排与海胆奶油可乐饼","url":"/zh-CN/6991df4f2944/","content":"\n剧情介绍　　相扑裁判木村正基因工作不顺，他决定去外食店换换心情。最终走进一家西餐馆，点了一份特别的“大人的儿童套餐”。巧合的是，井之头五郎也在这家店用餐，同样因为烦恼选择了特别的午餐。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"哈利·波特与阿兹卡班的囚徒","url":"/zh-CN/5db989d1b959/","content":"\n剧情介绍　　哈利（丹尼尔·雷德克里夫）即将在霍格沃兹渡过第三个年头，此时在阿兹塔班却传出恶棍小天狼星（加里·奥德曼）越狱的消息。据说小天狼星正是背叛哈利父母的好友，他的教父，而这次小天狼星越狱似乎正是为了找他。哈利的心里悄悄的滋生了为父母报仇的想法，期待着小天狼星的出现。　　新来的魔法老师卢平（大卫·休里斯）有着桀骜不驯的个性，与哈利关系很好，教了哈利许多实用的黑魔法防御知识。而此时在他的魔法地图上却出现了一个神秘人物，虫尾巴。偶然的机会下，在尖叫棚屋里集齐了哈利父亲当年的所有好友，卢平、虫尾巴、小天狼星，哈利的魔杖直指向小天狼星，但他发现那罪犯看他的眼神里充满了疼爱……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"孤独的美食家 第十一季 第五集 东京都台东区东上野三温暖饭","url":"/zh-CN/9eb1ab5078e6/","content":"\n剧情介绍　　新人热波师进藤由香里在桑拿房中感受到温暖后，迎来了她的出道日。紧张的首秀结束后，她感到饥饿，选择了一顿能够消除疲劳的桑拿饭，并意外遇到了井之头五郎。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"哈利·波特与火焰杯","url":"/zh-CN/f2fbb42eb6c8/","content":"\n剧情介绍　　这是一个不同寻常的学期，魔法学校的盛事：三强争霸赛在霍格沃茨举行。学生们争先报名，希翼获得永恒无上的荣誉。火焰杯在选出三所学校的三名勇士后，竟将未足年龄的哈利也挑选出来。　　哈利（Daniel Radcliffe饰）的当选引起其他学生的嫉妒连连，就连铁哥们罗恩（Rupert Grint饰）也首次和他闹起了别扭，哈利感到孤立无援，还好有教父小天狼星和赫敏一直支持他。可总有些好事者如记者丽塔等着看他的好戏。天知道这场比赛是何等艰辛危险，在龙的眼皮下偷蛋，潜入湖底救人，在迷宫中探险……一不小心，甚至可能付出生命的代价。　　黑魔王伏地魔的威胁渐渐显现，每一天都险象环生，动人心弦。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"这个杀手不太冷","url":"/zh-CN/b08d3461a1be/","content":"\n剧情介绍　　里昂（让·雷诺饰）是名孤独的职业杀手，受人雇佣。一天，邻居家小姑娘马蒂尔达（纳塔丽·波特曼饰)敲开他的房门，要求在他那里暂避杀身之祸。原来邻居家的主人是警方缉毒组的眼线，只因贪污了一小包毒品而遭恶警（加里·奥德曼饰）杀害全家的惩罚。马蒂尔达得到里昂的留救，幸免于难，并留在里昂那里。里昂教小女孩使枪，她教里昂法文，两人关系日趋亲密，相处融洽。　　女孩想着去报仇，反倒被抓，里昂及时赶到，将女孩救回。混杂着哀怨情仇的正邪之战渐次升级，更大的冲突在所难免……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"立冬","url":"/zh-CN/00a53348e384/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立冬\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立冬"]},{"title":"孤独的美食家 第十一季 第六集 神奈川县平冢市猪五花萝卜与炸鬼头刀","url":"/zh-CN/5ecd8e8c10dc/","content":"\n剧情介绍　　刚刚失去妻子的村山幸三和渴望与大人对话的小学生朝仓健太展开。健太对儿童餐厅海报产生兴趣，而村山收到亡妻朋友篠崎的邀请，一同前往餐厅。同时，井之头五郎也会登场，带来温馨的美食体验。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"哈利·波特与凤凰社","url":"/zh-CN/6e4515b05f5c/","content":"\n剧情介绍　　逃过摄魂怪的追杀，通过魔法部的审查，哈利（丹尼尔·雷德克里夫）终于回到美丽的霍格沃兹。然而这个学期并不轻松，他不仅要完成魔法等级考试，还要应对夜晚的噩梦和黑魔法防御课老师乌姆里奇的打压。在好友的支持下，哈利秘密组建了邓不利多军团，与大家一起练习黑魔法防御术。　　噩梦中，哈利总是以伏地魔的视角出现，似乎他们之间有着某种神秘的联系。在邓不利多（迈克尔·刚本）的指示下，哈利向斯内普教授（阿伦·瑞克曼）学习封闭术，却鲜有成效。终于在一次噩梦的诱使下，哈利偏执的赶往魔法部营救小天狼星，却不想陷入伏地魔的圈套，引发凤凰社与食死徒之间的正面冲突。在混战中，小天狼星（加里·奥德曼）不幸遇难。　　究竟哈利与伏地魔（拉尔夫·费因斯）之间有着怎样的联系？在悲恸中，邓不利多为哈利揭开谜底，哈利还有更长、更艰难的路要走……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"MacBook Pro（M4，M4 Pro，M4 Max，2024年）、Mac mini（M4，M4 Pro，2024年）和 iMac 24 英寸（M4，2024年）","url":"/zh-CN/338ade4296a3/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  新款 MacBook Pro、iMac\n  和全新 Mac mini 齐登场。\n\n\n\n  \n\n\n\n  MacBook Pro\n  超高能，超有范。\n\n\n\n  \n\n\n\n  Mac mini\n  尺寸爆减，实力却暴涨。\n\n\n\n  \n\n\n\n  iMac\n  多彩多出彩\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"红色一号：冬日行动","url":"/zh-CN/7828471bf212/","content":"\n剧情介绍　　圣诞老人（J·K·西蒙斯 饰）被神秘绑架，北极安保主管（道恩·强森 饰）不得已与全世界最臭名昭著的赏金猎人（克里斯·埃文斯 饰）展开合作，他们寻遍全球、打遍天下，力求拯救圣诞节。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"孤独的美食家 第十一季 第七集 岛根县出云市煎饺与白饭","url":"/zh-CN/585083254776/","content":"\n剧情介绍　　乘务员川端明日香在机场待命期间被同事邀请一起吃饭，却突然接到通知要去出云。工作结束后，饥肠辘辘的川端在当地找到了一家挂着“饺子”红灯笼的小店。井之头五郎也在出云出现，共同探索当地美食。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"哈利·波特与混血王子","url":"/zh-CN/66077338978a/","content":"\n剧情介绍　　这一集中，食死徒开始肆无忌惮横行于麻瓜和魔法两个世界中，霍格沃茨内忧外患，危机重重。邓不利多（迈克尔·甘本 Michael Gambon 饰）带着哈利（丹尼尔·雷德克里夫 Daniel Radcliffe 饰）辗转找到隐居多年的霍拉斯·斯拉格霍恩，请他出山接替斯内普（艾伦 ·里克曼 Alan Rickman 饰）担任魔药学的老师。霍拉斯曾经教授过无数优秀的学生，而汤姆·里德尔——伏地魔——正是他最出色的一名弟子。邓不利多深信霍拉斯保有伏地魔不死身的秘密，他希望哈利能够说服霍拉斯。　　另一方面，德拉科·马尔福（汤姆·费尔顿 Tom Felton 饰）宣誓效忠伏地魔，他想方设法将食死徒引入霍格沃茨。而此时，罗恩（鲁伯特·格林特 Rupert Grint 饰）、赫敏（艾玛·沃特森 Emma Watson 饰）他们却还沉浸在青春的躁动中，全然不知黑暗正渐渐逼近……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"35岁生日快乐","url":"/zh-CN/b45322351c2b/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  生日快乐\n\n\n\n  \n    \n  \n\n\n\n","categories":["纪念日"],"tags":["日常","生日"]},{"title":"海上钢琴师","url":"/zh-CN/9bcc87afacfd/","content":"\n剧情介绍　　本片讲述了一个钢琴天才传奇的一生。\n　　1900年，Virginian号豪华邮轮上，一个孤儿被遗弃在头等舱，由船上的水手抚养长大，取名1900（蒂姆•罗斯 饰）。1900慢慢长大，显示出了无师自通的非凡钢琴天赋，在船上的乐队表演钢琴，每个听过他演奏的人，都被深深打动。爵士乐鼻祖杰尼听说了1900的高超技艺，专门上船和他比赛，最后自叹弗如，黯然离去。　　可惜，这一切的事情都发生在海上，1900从来不愿踏上陆地，直到有一天，他爱上了一个女孩，情愫在琴键上流淌。他会不会为了爱情，踏上陆地开始新的生活，用他的琴声惊艳世界？他将怎样谱写自己非凡的人生。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"孤独的美食家 第十一季 第八集 东京都府中市白系台草鞋炸猪排","url":"/zh-CN/661a5fc984a8/","content":"\n剧情介绍　　自行车赛选手藤村智也在决赛中获胜，但感觉意犹未尽。赛后，胜者与败者一起享用特大型炸猪排。井之头五郎也加入了这场美食盛宴。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"哈利·波特与死亡圣器（上）","url":"/zh-CN/6f1cc7acef17/","content":"\n剧情介绍　　邓不利多死后，伏地魔（Ralph Fiennes 饰）与食死徒入侵魔法学校，魔法部也被伏地魔的爪牙操控，邪恶的阴云笼罩魔法世界上空。在哈利·波特（丹尼尔·雷德克里夫 Daniel Radcliffe 饰）17岁生日之际，凤凰社成员及一众好友护送他回到了凤凰社的据点陋居，然而这立即遭到食死徒毁灭性地打击。哈利和罗恩（鲁伯特·格林特 Rupert Grint 饰）、赫敏（爱玛·沃特森 Emma Watson 饰）侥幸逃亡，并且按照邓不利多的嘱托继续寻找伏地魔的魂器。死亡的威胁时刻逡巡左右，他们还要面对友情的考验。在寻找摧毁魂器方法的过程中，死亡圣器的面纱也渐渐揭开。　　与此同时，为了置哈利于死地，伏地魔也在寻找最后一件死亡圣器。最后的决战即将到来……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"小雪","url":"/zh-CN/1f2d2358a505/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小雪\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小雪"]},{"title":"角斗士2","url":"/zh-CN/8a1ef2d08105/","content":"\n剧情介绍　　影片故事延续前作，路奇乌斯（保罗·麦斯卡 Paul Mescal 饰）童年时亲眼目击受万人景仰的英雄马克西蒙斯死于舅舅之手，多年后已长大成人的他，在暴君的铁腕统治下，被迫进入竞技场为生存而战。心中充满怒火的卢修斯，眼见罗马帝国的未来岌岌可危，决心讨回本属于他的权力和荣誉，还 罗马人民一个辉煌的罗马。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"孤独的美食家 第十一季 第九集 千叶县香取市汽车餐厅泡菜炒猪肉蛋定食","url":"/zh-CN/dfaa49f8be40/","content":"\n剧情介绍　　女货车司机前岛瑞希从八户开车长途跋涉到郡山，终于来到了千叶县香取市。瑞希在同行司机阿铁的推荐下，来到了与仓汽车餐厅“运将的绿洲”，瑞希在琳琅满目的菜品能挑选出自己的专属套餐吗？而身为乘客的井之头五郎也加入了这场战斗。\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"哈利·波特与死亡圣器（下）","url":"/zh-CN/1e14361cd35f/","content":"\n剧情介绍　　当又一次和伏地魔（拉尔夫·费因斯 Ralph Fiennes 饰）的意识连通，哈利·波特（丹尼尔·雷德克里夫 Daniel Radcliffe 饰）断定最后一件魂器藏在霍格沃茨，于是和罗恩（鲁伯特·格林特 Rupert Grint 饰）、赫敏（艾玛·沃森 Emma Watson 饰）一同返回阴云密布的学校。在好友们的帮助下，他们成功驱逐了斯内普（艾伦·瑞克曼 Alan Rickman 饰），然而觉察到哈利目的的伏地魔则率领徒众向霍格沃茨逼近。食死徒、摄魂怪、巨人疯狂涌入这所有着悠久历史的魔法学校，正邪决战旋即爆发，一时间血雨腥风，死伤无数。从斯内普的眼泪中，哈利不仅了解到父辈的故事，也证实了藏缅于他体内最后的秘密。在此之后，他也和伏地魔迎来了最后的对决……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"孤独的美食家 第十一季 第十集 东京都中野区新井南印度午餐","url":"/zh-CN/3f14d41d7ded/","content":"\n剧情介绍　　由于身体不适，老祭司祐一无法前往原定的地镇祭，他的儿子祐太不得不挑起重担。祐太有惊无险的完成了地镇祭仪式后已饥肠辘辘。于是，他回到了来程中瞥见的一家印度咖喱餐厅，选择了只自己的专属菜单。而井之头五郎又会选择什么样的咖喱呢？\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"大雪","url":"/zh-CN/33c158a5ceed/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大雪\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大雪"]},{"title":"孤独的美食家 第十一季 第十一集 东京都武藏野市吉祥寺照烧鸡与熟食拼盘定食","url":"/zh-CN/83243778ae65/","content":"\n剧情介绍　　作为江口寿史老师新作漫画责任编辑的栞，然而在新作截稿日当天，江口老师却下落不明。栞从编辑长口中得知江口老师经常出没于附近的居酒屋，对此深信不疑的栞在吉祥寺的街头四处寻找，在江口老师来过的店里边吃边等他出现。不约而同来到店里的，还有我们的老朋友井之头五郎……\n\n","categories":["剧集"],"tags":["日常","TV Tokyo"]},{"title":"猎人克莱文","url":"/zh-CN/16b7c83869c8/","content":"\n剧情介绍　　少年谢尔盖·克拉维诺夫（亚伦·泰勒-约翰逊 饰）的父亲（罗素·克劳 饰）崇尚“强者为王”，对后代施行野蛮残酷的狼性教育，而在一次狩猎之中，经历野生雄狮袭击的谢尔盖被父亲抛弃。他在濒死之际意外因为狮子血液而产生变异，成为拥有超常力量的猎人克莱文，从此踏上向父亲的复仇之路，而犀牛人的出现，似乎也预示了更大的阴谋。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"Etsy开店流程","url":"/zh-CN/11530cb6a165/","content":"\n开店流程注册Etsy账户登录Etsy官网\n单击右上角Sign in\n\n单击Register\n\n录入信息后，单击Register\n\n注册好账号后，返回主页，点击右上角头像，之后单击Sell on Etsy\n\n单击Get started\n\n单击Let’s do this!\n\n根据实际情况选择，然后Next\n\n根据实际情况选择，然后Next\n\n\n单击Start your shop\n\n按照要求填写Shop preferences，然后单击Save and continue\n\n按照要求填写Name your shop，然后单击Save and continue\n\n按照要求填写Stock your shop，然后单击Save and continue\n\n继续填写Add more details，然后单击Save and continue\n\n单击Do this later\n\n到达How you’ll get paid之后，需要提供一个收款账号\n\n这时，登录WorldFirst官网，点击没有账号？立即注册\n\n点击跨境电商账号下面的立即注册\n\n填好信息后，点击注册\n\n之后进行账号认证，点击去认证\n\n根据要求填写实名认证，点击下一步\n\n选择中国内地个人电商账号，点击下一步\n\n填写账号基本信息，点击下一步\n\n选择立即验证人脸信息，点击下一步\n\n选择立即验证人脸信息\n\n保持默认选项，点击下一步\n\n上传身份证正反面，点击下一步\n\n核对识别的信息，点击下一步\n\n使用支付宝扫描屏幕上的二维码\n\n核对的信息，点击提交\n\n返回主页，点击申请收款账号\n\n选择Etsy\n\n选择合适的币种，点击申请\n\n现已成功申请到一个收款账号，点击查看店铺详细信息\n\n点击查看账户详情\n\n根据账户详情\n\n返回How you’ll get paid填写个人地址和收款账户信息，然后单击Save and continue\n\n使用护照验证个人信息，点击Continue with Persona\n\n点击Begin verifying\n\n选择对应国家&#x2F;地区的护照，点击Continue\n\n选择Passport\n\n选择Use another device\n\n使用手机扫描屏幕二维码\n\n拍照护照个人信息页\n\n点击Take a selfie\n\n点击Got it，等待验证通过\n\n验证通过后进入添加付款信用卡步骤，用于支付开店费用等\n\n这时，先登录Dupay官网，单击右上角注册\n\n勾选同意，点确定\n\n填写信息，单击注册\n\n单击申请卡\n\n保持默认，单击立即开卡\n\n这一步需要支付开卡费用\n\n手机上下载欧易，打开，点注册，选择对应的国际&#x2F;地区\n\n验证邮箱，验证手机号,输入密码\n\n实名认证\n\n回到首页，点击C2C买币，选择适合的额度，点击右侧购买，输入金额，之后转到支付宝（首推）进行转账，之后提交转账凭证截图，之后等USDT到账\n\n回到Dupay钱包，单击充币\n\n选择USDT\n\n一下有两个充值方案，\n方案一：选择TRC20网络\n\n复制充值地址\n\n返回欧易，资产-USDT-提币-提取数字货币\n\n地址簿-添加地址-普通地址\n\n网络选择Tron（TRC20），粘贴Dupay的钱包地址，填入地址名称，保存，返回地址簿，进入刚刚添加的地址，填入金额，提交，完成提币\n\n方案二：选择Polygon网络\n\n复制充值地址\n\n返回欧易，资产-USDT-提币-提取数字货币\n\n地址簿-添加地址-普通地址\n\n网络选择Polygon，粘贴Dupay的钱包地址，填入地址名称，保存，返回地址簿，进入刚刚添加的地址，填入金额，提交，完成提币\n\n两种方法的手续费不同\n\n\n\n方案\n手续费\n\n\n\n方案一\n5USD\n\n\n方案二\n0.8USD\n\n\n等一段时间，进入Dupay钱包，USDT已经到账，点击右上角Exchange\n\n将USDT兑换成美元\n\n然后回到开卡页面，支付开卡\n\n返回添加付款信用卡步骤，将虚拟信用卡信息填入，点Continue，完成支付开店费用\n\n根据屏幕指示完成两步验证操作，点击Open your shop\n\n至此，开店所需基本步骤已经完成\n\n\n","categories":["教程"],"tags":["开店","Etsy","WorldFirst","Dupay","OKX"]},{"title":"狮子王：木法沙传奇","url":"/zh-CN/6a5fa1dcac6f/","content":"\n剧情介绍　　回溯传奇狮王辛巴父亲“木法沙”的荣耀之路，揭秘他与迪士尼经典反派“刀疤”（塔卡）之间不为人知的羁绊。一次非凡的相遇，一场改变命运的冒险，当荣耀大地上的一切回到起点，是殊途同归还是背道而驰？这对“狮兄弟”的未来将如何展开？\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"冬至","url":"/zh-CN/b3aa1bb1b2d5/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  冬至\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","冬至"]},{"title":"Hushed注册美国号码流程","url":"/zh-CN/de6d14d1d01e/","content":"\n注册美国号码流程注册Hushed账户登录Hushed官网\n单击右上角Log in\n\n录入信息后，单击Sign up\n\n单击Get a New Number\n\n单击United States\n\n单击Mobile\n\n单击Select a Region,选择归属地\n\n选择号码，会自动跳转下一项\n\n选择套餐，会自动跳转下一项\n\n选择添加信用卡\n\n填写信用卡信息后，单击Next\n\n得到号码\n\n手机上下载Hushed，打开，登录\n\n选中号码，在新页面中点击右上角新建图标，即可开始发送短信\n\n\n","categories":["教程"],"tags":["Dupay","OKX","号码","Hushed"]},{"title":"元旦","url":"/zh-CN/098f15b532b4/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  元旦快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","元旦"]},{"title":"AirPods 4 蛇年特别款 (支持主动降噪)","url":"/zh-CN/de981b24d418/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n","categories":["电子产品"],"tags":["Apple","AirPods"]},{"title":"小寒","url":"/zh-CN/b533c0f40c0c/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小寒\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小寒"]},{"title":"Apple 合肥万象城","url":"/zh-CN/ab7f7f8aec38/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple 合肥万象城\n  欢迎来会合\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["零售店"],"tags":["Apple","Retail"]},{"title":"大寒","url":"/zh-CN/1e19b7c04af0/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大寒\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大寒"]},{"title":"除夕","url":"/zh-CN/4bbadc808e78/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  除夕快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","除夕"]},{"title":"立春","url":"/zh-CN/a39feb5bf99e/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立春\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立春"]},{"title":"元宵节","url":"/zh-CN/7a75c12c9a19/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  元宵节快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","元宵节"]},{"title":"美国队长4","url":"/zh-CN/00ee70f2d866/","content":"\n剧情介绍　　回能够展翅高飞的猎鹰山姆·威尔逊（安东尼·麦凯 Anthony Mackie 饰）受史蒂夫·罗杰斯的信任所托，接过盾牌，正式成为美国队长。在与美国总统塔迪厄斯·罗斯（哈里森·福特 Harrison Ford 饰）会面后，山姆发现自己被卷入了一场国际事件。他必须赶在真正的幕后黑手让全世界陷入混乱之前查明真相，揭露这起波及全球的阴谋。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"雨水","url":"/zh-CN/3d70c0f1bfff/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  雨水\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","雨水"]},{"title":"iPhone 16e（A18，2025年）","url":"/zh-CN/75717d71453e/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  iPhone 16e\n  明智之选，升级正当时。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPhone"]},{"title":"惊蛰","url":"/zh-CN/e6b77afd226a/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  惊蛰\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","惊蛰"]},{"title":"iPad Air（M3，2025年）和 iPad（A16，2025年）","url":"/zh-CN/aad54414235c/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPad Air\n  快如飞\n\n\n\n  \n\n\n\n  iPad\n  可圈\n  可点\n  可画心\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPad"]},{"title":"MacBook Air（M4，2025年）和 Mac Studio（M4 Max，M3 Ultra，2025年）","url":"/zh-CN/7c07849c286a/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  MacBook Air\n  身轻身手快\n\n\n\n  \n\n\n\n  Mac Studio\n  硬核加载\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"春分","url":"/zh-CN/967f9ba011a5/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  春分\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","春分"]},{"title":"清明","url":"/zh-CN/4cf285e950fb/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  清明\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","清明"]},{"title":"速度与激情7","url":"/zh-CN/f48e5d64a00f/","content":"\n剧情介绍　　经历了紧张刺激的伦敦大战，多米尼克·托雷托（范·迪塞尔 Vin Diesel 饰）和他的伙伴们重新回归平静的生活，但是江湖的恩恩怨怨却决不允许他们轻易抽身而去。棘手的死对头欧文·肖瘫在医院，不得动弹，他的哥哥戴克·肖（杰森·斯坦森 Jason Stantham 饰）则发誓要为弟弟复仇。戴克曾是英国特种部队的王牌杀手，不仅身怀绝技，而且心狠手辣。他干掉了远在东京的韩，还几乎把探长卢克·霍布斯（道恩·强森 Dwayne Johnson 饰）送到另一个世界，甚至多米尼克那世外桃源般的家也被对方炸毁。　　复仇的利刃已经架在脖子上，多米尼克再也没有选择，他找到长久以来最为信赖的团队，与来势汹汹的戴克展开生死对决……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"雷霆特工队","url":"/zh-CN/c85ddc8d47c8/","content":"\n剧情介绍　　《雷霆特攻队*》中集结了一支颠覆传统的反英雄团队——“二代黑寡妇”叶莲娜、“冬兵”巴基、“红色守卫”阿列克谢、“幽灵”、“模仿大师”和“美国密探”约翰·沃克。在发现陷入了瓦伦蒂娜设置的死亡陷阱后，这群已不抱有幻想的弃儿必须开始一项危险的任务，迫使他们面对各自最黑暗的过往。这个混乱的“最低配”团队是否会一盘散沙内部瓦解，还是会在为时已晚之前及时完成救赎并团结起来呢？\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"立夏","url":"/zh-CN/d206ec358d1a/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立夏\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立夏"]},{"title":"小满","url":"/zh-CN/08cda594ca6d/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小满\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小满"]},{"title":"谷雨","url":"/zh-CN/de1345ad8668/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  谷雨\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","谷雨"]},{"title":"碟中谍8：最终清算","url":"/zh-CN/c0840bc37a6d/","content":"\n剧情介绍　　超级人工智能“智体”即将引爆全球核弹危机，把世界推向毁灭边缘。而伊森·亨特（汤姆·克鲁斯 饰）和他的IMF小队在上次行动中遭遇重创，团队濒临分崩离析。虽然伊森已获得关闭“智体”的钥匙，但要彻底消灭“智体”，完成这一拯救全人类的终极任务，仍需要IMF小队齐心协力突破重重困难。他们不仅要面对全知全能又无影无形的“智体”与其手下盖布瑞尔（埃塞·莫拉雷斯 饰）的百般阻拦，还要解决来自过去的种种恩怨。每个抉择都关乎信念与命运，等待伊森和IMF小队的，究竟是怎样的结局？\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"芒种","url":"/zh-CN/714f2b34f647/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  芒种\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","芒种"]},{"title":"Apple 2025 全球开发者大会","url":"/zh-CN/c8d773fddd59/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["开发者大会"],"tags":["Apple","WWDC"]},{"title":"新·驯龙高手","url":"/zh-CN/3a0ce690841e/","content":"\n剧情介绍　　影片讲述小嗝嗝（梅森·泰晤士 Mason Thames 饰）偶然间遭遇传说中的夜煞没牙仔，并由此与之建立深厚友谊，进而打破两大族群间的隔阂，携手寻求和平的故事。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"黑神话：悟空","url":"/zh-CN/9bab5c982290/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","实体","SONY","PlayStation","光盘"]},{"title":"夏至","url":"/zh-CN/2e3669a75ea7/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  夏至\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","夏至"]},{"title":"F1：狂飙飞车","url":"/zh-CN/22be0dea6585/","content":"\n剧情介绍　　桑尼·海耶斯（布拉德·皮特 饰）曾经是F1赛场上最具潜力的天才新星，但一场意外葬送了他的职业生涯，从此他沦为人们口中最生不逢时的“沧海遗珠”。三十年后的如今，桑尼是一名自由职业的落魄赛车手，他的前队友——如今是濒临破产的F1车队老板鲁本·塞万提斯（哈维尔·巴登 饰）却突然找上门来。鲁本说服桑尼重返F1赛场，这不仅是拯救他车队的最后希望，更是桑尼向世界证明自己仍是顶尖车手的最佳契机。桑尼将与车队的热门新秀乔舒亚·皮尔斯（达姆森·伊德瑞斯 饰）并肩前行，这位年轻的车手也渴望在赛道上书写自己的传奇。然而伴随着引擎开始轰鸣，桑尼过去的创伤也如影随形，他同时意识到在F1的世界里，并肩作战的队友也会是最强劲的对手，而通往自我救赎的道路，绝非孤身一人能够走完。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"侏罗纪世界：重生","url":"/zh-CN/4ad230ca4cf3/","content":"\n剧情介绍　　故事发生在《侏罗纪世界3》事件的五年后。危在旦夕的恐龙族群生存于孤岛之上，但是它们中却隐藏着能够带来人类医药奇迹的关键基因，为获取神秘基因，一支精英小队潜入恐龙禁地，然而等待他们的却是无法预知的危机和惊天阴谋……\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"小暑","url":"/zh-CN/805b7fcb700e/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小暑"]},{"title":"超人","url":"/zh-CN/b7282dbe7869/","content":"\n剧情介绍　　导演詹姆斯·古恩这次带来了一个前所未见的超人故事：聚焦英雄的成长烦恼，展现超人在力量与责任之间的艰难抉择。　　当超人（大卫·科伦斯韦 饰）被卷入国内外多重冲突时，他保护人类的行为遭到质疑。而他显露的弱点，也趁机被科技巨擘、阴谋大师莱克斯·卢瑟（尼古拉斯·霍尔特 饰）利用，准备一举铲除超人。《星球日报》勇敢无畏的记者露易丝·莱恩（瑞秋·布罗斯纳安 饰）能否联手大都会的其他超能力者，以及超人忠诚的伙伴超狗小氪，在卢瑟彻底毁灭超人前拯救他？　　影片讲述了超人在两个身份之间自我和解的成长之旅，他既是来自氪星的卡尔-艾尔，也是在堪萨斯小镇长大的克拉克·肯特，他选择怀抱无私信念，将自身的强大力量用于守护人类。在这个将“善良”视作过时的世界里，他以人性之善为指引，坚定践行“真理、正义与更美好的明天”的永恒信念。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"大暑","url":"/zh-CN/514c5ede5ebb/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大暑"]},{"title":"神奇4侠：初露锋芒","url":"/zh-CN/2e4b39613b99/","content":"\n剧情介绍　　神奇先生（佩德罗·帕斯卡 饰）、隐形女（凡妮莎·柯比 饰）、霹雳火（约瑟夫·奎恩 饰）和石头人（爱波·莫斯-巴克拉赫 饰）。面对来自宇宙级威胁“行星吞噬者”（拉尔夫·伊内森 饰）及其使者“银影侠”（朱莉娅·加纳 饰）对地球上所有生灵的威胁，四人必须在家庭羁绊与英雄使命间抉择，挺身而出接受这个前所未有的严峻挑战。更令人措手不及的是，这场关乎地球存亡的危机竟与他们有着意想不到的关联。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"立秋","url":"/zh-CN/be6b0620bf8e/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立秋\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立秋"]},{"title":"Apple 百年城","url":"/zh-CN/f216bfc5a1c4/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple 百年城\n  已关闭\n  20151024-20250809\n\n\n\n  \n\n\n\n","categories":["零售店"],"tags":["Apple","Retail"]},{"title":"死神来了：血脉诅咒","url":"/zh-CN/827fe8a532de/","content":"\n剧情介绍　　大学生斯蒂芬妮（凯特琳·桑塔·胡安娜 Kaitlyn Santa Juana 饰）长期被噩梦困扰，她决定返回家乡寻找噩梦起源，却意外发现曾发生在外婆艾莉丝身上的离奇旧事，并牵连出流淌在整个家族血脉中的秘密：死神诅咒。当她试图破解诅咒密码，却发现死神的镰刀早已垂下…… 随着身边亲人一个个离奇惨死，斯蒂芬妮还能带领幸存者逃脱死神的宿命猎杀吗？\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"Apple 前海壹方城","url":"/zh-CN/c9a212830cdf/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple 前海壹方城\n  这方来逐浪\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["零售店"],"tags":["Apple","Retail"]},{"title":"处暑","url":"/zh-CN/ec00fc3d4b93/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  处暑\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","处暑"]},{"title":"白露","url":"/zh-CN/b11924d26cd5/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  白露\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","白露"]},{"title":"失落之魂","url":"/zh-CN/083897f63504/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","实体","SONY","PlayStation","光盘"]},{"title":"Apple 特别活动","url":"/zh-CN/e415a8bd7c84/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["发布会"],"tags":["Apple","Apple Event"]},{"title":"iPhone 17 Pro（A19 Pro，2025年）和 iPhone 17（A19，2025年）","url":"/zh-CN/d6b40790ab87/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  iPhone 17 Pro Max | iPhone 17 Pro\n  创新设计，打造巅峰性能和超长续航。\n\n\n\n  \n\n\n\n  iPhone 17\n  拉高好感度，再添耐用性。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPhone"]},{"title":"Apple Watch Ultra 3（S10，2025年）、 Apple Watch Series 11（S10，2025年）和 Apple Watch SE 3（S10，2025年）","url":"/zh-CN/70b5dfec823b/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple Watch Ultra 3\n  无限你的野\n\n\n\n  \n\n\n\n  Apple Watch Series 11\n  满手高招，\n  时刻照看好你的健康。\n\n\n\n  \n\n\n\n  Apple Watch SE 3\n  陪你练，随你聊，\n  帮你记，懂你心。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Watch"]},{"title":"秋分","url":"/zh-CN/8116da2d51fc/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  秋分\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","秋分"]},{"title":"AirPods Pro 3（H2，2025年）","url":"/zh-CN/9675917ae4e1/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  AirPods Pro 3\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","AirPods"]},{"title":"Taylor Swift The Life of a Showgirl (Track by Track Version)","url":"/zh-CN/931714ed0ef1/","content":"\n专辑介绍在《The Eras Tour》巡演打破各项纪录并圆满落幕后，Taylor Swift 的下一步是什么？这场巡演的成功点燃了她的创作热情，促使她与老搭档 Max Martin 和 Shellback 再次联手，共同打造第 12 张全长专辑《The Life of a Showgirl》。“《The Eras Tour》巡演无与伦比，是我最引以为傲的成就之一。当时我就想，‘我要制作一张同样让我骄傲的专辑。’这个念头催生了这张作品。我打电话问 Max，‘你们想不想一起？我可以去找你们。’”Taylor Swift 表示。\n的确，坚信“时差只是一种选择”的她，就像一位职业的歌舞女郎，在欧洲巡演的间隙往返于瑞典，与 Martin 和 Shellback 会合。这两位制作人曾参与 Swift 音乐生涯中多首经典作品的创作与制作，包括《We Are Never Ever Getting Back Together》《22》《Shake It Off》《Blank Space》《Don’t Blame Me》《Delicate》等。于是这一次，他们打造了一张自信闪耀、时而优雅、时而俏皮又时而感性的流行作品，探讨了 Swift 的人际关系与名望。专辑的大部分曲目既深刻私密又极具共鸣，也不乏《Elizabeth Taylor》这样专属于舞台巨星的篇章，在摇滚律动之间流露内心的种种挣扎。\n在首支单曲《The Fate of Ophelia》中，Swift 再次涉猎莎士比亚题材，这一灵感源泉曾给她带来了跨界的成功与歌迷的喜爱。她再度将莎翁的故事改写为浪漫颂歌而非悲剧，不过这一次，女主角在遇到男主角之前就已坦然接受孤独：“我曾发誓效忠于我 自我 我自己&#x2F;就在你点亮我的天空之前”（I swore my loyalty to me, myself, and I&#x2F;Right before you lit my sky up），显得更加成熟、更具有锋芒。\n当然，听众也免不了揣测她的灵感对象。《The Fate of Ophelia》中的“救赎者”，似乎是 Swift 的未婚夫、三届超级碗冠军 Travis Kelce，Swift 也正是在他的播客上宣布了这张专辑的发行消息。专辑中可能还有几首歌是为他而作，其中最直白的要数那首带有挑逗意味、充满 70 年代 Funk 风情的《Wood》，“男子气概的新高度”（New Heights of manhood）的歌词耐人寻味。\n除了恋人，制作精简的《Actually Romantic》出人意料地探讨了一位讨厌她的人。“你觉得我很俗气 宝贝&#x2F;别对我说粗话&#x2F;听起来很糟糕 但是&#x2F;感觉你像是在和我调情&#x2F;我管好自己的事 上帝可以证明我没有挑衅&#x2F;这让我有点兴奋”（You think I’m tacky, baby&#x2F;Stop talking dirty to me&#x2F;It sounded nasty but it feels like you’re flirting with me&#x2F;I mind my business, God’s my witness that I don’t provoke it&#x2F;It’s kind of making me wet），Swift 戏谑地唱道。而在《Father Figure》中，她以轻柔嗓音向 GEORGE MICHAEL 致敬，最后却以一位门徒的背叛骤然收场：“你和这个魔鬼做了交易&#x2F;结果我的家伙更大&#x2F;你想要战斗 你得到了&#x2F;我已经包围了这个地方”（You made a deal with this devil&#x2F;Turns out my dick’s bigger&#x2F;You want a fight, you found it&#x2F;I got the place surrounded）。\n不过，抛开这些被热议的灵感对象不谈，Swift 最擅长的便是创作令人沉醉、活力十足的流行歌曲，通过她讲述的故事传递普世的情感，这张专辑也鲜明地体现了这一点。《Opalite》轻快愉悦，讲述了两个人在正确的时间点相遇；巴洛克流行曲《Wi$h Li$t》描绘了一个清楚自己内心欲望的人；而按照惯例，Swift 每张专辑的第五首歌都是最脆弱动人的，这次的《Eldest Daughter》揭开了一份温柔奉献的承诺。\n专辑以同名曲《The Life of a Showgirl》收尾，Swift 与 Sabrina Carpenter 联袂上演了一场史诗般的二重唱，轮番讲述了一个名为 Kitty 的女孩的故事，或许也暗示了她们二人的处境与身份。“舞厅墙上所有的头像照 都是一个个辣妹 她们希望我快点去死&#x2F;但我现在已经得到永生 宝贝们&#x2F;即使我想也死不掉”（And all the headshots on the walls of the dance hall are of the bitches who wish I’d hurry up and die&#x2F;But I’m immortal now, baby dolls, I couldn’t if I tried），Swift 骄傲而笃定地唱道。正如她一次又一次证明过的那样，Taylor Swift 永远不会被时代淘汰。\n展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","Taylor Swift"]},{"title":"寒露","url":"/zh-CN/d613ac7aba65/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  寒露\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","寒露"]},{"title":"杨丞琳 有且","url":"/zh-CN/892964b7f601/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["杨丞琳","Apple Music"]},{"title":"iPhone Air（A19 Pro，2025年）","url":"/zh-CN/7deee6c42a79/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  iPhone Air\n  迄今最薄 iPhone，身藏高能内核。\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPhone"]},{"title":"霜降","url":"/zh-CN/b9fc4a3a36a5/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  霜降\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","霜降"]},{"title":"MacBook Pro 14英寸（M5，2025年）","url":"/zh-CN/2800be375550/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  MacBook Pro\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","Mac"]},{"title":"iPad Pro（M5，2025年）","url":"/zh-CN/9b0a108f8966/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  iPad Pro\n  高能猛进\n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","iPad"]},{"title":"SONY 次世代 PlayStation（Pro）上市","url":"/zh-CN/f8ceb214d894/","content":"\n主机介绍借助PS5 Pro主机，来自全球的优秀游戏创作者们可以通过进阶光线追踪、适用于4K电视的明快锐利图像清晰度，和高帧率游戏体验等令人难以置信的功能，来增强他们的游戏，为玩家们提供前所未有的游戏体验！\n展示\n\n\n","categories":["游戏"],"tags":["主机","国行","SONY","PlayStation"]},{"title":"潘玮柏 狂爱","url":"/zh-CN/d8aefced8af5/","content":"\n专辑介绍展示正面侧面背面\n","categories":["音乐"],"tags":["Apple Music","潘玮柏"]},{"title":"铁血战士：杀戮之地","url":"/zh-CN/c405930ae0f7/","content":"\n剧情介绍　　被部落放逐的年轻铁血战士戴克（迪米特里乌斯·舒斯特-科洛阿玛坦吉 饰），深入一片连宇宙顶级猎手都闻风丧胆的险恶之地。在那里，他将与维兰德-汤谷公司制造的仿生人希雅（艾丽·范宁 饰）意外结盟，这位仅存上半身的仿生人，与他共同踏上寻找终极对手的冒险征途。　　当“菜鸟”铁血初次狩猎便陷入最严酷的试炼，一步行差踏错即刻坠入无可挽回的深渊，唯有浴血厮杀，才能在绝境中争得一线生机。而这场终极较量也将颠覆铁血战士的狩猎法则——生存并非胜利的终点，而是通往更残酷考验的开始。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"立冬","url":"/zh-CN/15c57049c5ec/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立冬\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立冬"]},{"title":"鬼灭之刃：无限城篇 第一章 猗窝座再袭","url":"/zh-CN/e19cf92c8239/","content":"\n剧情介绍　　为了让变成鬼的妹妹祢豆子重新变回人类，灶门炭治郎加入了猎鬼组织“鬼杀队”，与同伴我妻善逸、嘴平伊之助一同对抗各类恶鬼，在成长的过程中彼此间的友情与羁绊也日益加深。此后，炭治郎与“鬼杀队”中最高级别的剑士“柱”们数次并肩作战。为备战即将到来的决战，炭治郎正与队员们一同挑战由“柱”们主持的联合强化训练时，鬼舞辻无惨突然现身于产屋敷宅邸。炭治郎与众“柱”虽为解救身处危机的主公大人而火速赶到，却遭无惨之手打入了一个神秘空间。炭治郎等人坠落之处，正是鬼的大本营“无限城”——“鬼杀队”与“鬼”的决战，就此拉开序幕。　　影片改编自同名畅销漫画《鬼灭之刃》。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"36岁生日快乐","url":"/zh-CN/5603344611ca/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  生日快乐\n\n\n\n  \n    \n  \n\n\n\n","categories":["纪念日"],"tags":["日常","生日"]},{"title":"小雪","url":"/zh-CN/a06883944477/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小雪\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小雪"]},{"title":"疯狂动物城2","url":"/zh-CN/8ebf4fe9d0e7/","content":"\n剧情介绍　　在《疯狂动物城2》中，警官兔朱迪（金妮弗·古德温 Ginnifer Goodwin 配音）与狐尼克（杰森·贝特曼 Jason Bateman 配音）这对备受全球观众喜爱的搭档将再度携手，带领观众重返充满活力的动物城，开启全新冒险。故事紧接前作，这对默契十足的搭档将直面职业与关系上的新挑战，揭开动物城深藏的秘密。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"Apple 北京荟聚","url":"/zh-CN/e5891e72115e/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  Apple 北京荟聚\n  有梦一起造\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["零售店"],"tags":["Apple","Retail"]},{"title":"大雪","url":"/zh-CN/71523711ecfd/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大雪\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大雪"]},{"title":"宇宙机器人","url":"/zh-CN/ede8059ad692/","content":"\n游戏介绍展示正面侧面背面\n","categories":["游戏"],"tags":["主机","实体","SONY","PlayStation","光盘"]},{"title":"冬至","url":"/zh-CN/d354749ba3e3/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  冬至\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","冬至"]},{"title":"阿凡达：火与烬","url":"/zh-CN/e10e2c416bec/","content":"\n剧情介绍　　影片聚焦杰克·萨利与奈蒂莉一家的命运起伏，在前作的情感余波之上，深刻描绘一个家族在战火中如何成长、并共同守护血脉相连的情感纽带的历程，从而将故事推向更具张力的全新维度。此外，潘多拉的全新领域也即将揭晓——观众将首次邂逅“风之商人”这个崇尚和平的全新游牧民族，他们乘坐独特的浮空生物飞船穿梭于各部落间，交易货物、传递信息。　　而更具颠覆性的是“灰烬族”的登场，这个以掠夺为生、性情凶猛的族群，与大地之母爱娃之间有着深刻的矛盾。他们的出现，将撕开潘多拉不为人知的黑暗传说。当弑亲之仇与部落恩怨交织，潘多拉的命运悬于一线——在这场跨文明的复仇之战中，人类与纳威族将如何抉择，才能真正守护各自的家园与未来？\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"元旦","url":"/zh-CN/28d765899b96/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  元旦快乐\n\n\n\n  \n\n\n\n","categories":["纪念日"],"tags":["日常","元旦"]},{"title":"小寒","url":"/zh-CN/cbe996e8b836/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  小寒\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","小寒"]},{"title":"AirPods Pro 3 马年特别款","url":"/zh-CN/b058cc597c97/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  \n\n\n\n  \n\n\n\n  \n\n\n\n","categories":["电子产品"],"tags":["Apple","AirPods"]},{"title":"大寒","url":"/zh-CN/b11c9e666abf/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  大寒\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","大寒"]},{"title":"重返寂静岭","url":"/zh-CN/ddf28c5b7274/","content":"\n剧情介绍　　在爱人神秘信件的召唤下，詹姆斯（杰瑞米·艾文 饰）重新回到了充满着秘密和诡谲的寂静岭。但当他踏入这座小镇的那一刻却开始了无尽极限逃生模式：永不停歇的防空警报撕裂耳膜，漫天余烬笼罩大地，熟悉的街道扭曲成噬人的迷宫，三角屠夫、无脸血腥护士、未知诡异生物无处不在，步步紧逼。　　现实与幻象在寂静岭彻底崩塌，詹姆斯一边躲避致命追杀，一边试图用破碎的记忆拼凑出真相。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"闪灵","url":"/zh-CN/425c5209fad7/","content":"\n剧情介绍　　杰克（杰克·尼科尔森 Jack Nicholson 饰）是一个作家。一个冬天，他得到了一个看管山顶酒店的差事。这正合杰克的意思，他正好可以有一个幽静的地方写作。于是杰克带着妻儿搬进了酒店。　　冬天大雪封路，山顶酒店只有杰克一家三口。从他们一搬进来，杰克的妻子温蒂（谢莉·杜 瓦尔 Shelley Duvall 饰）就发现这里气氛诡异，杰克的儿子丹尼（丹尼·劳埃德 Danny Lloyd 饰）经常看到一些他不认识的人，但这里除了他们一家别无他人。而杰克除了一整天闷头写作外，脾气亦变得越来越古怪。　　直到有一天，温蒂发现丈夫这些天来一直写就只有一句话：杰克发疯了！　　影片改编自斯蒂芬·金的同名小说。\n\n","categories":["电影"],"tags":["日常","IMAX"]},{"title":"立春","url":"/zh-CN/06e4e92a57a7/","content":"\n\n  #biaoti {\n    text-align: center;\n    padding: 20px;\n    font-size: 48px;\n  }\n\n\n\n  立春\n\n\n\n  \n\n\n\n","categories":["节气"],"tags":["日常","立春"]}]