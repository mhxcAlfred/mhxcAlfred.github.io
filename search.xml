<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode (1) Two Sum</title>
    <url>/90572e4a020b/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</p>
<p>因为 nums[<strong>0</strong>] + nums[<strong>1</strong>] &#x3D; 2 + 7 &#x3D; 9<br>所以返回 [<strong>0, 1</strong>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; m;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            if (m.count(target - nums[i])) &#123;</span><br><span class="line">                return &#123;i, m[target - nums[i]]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 99.97% of C++ online submissions for Two Sum.</p>
<p>Memory Usage: 10.4 MB, less than 26.36% of C++ online submissions for Two Sum.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Two Sum的C++提交中击败了64.21% 的用户</p>
<p>内存消耗 : 10.2 MB, 在Two Sum的C++提交中击败了0.82% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (10) Regular Expression Matching</title>
    <url>/ab531f709a92/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>)。实现支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>
<p><code>&#39;.&#39;</code> 匹配任意单个字符。<br><code>&#39;*&#39;</code> 匹配零个或多个前面的元素。</p>
<p>匹配应该覆盖<strong>整个</strong>字符串 (<code>s</code>) ，而不是部分字符串。</p>
<p><strong>说明:</strong></p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
</ul>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p><strong>输入:</strong><br><code>s = &quot;aa&quot;</code><br><code>p = &quot;a&quot;</code><br><strong>输出:</strong> false<br><strong>解释:</strong> <code>&quot;a&quot;</code> 无法匹配 <code>&quot;aa&quot;</code> 整个字符串。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong><br><code>s = &quot;aa&quot;</code><br><code>p = &quot;a*&quot;</code><br><strong>输出:</strong> true<br><strong>解释:</strong> <code>&#39;*&#39;</code> 代表可匹配零个或多个前面的元素, 即可以匹配 <code>&#39;a&#39;</code> 。因此, 重复 <code>&#39;a&#39;</code> 一次, 字符串可变为 <code>&quot;aa&quot;</code>。</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong><br><code>s = &quot;ab&quot;</code><br><code>p = &quot;.*&quot;</code><br><strong>输出:</strong> true<br><strong>解释:</strong> <code>&quot;.*&quot;</code>表示可匹配零个或多个<code>(&#39;*&#39;)</code>任意字符<code>(&#39;.&#39;)</code>。</p>
<h1 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h1><p><strong>输入:</strong><br><code>s = &quot;aab&quot;</code><br><code>p = &quot;c*a*b&quot;</code><br><strong>输出:</strong> true<br><strong>解释:</strong> <code>&#39;c&#39;</code> 可以不被重复, <code>&#39;a&#39;</code> 可以被重复一次。因此可以匹配字符串 <code>&quot;aab&quot;</code>。</p>
<h1 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h1><p><strong>输入:</strong><br><code>s = &quot;mississippi&quot;</code><br><code>p = &quot;mis*is*p*.&quot;</code><br><strong>输出:</strong> false</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] || (i &gt; <span class="number">0</span> &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 90.61% of C++ online submissions for Regular Expression Matching.</p>
<p>Memory Usage: 11.3 MB, less than 73.36% of C++ online submissions for Regular Expression Matching.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 32 ms, 在Regular Expression Matching的C++提交中击败了56.90% 的用户</p>
<p>内存消耗 : 11.2 MB, 在Regular Expression Matching的C++提交中击败了0.00% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (100) Same Tree</title>
    <url>/fc379004ee58/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>**输入: **</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   1         1</span><br><span class="line">  / \       / \</span><br><span class="line"> 2   3     2   3</span><br><span class="line">[1,2,3],   [1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p>**输入:  **</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     1         1</span><br><span class="line">    /           \</span><br><span class="line">   2             2</span><br><span class="line">[1,2],     [1,null,2]</span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong> false</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   1         1</span><br><span class="line">  / \       / \</span><br><span class="line"> 2   1     1   2</span><br><span class="line">[1,2,1],   [1,1,2]</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> false</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p &amp;&amp; !q) || (!p &amp;&amp; q) || (p-&gt;val != q-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Same Tree.</p>
<p>Memory Usage: 10 MB, less than 49.00% of C++ online submissions for Same Tree.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 4 ms, 在Same Tree的C++提交中击败了97.77% 的用户</p>
<p>内存消耗 : 9.8 MB, 在Same Tree的C++提交中击败了75.55% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (101) Symmetric Tree</title>
    <url>/2bb78c0fb0b4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSymmetric</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *left, TreeNode *right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!left &amp;&amp; !right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; !right || !left &amp;&amp; right || left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSymmetric</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">isSymmetric</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Symmetric Tree.</p>
<p>Memory Usage: 15 MB, less than 63.43% of C++ online submissions for Symmetric Tree.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Symmetric Tree的C++提交中击败了96.06% 的用户</p>
<p>内存消耗 : 15 MB, 在Symmetric Tree的C++提交中击败了79.19% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (102) Binary Tree Level Order Traversal</title>
    <url>/d701597a31cf/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; oneLevel;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                TreeNode *t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                oneLevel.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(oneLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 99.38% of C++ online submissions for Binary Tree Level Order Traversal.</p>
<p>Memory Usage: 14.2 MB, less than 28.31% of C++ online submissions for Binary Tree Level Order Traversal.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Binary Tree Level Order Traversal的C++提交中击败了95.59% 的用户</p>
<p>内存消耗 : 14.1 MB, 在Binary Tree Level Order Traversal的C++提交中击败了22.51% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (105) Construct Binary Tree from Preorder and Inorder Traversal</title>
    <url>/a10a473b6ba1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>前序遍历 preorder &#x3D; [3,9,20,15,7]<br>中序遍历 inorder &#x3D; [9,3,15,20,7]</p>
<p>返回如下的二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;preorder, vector&lt;<span class="type">int</span>&gt; &amp;inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;preorder, <span class="type">int</span> pLeft, <span class="type">int</span> pRight, vector&lt;<span class="type">int</span>&gt; &amp;inorder, <span class="type">int</span> iLeft, <span class="type">int</span> iRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pLeft &gt; pRight || iLeft &gt; iRight) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = iLeft; i &lt;= iRight; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preorder[pLeft] == inorder[i]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[pLeft]);</span><br><span class="line">        cur-&gt;left = <span class="built_in">buildTree</span>(preorder, pLeft + <span class="number">1</span>, pLeft + i - iLeft, inorder, iLeft, i - <span class="number">1</span>);</span><br><span class="line">        cur-&gt;right = <span class="built_in">buildTree</span>(preorder, pLeft + i - iLeft + <span class="number">1</span>, pRight, inorder, i + <span class="number">1</span>, iRight);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 96.64% of C++ online submissions for Construct Binary Tree from Preorder and Inorder Traversal.</p>
<p>Memory Usage: 16.8 MB, less than 53.69% of C++ online submissions for Construct Binary Tree from Preorder and Inorder Traversal.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 48 ms, 在Construct Binary Tree from Preorder and Inorder Traversal的C++提交中击败了53.08% 的用户</p>
<p>内存消耗 : 16.8 MB, 在Construct Binary Tree from Preorder and Inorder Traversal的C++提交中击败了38.02% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (104) Maximum Depth of Binary Tree</title>
    <url>/6e4eacccf3b2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 99.79% of C++ online submissions for Maximum Depth of Binary Tree.</p>
<p>Memory Usage: 19.6 MB, less than 15.62% of C++ online submissions for Maximum Depth of Binary Tree.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Maximum Depth of Binary Tree的C++提交中击败了96.43% 的用户</p>
<p>内存消耗 : 19.5 MB, 在Maximum Depth of Binary Tree的C++提交中击败了27.00% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (103) Binary Tree Zigzag Level Order Traversal</title>
    <url>/dc2eece1f79e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回锯齿形层次遍历如下：</p>
<p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode *root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;res;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        stack&lt;TreeNode*&gt; s1;</span><br><span class="line">        stack&lt;TreeNode*&gt; s2;</span><br><span class="line">        s1.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; out;</span><br><span class="line">        <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>() || !s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                TreeNode *cur = s1.<span class="built_in">top</span>();</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">                out.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) s2.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) s2.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (!out.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(out);</span><br><span class="line">            out.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span> (!s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                TreeNode *cur = s2.<span class="built_in">top</span>();</span><br><span class="line">                s2.<span class="built_in">pop</span>();</span><br><span class="line">                out.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) s1.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) s1.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!out.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(out);</span><br><span class="line">            out.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 94.20% of C++ online submissions for Binary Tree Zigzag Level Order Traversal.</p>
<p>Memory Usage: 13.7 MB, less than 20.86% of C++ online submissions for Binary Tree Zigzag Level Order Traversal.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 4 ms, 在Binary Tree Zigzag Level Order Traversal的C++提交中击败了99.71% 的用户</p>
<p>内存消耗 : 13.5 MB, 在Binary Tree Zigzag Level Order Traversal的C++提交中击败了44.22% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (106) Construct Binary Tree from Inorder and Postorder Traversal</title>
    <url>/3b7533c0f542/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder &#x3D; [9,3,15,20,7]<br>后序遍历 postorder &#x3D; [9,15,7,20,3]</p>
<p>返回如下的二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;inorder, vector&lt;<span class="type">int</span>&gt; &amp;postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;inorder, <span class="type">int</span> iLeft, <span class="type">int</span> iRight, vector&lt;<span class="type">int</span>&gt; &amp;postorder, <span class="type">int</span> pLeft, <span class="type">int</span> pRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (iLeft &gt; iRight || pLeft &gt; pRight) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode *cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[pRight]);</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = iLeft; i &lt; inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == cur-&gt;val) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;left = <span class="built_in">buildTree</span>(inorder, iLeft, i - <span class="number">1</span>, postorder, pLeft, pLeft + i - iLeft - <span class="number">1</span>);</span><br><span class="line">        cur-&gt;right = <span class="built_in">buildTree</span>(inorder, i + <span class="number">1</span>, iRight, postorder, pLeft + i - iLeft, pRight - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 97.13% of C++ online submissions for Construct Binary Tree from Inorder and Postorder Traversal.</p>
<p>Memory Usage: 16.7 MB, less than 69.05% of C++ online submissions for Construct Binary Tree from Inorder and Postorder Traversal.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 28 ms, 在Construct Binary Tree from Inorder and Postorder Traversal的C++提交中击败了94.01% 的用户</p>
<p>内存消耗 : 16.9 MB, 在Construct Binary Tree from Inorder and Postorder Traversal的C++提交中击败了34.72% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (107) Binary Tree Level Order Traversal II</title>
    <url>/7d096696b7cd/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其自底向上的层次遍历为：</p>
<p>[<br>  [15,7],<br>  [9,20],<br>  [3]<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">levelorder</span>(root, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; (res.<span class="built_in">rbegin</span>(), res.<span class="built_in">rend</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">levelorder</span><span class="params">(TreeNode* node, <span class="type">int</span> level, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() == level) res.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        res[level].<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) <span class="built_in">levelorder</span>(node-&gt;left, level + <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) <span class="built_in">levelorder</span>(node-&gt;right, level + <span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 99.29% of C++ online submissions for Binary Tree Level Order Traversal II.</p>
<p>Memory Usage: 15.3 MB, less than 7.44% of C++ online submissions for Binary Tree Level Order Traversal II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 20 ms, 在Binary Tree Level Order Traversal II的C++提交中击败了66.51% 的用户</p>
<p>内存消耗 : 15.2 MB, 在Binary Tree Level Order Traversal II的C++提交中击败了5.59% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (108) Convert Sorted Array to Binary Search Tree</title>
    <url>/53417ada784e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树 <strong>每个节点</strong> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<p>给定有序数组: [-10,-3,0,5,9],</p>
<p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     0</span><br><span class="line">    / \</span><br><span class="line">  -3   9</span><br><span class="line">  /   /</span><br><span class="line">-10  5</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(nums, <span class="number">0</span> , (<span class="type">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        TreeNode *cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        cur-&gt;left = <span class="built_in">helper</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        cur-&gt;right = <span class="built_in">helper</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 99.91% of C++ online submissions for Convert Sorted Array to Binary Search Tree.</p>
<p>Memory Usage: 21.2 MB, less than 42.93% of C++ online submissions for Convert Sorted Array to Binary Search Tree.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 32 ms, 在Convert Sorted Array to Binary Search Tree的C++提交中击败了94.69% 的用户</p>
<p>内存消耗 : 21.2 MB, 在Convert Sorted Array to Binary Search Tree的C++提交中击败了32.87% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (11) Container With Most Water</title>
    <url>/b1dc0dd14639/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定 n 个非负整数 a<sub>1</sub> ，a<sub>2</sub> , … , a<sub>n</sub> , 每个数代表坐标中的一个点 (i, a<sub>i</sub>) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, a<sub>i</sub>) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>说明:</strong> 你不能倾斜容器，且 n 的值至少为 2。</p>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"></p>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p><strong>输入:</strong> [1,8,6,2,5,4,8,3,7]<br><strong>输出:</strong> 49</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(height[i], height[j]) * (j - i));</span><br><span class="line">            height[i] &lt; height[j] ? ++i : --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 98.55% of C++ online submissions for Container With Most Water.</p>
<p>Memory Usage: 10.1 MB, less than 17.25% of C++ online submissions for Container With Most Water.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 40 ms, 在Container With Most Water的C++提交中击败了38.45% 的用户</p>
<p>内存消耗 : 9.9 MB, 在Container With Most Water的C++提交中击败了0.96% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (109) Convert Sorted List to Binary Search Tree</title>
    <url>/95eb0a62493e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树 <strong>每个节点</strong> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<p>给定的有序链表： [-10, -3, 0, 5, 9],</p>
<p>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     0</span><br><span class="line">    / \</span><br><span class="line">  -3   9</span><br><span class="line">  /   /</span><br><span class="line">-10  5</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (!head-&gt;next) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(head-&gt;val);</span><br><span class="line">        ListNode *slow = head, *fast = head, *last = slow;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            last = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode *cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(slow-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (head != slow) cur-&gt;left = <span class="built_in">sortedListToBST</span>(head);</span><br><span class="line">        cur-&gt;right = <span class="built_in">sortedListToBST</span>(fast);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 24 ms, faster than 99.26% of C++ online submissions for Convert Sorted List to Binary Search Tree.</p>
<p>Memory Usage: 24.5 MB, less than 47.72% of C++ online submissions for Convert Sorted List to Binary Search Tree.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 68 ms, 在Convert Sorted List to Binary Search Tree的C++提交中击败了45.82% 的用户</p>
<p>内存消耗 : 24.6 MB, 在Convert Sorted List to Binary Search Tree的C++提交中击败了27.89% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (110) Balanced Binary Tree</title>
    <url>/ef6ff4b5aa8c/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树 <strong>每个节点</strong> 的左右两个子树的高度差的绝对值不超过1。</p>
</blockquote>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回 <code>true</code> 。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>

<p>返回 <code>false</code> 。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(<span class="built_in">getDepth</span>(root-&gt;left) - <span class="built_in">getDepth</span>(root-&gt;right)) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">getDepth</span>(root-&gt;left), <span class="built_in">getDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 97.58% of C++ online submissions for Balanced Binary Tree.</p>
<p>Memory Usage: 17.4 MB, less than 28.11% of C++ online submissions for Balanced Binary Tree.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Balanced Binary Tree的C++提交中击败了97.47% 的用户</p>
<p>内存消耗 : 17.2 MB, 在Balanced Binary Tree的C++提交中击败了67.66% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (111) Minimum Depth of Binary Tree</title>
    <url>/622065a4681d/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最小深度  2.</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left) <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;right) <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 99.32% of C++ online submissions for Minimum Depth of Binary Tree.</p>
<p>Memory Usage: 20.2 MB, less than 5.05% of C++ online submissions for Minimum Depth of Binary Tree.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 20 ms, 在Minimum Depth of Binary Tree的C++提交中击败了94.92% 的用户</p>
<p>内存消耗 : 20.1 MB, 在Minimum Depth of Binary Tree的C++提交中击败了6.74% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (112) Path Sum</title>
    <url>/68fa22d79798/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure>

<p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == sum ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 91.41% of C++ online submissions for Path Sum.</p>
<p>Memory Usage: 20 MB, less than 17.20% of C++ online submissions for Path Sum.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 24 ms, 在Path Sum的C++提交中击败了92.18% 的用户</p>
<p>内存消耗 : 20 MB, 在Path Sum的C++提交中击败了5.96% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (113) Path Sum II</title>
    <url>/4a591b85b6c1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>

<p>返回:</p>
<p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">pathSum</span>(TreeNode *root, <span class="type">int</span> sum) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *cur = root, *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">                s.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                val += cur-&gt;val;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.<span class="built_in">back</span>(); </span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; val == sum) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it : s) &#123;</span><br><span class="line">                    v.<span class="built_in">push_back</span>(it-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                res.<span class="built_in">push_back</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right &amp;&amp; cur-&gt;right != pre) cur = cur-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                val -= cur-&gt;val;</span><br><span class="line">                s.<span class="built_in">pop_back</span>();</span><br><span class="line">                cur = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 95.56% of C++ online submissions for Path Sum II.</p>
<p>Memory Usage: 18.9 MB, less than 98.97% of C++ online submissions for Path Sum II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 28 ms, 在Path Sum II的C++提交中击败了94.76% 的用户</p>
<p>内存消耗 : 18.9 MB, 在Path Sum II的C++提交中击败了98.14% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (116) Populating Next Right Pointers in Each Node</title>
    <url>/3d889e0876b9/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<p><strong>示例:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png"></p>
<p><strong>输入:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;next&quot;:null,&quot;right&quot;:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;next&quot;:null,&quot;right&quot;:</span><br><span class="line">&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;7&quot;&#125;,&quot;val&quot;:1&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong>给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p>
<p><strong>提示：</strong></p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                Node *t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                    t-&gt;next = q.<span class="built_in">front</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 52 ms, faster than 97.65% of C++ online submissions for Populating Next Right Pointers in Each Node.</p>
<p>Memory Usage: 27.4 MB, less than 12.72% of C++ online submissions for Populating Next Right Pointers in Each Node.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 88 ms, 在Populating Next Right Pointers in Each Node的C++提交中击败了93.13% 的用户</p>
<p>内存消耗 : 27.3 MB, 在Populating Next Right Pointers in Each Node的C++提交中击败了11.35% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (115) Distinct Subsequences 待定</title>
    <url>/d719b2562a7f/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 **S **和一个字符串 <strong>T</strong>，计算在 <strong>S</strong> 的子序列中 <strong>T</strong> 出现的个数。</p>
<p>一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>&quot;ACE&quot;</code> 是 <code>&quot;ABCDE&quot;</code> 的一个子序列，而 <code>&quot;AEC&quot;</code> 不是）</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> S &#x3D; <code>&quot;rabbbit&quot;</code>, T &#x3D; <code>&quot;rabbit&quot; **输出:** 3</code> <strong>解释:</strong><br>如下图所示, 有 3 种可以从 S 中得到 <code>&quot;rabbit&quot; 的方案</code>。<br>(上箭头符号 ^ 表示选取的字母)</p>
<p><code>rabbbit</code><br>^^^^ ^^<br><code>rabbbit</code><br>^^ ^^^^<br><code>rabbbit</code><br>^^^ ^^^</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> S &#x3D; <code>&quot;babgbag&quot;</code>, T &#x3D; <code>&quot;bag&quot; **输出:** 5</code> <strong>解释:</strong><br>如下图所示, 有 5 种可以从 S 中得到 <code>&quot;bag&quot; 的方案</code>。<br>(上箭头符号 ^ 表示选取的字母)</p>
<p><code>babgbag</code><br>^^ ^<br><code>babgbag</code><br>^^    ^<br><code>babgbag</code><br>^    ^^<br><code>babgbag</code><br>  ^  ^^<br><code>babgbag</code><br>    ^^^</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">待定</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>待定</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>待定</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (114) Flatten Binary Tree to Linked List</title>
    <url>/1c4e0628471f/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，原地将它展开为链表。</p>
<p>例如，给定二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>

<p>将其展开为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) <span class="built_in">flatten</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line">        TreeNode *tmp = root-&gt;right;</span><br><span class="line">        root-&gt;right = root-&gt;left;</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (root-&gt;right) root = root-&gt;right;</span><br><span class="line">        root-&gt;right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 99.08% of C++ online submissions for Flatten Binary Tree to Linked List.</p>
<p>Memory Usage: 10 MB, less than 59.46% of C++ online submissions for Flatten Binary Tree to Linked List.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Flatten Binary Tree to Linked List的C++提交中击败了95.41% 的用户</p>
<p>内存消耗 : 10 MB, 在Flatten Binary Tree to Linked List的C++提交中击败了72.22% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (117) Populating Next Right Pointers in Each Node II</title>
    <url>/40ae94b13cbf/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<p><strong>示例：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png"></p>
<p><strong>输入:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:</span><br><span class="line">&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:1&#125;</span><br></pre></td></tr></table></figure>

<p>**解释:**给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p>
<p><strong>提示:</strong></p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                Node *t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i &lt; len - <span class="number">1</span>) t-&gt;next = q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 384 ms, faster than 99.16% of C++ online submissions for Populating Next Right Pointers in Each Node II.</p>
<p>Memory Usage: 67 MB, less than 23.95% of C++ online submissions for Populating Next Right Pointers in Each Node II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 828 ms, 在Populating Next Right Pointers in Each Node II的C++提交中击败了54.41% 的用户</p>
<p>内存消耗 : 67 MB, 在Populating Next Right Pointers in Each Node II的C++提交中击败了35.67% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (118) Pascal&#39;s Triangle</title>
    <url>/16370bbab784/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非负整数 <strong>numRows</strong>，生成杨辉三角的前 <strong>numRows</strong> 行。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif"></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> 5<br><strong>输出:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(numRows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">            res[i].<span class="built_in">resize</span>(i + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                res[i][j] = res[i - <span class="number">1</span>][j - <span class="number">1</span>] + res[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 87.85% of C++ online submissions for Pascal’s Triangle.</p>
<p>Memory Usage: 8.8 MB, less than 50.33% of C++ online submissions for Pascal’s Triangle.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Pascal’s Triangle的C++提交中击败了88.97% 的用户</p>
<p>内存消耗 : 8.8 MB, 在Pascal’s Triangle的C++提交中击败了12.32% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (119) Pascal&#39;s Triangle II</title>
    <url>/ac86a0ad8b09/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif"></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> 3<br><strong>输出:</strong> [1,3,3,1]</p>
<p><strong>进阶:</strong></p>
<p>你可以优化你的算法到 O(k) 空间复杂度吗？</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(rowIndex + <span class="number">1</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">                res[j] += res[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 88.22% of C++ online submissions for Pascal’s Triangle II.</p>
<p>Memory Usage: 8.6 MB, less than 37.72% of C++ online submissions for Pascal’s Triangle II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Pascal’s Triangle II的C++提交中击败了86.10% 的用户</p>
<p>内存消耗 : 8.4 MB, 在Pascal’s Triangle II的C++提交中击败了59.66% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (12) Integer to Roman</title>
    <url>/7ba23dca6fa4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<table>
<thead>
<tr>
<th align="center"><strong>字符</strong></th>
<th align="center"><strong>数值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">I</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">500</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">1000</td>
</tr>
</tbody></table>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p><strong>输入:</strong> 3<br><strong>输出:</strong> “III”</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 4<br><strong>输出:</strong> “IV”</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> 9<br><strong>输出:</strong> “IX”</p>
<h1 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h1><p><strong>输入:</strong> 58<br><strong>输出:</strong> “LVIII”<br><strong>解释:</strong> L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</p>
<h1 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h1><p><strong>输入:</strong> 1994<br><strong>输出:</strong> “MCMXCIV”<br><strong>解释:</strong> M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; roman&#123;<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;I&#x27;</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; value&#123;<span class="number">1000</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">7</span>; n += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x = num / value[n];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; ++i) res += roman[n];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">4</span>) &#123;</span><br><span class="line">                res = res + roman[n] + roman[n - <span class="number">1</span>]; </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">4</span> &amp;&amp; x &lt; <span class="number">9</span>) &#123;</span><br><span class="line">                res += roman[n - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">6</span>; i &lt;= x; ++i) res += roman[n];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">9</span>) &#123;</span><br><span class="line">                res = res + roman[n] + roman[n - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            num %= value[n];            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 44 ms, faster than 88.10% of C++ online submissions for Integer to Roman.</p>
<p>Memory Usage: 31.5 MB, less than 41.72% of C++ online submissions for Integer to Roman.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 112 ms, 在Integer to Roman的C++提交中击败了0.85% 的用户</p>
<p>内存消耗 : 31.4 MB, 在Integer to Roman的C++提交中击败了0.85% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (120) Triangle</title>
    <url>/899dbcb4867e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [**2**],</span><br><span class="line">    [**3**,4],</span><br><span class="line">   [6,**5**,7],</span><br><span class="line">  [4,**1**,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong>+ <strong>3</strong> + <strong>5</strong>+ <strong>1</strong> &#x3D; 11）。</p>
<p><strong>说明:</strong></p>
<p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(triangle.back())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="type">int</span>)triangle.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j + <span class="number">1</span>]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 98.89% of C++ online submissions for Triangle.</p>
<p>Memory Usage: 9.8 MB, less than 80.30% of C++ online submissions for Triangle.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Triangle的C++提交中击败了95.92% 的用户</p>
<p>内存消耗 : 9.9 MB, 在Triangle的C++提交中击败了59.60% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (121) Best Time to Buy and Sell Stock</title>
    <url>/483f822c9401/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [7,1,5,3,6,4]<br><strong>输出:</strong> 5<br><strong>解释:</strong> 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>入:</strong> [7,6,4,3,1]<br><strong>输出:</strong> 0<br><strong>解释:</strong> 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, buy = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            buy = <span class="built_in">min</span>(buy, price);</span><br><span class="line">            res = <span class="built_in">max</span>(res, price - buy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Best Time to Buy and Sell Stock.</p>
<p>Memory Usage: 9.7 MB, less than 9.41% of C++ online submissions for Best Time to Buy and Sell Stock.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Best Time to Buy and Sell Stock的C++提交中击败了90.78% 的用户</p>
<p>内存消耗 : 9.7 MB, 在Best Time to Buy and Sell Stock的C++提交中击败了6.64% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (124) Binary Tree Maximum Path Sum</title>
    <url>/e8af1e056acd/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 <strong>非空</strong> 二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [1,2,3]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> 6</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [-10,9,20,null,null,15,7]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> -10</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> 42</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN;</span><br><span class="line">        <span class="built_in">helper</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="type">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">max</span>(<span class="built_in">helper</span>(node-&gt;left, res), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">max</span>(<span class="built_in">helper</span>(node-&gt;right, res), <span class="number">0</span>);</span><br><span class="line">        res = <span class="built_in">max</span>(res, left + right + node-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 36 ms, faster than 75.91% of C++ online submissions for Binary Tree Maximum Path Sum.</p>
<p>Memory Usage: 25.3 MB, less than 32.82% of C++ online submissions for Binary Tree Maximum Path Sum.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 36 ms, 在Binary Tree Maximum Path Sum的C++提交中击败了96.23% 的用户</p>
<p>内存消耗 : 25.4 MB, 在Binary Tree Maximum Path Sum的C++提交中击败了13.08% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (122) Best Time to Buy and Sell Stock II</title>
    <url>/04a299e3d97b/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>**注意:**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [7,1,5,3,6,4]<br><strong>输出:</strong> 7<br><strong>解释:</strong> 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [1,2,3,4,5]<br><strong>输出:</strong> 4<br><strong>解释:</strong> 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> [7,6,4,3,1]<br><strong>输出:</strong> 0<br><strong>解释:</strong> 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>]) sum += prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 88.95% of C++ online submissions for Best Time to Buy and Sell Stock II.</p>
<p>Memory Usage: 9.7 MB, less than 5.19% of C++ online submissions for Best Time to Buy and Sell Stock II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Best Time to Buy and Sell Stock II的C++提交中击败了89.87% 的用户</p>
<p>内存消耗 : 9.6 MB, 在Best Time to Buy and Sell Stock II的C++提交中击败了5.21% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (123) Best Time to Buy and Sell Stock III</title>
    <url>/c0e46d6edda8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p><strong>注意:</strong> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [3,3,5,0,0,3,1,4]<br><strong>输出:</strong> 6<br><strong>解释:</strong> 在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。<br>     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [1,2,3,4,5]<br><strong>输出:</strong> 4<br><strong>解释:</strong> 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> [7,6,4,3,1]<br><strong>输出:</strong> 0<br><strong>解释:</strong> 在这个情况下, 没有交易完成, 所以最大利润为 0。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> g[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> l[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> diff = prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">                l[j] = <span class="built_in">max</span>(g[j - <span class="number">1</span>] + <span class="built_in">max</span>(diff, <span class="number">0</span>), l[j] + diff);</span><br><span class="line">                g[j] = <span class="built_in">max</span>(l[j], g[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 99.76% of C++ online submissions for Best Time to Buy and Sell Stock III.</p>
<p>Memory Usage: 9.6 MB, less than 57.69% of C++ online submissions for Best Time to Buy and Sell Stock III.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 20 ms, 在Best Time to Buy and Sell Stock III的C++提交中击败了37.53% 的用户</p>
<p>内存消耗 : 9.6 MB, 在Best Time to Buy and Sell Stock III的C++提交中击败了43.60% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (125) Valid Palindrome</title>
    <url>/540adb4b9f2f/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><strong>说明:</strong> 本题中，我们将空字符串定义为有效的回文串。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> “A man, a plan, a canal: Panama”<br><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> “race a car”<br><strong>输出:</strong> false</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isAlphaNum</span>(s[left])) ++left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">isAlphaNum</span>(s[right])) --right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((s[left] + <span class="number">32</span> - <span class="string">&#x27;a&#x27;</span>) %<span class="number">32</span> != (s[right] + <span class="number">32</span> - <span class="string">&#x27;a&#x27;</span>) % <span class="number">32</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++left; --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAlphaNum</span><span class="params">(<span class="type">char</span> &amp;ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 94.93% of C++ online submissions for Valid Palindrome.</p>
<p>Memory Usage: 9.3 MB, less than 60.19% of C++ online submissions for Valid Palindrome.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Valid Palindrome的C++提交中击败了87.19% 的用户</p>
<p>内存消耗 : 9.4 MB, 在Valid Palindrome的C++提交中击败了17.05% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (127) Word Ladder</title>
    <url>/bc2554e0cb48/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p><strong>说明:</strong></p>
<ul>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li>
</ul>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong><br>beginWord &#x3D; “hit”,<br>endWord &#x3D; “cog”,<br>wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p>
<p><strong>输出:</strong> 5</p>
<p><strong>解释:</strong> 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>     返回它的长度 5。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong><br>beginWord &#x3D; “hit”<br>endWord &#x3D; “cog”<br>wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”]</p>
<p><strong>输出:</strong> 0</p>
<p><strong>解释:</strong> endWord “cog” 不在字典中，所以无法进行转换。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordList.begin(), wordList.end())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!wordSet.<span class="built_in">count</span>(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue&lt;string&gt; q&#123;&#123;beginWord&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                string word = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (word == endWord) <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    string newWord = word;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>; ch &lt;= <span class="string">&#x27;z&#x27;</span>; ++ch) &#123;</span><br><span class="line">                        newWord[i] = ch;</span><br><span class="line">                        <span class="keyword">if</span> (wordSet.<span class="built_in">count</span>(newWord) &amp;&amp; newWord != word) &#123;</span><br><span class="line">                            q.<span class="built_in">push</span>(newWord);</span><br><span class="line">                            wordSet.<span class="built_in">erase</span>(newWord);</span><br><span class="line">                        &#125;   </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 68 ms, faster than 88.52% of C++ online submissions for Word Ladder.</p>
<p>Memory Usage: 13 MB, less than 76.15% of C++ online submissions for Word Ladder.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 140 ms, 在Word Ladder的C++提交中击败了70.67% 的用户</p>
<p>内存消耗 : 13.1 MB, 在Word Ladder的C++提交中击败了68.75% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (126) Word Ladder II</title>
    <url>/6c38d3f6443e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p><strong>说明:</strong></p>
<ul>
<li>如果不存在这样的转换序列，返回一个空列表。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li>
</ul>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong><br>beginWord &#x3D; “hit”,<br>endWord &#x3D; “cog”,<br>wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p>
<p><strong>输出:</strong><br>[<br>  [“hit”,”hot”,”dot”,”dog”,”cog”],<br>  [“hit”,”hot”,”lot”,”log”,”cog”]<br>]</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong><br>beginWord &#x3D; “hit”<br>endWord &#x3D; “cog”<br>wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”]</p>
<p><strong>输出:</strong> []</p>
<p><strong>解释:</strong> endWord “cog” 不在字典中，所以不存在符合要求的转换序列。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">findLadders</span>(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">dict</span><span class="params">(wordList.begin(), wordList.end())</span></span>;</span><br><span class="line">        vector&lt;string&gt; p&#123;beginWord&#125;;</span><br><span class="line">        queue&lt;vector&lt;string&gt;&gt; paths;</span><br><span class="line">        paths.<span class="built_in">push</span>(p);</span><br><span class="line">        <span class="type">int</span> level = <span class="number">1</span>, minLevel = INT_MAX;</span><br><span class="line">        unordered_set&lt;string&gt; words;</span><br><span class="line">        <span class="keyword">while</span> (!paths.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = paths.<span class="built_in">front</span>(); paths.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (t.<span class="built_in">size</span>() &gt; level) &#123;</span><br><span class="line">                <span class="keyword">for</span> (string w : words) dict.<span class="built_in">erase</span>(w);</span><br><span class="line">                words.<span class="built_in">clear</span>();</span><br><span class="line">                level = t.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">if</span> (level &gt; minLevel) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            string last = t.<span class="built_in">back</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; last.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                string newLast = last;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>; ch &lt;= <span class="string">&#x27;z&#x27;</span>; ++ch) &#123;</span><br><span class="line">                    newLast[i] = ch;</span><br><span class="line">                    <span class="keyword">if</span> (!dict.<span class="built_in">count</span>(newLast)) <span class="keyword">continue</span>;</span><br><span class="line">                    words.<span class="built_in">insert</span>(newLast);</span><br><span class="line">                    vector&lt;string&gt; nextPath = t;</span><br><span class="line">                    nextPath.<span class="built_in">push_back</span>(newLast);</span><br><span class="line">                    <span class="keyword">if</span> (newLast == endWord) &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(nextPath);</span><br><span class="line">                        minLevel = level;</span><br><span class="line">                    &#125; <span class="keyword">else</span> paths.<span class="built_in">push</span>(nextPath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 412 ms, faster than 53.28% of C++ online submissions for Word Ladder II.</p>
<p>Memory Usage: 178.4 MB, less than 19.69% of C++ online submissions for Word Ladder II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 648 ms, 在Word Ladder II的C++提交中击败了44.99% 的用户</p>
<p>内存消耗 : 178.4 MB, 在Word Ladder II的C++提交中击败了13.87% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (129) Sum Root to Leaf Numbers</title>
    <url>/88f365f68fab/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，它的每个结点都存放一个 <code>0-9</code> 的数字，每条从根到叶子节点的路径都代表一个数字。</p>
<p>例如，从根到叶子节点路径 <code>1-&gt;2-&gt;3</code> 代表数字 <code>123</code>。</p>
<p>计算从根到叶子节点生成的所有数字之和。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [1,2,3]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> 25<br><strong>解释:</strong><br>从根到叶子节点路径 <code>1-&gt;2</code> 代表数字 <code>12</code>.<br>从根到叶子节点路径 <code>1-&gt;3</code> 代表数字 <code>13</code>.<br>因此，数字总和 &#x3D; 12 + 13 &#x3D; <code>25</code>.</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [4,9,0,5,1]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  9   0</span><br><span class="line"> / \</span><br><span class="line">5   1</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> 1026<br><strong>解释:</strong><br>从根到叶子节点路径 <code>4-&gt;9-&gt;5</code> 代表数字 495.<br>从根到叶子节点路径 <code>4-&gt;9-&gt;1</code> 代表数字 491.<br>从根到叶子节点路径 <code>4-&gt;0</code> 代表数字 40.<br>因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; <code>1026</code>.</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sumNumbersDFS</span>(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNumbersDFS</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum = sum * <span class="number">10</span> + root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sumNumbersDFS</span>(root-&gt;left, sum) + <span class="built_in">sumNumbersDFS</span>(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 93.22% of C++ online submissions for Sum Root to Leaf Numbers.</p>
<p>Memory Usage: 12.3 MB, less than 79.30% of C++ online submissions for Sum Root to Leaf Numbers.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 4 ms, 在Sum Root to Leaf Numbers的C++提交中击败了96.39% 的用户</p>
<p>内存消耗 : 12.3 MB, 在Sum Root to Leaf Numbers的C++提交中击败了79.25% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (13) Roman to Integer</title>
    <url>/e366aa577dfd/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<table>
<thead>
<tr>
<th align="center"><strong>字符</strong></th>
<th align="center"><strong>数值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">I</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">500</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">1000</td>
</tr>
</tbody></table>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p><strong>输入:</strong> “III”<br><strong>输出:</strong> 3</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> “IV”<br><strong>输出:</strong> 4</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> “IX”<br><strong>输出:</strong> 9</p>
<h1 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h1><p><strong>输入:</strong> “LVIII”<br><strong>输出:</strong> 58<br><strong>解释:</strong> L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</p>
<h1 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h1><p><strong>输入:</strong> “MCMXCIV”<br><strong>输出:</strong> 1994<br><strong>解释:</strong> M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m&#123;&#123;<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>&#125;, &#123;<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>&#125;, &#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>&#125;, &#123;<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>&#125;, &#123;<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> val = m[s[i]];</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() - <span class="number">1</span> || m[s[i+<span class="number">1</span>]] &lt;= m[s[i]]) res += val;</span><br><span class="line">            <span class="keyword">else</span> res -= val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 60 ms, faster than 56.27% of C++ online submissions for Roman to Integer.</p>
<p>Memory Usage: 32.9 MB, less than 54.51% of C++ online submissions for Roman to Integer.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 140 ms, 在Roman to Integer的C++提交中击败了0.84% 的用户</p>
<p>内存消耗 : 32.9 MB, 在Roman to Integer的C++提交中击败了0.33% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (131) Palindrome Partitioning</title>
    <url>/c8001ba02a2e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 s 所有可能的分割方案。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> “aab”<br><strong>输出:</strong><br>[<br>  [“aa”,”b”],<br>  [“a”,”a”,”b”]<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        vector&lt;string&gt; out;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (i - j &lt;= <span class="number">2</span> || dp[j + <span class="number">1</span>][i - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[j][i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">helper</span>(s, <span class="number">0</span>, dp, out, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(string s, <span class="type">int</span> start, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; dp, vector&lt;string&gt;&amp; out, vector&lt;vector&lt;string&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.<span class="built_in">size</span>()) &#123; res.<span class="built_in">push_back</span>(out); <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dp[start][i]) <span class="keyword">continue</span>;</span><br><span class="line">            out.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(start, i - start + <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">helper</span>(s, i + <span class="number">1</span>, dp, out, res);</span><br><span class="line">            out.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 24 ms, faster than 70.14% of C++ online submissions for Palindrome Partitioning.</p>
<p>Memory Usage: 13.9 MB, less than 71.84% of C++ online submissions for Palindrome Partitioning.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 32 ms, 在Palindrome Partitioning的C++提交中击败了88.44% 的用户</p>
<p>内存消耗 : 13.7 MB, 在Palindrome Partitioning的C++提交中击败了84.77% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (132) Palindrome Partitioning II</title>
    <url>/c6dd07e89e27/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回符合要求的最少分割次数。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> “aab”<br><strong>输出:</strong> 1<br><strong>解释:</strong> 进行一次分割就可将 s 分割成 [“aa”,”b”] 这样两个回文子串。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">0</span>; i - len &gt;= <span class="number">0</span> &amp;&amp; i + len &lt; n &amp;&amp; s[i - len] == s[i + len]; ++len) &#123;</span><br><span class="line">                dp[i + len + <span class="number">1</span>] = <span class="built_in">min</span>(dp[i + len + <span class="number">1</span>], <span class="number">1</span> + dp[i - len]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">0</span>; i - len &gt;= <span class="number">0</span> &amp;&amp; i + len + <span class="number">1</span> &lt; n &amp;&amp; s[i - len] == s[i + len + <span class="number">1</span>]; ++len) &#123;</span><br><span class="line">                dp[i + len + <span class="number">2</span>] = <span class="built_in">min</span>(dp[i + len + <span class="number">2</span>], <span class="number">1</span> + dp[i - len]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 99.94% of C++ online submissions for Palindrome Partitioning II.</p>
<p>Memory Usage: 8.7 MB, less than 77.25% of C++ online submissions for Palindrome Partitioning II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Palindrome Partitioning II的C++提交中击败了94.40% 的用户</p>
<p>内存消耗 : 8.4 MB, 在Palindrome Partitioning II的C++提交中击败了94.94% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (130) Surrounded Regions</title>
    <url>/53cf3c1b5bbf/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p>
<p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>X X X X<br>X O O X<br>X X O X<br>X O X X</p>
<p>运行你的函数后，矩阵变为：</p>
<p>X X X X<br>X X X X<br>X X X X<br>X O X X</p>
<p><strong>解释:</strong></p>
<p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 <code>&#39;O&#39;</code> 都不会被填充为 <code>&#39;X&#39;</code>。 任何不在边界上，或不与边界上的 <code>&#39;O&#39;</code> 相连的 <code>&#39;O&#39;</code> 最终都会被填充为 <code>&#39;X&#39;</code>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i == <span class="number">0</span> || i == board.<span class="built_in">size</span>() - <span class="number">1</span> || j == <span class="number">0</span> || j == board[i].<span class="built_in">size</span>() - <span class="number">1</span>) &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                    <span class="built_in">solveDFS</span>(board, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;$&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveDFS</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt; &amp;board, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            board[i][j] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; board[i - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>) </span><br><span class="line">                <span class="built_in">solveDFS</span>(board, i - <span class="number">1</span>, j);</span><br><span class="line">            <span class="keyword">if</span> (j &lt; board[i].<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; board[i][j + <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) </span><br><span class="line">                <span class="built_in">solveDFS</span>(board, i, j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; board.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; board[i + <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>) </span><br><span class="line">                <span class="built_in">solveDFS</span>(board, i + <span class="number">1</span>, j);</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; board[i][j - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) </span><br><span class="line">                <span class="built_in">solveDFS</span>(board, i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 24 ms, faster than 99.10% of C++ online submissions for Surrounded Regions.</p>
<p>Memory Usage: 14.3 MB, less than 63.96% of C++ online submissions for Surrounded Regions.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 64 ms, 在Surrounded Regions的C++提交中击败了43.53% 的用户</p>
<p>内存消耗 : 14.1 MB, 在Surrounded Regions的C++提交中击败了82.24% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (128) Longest Consecutive Sequence</title>
    <url>/33543f717645/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>
<p>要求算法的时间复杂度为 O(n)。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> [100, 4, 200, 1, 3, 2]<br><strong>输出:</strong> 4<br><strong>解释:</strong> 最长连续序列是 <code>[1, 2, 3, 4]。它的长度为 4。</code></p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">count</span>(val)) <span class="keyword">continue</span>;</span><br><span class="line">            s.<span class="built_in">erase</span>(val);</span><br><span class="line">            <span class="type">int</span> pre = val - <span class="number">1</span>, next = val + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (s.<span class="built_in">count</span>(pre)) s.<span class="built_in">erase</span>(pre--);</span><br><span class="line">            <span class="keyword">while</span> (s.<span class="built_in">count</span>(next)) s.<span class="built_in">erase</span>(next++);</span><br><span class="line">            res = <span class="built_in">max</span>(res, next - pre - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 86.34% of C++ online submissions for Longest Consecutive Sequence.</p>
<p>Memory Usage: 10 MB, less than 63.63% of C++ online submissions for Longest Consecutive Sequence.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 20 ms, 在Longest Consecutive Sequence的C++提交中击败了79.27% 的用户</p>
<p>内存消耗 : 10 MB, 在Longest Consecutive Sequence的C++提交中击败了59.41% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (133) Clone Graph</title>
    <url>/053e85468f4f/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定无向<a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin"><strong>连通</strong></a>图中一个节点的引用，返回该图的<a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin"><strong>深拷贝</strong></a>（克隆）。图中的每个节点都包含它的值 <code>val</code>（<code>Int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="https://assets.leetcode.com/uploads/2019/02/19/113_sample.png"></p>
<p><strong>输入:</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[&#123;&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;1&quot;&#125;,&#123;&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&#123;&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;3&quot;&#125;,&#123;&quot;$ref&quot;:&quot;1&quot;&#125;],&quot;val&quot;:4&#125;],&quot;val&quot;:3&#125;],&quot;val&quot;:2&#125;,&#123;&quot;$ref&quot;:&quot;4&quot;&#125;],&quot;val&quot;:1&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释:</strong><br>节点 1 的值是 1，它有两个邻居：节点 2 和 4 。<br>节点 2 的值是 2，它有两个邻居：节点 1 和 3 。<br>节点 3 的值是 3，它有两个邻居：节点 2 和 4 。<br>节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</p>
<p><strong>提示:</strong></p>
<ol>
<li>节点数介于 1 到 100 之间。</li>
<li>无向图是一个<a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#Simple_graph">简单图</a>，这意味着图中没有重复的边，也没有自环。</li>
<li>由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。</li>
<li>必须将<strong>给定节点的拷贝</strong>作为对克隆图的引用返回。</li>
</ol>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; m;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(node, m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">helper</span><span class="params">(Node* node, unordered_map&lt;Node*, Node*&gt;&amp; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">count</span>(node)) <span class="keyword">return</span> m[node];</span><br><span class="line">        Node *clone = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        m[node] = clone;</span><br><span class="line">        <span class="keyword">for</span> (Node *neighbor : node-&gt;neighbors) &#123;</span><br><span class="line">            clone-&gt;neighbors.<span class="built_in">push_back</span>(<span class="built_in">helper</span>(neighbor, m));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 98.26% of C++ online submissions for Clone Graph.</p>
<p>Memory Usage: 16.8 MB, less than 22.41% of C++ online submissions for Clone Graph.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 52 ms, 在Clone Graph的C++提交中击败了53.78% 的用户</p>
<p>内存消耗 : 16.9 MB, 在Clone Graph的C++提交中击败了5.85% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (134) Gas Station</title>
    <url>/5b7ea4eb0139/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 <code>gas[i]</code>升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 <code>cost[i]</code>升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p><strong>说明:</strong> </p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong><br>gas  &#x3D; [1,2,3,4,5]<br>cost &#x3D; [3,4,5,1,2]</p>
<p><strong>输出:</strong> 3</p>
<p><strong>解释:</strong> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong><br>gas  &#x3D; [2,3,4]<br>cost &#x3D; [3,4,3]</p>
<p><strong>输出:</strong> -1</p>
<p><strong>解释:</strong> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油<br>开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油<br>开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油<br>你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>, mx = <span class="number">-1</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gas.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            total += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (total &gt; mx) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">                mx = total;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (total &lt; <span class="number">0</span>) ? <span class="number">-1</span> : start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 99.75% of C++ online submissions for Gas Station.</p>
<p>Memory Usage: 9 MB, less than 58.33% of C++ online submissions for Gas Station.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Gas Station的C++提交中击败了96.42% 的用户</p>
<p>内存消耗 : 9 MB, 在Gas Station的C++提交中击败了62.43% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (135) Candy</title>
    <url>/a2d1e399fb96/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 1 个糖果。</li>
<li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li>
</ul>
<p>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [1,0,2]<br><strong>输出:</strong> 5<br><strong>解释:</strong> 你可以分别给这三个孩子分发 2、1、2 颗糖果。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [1,2,2]<br><strong>输出:</strong> 4<br><strong>解释:</strong> 你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i + <span class="number">1</span>] &gt; ratings[i]) nums[i + <span class="number">1</span>] = nums[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i - <span class="number">1</span>] &gt; ratings[i]) nums[i - <span class="number">1</span>] = <span class="built_in">max</span>(nums[i - <span class="number">1</span>], nums[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) res += num;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 24 ms, faster than 96.92% of C++ online submissions for Candy.</p>
<p>Memory Usage: 10.8 MB, less than 33.51% of C++ online submissions for Candy.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 28 ms, 在Candy的C++提交中击败了96.41% 的用户</p>
<p>内存消耗 : 10.8 MB, 在Candy的C++提交中击败了23.44% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (139) Word Break</title>
    <url>/e10e5d10963c/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p><strong>说明:</strong></p>
<p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]<br><strong>输出:</strong> true<br><strong>解释:</strong> 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”]<br><strong>输出:</strong> true<br><strong>解释:</strong> 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。<br>     注意你可以重复使用字典中的单词。</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]<br><strong>输出:</strong> false</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(s.size())</span></span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> start = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!visited[start]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (wordSet.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(start, i - start))) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(i);</span><br><span class="line">                        <span class="keyword">if</span> (i == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[start] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 67.70% of C++ online submissions for Word Break.</p>
<p>Memory Usage: 14.5 MB, less than 32.39% of C++ online submissions for Word Break.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :44 ms, 在所有C++提交中击败了30.39%的用户</p>
<p>内存消耗 :14.4 MB, 在所有C++提交中击败了31.03%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (136) Single Number</title>
    <url>/feaa8ab7cf7b/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [2,2,1]<br><strong>输出:</strong> 1</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [4,1,2,1,2]<br><strong>输出:</strong> 4</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) res ^= num;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 87.57% of C++ online submissions for Single Number.</p>
<p>Memory Usage: 9.9 MB, less than 25.81% of C++ online submissions for Single Number.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :12 ms, 在所有C++提交中击败了99.44%的用户</p>
<p>内存消耗 :9.8 MB, 在所有C++提交中击败了11.54%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (138) Copy List with Random Pointer</title>
    <url>/2ea6f081b256/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>
<p>要求返回这个链表的**<a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy">深拷贝</a>**。 </p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong><img src="https://discuss.leetcode.com/uploads/files/1470150906153-2yxeznm.png"></strong></p>
<p><strong>输入:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;next&quot;:null,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:2&#125;,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:1&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释:</strong><br>节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。<br>节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。</p>
<p><strong>提示:</strong></p>
<p>你必须返回给定头的拷贝作为对克隆列表的引用。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next, Node* _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            Node *t = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">            t-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = t;</span><br><span class="line">            cur = t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;random) cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        Node *res = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            Node *t = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = t-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;next) t-&gt;next = t-&gt;next-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 32 ms, faster than 92.46% of C++ online submissions for Copy List with Random Pointer.</p>
<p>Memory Usage: 22.1 MB, less than 50.83% of C++ online submissions for Copy List with Random Pointer.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :80 ms, 在所有C++提交中击败了43.33%的用户</p>
<p>内存消耗 :22.1 MB, 在所有C++提交中击败了23.42%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (137) Single Number II</title>
    <url>/7ce0fe9f8b60/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [2,2,3,2]<br><strong>输出:</strong> 3</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [0,1,0,1,0,1,99]<br><strong>输出:</strong> 99</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            b = (b ^ nums[i]) &amp; ~a;</span><br><span class="line">            a = (a ^ nums[i]) &amp; ~b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 98.40% of C++ online submissions for Single Number II.</p>
<p>Memory Usage: 9.8 MB, less than 26.81% of C++ online submissions for Single Number II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有C++提交中击败了99.39%的用户</p>
<p>内存消耗 :9.7 MB, 在所有C++提交中击败了16.16%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (14) Longest Common Prefix</title>
    <url>/05c47ac09dda/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p><strong>输入:</strong> [“flower”,”flow”,”flight”]<br><strong>输出:</strong> “fl”</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [“dog”,”racecar”,”car”]<br><strong>输出:</strong> “”<br><strong>解释:</strong> 输入不存在公共前缀。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; strs[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= strs[i].<span class="built_in">size</span>() || strs[i][j] != strs[<span class="number">0</span>][j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[i].<span class="built_in">substr</span>(<span class="number">0</span>, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 98.80% of C++ online submissions for Longest Common Prefix.</p>
<p>Memory Usage: 9.4 MB, less than 81.72% of C++ online submissions for Longest Common Prefix.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Longest Common Prefix的C++提交中击败了16.93% 的用户</p>
<p>内存消耗 : 9.5 MB, 在Longest Common Prefix的C++提交中击败了0.90% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (141) Linked List Cycle</title>
    <url>/f795ff7d8ca7/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 <strong>pos</strong> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <strong>pos</strong> 是 -1，则在该链表中没有环。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> head &#x3D; [3,2,0,-4], pos &#x3D; 1<br><strong>输出:</strong> true<br><strong>解释:</strong> 链表中有一个环，其尾部连接到第二个节点。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png"></p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> head &#x3D; [1,2], pos &#x3D; 0<br><strong>输出:</strong> true<br><strong>解释:</strong> 链表中有一个环，其尾部连接到第一个节点。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png"></p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> head &#x3D; [1], pos &#x3D; -1<br><strong>输出:</strong> false<br><strong>解释:</strong> 链表中没有环。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png"></p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 90.24% of C++ online submissions for Linked List Cycle.</p>
<p>Memory Usage: 9.9 MB, less than 16.47% of C++ online submissions for Linked List Cycle.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有C++提交中击败了99.96%的用户</p>
<p>内存消耗 :9.8 MB, 在所有C++提交中击败了25.82%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (142) Linked List Cycle II</title>
    <url>/dca54d2dab4c/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <strong>null</strong>。</p>
<p>为了表示给定链表中的环，我们使用整数 <strong>pos</strong> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <strong>pos</strong> 是 -1，则在该链表中没有环。</p>
<p><strong>说明:</strong> 不允许修改给定的链表。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> head &#x3D; [3,2,0,-4], pos &#x3D; 1<br><strong>输出:</strong> tail connects to node index 1<br><strong>解释:</strong> 链表中有一个环，其尾部连接到第二个节点。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png"></p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> head &#x3D; [1,2], pos &#x3D; 0<br><strong>输出:</strong> tail connects to node index 0<br><strong>解释:</strong> 链表中有一个环，其尾部连接到第一个节点。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png"></p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> head &#x3D; [1], pos &#x3D; -1<br><strong>输出:</strong> no cycle<br><strong>解释:</strong> 链表中没有环。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png"></p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fast || !fast-&gt;next) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 90.75% of C++ online submissions for Linked List Cycle II.</p>
<p>Memory Usage: 9.8 MB, less than 32.58% of C++ online submissions for Linked List Cycle II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有C++提交中击败了99.87%的用户</p>
<p>内存消耗 :9.9 MB, 在所有C++提交中击败了14.85%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (143) Reorder List</title>
    <url>/fc280eca88c4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next || !head-&gt;next-&gt;next) <span class="keyword">return</span>;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *mid = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *last = mid, *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (last) &#123;</span><br><span class="line">            ListNode *next = last-&gt;next;</span><br><span class="line">            last-&gt;next = pre;</span><br><span class="line">            pre = last;</span><br><span class="line">            last = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head &amp;&amp; pre) &#123;</span><br><span class="line">            ListNode *next = head-&gt;next;</span><br><span class="line">            head-&gt;next = pre;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;next = next;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 44 ms, faster than 98.30% of C++ online submissions for Reorder List.</p>
<p>Memory Usage: 12.1 MB, less than 79.78% of C++ online submissions for Reorder List.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :76 ms, 在所有C++提交中击败了83.46%的用户</p>
<p>内存消耗 :12 MB, 在所有C++提交中击败了81.68%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (140) Word Break II</title>
    <url>/c8c06f66c69f/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 <strong>非空</strong> 字符串 s 和一个包含 <strong>非空</strong> 单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p>
<p><strong>说明:</strong></p>
<p>分隔时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong><br>s &#x3D; “catsanddog”<br>wordDict &#x3D; [“cat”, “cats”, “and”, “sand”, “dog”]<br><strong>输出:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;cats and dog&quot;,</span><br><span class="line">  &quot;cat sand dog&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong><br>s &#x3D; “pineapplepenapple”<br>wordDict &#x3D; [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br><strong>输出:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;pine apple pen apple&quot;,</span><br><span class="line">  &quot;pineapple pen apple&quot;,</span><br><span class="line">  &quot;pine applepen apple&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解释:</strong> 注意你可以重复使用字典中的单词。</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong><br>s &#x3D; “catsandog”<br>wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]<br><strong>输出:</strong><br>[]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(numRows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">            res[i].<span class="built_in">resize</span>(i + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                res[i][j] = res[i - <span class="number">1</span>][j - <span class="number">1</span>] + res[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 98.65% of C++ online submissions for Word Break II.</p>
<p>Memory Usage: 12.4 MB, less than 68.68% of C++ online submissions for Word Break II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :24 ms, 在所有C++提交中击败了79.19%的用户</p>
<p>内存消耗 :12.5 MB, 在所有C++提交中击败了54.00%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (144) Binary Tree Preorder Traversal</title>
    <url>/02e506548354/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，返回它的 <strong>前序</strong> 遍历。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> [1,null,2,3]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3 </span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> [1,2,3]</p>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; s&#123;&#123;root&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *t = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) s.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) s.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Preorder Traversal.</p>
<p>Memory Usage: 9.2 MB, less than 46.50% of C++ online submissions for Binary Tree Preorder Traversal.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有C++提交中击败了83.95%的用户</p>
<p>内存消耗 :9.3 MB, 在所有C++提交中击败了30.36%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (145) Binary Tree Postorder Traversal</title>
    <url>/07d69cf6dfb2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，返回它的 <strong>前序</strong> 遍历。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> [1,null,2,3]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3 </span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> [3,2,1]</p>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; s&#123;&#123;root&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *t = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(), t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) s.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) s.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Postorder Traversal.</p>
<p>Memory Usage: 9.3 MB, less than 43.22% of C++ online submissions for Binary Tree Postorder Traversal.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有C++提交中击败了84.09%的用户</p>
<p>内存消耗 :9.4 MB, 在所有C++提交中击败了21.24%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (146) LRU Cache</title>
    <url>/438137242c94/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>运用你所掌握的数据结构，设计和实现一个  <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU">LRU (最近最少使用) 缓存机制</a>。它应该支持以下操作： 获取数据 <strong>get</strong> 和 写入数据 <strong>put</strong> 。</p>
<p>获取数据 <strong>get(key)</strong> - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 <strong>put(key, value)</strong> - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<p><strong>进阶:</strong></p>
<p>你是否可以在 <strong>O(1)</strong> 时间复杂度内完成这两种操作？</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       // 返回  1</span><br><span class="line">cache.put(3, 3);    // 该操作会使得密钥 2 作废</span><br><span class="line">cache.get(2);       // 返回 -1 (未找到)</span><br><span class="line">cache.put(4, 4);    // 该操作会使得密钥 1 作废</span><br><span class="line">cache.get(1);       // 返回 -1 (未找到)</span><br><span class="line">cache.get(3);       // 返回  3</span><br><span class="line">cache.get(4);       // 返回  4</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == m.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        l.<span class="built_in">splice</span>(l.<span class="built_in">begin</span>(), l, it-&gt;second);</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) l.<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">        l.<span class="built_in">push_front</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        m[key] = l.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">size</span>() &gt; cap) &#123;</span><br><span class="line">            <span class="type">int</span> k = l.<span class="built_in">rbegin</span>()-&gt;first;</span><br><span class="line">            l.<span class="built_in">pop_back</span>();</span><br><span class="line">            m.<span class="built_in">erase</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; l;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator&gt; m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 100 ms, faster than 97.37% of C++ online submissions for LRU Cache.</p>
<p>Memory Usage: 39.3 MB, less than 52.05% of C++ online submissions for LRU Cache.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :136 ms, 在所有C++提交中击败了97.66%的用户</p>
<p>内存消耗 :39.3 MB, 在所有C++提交中击败了47.63%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (148) Sort List</title>
    <url>/0c861174ee8e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在 <strong>O(n log n)</strong> 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 4-&gt;2-&gt;1-&gt;3<br><strong>输出:</strong> 1-&gt;2-&gt;3-&gt;4</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> -1-&gt;5-&gt;3-&gt;4-&gt;0<br><strong>输出:</strong> -1-&gt;0-&gt;3-&gt;4-&gt;5</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *slow = head, *fast = head, *pre = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">sortList</span>(head), <span class="built_in">sortList</span>(slow));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = <span class="built_in">merge</span>(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = <span class="built_in">merge</span>(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 44 ms, faster than 93.47% of C++ online submissions for Sort List.</p>
<p>Memory Usage: 12.9 MB, less than 43.67% of C++ online submissions for Sort List.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :64 ms, 在所有C++提交中击败了95.17%的用户</p>
<p>内存消耗 :12.9 MB, 在所有C++提交中击败了45.63%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (149) Max Points on a Line</title>
    <url>/f195e8ec02fa/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二维平面，平面上有 <strong>n</strong> 个点，求最多有多少个点在同一条直线上。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [[1,1],[2,2],[3,3]]<br><strong>输出:</strong> 3<br><strong>解释:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^</span><br><span class="line">|</span><br><span class="line">|        o</span><br><span class="line">|     o</span><br><span class="line">|  o  </span><br><span class="line">+-------------&gt;</span><br><span class="line">0  1  2  3  4</span><br></pre></td></tr></table></figure>

<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]<br><strong>输出:</strong> 4<br><strong>解释:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^</span><br><span class="line">|</span><br><span class="line">|  o</span><br><span class="line">|     o        o</span><br><span class="line">|        o</span><br><span class="line">|  o        o</span><br><span class="line">+-------------------&gt;</span><br><span class="line">0  1  2  3  4  5  6</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">maxPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> res=<span class="number">0</span>,n;</span><br><span class="line">		<span class="keyword">if</span>(points.<span class="built_in">size</span>()&lt;=<span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> points.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">		vector&lt;Point&gt; ps;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:points) &#123;</span><br><span class="line">			Point p=<span class="built_in">Point</span>(e[<span class="number">0</span>],e[<span class="number">1</span>]);</span><br><span class="line">			ps.<span class="built_in">push_back</span>(p);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		map&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, <span class="type">int</span>&gt; A;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ps.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			A.<span class="built_in">clear</span>();</span><br><span class="line">			n = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; ps.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">				<span class="type">int</span> a = ps[i].x - ps[j].x, b = ps[i].y - ps[j].y;</span><br><span class="line">				<span class="keyword">if</span> (a==<span class="number">0</span> &amp;&amp; b==<span class="number">0</span>) &#123;</span><br><span class="line">					n ++;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (a==<span class="number">0</span>)</span><br><span class="line">					A[<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>)] ++;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (b==<span class="number">0</span>)</span><br><span class="line">					A[<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">0</span>)] ++;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="type">int</span> k = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">					A[<span class="built_in">make_pair</span>(a / k, b / k)] ++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			res = <span class="built_in">max</span>(res, n);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : A)</span><br><span class="line">				res = <span class="built_in">max</span>(res, x.second + n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 93.26% of C++ online submissions for Max Points on a Line.</p>
<p>Memory Usage: 11 MB, less than 45.11% of C++ online submissions for Max Points on a Line.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :32 ms, 在所有C++提交中击败了53.60%的用户</p>
<p>内存消耗 :11 MB, 在所有C++提交中击败了28.08%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (15) 3Sum</title>
    <url>/70d7210bf5ce/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a, b, c</em> 使得 <em>a + b + c &#x3D; 0</em> ？找出所有满足条件且不重复的三元组。</p>
<p><strong>注意:</strong> 答案中不可以包含重复的三元组。</p>
<p>例如, 给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || nums.<span class="built_in">back</span>() &lt; <span class="number">0</span> || nums.<span class="built_in">front</span>() &gt; <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; nums.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> target = <span class="number">0</span> - nums[k];</span><br><span class="line">            <span class="type">int</span> i = k + <span class="number">1</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[k], nums[i], nums[j]&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) ++i;</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) --j;</span><br><span class="line">                    ++i; --j;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] &lt; target) ++i;</span><br><span class="line">                <span class="keyword">else</span> --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 100 ms, faster than 96.60% of C++ online submissions for 3Sum.</p>
<p>Memory Usage: 16.6 MB, less than 63.63% of C++ online submissions for 3Sum.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 156 ms, 在3Sum的C++提交中击败了24.60% 的用户</p>
<p>内存消耗 : 16.3 MB, 在3Sum的C++提交中击败了0.92% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (147) Insertion Sort List</title>
    <url>/26bb083e9494/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>对链表进行插入排序。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif"></p>
<p>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p>
<p><strong>插入排序算法:</strong></p>
<ol>
<li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li>
<li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li>
<li>重复直到所有输入数据插入完为止。</li>
</ol>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 4-&gt;2-&gt;1-&gt;3<br><strong>输出:</strong> 1-&gt;2-&gt;3-&gt;4</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> -1-&gt;5-&gt;3-&gt;4-&gt;0<br><strong>输出:</strong> -1-&gt;0-&gt;3-&gt;4-&gt;5</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode *t = head-&gt;next;</span><br><span class="line">            cur = dummy;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val &lt;= head-&gt;val) &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = head;</span><br><span class="line">            head = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 48 ms, faster than 73.55% of C++ online submissions for Insertion Sort List.</p>
<p>Memory Usage: 9.6 MB, less than 37.30% of C++ online submissions for Insertion Sort List.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :64 ms, 在所有C++提交中击败了63.50%的用户</p>
<p>内存消耗 :9.7 MB, 在所有C++提交中击败了12.05%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (150) Evaluate Reverse Polish Notation</title>
    <url>/dc1863841484/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>根据<a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">逆波兰表示法</a>，求表达式的值。</p>
<p>有效的运算符包括 +, -, *, &#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p><strong>说明:</strong></p>
<ol>
<li>整数除法只保留整数部分。</li>
<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>
</ol>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [“2”, “1”, “+”, “3”, “*”]<br><strong>输出:</strong> 9<br><strong>解释:</strong> ((2 + 1) * 3) &#x3D; 9</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [“4”, “13”, “5”, “&#x2F;“, “+”]<br><strong>输出:</strong> 6<br><strong>解释:</strong> (4 + (13 &#x2F; 5)) &#x3D; 6</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong>  [“10”, “6”, “9”, “3”, “+”, “-11”, “<em>“, “&#x2F;“, “</em>“, “17”, “+”, “5”, “+”]<br><strong>输出:</strong> 22<br><strong>解释:</strong><br>  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5<br>&#x3D; ((10 * 0) + 17) + 5<br>&#x3D; (0 + 17) + 5<br>&#x3D; 17 + 5<br>&#x3D; 22</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> op = (<span class="type">int</span>)tokens.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(tokens, op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;string&gt;&amp; tokens, <span class="type">int</span>&amp; op)</span> </span>&#123;</span><br><span class="line">        string str = tokens[op];</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="string">&quot;+&quot;</span> &amp;&amp; str != <span class="string">&quot;-&quot;</span> &amp;&amp; str != <span class="string">&quot;*&quot;</span> &amp;&amp; str != <span class="string">&quot;/&quot;</span>) <span class="keyword">return</span> <span class="built_in">stoi</span>(str);</span><br><span class="line">        <span class="type">int</span> num1 = <span class="built_in">helper</span>(tokens, --op);</span><br><span class="line">        <span class="type">int</span> num2 = <span class="built_in">helper</span>(tokens, --op);</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">&quot;+&quot;</span>) <span class="keyword">return</span> num2 + num1;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">&quot;-&quot;</span>) <span class="keyword">return</span> num2 - num1;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">&quot;*&quot;</span>) <span class="keyword">return</span> num2 * num1;</span><br><span class="line">        <span class="keyword">return</span> num2 / num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 76.61% of C++ online submissions for Evaluate Reverse Polish Notation.</p>
<p>Memory Usage: 13 MB, less than 5.06% of C++ online submissions for Evaluate Reverse Polish Notation.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :12 ms, 在所有C++提交中击败了99.79%的用户</p>
<p>内存消耗 :12.7 MB, 在所有C++提交中击败了5.02%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (153) Find Minimum in Rotated Sorted Array</title>
    <url>/c00bacbdaf2a/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [3,4,5,1,2]<br><strong>输出:</strong> 1</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [4,5,6,7,0,1,2]<br><strong>输出:</strong> 0</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = num.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[left] &gt; num[right]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left != (right - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (num[left] &lt; num[mid]) left = mid;</span><br><span class="line">                <span class="keyword">else</span> right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(num[left], num[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 90.59% of C++ online submissions for Find Minimum in Rotated Sorted Array.</p>
<p>Memory Usage: 8.9 MB, less than 8.40% of C++ online submissions for Find Minimum in Rotated Sorted Array.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有 C++ 提交中击败了83.94%的用户</p>
<p>内存消耗 :8.6 MB, 在所有 C++ 提交中击败了78.75%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (151) Reverse Words in a String</title>
    <url>/864887f98dbf/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> “<code>the sky is blue</code>“<br><strong>输出:</strong> “<code>blue is sky the</code>“</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> “  hello world!  “<br><strong>输出:</strong> “world! hello”<br><strong>解释:</strong> 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> “a good   example”<br><strong>输出:</strong> “example good a”<br><strong>解释:</strong> 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<p><strong>说明:</strong></p>
<ol>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ol>
<p><strong>进阶:</strong></p>
<p>请选用 C 语言的用户尝试使用 O(1) 额外空间复杂度的原地解法。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n = s.<span class="built_in">size</span>(), ed = n, i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">&#x27; &#x27;</span> &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) res += s.<span class="built_in">substr</span>(i, ed-i) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) ed = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">substr</span>(<span class="number">0</span>, res.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 92.66% of C++ online submissions for Reverse Words in a String.</p>
<p>Memory Usage: 11 MB, less than 39.02% of C++ online submissions for Reverse Words in a String.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :4 ms, 在所有 C++ 提交中击败了99.58%的用户</p>
<p>内存消耗 :10.9 MB, 在所有 C++ 提交中击败了44.51%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (152) Maximum Product Subarray</title>
    <url>/7bd1c45b60e6/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 <code>nums</code> ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [2,3,-2,4]<br><strong>输出:</strong> 6<br><strong>解释:</strong> 子数组 [2,3] 有最大乘积 6。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [-2,0,-1]<br><strong>输出:</strong> 0<br><strong>解释:</strong> 结果不能为 2, 因为 [-2,-1] 不是子数组。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>], mn = nums[<span class="number">0</span>], mx = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> tmax = mx, tmin = mn;</span><br><span class="line">            mx = <span class="built_in">max</span>(<span class="built_in">max</span>(nums[i], tmax * nums[i]), tmin * nums[i]);</span><br><span class="line">            mn = <span class="built_in">min</span>(<span class="built_in">min</span>(nums[i], tmax * nums[i]), tmin * nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, mx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Maximum Product Subarray.</p>
<p>Memory Usage: 8.9 MB, less than 93.95% of C++ online submissions for Maximum Product Subarray.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有 C++ 提交中击败了90.44%的用户</p>
<p>内存消耗 :9.2 MB, 在所有 C++ 提交中击败了29.59%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (154) Find Minimum in Rotated Sorted Array II</title>
    <url>/a088f16d9ff7/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>请找出其中最小的元素。</p>
<p>注意数组中可能存在重复的元素。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [1,3,5]<br><strong>输出:</strong> 1</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [2,2,2,0,1]<br><strong>输出:</strong> 0</p>
<p><strong>说明：</strong></p>
<ol>
<li>这道题是 <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/">寻找旋转排序数组中的最小值</a> 的延伸题目。</li>
<li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li>
</ol>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>, res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, nums[left]);</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &gt; nums[mid]) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, nums[right]);</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">min</span>(res, nums[left]);</span><br><span class="line">        res = <span class="built_in">min</span>(res, nums[right]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 82.10% of C++ online submissions for Find Minimum in Rotated Sorted Array II.</p>
<p>Memory Usage: 8.8 MB, less than 74.00% of C++ online submissions for Find Minimum in Rotated Sorted Array II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :4 ms, 在所有 C++ 提交中击败了99.68%的用户</p>
<p>内存消耗 :8.8 MB, 在所有 C++ 提交中击败了47.83%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (157) Read N Characters Given Read4</title>
    <url>/74061e070b1a/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (155) Min Stack</title>
    <url>/f4d5c91689ca/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li>push(x) – 将元素 x 推入栈中。</li>
<li>pop() – 删除栈顶的元素。</li>
<li>top() – 获取栈顶元素。</li>
<li>getMin() – 检索栈中的最小元素。</li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        min_val = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= min_val) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(min_val);</span><br><span class="line">            min_val = x;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (t == min_val) &#123;</span><br><span class="line">            min_val = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_val;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> min_val;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 32 ms, faster than 84.78% of C++ online submissions for Min Stack.</p>
<p>Memory Usage: 16.7 MB, less than 94.92% of C++ online submissions for Min Stack.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :32 ms, 在所有 C++ 提交中击败了99.49%的用户</p>
<p>内存消耗 :17.1 MB, 在所有 C++ 提交中击败了23.35%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (158) Read N Characters Given Read4 II - Call multiple times</title>
    <url>/5982be1fba5f/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (159) Longest Substring with At Most Two Distinct Characters</title>
    <url>/f2805c637a88/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (156) Binary Tree Upside Down</title>
    <url>/0d49922261b6/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (16) 3Sum Closest</title>
    <url>/b9a1e63360ff/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code>和 一个目标值 <code>target</code>。找出 <code>nums</code>中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>例如，给定数组 nums &#x3D; [-1，2，1，-4], 和 target &#x3D; 1.</p>
<p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 &#x3D; 2).</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> closest = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> diff = <span class="built_in">abs</span>(closest - target);</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="type">int</span> newDiff = <span class="built_in">abs</span>(sum - target);</span><br><span class="line">                <span class="keyword">if</span> (diff &gt; newDiff) &#123;</span><br><span class="line">                    diff = newDiff;</span><br><span class="line">                    closest = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) ++left;</span><br><span class="line">                <span class="keyword">else</span> --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 72.59% of C++ online submissions for 3Sum Closest.</p>
<p>Memory Usage: 9.4 MB, less than 47.35% of C++ online submissions for 3Sum Closest.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 24 ms, 在3Sum Closest的C++提交中击败了20.07% 的用户</p>
<p>内存消耗 : 9.5 MB, 在3Sum Closest的C++提交中击败了0.33% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (160) Intersection of Two Linked Lists</title>
    <url>/46e1708c9819/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表:</p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png"></a></p>
<p>在节点 c1 开始相交。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"></a></p>
<p><strong>输入:</strong> intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br><strong>输出:</strong> Reference of the node with value &#x3D; 8<br><strong>输入解释:</strong> 相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"></a></p>
<p><strong>输入</strong> intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br><strong>输出</strong> Reference of the node with value &#x3D; 2<br><strong>输入解释:</strong> 相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"></a></p>
<p><strong>输入:</strong> intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br><strong>输出:</strong> null<br><strong>输入解释:</strong> 从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br><strong>解释:</strong> 这两个链表不相交，因此返回 null。</p>
<p><strong>注意:</strong></p>
<ul>
<li>如果两个链表没有交点，返回 null.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!headA || !headB) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *a = headA, *b = headB;</span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a ? a-&gt;next : headB;</span><br><span class="line">            b = b ? b-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 52 ms, faster than 81.04% of C++ online submissions for Intersection of Two Linked Lists.</p>
<p>Memory Usage: 16.8 MB, less than 46.59% of C++ online submissions for Intersection of Two Linked Lists.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :60 ms, 在所有 C++ 提交中击败了96.16%的用户</p>
<p>内存消耗 :16.8 MB, 在所有 C++ 提交中击败了13.89%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (163) Missing Ranges</title>
    <url>/19f9412a6e82/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (161) One Edit Distance</title>
    <url>/99fed8e09338/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (162) Find Peak Element</title>
    <url>/89ba49a24334/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给定一个输入数组 <code>nums</code>，其中 <code>nums[i] ≠ nums[i+1]</code>，找到峰值元素并返回其索引。</p>
<p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p>
<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code>。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> nums &#x3D; [1,2,3,1]<br><strong>输出:</strong> 2<br><strong>解释:</strong> 3 是峰值元素，你的函数应该返回其索引 2。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> nums &#x3D; [1,2,1,3,5,6,4]<br><strong>输出:</strong> 1 或 5<br><strong>解释:</strong> 你的函数可以返回索引 1，其峰值元素为 2；<br>     或者返回索引 5， 其峰值元素为 6。</p>
<p><strong>说明:</strong></p>
<p>你的解法应该是 O(logN) 时间复杂度的。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 98.47% of C++ online submissions for Find Peak Element.</p>
<p>Memory Usage: 8.5 MB, less than 79.45% of C++ online submissions for Find Peak Element.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :4 ms, 在所有 C++ 提交中击败了99.17%的用户</p>
<p>内存消耗 :8.6 MB, 在所有 C++ 提交中击败了73.30%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (164) Maximum Gap</title>
    <url>/bce97897398b/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。</p>
<p>如果数组元素个数小于 2，则返回 0。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [3,6,9,1]<br><strong>输出:</strong> 3<br><strong>解释:</strong> 排序后的数组是 [1,3,6,9]<strong><em>,</em></strong> 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [10]<br><strong>输出:</strong> 0<br><strong>解释:</strong> 数组元素个数小于 2，因此返回 0。</p>
<p><strong>说明:</strong></p>
<ul>
<li>你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。</li>
<li>请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumGap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mx = INT_MIN, mn = INT_MAX, n = nums.<span class="built_in">size</span>(), pre = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, num);</span><br><span class="line">            mn = <span class="built_in">min</span>(mn, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> size = (mx - mn) / n + <span class="number">1</span>, cnt = (mx - mn) / size + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bucket_min</span><span class="params">(cnt, INT_MAX)</span>, <span class="title">bucket_max</span><span class="params">(cnt, INT_MIN)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> idx = (num - mn) / size;</span><br><span class="line">            bucket_min[idx] = <span class="built_in">min</span>(bucket_min[idx], num);</span><br><span class="line">            bucket_max[idx] = <span class="built_in">max</span>(bucket_max[idx], num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket_min[i] == INT_MAX || bucket_max[i] == INT_MIN) <span class="keyword">continue</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(res, bucket_min[i] - bucket_max[pre]);</span><br><span class="line">            pre = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 99.75% of C++ online submissions for Maximum Gap.</p>
<p>Memory Usage: 9.3 MB, less than 69.17% of C++ online submissions for Maximum Gap.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有 C++ 提交中击败了98.20%的用户</p>
<p>内存消耗 :9.4 MB, 在所有 C++ 提交中击败了50.00%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (168) Excel Sheet Column Title</title>
    <url>/ed29a7d82639/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p>
<p>例如，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 1<br><strong>输出:</strong> “A”</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 28<br><strong>输出:</strong> “AB”</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> 701<br><strong>输出:</strong> “ZY”</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">26</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                res += <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">                n -= <span class="number">26</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += n % <span class="number">26</span> - <span class="number">1</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                n -= n % <span class="number">26</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Excel Sheet Column Title.</p>
<p>Memory Usage: 8.1 MB, less than 41.83% of C++ online submissions for Excel Sheet Column Title.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :4 ms, 在所有 C++ 提交中击败了88.51%的用户</p>
<p>内存消耗 :8.1 MB, 在所有 C++ 提交中击败了47.17%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (165) Compare Version Numbers</title>
    <url>/1f40f42a0f14/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>比较两个版本号 version1 和 version2。<br>如果 <code>version1 &gt; version2</code> 返回 1，如果 <code>version1 &lt; version2</code> 返回 -1， 除此之外返回 0。</p>
<p>你可以假设版本字符串非空，并且只包含数字和 . 字符。</p>
<p> . 字符不代表小数点，而是用于分隔数字序列。</p>
<p>例如，<code>2.5</code> 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。</p>
<p>你可以假设版本号的每一级的默认修订版号为 <code>0</code>。例如，版本号 <code>3.4</code> 的第一级（大版本）和第二级（小版本）修订号分别为 <code>3</code> 和 <code>4</code>。其第三级和第四级修订号均为 <code>0</code>。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> version1 &#x3D; “0.1”, version2 &#x3D; “1.1”<br><strong>输出:</strong> -1</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> version1 &#x3D; “1.0.1”, version2 &#x3D; “1”<br><strong>输出:</strong> 1</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> version1 &#x3D; “7.5.2.4”, version2 &#x3D; “7.5.3”<br><strong>输出:</strong> -1</p>
<h1 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h1><p><strong>输入:</strong> version1 &#x3D; “1.01”, version2 &#x3D; “1.001”<br><strong>输出:</strong> 0<br><strong>解释:</strong> 忽略前导零，“01” 和 “001” 表示相同的数字 “1”。</p>
<h1 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h1><p><strong>输入:</strong> version1 &#x3D; “1.0”, version2 &#x3D; “1.0.0”<br><strong>输出:</strong> 0<br><strong>解释:</strong> version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。</p>
<p><strong>提示：</strong></p>
<ol>
<li>版本字符串由以点 （<code>.</code>） 分隔的数字字符串组成。这个数字字符串 <strong>可能</strong> 有前导零。</li>
<li>版本字符串不以点开始或结束，并且其中不会有两个连续的点。</li>
</ol>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1 = version1.<span class="built_in">size</span>(), n2 = version2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, d1 = <span class="number">0</span>, d2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1 || j &lt; n2) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n1 &amp;&amp; version1[i] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                d1 = d1 * <span class="number">10</span> + version1[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n2 &amp;&amp; version2[j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                d2 = d2 * <span class="number">10</span> + version2[j++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (d1 &gt; d2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (d1 &lt; d2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            d1 = d2 = <span class="number">0</span>;</span><br><span class="line">            ++i; ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Compare Version Numbers.</p>
<p>Memory Usage: 8.5 MB, less than 40.49% of C++ online submissions for Compare Version Numbers.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有 C++ 提交中击败了71.98%的用户</p>
<p>内存消耗 :8.3 MB, 在所有 C++ 提交中击败了56.60%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (166) Fraction to Recurring Decimal</title>
    <url>/6edce43948e4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。</p>
<p>如果小数部分为循环小数，则将循环的部分括在括号内。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> numerator &#x3D; 1, denominator &#x3D; 2<br><strong>输出:</strong> “0.5”</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> numerator &#x3D; 2, denominator &#x3D; 1<br><strong>输出:</strong> “2”</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> numerator &#x3D; 2, denominator &#x3D; 3<br><strong>输出:</strong> “0.(6)”</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">fractionToDecimal</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s1 = numerator &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> s2 = denominator &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num = <span class="built_in">abs</span>( (<span class="type">long</span> <span class="type">long</span>)numerator );</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> den = <span class="built_in">abs</span>( (<span class="type">long</span> <span class="type">long</span>)denominator );</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> out = num / den;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> rem = num % den;</span><br><span class="line">        unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        string res = <span class="built_in">to_string</span>(out);</span><br><span class="line">        <span class="keyword">if</span> (s1 * s2 == <span class="number">-1</span> &amp;&amp; (out &gt; <span class="number">0</span> || rem &gt; <span class="number">0</span>)) res = <span class="string">&quot;-&quot;</span> + res;</span><br><span class="line">        <span class="keyword">if</span> (rem == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (rem != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(rem) != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(m[rem], <span class="string">&quot;(&quot;</span>);</span><br><span class="line">                s += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> res + s;</span><br><span class="line">            &#125;</span><br><span class="line">            m[rem] = pos;</span><br><span class="line">            s += <span class="built_in">to_string</span>((rem * <span class="number">10</span>) / den);</span><br><span class="line">            rem = (rem * <span class="number">10</span>) % den;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Fraction to Recurring Decimal.</p>
<p>Memory Usage: 8.8 MB, less than 52.70% of C++ online submissions for Fraction to Recurring Decimal.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :4 ms, 在所有 C++ 提交中击败了94.25%的用户</p>
<p>内存消耗 :8.8 MB, 在所有 C++ 提交中击败了61.66%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (167) Two Sum II - Input array is sorted</title>
    <url>/8c1538ff4269/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个已按照 <strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p><strong>说明:</strong></p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9<br><strong>输出:</strong> [1,2]<br><strong>解释:</strong> 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> sum = numbers[l] + numbers[r];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) <span class="keyword">return</span> &#123;l + <span class="number">1</span>, r + <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) ++l;</span><br><span class="line">            <span class="keyword">else</span> --r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 98.63% of C++ online submissions for Two Sum II - Input array is sorted.</p>
<p>Memory Usage: 9.4 MB, less than 74.77% of C++ online submissions for Two Sum II - Input array is sorted.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :12 ms, 在所有 C++ 提交中击败了79.10%的用户</p>
<p>内存消耗 :9.6 MB, 在所有 C++ 提交中击败了13.45%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (169) Majority Element</title>
    <url>/efd61f6014f6/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [3,2,3]<br><strong>输出:</strong> 3</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [2,2,1,1,1,2,2]<br><strong>输出:</strong> 2</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;res = num; ++cnt;&#125;</span><br><span class="line">            <span class="keyword">else</span> (num == res) ? ++cnt : --cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 88.56% of C++ online submissions for Majority Element.</p>
<p>Memory Usage: 11.1 MB, less than 53.62% of C++ online submissions for Majority Element.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :24 ms, 在所有 C++ 提交中击败了92.77%的用户</p>
<p>内存消耗 :11 MB, 在所有 C++ 提交中击败了88.30%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (17) Letter Combinations of a Phone Number</title>
    <url>/efee7b2b95ed/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png"></p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p><strong>输入:</strong> “23”<br><strong>输出:</strong> [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string dict[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        <span class="built_in">letterCombinationsDFS</span>(digits, dict, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">letterCombinationsDFS</span><span class="params">(string digits, string dict[], <span class="type">int</span> level, string out, vector&lt;string&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level == digits.<span class="built_in">size</span>()) &#123;res.<span class="built_in">push_back</span>(out); <span class="keyword">return</span>;&#125;</span><br><span class="line">        string str = dict[digits[level] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">letterCombinationsDFS</span>(digits, dict, level + <span class="number">1</span>, out + <span class="built_in">string</span>(<span class="number">1</span>, str[i]), res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Letter Combinations of a Phone Number.</p>
<p>Memory Usage: 8.6 MB, less than 76.83% of C++ online submissions for Letter Combinations of a Phone Number.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Letter Combinations of a Phone Number的C++提交中击败了11.27% 的用户</p>
<p>内存消耗 : 8.5 MB, 在Letter Combinations of a Phone Number的C++提交中击败了0.93% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (171) Excel Sheet Column Number</title>
    <url>/782031cfac40/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个Excel表格中的列名称，返回其相应的列序号。</p>
<p>例如，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> “A”<br><strong>输出:</strong> 1</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> “AB”<br><strong>输出:</strong> 28</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> “ZY”<br><strong>输出:</strong> 701</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">titleToNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(s.<span class="built_in">empty</span>())</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">      &#123;</span><br><span class="line">          num = num +(s[i]<span class="number">-64</span>)*<span class="built_in">pow</span>(<span class="number">26</span>,c); c++;</span><br><span class="line">                </span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 87.82% of C++ online submissions for Excel Sheet Column Number.</p>
<p>Memory Usage: 8.4 MB, less than 11.48% of C++ online submissions for Excel Sheet Column Number.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有 C++ 提交中击败了85.41%的用户</p>
<p>内存消耗 :8.4 MB, 在所有 C++ 提交中击败了8.07%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (170) Two Sum III - Data structure design</title>
    <url>/7af769c2c759/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (173) Binary Search Tree Iterator</title>
    <url>/9dc972ed4f74/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p>
<p>调用 <code>next()</code> 将返回二叉搜索树中的下一个最小的数。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BSTIterator iterator = new BSTIterator(root);</span><br><span class="line">iterator.next();    // 返回 3</span><br><span class="line">iterator.next();    // 返回 7</span><br><span class="line">iterator.hasNext(); // 返回 true</span><br><span class="line">iterator.next();    // 返回 9</span><br><span class="line">iterator.hasNext(); // 返回 true</span><br><span class="line">iterator.next();    // 返回 15</span><br><span class="line">iterator.hasNext(); // 返回 true</span><br><span class="line">iterator.next();    // 返回 20</span><br><span class="line">iterator.hasNext(); // 返回 false</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>next()</code> 和 <code>hasNext()</code> 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。</li>
<li>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 中至少存在一个下一个最小的数。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BSTIterator</span>(TreeNode *root) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !s.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode *n = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> res = n-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (n-&gt;right) &#123;</span><br><span class="line">            n = n-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (n) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(n);</span><br><span class="line">                n = n-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator* obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 60 ms, faster than 71.08% of C++ online submissions for Binary Search Tree Iterator.</p>
<p>Memory Usage: 23.9 MB, less than 100.00% of C++ online submissions for Binary Search Tree Iterator.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :108 ms, 在所有 C++ 提交中击败了44.40%的用户</p>
<p>内存消耗 :24.2 MB, 在所有 C++ 提交中击败了83.82%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (174) Dungeon Game</title>
    <url>/4e0fc0e06b43/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p>
<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| -2 (K) | -3 | 3 |</span><br><span class="line">| -5 | -10 | 1 |</span><br><span class="line">| 10 | 30 | -5 (P) |</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>骑士的健康点数没有上限。</li>
<li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = dungeon.<span class="built_in">size</span>(), n = dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">min</span>(dp[j], dp[j + <span class="number">1</span>]) - dungeon[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 86.55% of C++ online submissions for Dungeon Game.</p>
<p>Memory Usage: 9.7 MB, less than 95.45% of C++ online submissions for Dungeon Game.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :12 ms, 在所有 C++ 提交中击败了83.46%的用户</p>
<p>内存消耗 :9.9 MB, 在所有 C++ 提交中击败了88.28%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (172) Factorial Trailing Zeroes</title>
    <url>/bb4dcd1cd70e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 3<br><strong>输出:</strong> 0<br><strong>解释:</strong> 3! &#x3D; 6, 尾数中没有零。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 5<br><strong>输出:</strong> 1<br><strong>解释:</strong> 5! &#x3D; 120, 尾数中有 1 个零。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            res += n / <span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Factorial Trailing Zeroes.</p>
<p>Memory Usage: 8.1 MB, less than 80.10% of C++ online submissions for Factorial Trailing Zeroes.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有 C++ 提交中击败了77.84%的用户</p>
<p>内存消耗 :8.5 MB, 在所有 C++ 提交中击败了73.63%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (175) Combine Two Tables</title>
    <url>/eeaccd5b5b5b/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>SQL架构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create table Person (PersonId int, FirstName varchar(255), LastName varchar(255))</span><br><span class="line">Create table Address (AddressId int, PersonId int, City varchar(255), State varchar(255))</span><br><span class="line">Truncate table Person</span><br><span class="line">insert into Person (PersonId, LastName, FirstName) values (&#x27;1&#x27;, &#x27;Wang&#x27;, &#x27;Allen&#x27;)</span><br><span class="line">Truncate table Address</span><br><span class="line">insert into Address (AddressId, PersonId, City, State) values (&#x27;1&#x27;, &#x27;2&#x27;, &#x27;New York City&#x27;, &#x27;New York&#x27;)</span><br></pre></td></tr></table></figure>

<p>表1: Person</p>
<p>+————-+———+<br>| 列名         | 类型     |<br>+————-+———+<br>| PersonId    | int     |<br>| FirstName   | varchar |<br>| LastName    | varchar |<br>+————-+———+<br>PersonId 是上表主键</p>
<p>表2: Address</p>
<p>+————-+———+<br>| 列名         | 类型    |<br>+————-+———+<br>| AddressId   | int     |<br>| PersonId    | int     |<br>| City        | varchar |<br>| State       | varchar |<br>+————-+———+<br>AddressId 是上表主键</p>
<p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p>
<p>FirstName, LastName, City, State</p>
<h1 id="MySQL-解决方法"><a href="#MySQL-解决方法" class="headerlink" title="MySQL 解决方法"></a>MySQL 解决方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">SELECT Person.FirstName, Person.LastName, Address.City, Address.State FROM Person LEFT JOIN Address USING(PersonId);</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 325 ms, faster than 5.22% of MySQL online submissions for Combine Two Tables.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :1006 ms, 在所有 MySQL 提交中击败了5.03%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (177) Nth Highest Salary</title>
    <url>/1446da1d063f/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第 n 高的薪水（Salary）。</p>
<p>+—-+——–+<br>| Id | Salary |<br>+—-+——–+<br>| 1  | 100    |<br>| 2  | 200    |<br>| 3  | 300    |<br>+—-+——–+<br>例如上述 <code>Employee</code> 表，n &#x3D; 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 <code>null</code>。</p>
<p>+————————+<br>| getNthHighestSalary(2) |<br>+————————+<br>| 200                    |<br>+————————+</p>
<h1 id="MySQL-解决方法"><a href="#MySQL-解决方法" class="headerlink" title="MySQL 解决方法"></a>MySQL 解决方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">  SET N = N - 1;</span><br><span class="line">  RETURN (</span><br><span class="line">      SELECT DISTINCT Salary FROM Employee GROUP BY Salary</span><br><span class="line">      ORDER BY Salary DESC LIMIT 1 OFFSET N</span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 224 ms, faster than 18.68% of MySQL online submissions for Nth Highest Salary.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :648 ms, 在所有 MySQL 提交中击败了22.66%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (178) Rank Scores</title>
    <url>/a489a5fb6465/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>SQL架构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create table If Not Exists Scores (Id int, Score DECIMAL(3,2))</span><br><span class="line">Truncate table Scores</span><br><span class="line">insert into Scores (Id, Score) values (&#x27;1&#x27;, &#x27;3.5&#x27;)</span><br><span class="line">insert into Scores (Id, Score) values (&#x27;2&#x27;, &#x27;3.65&#x27;)</span><br><span class="line">insert into Scores (Id, Score) values (&#x27;3&#x27;, &#x27;4.0&#x27;)</span><br><span class="line">insert into Scores (Id, Score) values (&#x27;4&#x27;, &#x27;3.85&#x27;)</span><br><span class="line">insert into Scores (Id, Score) values (&#x27;5&#x27;, &#x27;4.0&#x27;)</span><br><span class="line">insert into Scores (Id, Score) values (&#x27;6&#x27;, &#x27;3.65&#x27;)</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。</p>
<p>+—-+——-+<br>| Id | Score |<br>+—-+——-+<br>| 1  | 3.50  |<br>| 2  | 3.65  |<br>| 3  | 4.00  |<br>| 4  | 3.85  |<br>| 5  | 4.00  |<br>| 6  | 3.65  |<br>+—-+——-+</p>
<p>例如，根据上述给定的 <code>Scores</code> 表，你的查询应该返回（按分数从高到低排列）：</p>
<p>+——-+——+<br>| Score | Rank |<br>+——-+——+<br>| 4.00  | 1    |<br>| 4.00  | 1    |<br>| 3.85  | 2    |<br>| 3.65  | 3    |<br>| 3.65  | 3    |<br>| 3.50  | 4    |<br>+——-+——+</p>
<h1 id="MySQL-解决方法"><a href="#MySQL-解决方法" class="headerlink" title="MySQL 解决方法"></a>MySQL 解决方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select Score, cast(num as signed) as Rank</span><br><span class="line">from(select score, if(@scr=score, @no, @no:=@no+1) as num, @scr:=score</span><br><span class="line">from(select score, @scr:=(select score from scores order by score desc limit 1), @no:=1</span><br><span class="line">from scores order by score desc)a)b</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 176 ms, faster than 92.49% of MySQL online submissions for Rank Scores.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :381 ms, 在所有 MySQL 提交中击败了93.59%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (179) Largest Number</title>
    <url>/3a7e5650daaa/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [10,2]<br><strong>输出:</strong> 210</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [3,30,34,5,9]<br><strong>输出:</strong> 9534330</p>
<p><strong>说明:</strong> 输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">to_string</span>(a) + <span class="built_in">to_string</span>(b) &gt; <span class="built_in">to_string</span>(b) + <span class="built_in">to_string</span>(a); </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res += <span class="built_in">to_string</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 17.56% of C++ online submissions for Largest Number.</p>
<p>Memory Usage: 8.7 MB, less than 90.44% of C++ online submissions for Largest Number.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :28 ms, 在所有 C++ 提交中击败了38.62%的用户</p>
<p>内存消耗 :9 MB, 在所有 C++ 提交中击败了83.33%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (176) Second Highest Salary</title>
    <url>/8588e29da886/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>SQL架构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create table If Not Exists Employee (Id int, Salary int)</span><br><span class="line">Truncate table Employee</span><br><span class="line">insert into Employee (Id, Salary) values (&#x27;1&#x27;, &#x27;100&#x27;)</span><br><span class="line">insert into Employee (Id, Salary) values (&#x27;2&#x27;, &#x27;200&#x27;)</span><br><span class="line">insert into Employee (Id, Salary) values (&#x27;3&#x27;, &#x27;300&#x27;)</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第二高的薪水（Salary） 。</p>
<p>+—-+——–+<br>| Id | Salary |<br>+—-+——–+<br>| 1  | 100    |<br>| 2  | 200    |<br>| 3  | 300    |<br>+—-+——–+</p>
<p>例如上述 <code>Employee</code> 表，SQL查询应该返回 <code>200</code> 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 <code>null</code>。</p>
<p>+———————+<br>| SecondHighestSalary |<br>+———————+<br>| 200                 |<br>+———————+</p>
<h1 id="MySQL-解决方法"><a href="#MySQL-解决方法" class="headerlink" title="MySQL 解决方法"></a>MySQL 解决方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">SELECT max(Salary) as SecondHighestSalary</span><br><span class="line">FROM Employee</span><br><span class="line">WHERE Salary &lt; (SELECT max(Salary) FROM Employee)</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 180 ms, faster than 6.51% of MySQL online submissions for Second Highest Salary.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :250 ms, 在所有 MySQL 提交中击败了73.63%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (180) Consecutive Numbers</title>
    <url>/558a08051a8d/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>SQL架构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create table If Not Exists Logs (Id int, Num int)</span><br><span class="line">Truncate table Logs</span><br><span class="line">insert into Logs (Id, Num) values (&#x27;1&#x27;, &#x27;1&#x27;)</span><br><span class="line">insert into Logs (Id, Num) values (&#x27;2&#x27;, &#x27;1&#x27;)</span><br><span class="line">insert into Logs (Id, Num) values (&#x27;3&#x27;, &#x27;1&#x27;)</span><br><span class="line">insert into Logs (Id, Num) values (&#x27;4&#x27;, &#x27;2&#x27;)</span><br><span class="line">insert into Logs (Id, Num) values (&#x27;5&#x27;, &#x27;1&#x27;)</span><br><span class="line">insert into Logs (Id, Num) values (&#x27;6&#x27;, &#x27;2&#x27;)</span><br><span class="line">insert into Logs (Id, Num) values (&#x27;7&#x27;, &#x27;2&#x27;)</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL 查询，查找所有至少连续出现三次的数字。</p>
<p>+—-+—–+<br>| Id | Num |<br>+—-+—–+<br>| 1  |  1  |<br>| 2  |  1  |<br>| 3  |  1  |<br>| 4  |  2  |<br>| 5  |  1  |<br>| 6  |  2  |<br>| 7  |  2  |<br>+—-+—–+</p>
<p>例如，给定上面的 <code>Logs</code> 表， <code>1</code> 是唯一连续出现至少三次的数字。</p>
<p>+—————–+<br>| ConsecutiveNums |<br>+—————–+<br>| 1               |<br>+—————–+</p>
<h1 id="MySQL-解决方法"><a href="#MySQL-解决方法" class="headerlink" title="MySQL 解决方法"></a>MySQL 解决方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select distinct ConsecutiveNums from(</span><br><span class="line">select if(@no=num, @n, @n:=@n+1) ids, @no:=num ConsecutiveNums from logs,</span><br><span class="line">(select @no:=(select num from logs limit 1), @n:=1)a) b</span><br><span class="line">group by ids having count(ConsecutiveNums)&gt;=3;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 311 ms, faster than 93.34% of MySQL online submissions for Consecutive Numbers.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :1115 ms, 在所有 MySQL 提交中击败了15.35%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (18) 4Sum</title>
    <url>/e01a3214a389/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 a，b，c 和 d，使得 a + b + c + d 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意:</strong></p>
<p>答案中不可以包含重复的四元组。</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p>给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。</p>
<p>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left = j + <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="type">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        vector&lt;<span class="type">int</span>&gt; out&#123;nums[i], nums[j], nums[left], nums[right]&#125;;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(out);</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) ++left;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) --right;</span><br><span class="line">                        ++left; --right;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) ++left;</span><br><span class="line">                    <span class="keyword">else</span> --right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 44 ms, faster than 64.66% of C++ online submissions for 4Sum.</p>
<p>Memory Usage: 10.7 MB, less than 81.11% of C++ online submissions for 4Sum.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 96 ms, 在4Sum的C++提交中击败了9.05% 的用户</p>
<p>内存消耗 : 10.6 MB, 在4Sum的C++提交中击败了0.95% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (181) Employees Earning More Than Their Managers</title>
    <url>/9b89c680a806/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>SQL架构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create table If Not Exists Employee (Id int, Name varchar(255), Salary int, ManagerId int)</span><br><span class="line">Truncate table Employee</span><br><span class="line">insert into Employee (Id, Name, Salary, ManagerId) values (&#x27;1&#x27;, &#x27;Joe&#x27;, &#x27;70000&#x27;, &#x27;3&#x27;)</span><br><span class="line">insert into Employee (Id, Name, Salary, ManagerId) values (&#x27;2&#x27;, &#x27;Henry&#x27;, &#x27;80000&#x27;, &#x27;4&#x27;)</span><br><span class="line">insert into Employee (Id, Name, Salary, ManagerId) values (&#x27;3&#x27;, &#x27;Sam&#x27;, &#x27;60000&#x27;, &#x27;None&#x27;)</span><br><span class="line">insert into Employee (Id, Name, Salary, ManagerId) values (&#x27;4&#x27;, &#x27;Max&#x27;, &#x27;90000&#x27;, &#x27;None&#x27;)</span><br></pre></td></tr></table></figure>

<p><code>Employee</code> 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</p>
<p>+—-+——-+——–+———–+<br>| Id | Name  | Salary | ManagerId |<br>+—-+——-+——–+———–+<br>| 1  | Joe   | 70000  | 3         |<br>| 2  | Henry | 80000  | 4         |<br>| 3  | Sam   | 60000  | NULL      |<br>| 4  | Max   | 90000  | NULL      |<br>+—-+——-+——–+———–+<br>给定 <code>Employee</code> 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p>
<p>+———-+<br>| Employee |<br>+———-+<br>| Joe      |<br>+———-+</p>
<h1 id="MySQL-解决方法"><a href="#MySQL-解决方法" class="headerlink" title="MySQL 解决方法"></a>MySQL 解决方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select e1.Name as Employee </span><br><span class="line">from Employee e1, Employee e2 </span><br><span class="line">where e1.Salary &gt; e2.Salary and e1.ManagerId = e2.Id;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 652 ms, faster than 11.20% of MySQL online submissions for Employees Earning More Than Their Managers.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :676 ms, 在所有 MySQL 提交中击败了58.80%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (182) Duplicate Emails</title>
    <url>/a8b7191dbcdf/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>SQL架构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create table If Not Exists Person (Id int, Email varchar(255))</span><br><span class="line">Truncate table Person</span><br><span class="line">insert into Person (Id, Email) values (&#x27;1&#x27;, &#x27;a@b.com&#x27;)</span><br><span class="line">insert into Person (Id, Email) values (&#x27;2&#x27;, &#x27;c@d.com&#x27;)</span><br><span class="line">insert into Person (Id, Email) values (&#x27;3&#x27;, &#x27;a@b.com&#x27;)</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL 查询，查找 <code>Person</code> 表中所有重复的电子邮箱。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>+—-+———+<br>| Id | Email   |<br>+—-+———+<br>| 1  | <a href="mailto:&#x61;&#64;&#x62;&#x2e;&#x63;&#111;&#109;">&#x61;&#64;&#x62;&#x2e;&#x63;&#111;&#109;</a> |<br>| 2  | <a href="mailto:&#x63;&#x40;&#100;&#x2e;&#99;&#x6f;&#109;">&#x63;&#x40;&#100;&#x2e;&#99;&#x6f;&#109;</a> |<br>| 3  | <a href="mailto:&#97;&#x40;&#x62;&#x2e;&#x63;&#111;&#109;">&#97;&#x40;&#x62;&#x2e;&#x63;&#111;&#109;</a> |<br>+—-+———+</p>
<p>根据以上输入，你的查询应返回以下结果：</p>
<p>+———+<br>| Email   |<br>+———+<br>| <a href="mailto:&#97;&#64;&#98;&#46;&#x63;&#111;&#x6d;">&#97;&#64;&#98;&#46;&#x63;&#111;&#x6d;</a> |<br>+———+</p>
<p><strong>说明:</strong> 所有电子邮箱都是小写字母。</p>
<h1 id="MySQL-解决方法"><a href="#MySQL-解决方法" class="headerlink" title="MySQL 解决方法"></a>MySQL 解决方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">SELECT DISTINCT p1.Email FROM Person p1</span><br><span class="line">JOIN Person p2 ON p1.Email = p2.Email</span><br><span class="line">WHERE p1.Id &lt;&gt; p2.Id;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 223 ms, faster than 26.00% of MySQL online submissions for Duplicate Emails.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :512 ms, 在所有 MySQL 提交中击败了36.77%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (183) Customers Who Never Order</title>
    <url>/7eee9e7bc058/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>SQL架构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create table If Not Exists Customers (Id int, Name varchar(255))</span><br><span class="line">Create table If Not Exists Orders (Id int, CustomerId int)</span><br><span class="line">Truncate table Customers</span><br><span class="line">insert into Customers (Id, Name) values (&#x27;1&#x27;, &#x27;Joe&#x27;)</span><br><span class="line">insert into Customers (Id, Name) values (&#x27;2&#x27;, &#x27;Henry&#x27;)</span><br><span class="line">insert into Customers (Id, Name) values (&#x27;3&#x27;, &#x27;Sam&#x27;)</span><br><span class="line">insert into Customers (Id, Name) values (&#x27;4&#x27;, &#x27;Max&#x27;)</span><br><span class="line">Truncate table Orders</span><br><span class="line">insert into Orders (Id, CustomerId) values (&#x27;1&#x27;, &#x27;3&#x27;)</span><br><span class="line">insert into Orders (Id, CustomerId) values (&#x27;2&#x27;, &#x27;1&#x27;)</span><br></pre></td></tr></table></figure>

<p>某网站包含两个表，<code>Customers</code> 表和 <code>Orders</code> 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p>
<p><code>Customers</code> 表：</p>
<p>+—-+——-+<br>| Id | Name  |<br>+—-+——-+<br>| 1  | Joe   |<br>| 2  | Henry |<br>| 3  | Sam   |<br>| 4  | Max   |<br>+—-+——-+</p>
<p><code>Orders</code> 表：</p>
<p>+—-+————+<br>| Id | CustomerId |<br>+—-+————+<br>| 1  | 3          |<br>| 2  | 1          |<br>+—-+————+</p>
<p>例如给定上述表格，你的查询应返回：</p>
<p>+———–+<br>| Customers |<br>+———–+<br>| Henry     |<br>| Max       |<br>+———–+</p>
<h1 id="MySQL-解决方法"><a href="#MySQL-解决方法" class="headerlink" title="MySQL 解决方法"></a>MySQL 解决方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">SELECT Name AS Customers FROM Customers </span><br><span class="line">WHERE Id NOT IN (SELECT CustomerId FROM Orders);</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 297 ms, faster than 17.59% of MySQL online submissions for Customers Who Never Order.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :640 ms, 在所有 MySQL 提交中击败了45.65%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (184) Department Highest Salary</title>
    <url>/5936052a0655/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>SQL架构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create table If Not Exists Employee (Id int, Name varchar(255), Salary int, DepartmentId int)</span><br><span class="line">Create table If Not Exists Department (Id int, Name varchar(255))</span><br><span class="line">Truncate table Employee</span><br><span class="line">insert into Employee (Id, Name, Salary, DepartmentId) values (&#x27;1&#x27;, &#x27;Joe&#x27;, &#x27;70000&#x27;, &#x27;1&#x27;)</span><br><span class="line">insert into Employee (Id, Name, Salary, DepartmentId) values (&#x27;2&#x27;, &#x27;Jim&#x27;, &#x27;90000&#x27;, &#x27;1&#x27;)</span><br><span class="line">insert into Employee (Id, Name, Salary, DepartmentId) values (&#x27;3&#x27;, &#x27;Henry&#x27;, &#x27;80000&#x27;, &#x27;2&#x27;)</span><br><span class="line">insert into Employee (Id, Name, Salary, DepartmentId) values (&#x27;4&#x27;, &#x27;Sam&#x27;, &#x27;60000&#x27;, &#x27;2&#x27;)</span><br><span class="line">insert into Employee (Id, Name, Salary, DepartmentId) values (&#x27;5&#x27;, &#x27;Max&#x27;, &#x27;90000&#x27;, &#x27;1&#x27;)</span><br><span class="line">Truncate table Department</span><br><span class="line">insert into Department (Id, Name) values (&#x27;1&#x27;, &#x27;IT&#x27;)</span><br><span class="line">insert into Department (Id, Name) values (&#x27;2&#x27;, &#x27;Sales&#x27;)</span><br></pre></td></tr></table></figure>

<p><code>Employee</code> 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。</p>
<p>+—-+——-+——–+————–+<br>| Id | Name  | Salary | DepartmentId |<br>+—-+——-+——–+————–+<br>| 1  | Joe   | 70000  | 1            |<br>| 2  | Henry | 80000  | 2            |<br>| 3  | Sam   | 60000  | 2            |<br>| 4  | Max   | 90000  | 1            |<br>+—-+——-+——–+————–+</p>
<p><code>Department</code> 表包含公司所有部门的信息。</p>
<p>+—-+———-+<br>| Id | Name     |<br>+—-+———-+<br>| 1  | IT       |<br>| 2  | Sales    |<br>+—-+———-+</p>
<p>编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。</p>
<p>+————+———-+——–+<br>| Department | Employee | Salary |<br>+————+———-+——–+<br>| IT         | Max      | 90000  |<br>| Sales      | Henry    | 80000  |<br>+————+———-+——–+</p>
<h1 id="MySQL-解决方法"><a href="#MySQL-解决方法" class="headerlink" title="MySQL 解决方法"></a>MySQL 解决方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">SELECT d.Name AS Department, e.Name AS Employee, e.Salary FROM Employee e, Department d</span><br><span class="line">WHERE e.DepartmentId = d.Id AND e.Salary &gt;= ALL (SELECT Salary FROM Employee e2 WHERE e2.DepartmentId = d.Id);</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 396 ms, faster than 22.14% of MySQL online submissions for Department Highest Salary.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :778 ms, 在所有 MySQL 提交中击败了66.30%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (185) Department Top Three Salaries</title>
    <url>/ac0408ce28ea/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>SQL架构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create table If Not Exists Employee (Id int, Name varchar(255), Salary int, DepartmentId int)</span><br><span class="line">Create table If Not Exists Department (Id int, Name varchar(255))</span><br><span class="line">Truncate table Employee</span><br><span class="line">insert into Employee (Id, Name, Salary, DepartmentId) values (&#x27;1&#x27;, &#x27;Joe&#x27;, &#x27;85000&#x27;, &#x27;1&#x27;)</span><br><span class="line">insert into Employee (Id, Name, Salary, DepartmentId) values (&#x27;2&#x27;, &#x27;Henry&#x27;, &#x27;80000&#x27;, &#x27;2&#x27;)</span><br><span class="line">insert into Employee (Id, Name, Salary, DepartmentId) values (&#x27;3&#x27;, &#x27;Sam&#x27;, &#x27;60000&#x27;, &#x27;2&#x27;)</span><br><span class="line">insert into Employee (Id, Name, Salary, DepartmentId) values (&#x27;4&#x27;, &#x27;Max&#x27;, &#x27;90000&#x27;, &#x27;1&#x27;)</span><br><span class="line">insert into Employee (Id, Name, Salary, DepartmentId) values (&#x27;5&#x27;, &#x27;Janet&#x27;, &#x27;69000&#x27;, &#x27;1&#x27;)</span><br><span class="line">insert into Employee (Id, Name, Salary, DepartmentId) values (&#x27;6&#x27;, &#x27;Randy&#x27;, &#x27;85000&#x27;, &#x27;1&#x27;)</span><br><span class="line">insert into Employee (Id, Name, Salary, DepartmentId) values (&#x27;7&#x27;, &#x27;Will&#x27;, &#x27;70000&#x27;, &#x27;1&#x27;)</span><br><span class="line">Truncate table Department</span><br><span class="line">insert into Department (Id, Name) values (&#x27;1&#x27;, &#x27;IT&#x27;)</span><br><span class="line">insert into Department (Id, Name) values (&#x27;2&#x27;, &#x27;Sales&#x27;)</span><br></pre></td></tr></table></figure>

<p><code>Employee</code> 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id 。</p>
<p>+—-+——-+——–+————–+<br>| Id | Name  | Salary | DepartmentId |<br>+—-+——-+——–+————–+<br>| 1  | Joe   | 70000  | 1            |<br>| 2  | Henry | 80000  | 2            |<br>| 3  | Sam   | 60000  | 2            |<br>| 4  | Max   | 90000  | 1            |<br>| 5  | Janet | 69000  | 1            |<br>| 6  | Randy | 85000  | 1            |<br>+—-+——-+——–+————–+</p>
<p><code>Department</code> 表包含公司所有部门的信息。</p>
<p>+—-+———-+<br>| Id | Name     |<br>+—-+———-+<br>| 1  | IT       |<br>| 2  | Sales    |<br>+—-+———-+</p>
<p>编写一个 SQL 查询，找出每个部门工资前三高的员工。例如，根据上述给定的表格，查询结果应返回：</p>
<p>+————+———-+——–+<br>| Department | Employee | Salary |<br>+————+———-+——–+<br>| IT         | Max      | 90000  |<br>| IT         | Randy    | 85000  |<br>| IT         | Joe      | 70000  |<br>| Sales      | Henry    | 80000  |<br>| Sales      | Sam      | 60000  |<br>+————+———-+——–+</p>
<h1 id="MySQL-解决方法"><a href="#MySQL-解决方法" class="headerlink" title="MySQL 解决方法"></a>MySQL 解决方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">SELECT d.Name AS Department, e.Name AS Employee, e.Salary FROM </span><br><span class="line">(SELECT Name, Salary, DepartmentId,</span><br><span class="line">@rank := IF(@pre_d = DepartmentId, @rank + (@pre_s &lt;&gt; Salary), 1) AS rank,</span><br><span class="line">@pre_d := DepartmentId, @pre_s := Salary </span><br><span class="line">FROM Employee, (SELECT @pre_d := -1, @pre_s := -1, @rank := 1) AS init</span><br><span class="line">ORDER BY DepartmentId, Salary DESC) e JOIN Department d ON e.DepartmentId = d.Id</span><br><span class="line">WHERE e.rank &lt;= 3 ORDER BY d.Name, e.Salary DESC;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 435 ms, faster than 93.72% of MySQL online submissions for Department Top Three Salaries.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :1581 ms, 在所有 MySQL 提交中击败了40.47%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (186) Reverse Words in a String II</title>
    <url>/2e0ccab4ae57/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (187) Repeated DNA Sequences</title>
    <url>/1e3002b51331/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> s &#x3D; “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”<br><strong>输出:</strong> [“AAAAACCCCC”, “CCCCCAAAAA”]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; res;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) cur = cur &lt;&lt; <span class="number">3</span> | (s[i] &amp; <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cur = ((cur &amp; <span class="number">0x7ffffff</span>) &lt;&lt; <span class="number">3</span>) | (s[i] &amp; <span class="number">7</span>);</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">count</span>(cur)) res.<span class="built_in">insert</span>(s.<span class="built_in">substr</span>(i - <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">insert</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;string&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 36 ms, faster than 94.81% of C++ online submissions for Repeated DNA Sequences.</p>
<p>Memory Usage: 16.7 MB, less than 76.37% of C++ online submissions for Repeated DNA Sequences.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :48 ms, 在所有 C++ 提交中击败了97.96%的用户</p>
<p>内存消耗 :16.6 MB, 在所有 C++ 提交中击败了85.00%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (19) Remove Nth Node From End of List</title>
    <url>/5a198aaccfd6/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p><strong>说明:</strong></p>
<p>给定的 n 保证是有效的。</p>
<p><strong>进阶:</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 ** n &#x3D; 2**.</p>
<p>当删除了倒数第二个节点后，链表变为 <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head-&gt;next) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *pre = head, *cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!cur) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 99.75% of C++ online submissions for Remove Nth Node From End of List.</p>
<p>Memory Usage: 9.5 MB, less than 96.87% of C++ online submissions for Remove Nth Node From End of List.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 24 ms, 在Remove Nth Node From End of List的C++提交中击败了4.22% 的用户</p>
<p>内存消耗 : 9.7 MB, 在Remove Nth Node From End of List的C++提交中击败了0.76% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (188) Best Time to Buy and Sell Stock IV</title>
    <url>/092e7697faca/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p><strong>注意:</strong> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [2,4,1], k &#x3D; 2<br><strong>输出:</strong> 2<br><strong>解释:</strong> 在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [3,2,6,5,0,3], k &#x3D; 2<br><strong>输出:</strong> 7<br><strong>解释:</strong> 在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。<br>     随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= prices.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">solveMaxProfit</span>(prices);</span><br><span class="line">        <span class="type">int</span> g[k + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> l[k + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> diff = prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = k; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">                l[j] = <span class="built_in">max</span>(g[j - <span class="number">1</span>] + <span class="built_in">max</span>(diff, <span class="number">0</span>), l[j] + diff);</span><br><span class="line">                g[j] = <span class="built_in">max</span>(g[j], l[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solveMaxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - prices[i - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 99.25% of C++ online submissions for Best Time to Buy and Sell Stock IV.</p>
<p>Memory Usage: 8.9 MB, less than 88.76% of C++ online submissions for Best Time to Buy and Sell Stock IV.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :12 ms, 在所有 C++ 提交中击败了84.22%的用户</p>
<p>内存消耗 :8.8 MB, 在所有 C++ 提交中击败了91.50%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (190) Reverse Bits</title>
    <url>/14c76ff6d03e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 00000010100101000001111010011100<br><strong>输出:</strong> 00111001011110000010100101000000<br><strong>解释:</strong> 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 11111111111111111111111111111101<br><strong>输出:</strong> 10111111111111111111111111111111<br><strong>解释:</strong> 输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，<br>      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。</p>
<p>**<strong>提示:</strong></p>
<ul>
<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
<li>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            res = (res &lt;&lt; <span class="number">1</span>) + (n &gt;&gt; i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Reverse Bits.</p>
<p>Memory Usage: 8.1 MB, less than 24.40% of C++ online submissions for Reverse Bits.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗 :8.2 MB, 在所有 C++ 提交中击败了7.61%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (191) Number of 1 Bits</title>
    <url>/b22b575abe15/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>）。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 00000000000000000000000000001011<br><strong>输出:</strong> 3<br><strong>解释:</strong> 输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 00000000000000000000000010000000<br><strong>输出:</strong> 1<br><strong>解释:</strong> 输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> 11111111111111111111111111111101<br><strong>输出:</strong> 31<br><strong>解释:</strong> 输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p>
<p><strong>提示:</strong></p>
<ul>
<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
<li>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</li>
</ul>
<p><strong>进阶:</strong></p>
<p>如果多次调用这个函数，你将如何优化你的算法？</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            res += (n &amp; <span class="number">1</span>);</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 84.13% of C++ online submissions for Number of 1 Bits.</p>
<p>Memory Usage: 8.2 MB, less than 22.15% of C++ online submissions for Number of 1 Bits.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有 C++ 提交中击败了79.51%的用户</p>
<p>内存消耗 :8.2 MB, 在所有 C++ 提交中击败了27.22%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (192) Word Frequency</title>
    <url>/1966f36065ed/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>写一个 bash 脚本以统计一个文本文件 <code>words.txt</code> 中每个单词出现的频率。</p>
<p>为了简单起见，你可以假设：</p>
<ul>
<li><code>words.txt</code>只包括小写字母和 ‘ ‘ 。</li>
<li>每个单词只由小写字母组成。</li>
<li>单词间由一个或多个空格字符分隔。</li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>假设 <code>words.txt</code> 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the day is sunny the the</span><br><span class="line">the sunny is is</span><br></pre></td></tr></table></figure>

<p>你的脚本应当输出（以词频降序排列）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the 4</span><br><span class="line">is 3</span><br><span class="line">sunny 2</span><br><span class="line">day 1</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。</li>
<li>你可以使用一行 <a href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-4.html">Unix pipes</a> 实现吗？</li>
</ul>
<h1 id="Bash-解决方法"><a href="#Bash-解决方法" class="headerlink" title="Bash 解决方法"></a>Bash 解决方法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Read from the file words.txt and output the word frequency list to stdout.</span></span><br><span class="line">grep -oE <span class="string">&#x27;[a-z]+&#x27;</span> words.txt | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr | awk <span class="string">&#x27;&#123;print $2&quot; &quot;$1&#125;&#x27;</span> </span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of Bash online submissions for Word Frequency.</p>
<p>Memory Usage: 3.3 MB, less than 81.02% of Bash online submissions for Word Frequency.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :4 ms, 在所有 Bash 提交中击败了84.93%的用户</p>
<p>内存消耗 :3.3 MB, 在所有 Bash 提交中击败了79.57%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (189) Rotate Array</title>
    <url>/6037918b74d4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [1,2,3,4,5,6,7] 和 k &#x3D; 3<br><strong>输出:</strong> [5,6,7,1,2,3,4]<br><strong>解释:</strong><br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [-1,-100,3,99] 和 k &#x3D; 2<br><strong>输出:</strong> [3,99,-1,-100]<br><strong>解释:</strong><br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]</p>
<p><strong>说明:</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>要求使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || (k %= nums.<span class="built_in">size</span>()) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + n - k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + n - k, nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 92.37% of C++ online submissions for Rotate Array.</p>
<p>Memory Usage: 9.5 MB, less than 47.71% of C++ online submissions for Rotate Array.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :24 ms, 在所有 C++ 提交中击败了94.33%的用户</p>
<p>内存消耗 :9.3 MB, 在所有 C++ 提交中击败了88.16%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (194) Transpose File</title>
    <url>/93131f30db4c/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个文件 <code>file.txt</code>，转置它的内容。</p>
<p>你可以假设每行列数相同，并且每个字段由 <code>&#39; &#39;</code> 分隔.</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>假设 <code>file.txt</code> 文件内容如下:</p>
<p>name age<br>alice 21<br>ryan 30</p>
<p>应当输出:</p>
<p>name alice ryan<br>age 21 30</p>
<h1 id="Bash-解决方法"><a href="#Bash-解决方法" class="headerlink" title="Bash 解决方法"></a>Bash 解决方法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Read from the file file.txt and print its transposed content to stdout.</span></span><br><span class="line">awk <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    for (i = 1; i &lt;= NF; ++i) &#123;</span></span><br><span class="line"><span class="string">        if (NR == 1) s[i] = $i;</span></span><br><span class="line"><span class="string">        else s[i] = s[i] &quot; &quot; $i;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125; END &#123;</span></span><br><span class="line"><span class="string">    for (i = 1; s[i] != &quot;&quot;; ++i) &#123;</span></span><br><span class="line"><span class="string">        print s[i];</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 75.19% of Bash online submissions for Transpose File.</p>
<p>Memory Usage: 3.5 MB, less than 82.17% of Bash online submissions for Transpose File.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :16 ms, 在所有 Bash 提交中击败了80.53%的用户</p>
<p>内存消耗 :3.7 MB, 在所有 Bash 提交中击败了26.11%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (193) Valid Phone Numbers</title>
    <url>/83746a0c174d/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含电话号码列表（一行一个电话号码）的文本文件 <code>file.txt</code>，写一个 bash 脚本输出所有有效的电话号码。</p>
<p>你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）</p>
<p>你也可以假设每行前后没有多余的空格字符。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>假设 <code>file.txt</code> 内容如下：</p>
<p>987-123-4567<br>123 456 7890<br>(123) 456-7890</p>
<p>你的脚本应当输出下列有效的电话号码：</p>
<p>987-123-4567<br>(123) 456-7890</p>
<h1 id="Bash-解决方法"><a href="#Bash-解决方法" class="headerlink" title="Bash 解决方法"></a>Bash 解决方法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Read from the file file.txt and output all valid phone numbers to stdout.</span></span><br><span class="line">sed -n -r <span class="string">&#x27;/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/p&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of Bash online submissions for Valid Phone Numbers.</p>
<p>Memory Usage: 3.1 MB, less than 98.39% of Bash online submissions for Valid Phone Numbers.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :0 ms, 在所有 Bash 提交中击败了100.00%的用户</p>
<p>内存消耗 :3.1 MB, 在所有 Bash 提交中击败了69.85%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (195) Tenth Line</title>
    <url>/c4d28e3b3ed1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个文本文件 <code>file.txt</code>，请只打印这个文件中的第十行。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>假设 <code>file.txt</code> 有如下内容：</p>
<p>Line 1<br>Line 2<br>Line 3<br>Line 4<br>Line 5<br>Line 6<br>Line 7<br>Line 8<br>Line 9<br>Line 10</p>
<p>你的脚本应当显示第十行：</p>
<p>Line 10</p>
<p><strong>说明:</strong></p>
<ol>
<li>如果文件少于十行，你应当输出什么？</li>
<li>至少有三种不同的解法，请尝试尽可能多的方法来解题。</li>
</ol>
<h1 id="Bash-解决方法"><a href="#Bash-解决方法" class="headerlink" title="Bash 解决方法"></a>Bash 解决方法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Read from the file file.txt and output the tenth line to stdout.</span></span><br><span class="line">sed -n 10p file.txt</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 87.60% of Bash online submissions for Tenth Line.</p>
<p>Memory Usage: 3.6 MB, less than 97.31% of Bash online submissions for Tenth Line.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :4 ms, 在所有 Bash 提交中击败了94.55%的用户</p>
<p>内存消耗 :3.7 MB, 在所有 Bash 提交中击败了48.45%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (197) Rising Temperature</title>
    <url>/36712851eb43/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>SQL架构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create table If Not Exists Weather (Id int, RecordDate date, Temperature int)</span><br><span class="line">Truncate table Weather</span><br><span class="line">insert into Weather (Id, RecordDate, Temperature) values (&#x27;1&#x27;, &#x27;2015-01-01&#x27;, &#x27;10&#x27;)</span><br><span class="line">insert into Weather (Id, RecordDate, Temperature) values (&#x27;2&#x27;, &#x27;2015-01-02&#x27;, &#x27;25&#x27;)</span><br><span class="line">insert into Weather (Id, RecordDate, Temperature) values (&#x27;3&#x27;, &#x27;2015-01-03&#x27;, &#x27;20&#x27;)</span><br><span class="line">insert into Weather (Id, RecordDate, Temperature) values (&#x27;4&#x27;, &#x27;2015-01-04&#x27;, &#x27;30&#x27;)</span><br></pre></td></tr></table></figure>

<p>给定一个 <code>Weather</code> 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。</p>
<p>+———+——————+——————+<br>| Id(INT) | RecordDate(DATE) | Temperature(INT) |<br>+———+——————+——————+<br>|       1 |       2015-01-01 |               10 |<br>|       2 |       2015-01-02 |               25 |<br>|       3 |       2015-01-03 |               20 |<br>|       4 |       2015-01-04 |               30 |<br>+———+——————+——————+</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>例如，根据上述给定的 <code>Weather</code> 表格，返回如下 Id:</p>
<p>+—-+<br>| Id |<br>+—-+<br>|  2 |<br>|  4 |<br>+—-+</p>
<h1 id="MySQL-解决方法"><a href="#MySQL-解决方法" class="headerlink" title="MySQL 解决方法"></a>MySQL 解决方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">SELECT Id from (</span><br><span class="line">    SELECT Id,</span><br><span class="line">        IF(@prev_day is not null </span><br><span class="line">           and date_add(@prev_day, interval 1 day) = RecordDate</span><br><span class="line">           and @prev_temp &lt; Temperature, 1, 0) result,</span><br><span class="line">        @prev_day := RecordDate,</span><br><span class="line">        @prev_temp := Temperature</span><br><span class="line">        FROM Weather, (select @prev_temp := 0, @prev_day := NULL) a</span><br><span class="line">    order by RecordDate </span><br><span class="line">    ) b</span><br><span class="line">    where result = 1;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 183 ms, faster than 100.00% of MySQL online submissions for Rising Temperature.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :581 ms, 在所有 MySQL 提交中击败了72.25%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (196) Delete Duplicate Emails</title>
    <url>/437b00288b55/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个 SQL 查询，来删除 <code>Person</code> 表中所有重复的电子邮箱，重复的邮箱里只保留 **Id ** 最小 的那个。</p>
<p>+—-+——————+<br>| Id | Email            |<br>+—-+——————+<br>| 1  | <a href="mailto:&#x6a;&#x6f;&#104;&#x6e;&#64;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#x6f;&#109;">&#x6a;&#x6f;&#104;&#x6e;&#64;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#x6f;&#109;</a> |<br>| 2  | <a href="mailto:&#98;&#x6f;&#x62;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;">&#98;&#x6f;&#x62;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;</a>  |<br>| 3  | <a href="mailto:&#106;&#111;&#x68;&#x6e;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;">&#106;&#111;&#x68;&#x6e;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a> |<br>+—-+——————+<br>Id 是这个表的主键。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>例如，在运行你的查询语句之后，上面的 <code>Person</code> 表应返回以下几行:</p>
<p>+—-+——————+<br>| Id | Email            |<br>+—-+——————+<br>| 1  | <a href="mailto:&#106;&#x6f;&#104;&#x6e;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;">&#106;&#x6f;&#104;&#x6e;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;</a> |<br>| 2  | <a href="mailto:&#98;&#111;&#98;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#98;&#111;&#98;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;</a>  |<br>+—-+——————+</p>
<h1 id="MySQL-解决方法"><a href="#MySQL-解决方法" class="headerlink" title="MySQL 解决方法"></a>MySQL 解决方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">DELETE FROM Person WHERE Id NOT IN</span><br><span class="line">(SELECT Id FROM (SELECT MIN(Id) Id FROM Person GROUP BY Email) p);</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 519 ms, faster than 99.71% of MySQL online submissions for Delete Duplicate Emails.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :1010 ms, 在所有 MySQL 提交中击败了93.70%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (199) Binary Tree Right Side View</title>
    <url>/c370747d6e6b/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [1,2,3,null,5,null,4]<br><strong>输出:</strong> [1, 3, 4]<br><strong>解释:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(q.<span class="built_in">back</span>()-&gt;val);</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                TreeNode *node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 86.64% of C++ online submissions for Binary Tree Right Side View.</p>
<p>Memory Usage: 9.6 MB, less than 48.73% of C++ online submissions for Binary Tree Right Side View.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有 C++ 提交中击败了85.81%的用户</p>
<p>内存消耗 :9.4 MB, 在所有 C++ 提交中击败了80.30%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (198) House Robber</title>
    <url>/93aa32c83c3d/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong>，能够偷窃到的最高金额。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [1,2,3,1]<br><strong>输出:</strong> 4<br><strong>解释:</strong> 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [2,7,9,3,1]<br><strong>输出:</strong> 12<br><strong>解释:</strong> 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rob = <span class="number">0</span>, notRob = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> preRob = rob, preNotRob = notRob;</span><br><span class="line">            rob = preNotRob + nums[i];</span><br><span class="line">            notRob = <span class="built_in">max</span>(preRob, preNotRob);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rob, notRob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 77.55% of C++ online submissions for House Robber.</p>
<p>Memory Usage: 8.6 MB, less than 42.93% of C++ online submissions for House Robber.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有 C++ 提交中击败了68.17%的用户</p>
<p>内存消耗 :8.5 MB, 在所有 C++ 提交中击败了89.30%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (2) Add Two Numbers</title>
    <url>/c0fefafffeb8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入：</strong>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><strong>输出：</strong>7 -&gt; 0 -&gt; 8<br><strong>原因：</strong>342 + 465 &#x3D; 807</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *cur = dummy;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">            <span class="type">int</span> val1 = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> val2 = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = val1 + val2 + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry) cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 40 ms, faster than 96.35% of C++ online submissions for Add Two Numbers.</p>
<p>Memory Usage: 19.3 MB, less than 17.61% of C++ online submissions for Add Two Numbers.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 68 ms, 在Add Two Numbers的C++提交中击败了3.43% 的用户</p>
<p>内存消耗 : 19 MB, 在Add Two Numbers的C++提交中击败了0.94% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (200) Number of Islands</title>
    <url>/b7209b7c7775/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong><br>11110<br>11010<br>11000<br>00000</p>
<p><strong>输出:</strong> 1</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong><br>11000<br>11000<br>00100<br>00011</p>
<p><strong>输出:</strong> 3</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n));</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dirX&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dirY&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;0&#x27;</span> || visited[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                ++res;</span><br><span class="line">                queue&lt;<span class="type">int</span>&gt; q&#123;&#123;i * n + j&#125;&#125;;</span><br><span class="line">                <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="type">int</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                        <span class="type">int</span> x = t / n + dirX[k], y = t % n + dirY[k];</span><br><span class="line">                        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] == <span class="string">&#x27;0&#x27;</span> || visited[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">                        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(x * n + y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 95.73% of C++ online submissions for Number of Islands.</p>
<p>Memory Usage: 11.6 MB, less than 18.27% of C++ online submissions for Number of Islands.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :24 ms, 在所有 C++ 提交中击败了52.35%的用户</p>
<p>内存消耗 :11.5 MB, 在所有 C++ 提交中击败了16.88%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (202) Happy Number</title>
    <url>/e293ffc3cd6e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>写一个算法来判断一个数是不是“快乐数”。</p>
<p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> 19<br><strong>输出:</strong> true<br><strong>解释:</strong> </p>
<p>$$<br>1^2 + 9^2 &#x3D; 82\<br>8^2 + 2^2 &#x3D; 68\<br>6^2 + 8^2 &#x3D; 100\<br>1^2 + 0^2 + 0^2 &#x3D; 1<br>$$</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; n != <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n) &#123;</span><br><span class="line">                sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Happy Number.</p>
<p>Memory Usage: 8.1 MB, less than 77.46% of C++ online submissions for Happy Number.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :4 ms, 在所有 C++ 提交中击败了95.14%的用户</p>
<p>内存消耗 :8.1 MB, 在所有 C++ 提交中击败了69.39%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (201) Bitwise AND of Numbers Range</title>
    <url>/9b38d7666d78/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定范围 [m, n]，其中 0 &lt;&#x3D; m &lt;&#x3D; n &lt;&#x3D; 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [5,7]<br><strong>输出:</strong> 4</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [0,1]<br><strong>输出:</strong> 0</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (m != n) &#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (m &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 99.46% of C++ online submissions for Bitwise AND of Numbers Range.</p>
<p>Memory Usage: 8.1 MB, less than 65.30% of C++ online submissions for Bitwise AND of Numbers Range.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :24 ms, 在所有 C++ 提交中击败了74.89%的用户</p>
<p>内存消耗 :8 MB, 在所有 C++ 提交中击败了83.33%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (20) Valid Parentheses</title>
    <url>/38e9a95d007c/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意：空字符串可被认为是有效字符串。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> “()”<br><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> “()[]{}”<br><strong>输出:</strong> true</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> “(]”<br><strong>输出:</strong> false</p>
<h1 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h1><p><strong>输入:</strong> “([)]”<br><strong>输出:</strong> false</p>
<h1 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h1><p><strong>输入:</strong> “{[]}”<br><strong>输出:</strong> true</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; parentheses;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>) parentheses.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parentheses.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; parentheses.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; parentheses.<span class="built_in">top</span>() != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; parentheses.<span class="built_in">top</span>() != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                parentheses.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parentheses.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Valid Parentheses.</p>
<p>Memory Usage: 9 MB, less than 57.02% of C++ online submissions for Valid Parentheses.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Valid Parentheses的C++提交中击败了13.39% 的用户</p>
<p>内存消耗 : 8.9 MB, 在Valid Parentheses的C++提交中击败了0.93% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (203) Remove Linked List Elements</title>
    <url>/42e8b4650fc6/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>删除链表中等于给定值 <strong>val</strong> 的所有节点。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, <strong>val</strong> &#x3D; 6<br><strong>输出:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *pre = dummy;</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span> (pre-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode *t = pre-&gt;next;</span><br><span class="line">                pre-&gt;next = t-&gt;next;</span><br><span class="line">                t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">delete</span> t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 24 ms, faster than 96.79% of C++ online submissions for Remove Linked List Elements.</p>
<p>Memory Usage: 11.2 MB, less than 16.15% of C++ online submissions for Remove Linked List Elements.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :44 ms, 在所有 C++ 提交中击败了74.02%的用户</p>
<p>内存消耗 :11.2 MB, 在所有 C++ 提交中击败了64.86%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (204) Count Primes</title>
    <url>/d82958f39d8c/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>统计所有小于非负整数 <strong>n</strong> 的质数的数量。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> 10<br><strong>输出:</strong> 4<br><strong>解释:</strong> 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">prime</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prime[i]) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; i * j &lt; n; ++j) &#123;</span><br><span class="line">                    prime[i * j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 88 ms, faster than 36.53% of C++ online submissions for Count Primes.</p>
<p>Memory Usage: 8.6 MB, less than 74.05% of C++ online submissions for Count Primes.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :168 ms, 在所有 C++ 提交中击败了33.37%的用户</p>
<p>内存消耗 :8.7 MB, 在所有 C++ 提交中击败了61.99%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (205) Isomorphic Strings</title>
    <url>/5ed4ff95b107/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个字符串 <strong>s</strong> 和 <strong>t</strong>，判断它们是否是同构的。</p>
<p>如果 <strong>s</strong> 中的字符可以被替换得到 <strong>t</strong> ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> <strong>s</strong> &#x3D; <code>&quot;egg&quot;</code> , <strong>t</strong> &#x3D; <code>&quot;add&quot;</code><br><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> <strong>s</strong> &#x3D; <code>&quot;foo&quot;</code> , <strong>t</strong> &#x3D; <code>&quot;bar&quot;</code><br><strong>输出:</strong> false</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> <strong>s</strong> &#x3D; <code>&quot;paper&quot;</code> , <strong>t</strong> &#x3D; <code>&quot;title&quot;</code><br><strong>输出:</strong> true</p>
<p><strong>说明:</strong><br>你可以假设 <strong>s</strong> 和 <strong>t</strong> 具有相同的长度。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m1[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, m2[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m1[s[i]] != m2[t[i]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            m1[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">            m2[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 91.00% of C++ online submissions for Isomorphic Strings.</p>
<p>Memory Usage: 9.1 MB, less than 64.48% of C++ online submissions for Isomorphic Strings.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有 C++ 提交中击败了98.40%的用户</p>
<p>内存消耗 :8.9 MB, 在所有 C++ 提交中击败了65.49%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (208) Implement Trie (Prefix Tree)</title>
    <url>/5f225e29d7a0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现一个 Trie (前缀树)，包含 <code>insert</code>, <code>search</code>, 和 <code>startsWith</code> 这三个操作。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Trie trie = new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 true</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 false</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 true</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>你可以假设所有的输入都是由小写字母 <code>a-z</code> 构成的。</li>
<li>保证所有输入均为非空字符串。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    TrieNode *child[<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> isWord;</span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : child) a = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : s) &#123;</span><br><span class="line">            <span class="type">int</span> i = a - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;child[i]) p-&gt;child[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            p = p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string key)</span> </span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : key) &#123;</span><br><span class="line">            <span class="type">int</span> i = a - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;child[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : prefix) &#123;</span><br><span class="line">            <span class="type">int</span> i = a - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;child[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 60 ms, faster than 97.58% of C++ online submissions for Implement Trie (Prefix Tree).</p>
<p>Memory Usage: 44.8 MB, less than 56.40% of C++ online submissions for Implement Trie (Prefix Tree).</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :88 ms, 在所有 C++ 提交中击败了92.18%的用户</p>
<p>内存消耗 :44.8 MB, 在所有 C++ 提交中击败了68.72%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (207) Course Schedule</title>
    <url>/40f88d10a3b7/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 2, [[1,0]]<br><strong>输出:</strong> true<br><strong>解释:</strong> 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 2, [[1,0],[0,1]]<br><strong>输出:</strong> false<br><strong>解释:</strong> 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p>
<p><strong>说明:</strong></p>
<ol>
<li>输入的先决条件是由 <strong>边缘列表</strong> 表示的图形，而不是邻接矩阵。详情请参见<a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs">图的表示法</a>。</li>
<li>你可以假定输入的先决条件中没有重复的边。</li>
</ol>
<p><strong>提示:</strong></p>
<ol>
<li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li>
<li><a href="https://www.coursera.org/specializations/algorithms">通过 DFS 进行拓扑排序</a> - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li>
<li>拓扑排序也可以通过 <a href="https://baike.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/5224802?fr=aladdin&fromid=2148012&fromtitle=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">BFS</a> 完成。</li>
</ol>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : prerequisites) &#123;</span><br><span class="line">            graph[a[<span class="number">1</span>]].<span class="built_in">push_back</span>(a[<span class="number">0</span>]);</span><br><span class="line">            ++in[a[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> a : graph[t]) &#123;</span><br><span class="line">                --in[a];</span><br><span class="line">                <span class="keyword">if</span> (in[a] == <span class="number">0</span>) q.<span class="built_in">push</span>(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 24 ms, faster than 65.45% of C++ online submissions for Course Schedule.</p>
<p>Memory Usage: 13.6 MB, less than 41.72% of C++ online submissions for Course Schedule.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :56 ms, 在所有 C++ 提交中击败了41.77%的用户</p>
<p>内存消耗 :13.6 MB, 在所有 C++ 提交中击败了16.59%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (206) Reverse Linked List</title>
    <url>/a6eca0e48224/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>反转一个单链表。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br><strong>输出:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 87.92% of C++ online submissions for Reverse Linked List.</p>
<p>Memory Usage: 9.4 MB, less than 5.15% of C++ online submissions for Reverse Linked List.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :20 ms, 在所有 C++ 提交中击败了32.42%的用户</p>
<p>内存消耗 :9.3 MB, 在所有 C++ 提交中击败了6.35%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (209) Minimum Size Subarray Sum</title>
    <url>/4d39bb2f896d/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个含有 <strong>n</strong> 个正整数的数组和一个正整数 <strong>s</strong> ，找出该数组中满足其和 <strong>≥ s</strong> 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br><strong>输出:</strong> 2<br><strong>解释:</strong> 子数组 <code>[4,3]</code> 是该条件下的长度最小的连续子数组。</p>
<p><strong>进阶:</strong></p>
<p>如果你已经完成了 O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>, len = nums.<span class="built_in">size</span>(), res = len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">while</span> (sum &lt; s &amp;&amp; right &lt; len) &#123;</span><br><span class="line">                sum += nums[right++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, right - left);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == len + <span class="number">1</span> ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 97.95% of C++ online submissions for Minimum Size Subarray Sum.</p>
<p>Memory Usage: 9.9 MB, less than 67.24% of C++ online submissions for Minimum Size Subarray Sum.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :12 ms, 在所有 C++ 提交中击败了93.34%的用户</p>
<p>内存消耗 :9.8 MB, 在所有 C++ 提交中击败了94.22%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (21) Merge Two Sorted Lists</title>
    <url>/51ff3959837f/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br><strong>输出:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode *head = l1-&gt;val &lt; l2-&gt;val ? l1 : l2;</span><br><span class="line">        ListNode *nonhead = l1-&gt;val &lt; l2-&gt;val ? l2 : l1;</span><br><span class="line">        head-&gt;next = <span class="built_in">mergeTwoLists</span>(head-&gt;next, nonhead);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 100.00% of C++ online submissions for Merge Two Sorted Lists.</p>
<p>Memory Usage: 8.8 MB, less than 100.00% of C++ online submissions for Merge Two Sorted Lists.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 32 ms, 在Merge Two Sorted Lists的C++提交中击败了2.59% 的用户</p>
<p>内存消耗 : 9.9 MB, 在Merge Two Sorted Lists的C++提交中击败了0.38% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (211) Add and Search Word - Data structure design</title>
    <url>/3c028afb2353/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>设计一个支持以下两种操作的数据结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void addWord(word)</span><br><span class="line">bool search(word)</span><br></pre></td></tr></table></figure>

<p>search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 <code>.</code> 或 <code>a-z</code> 。 <code>.</code> 可以表示任何一个字母。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addWord(&quot;bad&quot;)</span><br><span class="line">addWord(&quot;dad&quot;)</span><br><span class="line">addWord(&quot;mad&quot;)</span><br><span class="line">search(&quot;pad&quot;) -&gt; false</span><br><span class="line">search(&quot;bad&quot;) -&gt; true</span><br><span class="line">search(&quot;.ad&quot;) -&gt; true</span><br><span class="line">search(&quot;b..&quot;) -&gt; true</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>你可以假设所有单词都是由小写字母 <code>a-z</code> 组成的。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TrieNode *child[<span class="number">26</span>];</span><br><span class="line">        <span class="type">bool</span> isWord;</span><br><span class="line">        <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : child) a = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : word) &#123;</span><br><span class="line">            <span class="type">int</span> i = a - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;child[i]) p-&gt;child[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            p = p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isWord = <span class="literal">true</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchWord</span>(word, root, <span class="number">0</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">searchWord</span><span class="params">(string &amp;word, TrieNode *p, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == word.<span class="built_in">size</span>()) <span class="keyword">return</span> p-&gt;isWord;</span><br><span class="line">        <span class="keyword">if</span> (word[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : p-&gt;child) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &amp;&amp; <span class="built_in">searchWord</span>(word, a, i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;child[word[i] - <span class="string">&#x27;a&#x27;</span>] &amp;&amp; <span class="built_in">searchWord</span>(word, p-&gt;child[word[i] - <span class="string">&#x27;a&#x27;</span>], i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 92 ms, faster than 86.76% of C++ online submissions for Add and Search Word - Data structure design.</p>
<p>Memory Usage: 44.2 MB, less than 77.41% of C++ online submissions for Add and Search Word - Data structure design.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :176 ms, 在所有 C++ 提交中击败了62.84%的用户</p>
<p>内存消耗 :44.4 MB, 在所有 C++ 提交中击败了71.27%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (212) Word Search II</title>
    <url>/23f27a8d8ddb/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二维网格 <code>board</code> 和一个字典中的单词列表 <code>words</code>，找出所有同时在二维网格和字典中出现的单词。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong><br>words &#x3D; [“oath”,”pea”,”eat”,”rain”] and board &#x3D;<br>[<br>  [‘o’,’a’,’a’,’n’],<br>  [‘e’,’t’,’a’,’e’],<br>  [‘i’,’h’,’k’,’r’],<br>  [‘i’,’f’,’l’,’v’]<br>]</p>
<p><strong>输出:</strong> [“eat”,”oath”]</p>
<p><strong>说明:</strong></p>
<p>你可以假设所有输入都由小写字母 <code>a-z</code> 组成。</p>
<p><strong>提示:</strong></p>
<ul>
<li>你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？</li>
<li>如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/description/">实现Trie（前缀树）</a>。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        TrieNode *child[<span class="number">26</span>];</span><br><span class="line">        string str;</span><br><span class="line">        <span class="built_in">TrieNode</span>() : <span class="built_in">str</span>(<span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : child) a = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        TrieNode *root;</span><br><span class="line">        <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">            TrieNode *p = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : s) &#123;</span><br><span class="line">                <span class="type">int</span> i = a - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (!p-&gt;child[i]) p-&gt;child[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">                p = p-&gt;child[i];</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;str = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (words.<span class="built_in">empty</span>() || board.<span class="built_in">empty</span>() || board[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> res;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visit</span>(board.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(board[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        Trie T;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : words) T.<span class="built_in">insert</span>(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (T.root-&gt;child[board[i][j] - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                    <span class="built_in">search</span>(board, T.root-&gt;child[board[i][j] - <span class="string">&#x27;a&#x27;</span>], i, j, visit, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, TrieNode* p, <span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visit, vector&lt;string&gt;&amp; res)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(p-&gt;str);</span><br><span class="line">            p-&gt;str.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> d[][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        visit[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : d) &#123;</span><br><span class="line">            <span class="type">int</span> nx = a[<span class="number">0</span>] + i, ny = a[<span class="number">1</span>] + j;</span><br><span class="line">            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; board.<span class="built_in">size</span>() &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; !visit[nx][ny] &amp;&amp; p-&gt;child[board[nx][ny] - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="built_in">search</span>(board, p-&gt;child[board[nx][ny] - <span class="string">&#x27;a&#x27;</span>], nx, ny, visit, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i][j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 44 ms, faster than 92.30% of C++ online submissions for Word Search II.</p>
<p>Memory Usage: 31.4 MB, less than 80.50% of C++ online submissions for Word Search II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :64 ms, 在所有 C++ 提交中击败了92.84%的用户</p>
<p>内存消耗 :31.5 MB, 在所有 C++ 提交中击败了87.98%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (213) House Robber II</title>
    <url>/c672fe5963a0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <code>围成一圈</code>，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<code>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</code>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <code>在不触动警报装置的情况下</code>，能够偷窃到的最高金额。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [2,3,2]<br><strong>输出:</strong> 3<br><strong>解释:</strong> 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [1,2,3,1]<br><strong>输出:</strong> 4<br><strong>解释:</strong> 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">empty</span>() ? <span class="number">0</span> : nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">rob</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>), <span class="built_in">rob</span>(nums, <span class="number">1</span>, nums.<span class="built_in">size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rob = <span class="number">0</span>, notRob = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; right; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> preRob = rob, preNotRob = notRob;</span><br><span class="line">            rob = preNotRob + nums[i];</span><br><span class="line">            notRob = <span class="built_in">max</span>(preRob, preNotRob);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rob, notRob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for House Robber II.</p>
<p>Memory Usage: 8.5 MB, less than 62.27% of C++ online submissions for House Robber II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :4 ms, 在所有 C++ 提交中击败了89.41%的用户</p>
<p>内存消耗 :8.6 MB, 在所有 C++ 提交中击败了76.60%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (210) Course Schedule II</title>
    <url>/3d57e4363b30/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 2, [[1,0]]<br><strong>输出:</strong> [0,1]<br><strong>解释:</strong> 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 4, [[1,0],[2,0],[3,1],[3,2]]<br><strong>输出:</strong> [0,1,2,3] or [0,2,1,3]<br><strong>解释:</strong> 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。<br>     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</p>
<p><strong>说明:</strong></p>
<ol>
<li>输入的先决条件是由 <strong>边缘列表</strong> 表示的图形，而不是邻接矩阵。详情请参见<a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs">图的表示法</a>。</li>
<li>你可以假定输入的先决条件中没有重复的边。</li>
</ol>
<p><strong>提示:</strong></p>
<ol>
<li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li>
<li><a href="https://www.coursera.org/specializations/algorithms">通过 DFS 进行拓扑排序</a> - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li>
<li>拓扑排序也可以通过 <a href="https://baike.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/5224802?fr=aladdin&fromid=2148012&fromtitle=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">BFS</a> 完成。</li>
</ol>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="type">bool</span> hasCycle;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; white;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; gray;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numCourses == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    n = numCourses;</span><br><span class="line">    hasCycle = <span class="literal">false</span>;</span><br><span class="line">    white = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">    result = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line">    graph = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : prerequisites)</span><br><span class="line">        graph[x[<span class="number">1</span>]].<span class="built_in">push_back</span>(x[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)</span><br><span class="line">        <span class="keyword">if</span>(!white[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(hasCycle)</span><br><span class="line">        <span class="keyword">return</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hasCycle || white[node])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        white[node] = <span class="number">1</span>;</span><br><span class="line">        gray.<span class="built_in">insert</span>(node);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ele : graph[node])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(gray.<span class="built_in">find</span>(ele) != gray.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                hasCycle = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        gray.<span class="built_in">erase</span>(gray.<span class="built_in">find</span>(node));</span><br><span class="line">        result[--n] = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 28 ms, faster than 55.66% of C++ online submissions for Course Schedule II.</p>
<p>Memory Usage: 16.7 MB, less than 10.61% of C++ online submissions for Course Schedule II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :44 ms, 在所有 C++ 提交中击败了56.80%的用户</p>
<p>内存消耗 :16.7 MB, 在所有 C++ 提交中击败了5.48%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (214) Shortest Palindrome</title>
    <url>/5b992fbb7c93/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 <strong>s</strong>，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> <code>&quot;aacecaaa&quot;</code><br><strong>输出:</strong> <code>&quot;aaacecaaa&quot;</code></p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> <code>&quot;abcd&quot;</code><br><strong>输出:</strong> <code>&quot;dcbabcd&quot;</code></p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">shortestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string r = s;</span><br><span class="line">        <span class="built_in">reverse</span>(r.<span class="built_in">begin</span>(), r.<span class="built_in">end</span>());</span><br><span class="line">        string t = s + <span class="string">&quot;#&quot;</span> + r;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(t.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = next[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; t[i] != t[j]) j = next[j - <span class="number">1</span>];</span><br><span class="line">            next[i] = (j += t[i] == t[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r.<span class="built_in">substr</span>(<span class="number">0</span>, s.<span class="built_in">size</span>() - next.<span class="built_in">back</span>()) + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 95.14% of C++ online submissions for Shortest Palindrome.</p>
<p>Memory Usage: 10.3 MB, less than 18.08% of C++ online submissions for Shortest Palindrome.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :4 ms, 在所有 C++ 提交中击败了96.43%的用户</p>
<p>内存消耗 :10.1 MB, 在所有 C++ 提交中击败了54.17%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (216) Combination Sum III</title>
    <url>/e1ffbd0e1cc9/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>找出所有相加之和为 <strong>n</strong> 的 <strong>k</strong> 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p><strong>说明:</strong></p>
<ul>
<li>所有数字都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> <strong>k</strong> &#x3D; 3, <strong>n</strong> &#x3D; 7<br><strong>输出:</strong> [[1,2,4]]</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> <strong>k</strong> &#x3D; 3, <strong>n</strong> &#x3D; 9<br><strong>输出:</strong> [[1,2,6], [1,3,5], [2,3,4]]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; out;</span><br><span class="line">        <span class="built_in">combinationSum3DFS</span>(k, n, <span class="number">1</span>, out, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">combinationSum3DFS</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> level, vector&lt;<span class="type">int</span>&gt; &amp;out, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; out.<span class="built_in">size</span>() == k) res.<span class="built_in">push_back</span>(out);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = level; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            out.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">combinationSum3DFS</span>(k, n - i, i + <span class="number">1</span>, out, res);</span><br><span class="line">            out.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 77.84% of C++ online submissions for Combination Sum III.</p>
<p>Memory Usage: 8.6 MB, less than 67.42% of C++ online submissions for Combination Sum III.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有 C++ 提交中击败了70.16%的用户</p>
<p>内存消耗 :8.5 MB, 在所有 C++ 提交中击败了66.94%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (215) Kth Largest Element in an Array</title>
    <url>/c21dbb763718/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [3,2,1,5,6,4] 和 k &#x3D; 2<br><strong>输出:</strong> 5</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4<br><strong>输出:</strong> 4</p>
<p><strong>说明:</strong></p>
<p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 86.26% of C++ online submissions for Kth Largest Element in an Array.</p>
<p>Memory Usage: 9.3 MB, less than 58.63% of C++ online submissions for Kth Largest Element in an Array.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :16 ms, 在所有 C++ 提交中击败了87.25%的用户</p>
<p>内存消耗 :9.2 MB, 在所有 C++ 提交中击败了74.05%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (218) The Skyline Problem</title>
    <url>/a9839422de6d/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。现在，假设您获得了城市风光照片（图A）<code>上显示的所有建筑物的位置和高度</code>，请编写一个程序以输出由这些建筑物 <code>形成的天际线</code>（图B）</p>
<p><a href="https://leetcode.com/static/images/problemset/skyline1.jpg"><img src="https://assets.leetcode.com/uploads/2018/10/22/skyline1.png" alt="Buildings"> </a><br><a href="https://leetcode.com/static/images/problemset/skyline2.jpg"><img src="https://assets.leetcode.com/uploads/2018/10/22/skyline2.png" alt="Skyline Contour"></a></p>
<p>每个建筑物的几何信息用三元组 <code>[Li，Ri，Hi]</code> 表示，其中 <code>Li</code> 和 <code>Ri</code> 分别是第 i 座建筑物左右边缘的 x 坐标，<code>Hi</code> 是其高度。可以保证 <code>0 ≤ Li, Ri ≤ INT_MAX</code>, <code>0 &lt; Hi ≤ INT_MAX</code> 和 <code>Ri - Li &gt; 0</code>。您可以假设所有建筑物都是在绝对平坦且高度为 0 的表面上的完美矩形。</p>
<p>例如，图A中所有建筑物的尺寸记录为：<code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ]</code> 。</p>
<p>输出是以 <code>[ [x1,y1], [x2, y2], [x3, y3], ... ]</code> 格式的“<strong>关键点</strong>”（图B中的红点）的列表，它们唯一地定义了天际线。<strong>关键点是水平线段的左端点</strong>。请注意，最右侧建筑物的最后一个关键点仅用于标记天际线的终点，并始终为零高度。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>
<p>例如，图B中的天际线应该表示为：<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code>。</p>
<p><strong>说明:</strong></p>
<ul>
<li>任何输入列表中的建筑物数量保证在 <code>[0, 10000]</code> 范围内。</li>
<li>输入列表已经按左 <code>x</code> 坐标 <code>Li</code>  进行升序排列。</li>
<li>输出列表必须按 x 位排序。</li>
<li>输出天际线中不得有连续的相同高度的水平线。例如 <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code> 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：<code>[...[2 3], [4 5], [12 7], ...]</code></li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">getSkyline</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a.first == b.first)</span><br><span class="line">                <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        &#125;;</span><br><span class="line">        multiset&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">edges</span>(cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; ele : buildings)</span><br><span class="line">        &#123;</span><br><span class="line">            edges.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(ele[<span class="number">0</span>], ele[<span class="number">2</span>]));</span><br><span class="line">            edges.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(ele[<span class="number">1</span>], -ele[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pending_delete;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> before = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">                before = pq.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(e.second &gt; <span class="number">0</span>)</span><br><span class="line">                pq.<span class="built_in">push</span>(e.second);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pending_delete[-e.second]++;</span><br><span class="line">                <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>() &amp;&amp; pending_delete[pq.<span class="built_in">top</span>()])</span><br><span class="line">                &#123;</span><br><span class="line">                    pending_delete[pq.<span class="built_in">top</span>()]--;</span><br><span class="line">                    pq.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> after = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">                after = pq.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(before != after)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;e.first, after&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 40 ms, faster than 52.02% of C++ online submissions for The Skyline Problem.</p>
<p>Memory Usage: 16.5 MB, less than 21.00% of C++ online submissions for The Skyline Problem.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :56 ms, 在所有 C++ 提交中击败了67.37%的用户</p>
<p>内存消耗 :16.4 MB, 在所有 C++ 提交中击败了7.45%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (217) Contains Duplicate</title>
    <url>/de5b4e6e68c5/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [1,2,3,1]<br><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [1,2,3,4]<br><strong>输出:</strong> false</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> [1,1,1,3,3,4,3,2,4,2]<br><strong>输出:</strong> true</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 40 ms, faster than 70.93% of C++ online submissions for Contains Duplicate.</p>
<p>Memory Usage: 11.3 MB, less than 89.77% of C++ online submissions for Contains Duplicate.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :44 ms, 在所有 C++ 提交中击败了78.54%的用户</p>
<p>内存消耗 :11.3 MB, 在所有 C++ 提交中击败了68.77%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (22) Generate Parentheses</title>
    <url>/6c3fde0dffb7/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p>
<p>例如，给出 n &#x3D;3，生成结果为：</p>
<p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="built_in">generateParenthesisDFS</span>(n, n, <span class="string">&quot;&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">generateParenthesisDFS</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, string out, vector&lt;string&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) res.<span class="built_in">push_back</span>(out);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; <span class="number">0</span>) <span class="built_in">generateParenthesisDFS</span>(left - <span class="number">1</span>, right, out + <span class="string">&#x27;(&#x27;</span>, res);</span><br><span class="line">            <span class="keyword">if</span> (right &gt; <span class="number">0</span>) <span class="built_in">generateParenthesisDFS</span>(left, right - <span class="number">1</span>, out + <span class="string">&#x27;)&#x27;</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 98.43% of C++ online submissions for Generate Parentheses.</p>
<p>Memory Usage: 17.1 MB, less than 66.40% of C++ online submissions for Generate Parentheses.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 20 ms, 在Generate Parentheses的C++提交中击败了8.10% 的用户</p>
<p>内存消耗 : 17.2 MB, 在Generate Parentheses的C++提交中击败了1.00% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (219) Contains Duplicate II</title>
    <url>/30c84b918ba2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组和一个整数 <code>k</code>，判断数组中是否存在两个不同的索引 <code>i</code> 和 <code>j</code>，使得 **nums [i] &#x3D; nums [j]**，并且 <code>i</code> 和 <code>j</code> 的差的绝对值最大为 <code>k</code>。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> nums &#x3D; [1,2,3,1], k&#x3D; 3<br><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> nums &#x3D; [1,0,1,1], k&#x3D;1<br><strong>输出:</strong> true</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> nums &#x3D; [1,2,3,1,2,3], k&#x3D;2<br><strong>输出:</strong> false</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(nums[i]) != m.<span class="built_in">end</span>() &amp;&amp; i - m[nums[i]] &lt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 28 ms, faster than 91.06% of C++ online submissions for Contains Duplicate II.</p>
<p>Memory Usage: 15.4 MB, less than 44.11% of C++ online submissions for Contains Duplicate II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :32 ms, 在所有 C++ 提交中击败了93.66%的用户</p>
<p>内存消耗 :15.5 MB, 在所有 C++ 提交中击败了5.03%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (220) Contains Duplicate III</title>
    <url>/67a000eb8e6e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组，判断数组中是否有两个不同的索引 <code>i</code> 和 <code>j</code>，使得 <strong>nums [i]</strong> 和 <strong>nums [j]</strong> 的差的绝对值最大为 <code>t</code>，并且 <code>i</code> 和 <code>j</code> 之间的差的绝对值最大为 <code>ķ</code>。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> nums &#x3D; [1,2,3,1], k&#x3D; 3, t &#x3D; 0<br><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> nums &#x3D; [1,0,1,1], k&#x3D;1, t &#x3D; 2<br><strong>输出:</strong> true</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> nums &#x3D; [1,5,9,1,5,9], k &#x3D; 2, t &#x3D; 3<br><strong>输出:</strong> false</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - j &gt; k) m.<span class="built_in">erase</span>(nums[j++]);</span><br><span class="line">            <span class="keyword">auto</span> a = m.<span class="built_in">lower_bound</span>((<span class="type">long</span> <span class="type">long</span>)nums[i] - t);</span><br><span class="line">            <span class="keyword">if</span> (a != m.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">abs</span>(a-&gt;first - nums[i]) &lt;= t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 89.61% of C++ online submissions for Contains Duplicate III.</p>
<p>Memory Usage: 10.7 MB, less than 84.30% of C++ online submissions for Contains Duplicate III.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :28 ms, 在所有 C++ 提交中击败了63.67%的用户</p>
<p>内存消耗 :10.9 MB, 在所有 C++ 提交中击败了19.72%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (221) Maximal Square</title>
    <url>/47f08ef8fd22/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong><br>1 0 1 0 0<br>1 0 <strong>1 1</strong> 1<br>1 1 <strong>1 1</strong> 1<br>1 0 0 1 0</p>
<p><strong>输出:</strong> 4</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), res = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">                <span class="type">int</span> t = dp[i];</span><br><span class="line">                <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], <span class="built_in">min</span>(dp[i - <span class="number">1</span>], pre)) + <span class="number">1</span>;</span><br><span class="line">                    res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 97.14% of C++ online submissions for Maximal Square.</p>
<p>Memory Usage: 10.3 MB, less than 98.91% of C++ online submissions for Maximal Square.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :24 ms, 在所有 C++ 提交中击败了82.42%的用户</p>
<p>内存消耗 :10.4 MB, 在所有 C++ 提交中击败了99.72%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (222) Count Complete Tree Nodes</title>
    <url>/cd791c80c123/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个 <strong>完全二叉树</strong>，求出该树的节点个数。</p>
<p><strong>说明:</strong></p>
<p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含</p>
<p>$$<br>1 - 2^h<br>$$<br>个节点。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \  /</span><br><span class="line">4  5 6</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> 6</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hLeft = <span class="number">0</span>, hRight = <span class="number">0</span>;</span><br><span class="line">        TreeNode *pLeft = root, *pRight = root;</span><br><span class="line">        <span class="keyword">while</span> (pLeft) &#123;</span><br><span class="line">            ++hLeft;</span><br><span class="line">            pLeft = pLeft-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pRight) &#123;</span><br><span class="line">            ++hRight;</span><br><span class="line">            pRight = pRight-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hLeft == hRight) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, hLeft) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 24 ms, faster than 98.78% of C++ online submissions for Count Complete Tree Nodes.</p>
<p>Memory Usage: 28.6 MB, less than 84.12% of C++ online submissions for Count Complete Tree Nodes.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :76 ms, 在所有 C++ 提交中击败了28.94%的用户</p>
<p>内存消耗 :28.6 MB, 在所有 C++ 提交中击败了85.66%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (223) Rectangle Area</title>
    <url>/aca345e8e20c/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在<strong>二维</strong>平面上计算出两个<strong>由直线构成的</strong>矩形重叠后形成的总面积。</p>
<p>每个矩形由其左下顶点和右上顶点坐标表示，如图所示。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/rectangle_area.png" alt="Rectangle Area"></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> -3, 0, 3, 4, 0, -1, 9, 2<br><strong>输出:</strong> 45</p>
<p><strong>说明:</strong> 假设矩形面积不会超出 <strong>int</strong> 的范围。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">computeArea</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B, <span class="type">int</span> C, <span class="type">int</span> D, <span class="type">int</span> E, <span class="type">int</span> F, <span class="type">int</span> G, <span class="type">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">max</span>(A,E), right = <span class="built_in">max</span>(<span class="built_in">min</span>(C,G), left);</span><br><span class="line">        <span class="type">int</span> bottom = <span class="built_in">max</span>(B,F), top = <span class="built_in">max</span>(<span class="built_in">min</span>(D,H), bottom);</span><br><span class="line">        <span class="keyword">return</span> (C - A) * (D - B) - (right - left) * (top - bottom) + (G - E) * (H - F);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 94.48% of C++ online submissions for Rectangle Area.</p>
<p>Memory Usage: 8.1 MB, less than 77.24% of C++ online submissions for Rectangle Area.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :20 ms, 在所有 C++ 提交中击败了73.52%的用户</p>
<p>内存消耗 :8.2 MB, 在所有 C++ 提交中击败了21.01%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (224) Basic Calculator</title>
    <url>/716d6f7ab252/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现一个基本的计算器来计算一个简单的字符串表达式的值。</p>
<p>字符串表达式可以包含左括号 <code>(</code> ，右括号 <code>)</code>，加号 <code>+</code> ，减号 <code>-</code>，<strong>非负</strong>整数和空格 。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> “1 + 1”<br><strong>输出:</strong> 2</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> “ 2-1 + 2 “<br><strong>输出:</strong> 3</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> “(1+(4+5+2)-3)+(6+8)”<br><strong>输出:</strong> 23</p>
<p><strong>说明：</strong></p>
<ul>
<li>你可以假设所给定的表达式都是有效的。</li>
<li>请<strong>不要</strong>使用内置的库函数 <code>eval</code>。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, num = <span class="number">0</span>, sign = <span class="number">1</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                num = <span class="number">10</span> * num + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                res += sign * num;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                sign = (c == <span class="string">&#x27;+&#x27;</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(res);</span><br><span class="line">                st.<span class="built_in">push</span>(sign);</span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                res += sign * num;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                res *= st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">                res += st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += sign * num;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 99.92% of C++ online submissions for Basic Calculator.</p>
<p>Memory Usage: 10.4 MB, less than 54.96% of C++ online submissions for Basic Calculator.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :16 ms, 在所有 C++ 提交中击败了93.29%的用户</p>
<p>内存消耗 :10.4 MB, 在所有 C++ 提交中击败了72.93%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (225) Implement Stack using Queues</title>
    <url>/52764907f002/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) – 元素 x 入栈</li>
<li>pop() – 移除栈顶元素</li>
<li>top() – 获取栈顶元素</li>
<li>empty() – 返回栈是否为空</li>
</ul>
<p><strong>注意:</strong></p>
<ul>
<li>你只能使用队列的基本操作– 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
<li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q2.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (q2.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            q1.<span class="built_in">push</span>(q2.<span class="built_in">front</span>()); q2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">top</span>(); q2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)q1.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                q1.<span class="built_in">push</span>(q1.<span class="built_in">front</span>()); q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>()); q1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q2.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">empty</span>() &amp;&amp; q2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q1, q2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Implement Stack using Queues.</p>
<p>Memory Usage: 8.7 MB, less than 78.51% of C++ online submissions for Implement Stack using Queues.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :4 ms, 在所有 C++ 提交中击败了87.76%的用户</p>
<p>内存消耗 :8.6 MB, 在所有 C++ 提交中击败了93.44%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (226) Invert Binary Tree</title>
    <url>/b580b75e837b/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>翻转一棵二叉树。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<p><strong>备注:</strong></p>
<p>这个问题是受到 <a href="https://twitter.com/mxcl">Max Howell </a>的 <a href="https://twitter.com/mxcl/status/608682016205344768">原问题</a> 启发的:</p>
<blockquote>
<p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>
</blockquote>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode *tmp = node-&gt;left;</span><br><span class="line">            node-&gt;left = node-&gt;right;</span><br><span class="line">            node-&gt;right = tmp;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 73.28% of C++ online submissions for Invert Binary Tree.</p>
<p>Memory Usage: 9 MB, less than 93.76% of C++ online submissions for Invert Binary Tree.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗 :9.1 MB, 在所有 C++ 提交中击败了57.73%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (227) Basic Calculator II</title>
    <url>/92bfde3881bf/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现一个基本的计算器来计算一个简单的字符串表达式的值。</p>
<p>字符串表达式仅包含非负整数，<code>+</code>， <code>-</code> ，<code>*</code>，<code>/</code> 四种运算符和空格 。 整数除法仅保留整数部分。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> “3+2*2”<br><strong>输出:</strong> 7</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> “ 3&#x2F;2 “<br><strong>输出:</strong> 1</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> “ 3+5 &#x2F; 2 “<br><strong>输出:</strong> 5</p>
<p><strong>说明：</strong></p>
<ul>
<li>你可以假设所给定的表达式都是有效的。</li>
<li>请<strong>不要</strong>使用内置的库函数 <code>eval</code>。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> res = <span class="number">0</span>, curRes = <span class="number">0</span>, num = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">char</span> op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: curRes += num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: curRes -= num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: curRes *= num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: curRes /= num; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    res += curRes;</span><br><span class="line">                    curRes = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                op = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 92.48% of C++ online submissions for Basic Calculator II.</p>
<p>Memory Usage: 9.9 MB, less than 94.77% of C++ online submissions for Basic Calculator II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :16 ms, 在所有 C++ 提交中击败了89.47%的用户</p>
<p>内存消耗 :9.9 MB, 在所有 C++ 提交中击败了88.18%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (228) Summary Ranges</title>
    <url>/c1eacf8c0939/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [0,1,2,4,5,7]<br><strong>输出:</strong> [“0-&gt;2”,”4-&gt;5”,”7”]<br><strong>解释:</strong> 0,1,2 可组成一个连续的区间; 4,5 可组成一个连续的区间。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [0,2,3,4,6,8,9]<br><strong>输出:</strong> [“0”,”2-&gt;4”,”6”,”8-&gt;9”]<br><strong>解释:</strong> 2,3,4 可组成一个连续的区间; 8,9 可组成一个连续的区间。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + j &lt; n &amp;&amp; (<span class="type">long</span>)nums[i + j] - nums[i] == j) ++j;</span><br><span class="line">            res.<span class="built_in">push_back</span>(j &lt;= <span class="number">1</span> ? <span class="built_in">to_string</span>(nums[i]) : <span class="built_in">to_string</span>(nums[i]) + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(nums[i + j - <span class="number">1</span>]));</span><br><span class="line">            i += j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 69.06% of C++ online submissions for Summary Ranges.</p>
<p>Memory Usage: 8.5 MB, less than 24.42% of C++ online submissions for Summary Ranges.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有 C++ 提交中击败了48.63%的用户</p>
<p>内存消耗 :8.4 MB, 在所有 C++ 提交中击败了87.07%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (23) Merge k Sorted Lists</title>
    <url>/4d2c946f4efc/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong><br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br><strong>输出:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> n = lists.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> k = (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                lists[i] = <span class="built_in">mergeTwoLists</span>(lists[i], lists[i + k]);</span><br><span class="line">            &#125;</span><br><span class="line">            n = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span> (l2) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 24 ms, faster than 99.83% of C++ online submissions for Merge k Sorted Lists.</p>
<p>Memory Usage: 11.2 MB, less than 98.90% of C++ online submissions for Merge k Sorted Lists.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 72 ms, 在Merge k Sorted Lists的C++提交中击败了36.15% 的用户</p>
<p>内存消耗 : 11.6 MB, 在Merge k Sorted Lists的C++提交中击败了0.81% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (229) Majority Element II</title>
    <url>/edbe92a146c9/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个大小为 n 的数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。</p>
<p><strong>说明:</strong> 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [3,2,3]<br><strong>输出:</strong> [3]</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [1,1,1,3,3,2,2,2]<br><strong>输出:</strong> [1,2]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == a) ++cnt1;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num == b) ++cnt2;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt1 == <span class="number">0</span>) &#123; a = num; cnt1 = <span class="number">1</span>; &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt2 == <span class="number">0</span>) &#123; b = num; cnt2 = <span class="number">1</span>; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; --cnt1; --cnt2; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == a) ++cnt1;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num == b) ++cnt2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt1 &gt; n / <span class="number">3</span>) res.<span class="built_in">push_back</span>(a);</span><br><span class="line">        <span class="keyword">if</span> (cnt2 &gt; n / <span class="number">3</span>) res.<span class="built_in">push_back</span>(b);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 68.22% of C++ online submissions for Majority Element II.</p>
<p>Memory Usage: 10.5 MB, less than 81.80% of C++ online submissions for Majority Element II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :24 ms, 在所有 C++ 提交中击败了47.05%的用户</p>
<p>内存消耗 :10.4 MB, 在所有 C++ 提交中击败了93.85%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (230) Kth Smallest Element in a BST</title>
    <url>/a205a34ac1b9/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉搜索树，编写一个函数 <code>kthSmallest</code> 来查找其中第 **k **个最小的元素。</p>
<p><strong>说明:</strong></p>
<p>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> root &#x3D; [3,1,4,null,2], k &#x3D; 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line"> \</span><br><span class="line">  2</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> 1</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">   / \</span><br><span class="line">  2   4</span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> 3</p>
<p><strong>进阶:</strong></p>
<p>如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 <code>kthSmallest</code> 函数？</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kthSmallestDFS</span>(root, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallestDFS</span><span class="params">(TreeNode* root, <span class="type">int</span> &amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> val = <span class="built_in">kthSmallestDFS</span>(root-&gt;left, k);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kthSmallestDFS</span>(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 97.56% of C++ online submissions for Kth Smallest Element in a BST.</p>
<p>Memory Usage: 21.3 MB, less than 99.52% of C++ online submissions for Kth Smallest Element in a BST.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :32 ms, 在所有 C++ 提交中击败了73.72%的用户</p>
<p>内存消耗 :21.4 MB, 在所有 C++ 提交中击败了86.92%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (232) Implement Queue using Stacks</title>
    <url>/3ce258ed6834/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) – 将一个元素放入队列的尾部。</li>
<li>pop() – 从队列首部移除元素。</li>
<li>peek() – 返回队列首部的元素。</li>
<li>empty() – 返回队列是否为空。</li>
</ul>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  // 返回 1</span><br><span class="line">queue.pop();   // 返回 1</span><br><span class="line">queue.empty(); // 返回 false</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>你只能使用标准的栈操作 – 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        _new.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">shiftStack</span>();</span><br><span class="line">        <span class="type">int</span> val = _old.<span class="built_in">top</span>(); _old.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">shiftStack</span>();</span><br><span class="line">        <span class="keyword">return</span> _old.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _old.<span class="built_in">empty</span>() &amp;&amp; _new.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!_old.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (!_new.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _old.<span class="built_in">push</span>(_new.<span class="built_in">top</span>());</span><br><span class="line">            _new.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; _old, _new;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Implement Queue using Stacks.</p>
<p>Memory Usage: 8.9 MB, less than 18.21% of C++ online submissions for Implement Queue using Stacks.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :4 ms, 在所有 C++ 提交中击败了88.74%的用户</p>
<p>内存消耗 :8.7 MB, 在所有 C++ 提交中击败了87.76%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (231) Power of Two</title>
    <url>/de543bd1fd05/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 1<br><strong>输出:</strong> true<br><strong>解释:</strong> 20 &#x3D; 1</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 16<br><strong>输出:</strong> true<br><strong>解释:</strong> 24 &#x3D; 16</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> 218<br><strong>输出:</strong> false</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> (n &gt; <span class="number">0</span>) &amp;&amp; (!(n &amp; (n - <span class="number">1</span>)));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 71.47% of C++ online submissions for Power of Two.</p>
<p>Memory Usage: 8 MB, less than 73.86% of C++ online submissions for Power of Two.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗 :7.9 MB, 在所有 C++ 提交中击败了84.19%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (233) Number of Digit One</title>
    <url>/927a6ed16881/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> 13<br><strong>输出:</strong> 6<br><strong>解释:</strong> 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> k = <span class="number">1</span>; k &lt;= n; k *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">long</span> r = n / k, m = n % k;</span><br><span class="line">            res += (r + <span class="number">8</span>) / <span class="number">10</span> * k + (r % <span class="number">10</span> == <span class="number">1</span> ? m + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 68.37% of C++ online submissions for Number of Digit One.</p>
<p>Memory Usage: 8.1 MB, less than 82.72% of C++ online submissions for Number of Digit One.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :4 ms, 在所有 C++ 提交中击败了81.21%的用户</p>
<p>内存消耗 :8.3 MB, 在所有 C++ 提交中击败了18.63%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (234) Palindrome Linked List</title>
    <url>/8297c68c0040/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请判断一个链表是否为回文链表。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 1-&gt;2<br><strong>输出:</strong> false</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 1-&gt;2-&gt;2-&gt;1<br><strong>输出:</strong> true</p>
<p><strong>进阶:</strong></p>
<p>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *last = slow-&gt;next, *pre = head;</span><br><span class="line">        <span class="keyword">while</span> (last-&gt;next) &#123;</span><br><span class="line">            ListNode *tmp = last-&gt;next;</span><br><span class="line">            last-&gt;next = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = slow-&gt;next;</span><br><span class="line">            slow-&gt;next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (slow-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (pre-&gt;val != slow-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 94.20% of C++ online submissions for Palindrome Linked List.</p>
<p>Memory Usage: 12.8 MB, less than 54.17% of C++ online submissions for Palindrome Linked List.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :28 ms, 在所有 C++ 提交中击败了86.12%的用户</p>
<p>内存消耗 :12.9 MB, 在所有 C++ 提交中击败了38.54%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (236) Lowest Common Ancestor of a Binary Tree</title>
    <url>/94985ed410f3/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">维基百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png"></p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br><strong>输出:</strong> 3<br><strong>解释:</strong> 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br><strong>输出:</strong> 5<br><strong>解释:</strong> 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!root || p == root || q == root) <span class="keyword">return</span> root;</span><br><span class="line">       TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">       TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p , q);</span><br><span class="line">       <span class="keyword">if</span> (left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">       <span class="keyword">return</span> left ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 24 ms, faster than 58.65% of C++ online submissions for Lowest Common Ancestor of a Binary Tree.</p>
<p>Memory Usage: 16.6 MB, less than 78.95% of C++ online submissions for Lowest Common Ancestor of a Binary Tree.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :36 ms, 在所有 C++ 提交中击败了43.99%的用户</p>
<p>内存消耗 :16.5 MB, 在所有 C++ 提交中击败了86.75%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (235) Lowest Common Ancestor of a Binary Search Tree</title>
    <url>/894203ef8385/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">维基百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png"></p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8<br><strong>输出:</strong> 6<br><strong>解释:</strong> 节点 2 和节点 8 的最近公共祖先是 6。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4<br><strong>输出:</strong> 2<br><strong>解释:</strong> 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; <span class="built_in">max</span>(p-&gt;val, q-&gt;val)) root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; <span class="built_in">min</span>(p-&gt;val, q-&gt;val)) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 40 ms, faster than 68.25% of C++ online submissions for Lowest Common Ancestor of a Binary Search Tree.</p>
<p>Memory Usage: 25.5 MB, less than 99.80% of C++ online submissions for Lowest Common Ancestor of a Binary Search Tree.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :92 ms, 在所有 C++ 提交中击败了11.72%的用户</p>
<p>内存消耗 :25.7 MB, 在所有 C++ 提交中击败了52.76%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (237) Delete Node in a Linked List</title>
    <url>/8b1dd79e8994/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<p>现有一个链表 – head &#x3D; [4,5,1,9]，它可以表示为:</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/28/237_example.png"></p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> head &#x3D; [4,5,1,9], node &#x3D; 5<br><strong>输出:</strong> [4,1,9]<br><strong>解释:</strong> 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> head &#x3D; [4,5,1,9], node &#x3D; 1<br><strong>输出:</strong> [4,5,9]<br><strong>解释:</strong> 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<p><strong>说明:</strong></p>
<ul>
<li>链表至少包含两个节点。</li>
<li>链表中所有节点的值都是唯一的。</li>
<li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li>
<li>不要从你的函数中返回任何结果。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        ListNode *tmp = node-&gt;next;</span><br><span class="line">        node-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 87.12% of C++ online submissions for Delete Node in a Linked List.</p>
<p>Memory Usage: 9.4 MB, less than 5.96% of C++ online submissions for Delete Node in a Linked List.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :28 ms, 在所有 C++ 提交中击败了30.57%的用户</p>
<p>内存消耗 :9.2 MB, 在所有 C++ 提交中击败了37.88%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (238) Product of Array Except Self</title>
    <url>/7d9b2374decb/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定长度为 n 的整数数组 <code>nums</code>，其中 n &gt; 1，返回输出数组 <code>output</code> ，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> [1,2,3,4]<br><strong>输出:</strong> [24,12,8,6]</p>
<p><strong>说明:</strong> 请 <strong>不要使用除法</strong>，且在 O(n) 时间复杂度内完成此题。</p>
<p><strong>进阶:</strong></p>
<p>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 <strong>不被视为</strong> 额外空间。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            res[i] *= right;</span><br><span class="line">            right *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 40 ms, faster than 86.64% of C++ online submissions for Product of Array Except Self.</p>
<p>Memory Usage: 12.5 MB, less than 62.11% of C++ online submissions for Product of Array Except Self.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :56 ms, 在所有 C++ 提交中击败了92.75%的用户</p>
<p>内存消耗 :12.5 MB, 在所有 C++ 提交中击败了66.48%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (239) Sliding Window Maximum</title>
    <url>/a5c338eda1a6/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口最大值。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3<br><strong>输出:</strong> [3,3,5,5,6,7]<br><strong>解释:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<p>你可以假设 k 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。</p>
<p><strong>进阶:</strong></p>
<p>你能在线性时间复杂度内解决此题吗？</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">front</span>() == i - k) q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; nums[q.<span class="built_in">back</span>()] &lt; nums[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) res.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 56 ms, faster than 88.57% of C++ online submissions for Sliding Window Maximum.</p>
<p>Memory Usage: 13 MB, less than 73.58% of C++ online submissions for Sliding Window Maximum.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :76 ms, 在所有 C++ 提交中击败了94.25%的用户</p>
<p>内存消耗 :13.1 MB, 在所有 C++ 提交中击败了58.15%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (24) Swap Nodes in Pairs</title>
    <url>/b2614d81ccfe/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p>给定 <code>1-&gt;2-&gt;3-&gt;4</code>, 你应该返回 <code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *t = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="built_in">swapPairs</span>(head-&gt;next-&gt;next);</span><br><span class="line">        t-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Swap Nodes in Pairs.</p>
<p>Memory Usage: 8.6 MB, less than 100.00% of C++ online submissions for Swap Nodes in Pairs.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Swap Nodes in Pairs的C++提交中击败了11.76% 的用户</p>
<p>内存消耗 : 8.8 MB, 在Swap Nodes in Pairs的C++提交中击败了0.68% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (241) Different Ways to Add Parentheses</title>
    <url>/61f487954715/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 <code>+</code>, <code>-</code> 以及 <code>*</code> 。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> <code>&quot;2-1-1&quot;</code><br><strong>输出:</strong> <code>[0, 2]</code><br><strong>解释:</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((2-1)-1) = 0 </span><br><span class="line">(2-(1-1)) = 2</span><br></pre></td></tr></table></figure>

<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> <code>&quot;2*3-4*5&quot;</code><br><strong>输出:</strong> <code>[-34, -14, -10, -10, 10]</code><br><strong>解释:</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(2*(3-(4*5))) = -34 </span><br><span class="line">((2*3)-(4*5)) = -14 </span><br><span class="line">((2*(3-4))*5) = -10 </span><br><span class="line">(2*((3-4)*5)) = -10 </span><br><span class="line">(((2*3)-4)*5) = 10</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;string&gt; ops;</span><br><span class="line">        <span class="type">int</span> n = input.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; <span class="built_in">isdigit</span>(input[j])) ++j;</span><br><span class="line">            ops.<span class="built_in">push_back</span>(input.<span class="built_in">substr</span>(i, j - i));</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n) ops.<span class="built_in">push_back</span>(input.<span class="built_in">substr</span>(j, <span class="number">1</span>));</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = (ops.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(cnt, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(cnt, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;()));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) dp[i][i].<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(ops[i * <span class="number">2</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">0</span>; len &lt; cnt; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt - len; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; i + len; ++j) &#123;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt; left = dp[i][j], right = dp[j + <span class="number">1</span>][i + len];</span><br><span class="line">                    string op = ops[j * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> num1 : left) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> num2 : right) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (op == <span class="string">&quot;+&quot;</span>) dp[i][i + len].<span class="built_in">push_back</span>(num1 + num2);</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;-&quot;</span>) dp[i][i + len].<span class="built_in">push_back</span>(num1 - num2);</span><br><span class="line">                            <span class="keyword">else</span> dp[i][i + len].<span class="built_in">push_back</span>(num1 * num2);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][cnt - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Different Ways to Add Parentheses.</p>
<p>Memory Usage: 8.8 MB, less than 97.46% of C++ online submissions for Different Ways to Add Parentheses.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :4 ms, 在所有 C++ 提交中击败了96.52%的用户</p>
<p>内存消耗 :8.6 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (240) Search a 2D Matrix II</title>
    <url>/e24be00c29fa/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>现有矩阵 matrix 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>给定 target &#x3D; 5，返回 true。</p>
<p>给定 target &#x3D; 20，返回 false。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix.<span class="built_in">back</span>().<span class="built_in">back</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> x = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] &gt; target) --x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[x][y] &lt; target) ++y;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &gt;= matrix[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 100 ms, faster than 30.93% of C++ online submissions for Search a 2D Matrix II.</p>
<p>Memory Usage: 12.8 MB, less than 70.25% of C++ online submissions for Search a 2D Matrix II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :128 ms, 在所有 C++ 提交中击败了41.29%的用户</p>
<p>内存消耗 :12.9 MB, 在所有 C++ 提交中击败了23.79%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (242) Valid Anagram</title>
    <url>/d8236686b034/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> s &#x3D; “anagram”, t &#x3D; “nagaram”<br><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> s &#x3D; “rat”, t &#x3D; “car”<br><strong>输出:</strong> false</p>
<p><strong>说明:</strong></p>
<p>你可以假设字符串只包含小写字母。</p>
<p><strong>进阶:</strong></p>
<p>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> m[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) ++m[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--m[t[i] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 98.27% of C++ online submissions for Valid Anagram.</p>
<p>Memory Usage: 9.6 MB, less than 31.91% of C++ online submissions for Valid Anagram.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :20 ms, 在所有 C++ 提交中击败了60.34%的用户</p>
<p>内存消耗 :9.4 MB, 在所有 C++ 提交中击败了14.08%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (244) Shortest Word Distance II</title>
    <url>/26fb0fc7b37c/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (243) Shortest Word Distance</title>
    <url>/4a9cc46b2191/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (245) Shortest Word Distance III</title>
    <url>/cafee3bacdef/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (246) Strobogrammatic Number</title>
    <url>/9971ddb840dc/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (247) Strobogrammatic Number II</title>
    <url>/481fbfe4263b/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (248) Strobogrammatic Number III</title>
    <url>/eb359d6e27ba/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (249) Group Shifted Strings</title>
    <url>/2fc29e12600a/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (25) Reverse Nodes in k-Group</title>
    <url>/1a1b6f80236b/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。</p>
<p> k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p>给定这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>当 k &#x3D; 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>当 k &#x3D; 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>说明 :</strong></p>
<ul>
<li>你的算法只能使用常数的额外空间。</li>
<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur) <span class="keyword">return</span> head;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *new_head = <span class="built_in">reverse</span>(head, cur);</span><br><span class="line">        head-&gt;next = <span class="built_in">reverseKGroup</span>(cur, k);</span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head, ListNode* tail)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = tail;</span><br><span class="line">        <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">            ListNode *t = head-&gt;next;</span><br><span class="line">            head-&gt;next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 100.00% of C++ online submissions for Reverse Nodes in k-Group.</p>
<p>Memory Usage: 9.6 MB, less than 100.00% of C++ online submissions for Reverse Nodes in k-Group.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 36 ms, 在Reverse Nodes in k-Group的C++提交中击败了6.67% 的用户</p>
<p>内存消耗 : 10.2 MB, 在Reverse Nodes in k-Group的C++提交中击败了0.61% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (250) Count Univalue Subtrees</title>
    <url>/0e5c3c40df89/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (252) Meeting Rooms</title>
    <url>/806a5667a9f3/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (251) Flatten 2D Vector</title>
    <url>/45cf39e808ec/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (253) Meeting Rooms II</title>
    <url>/17556eba8b06/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (254) Factor Combinations</title>
    <url>/ef6bfa8993e4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (255) Verify Preorder Sequence in Binary Search Tree</title>
    <url>/442377fa3041/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (258) Add Digits</title>
    <url>/7834e91aff12/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> <code>38</code><br><strong>输出:</strong> 2<br><strong>解释:</strong> 各位相加的过程为<strong>：</strong><code>3 + 8 = 11</code>, <code>1 + 1 = 2</code>。 由于 <code>2</code> 是一位数，所以返回 2。</p>
<p><strong>进阶:</strong></p>
<p>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="type">int</span> <span class="title">addDigits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; <span class="keyword">return</span> (num == <span class="number">0</span>) ? <span class="number">0</span> : (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 75.76% of C++ online submissions for Add Digits.</p>
<p>Memory Usage: 8.1 MB, less than 62.20% of C++ online submissions for Add Digits.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗 :8.1 MB, 在所有 C++ 提交中击败了56.17%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (256) Paint House</title>
    <url>/06fcbf7f26bc/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (259) 3Sum Smaller</title>
    <url>/788634cfb9ba/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (257) Binary Tree Paths</title>
    <url>/e7d6fa0e288c/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> [“1-&gt;2-&gt;5”, “1-&gt;3”]</p>
<p><strong>解释:</strong> 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root) <span class="built_in">helper</span>(root, <span class="string">&quot;&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(TreeNode* node, string out, vector&lt;string&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) res.<span class="built_in">push_back</span>(out + <span class="built_in">to_string</span>(node-&gt;val));</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) <span class="built_in">helper</span>(node-&gt;left, out + <span class="built_in">to_string</span>(node-&gt;val) + <span class="string">&quot;-&gt;&quot;</span>, res);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) <span class="built_in">helper</span>(node-&gt;right, out + <span class="built_in">to_string</span>(node-&gt;val) + <span class="string">&quot;-&gt;&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Paths.</p>
<p>Memory Usage: 11.3 MB, less than 80.00% of C++ online submissions for Binary Tree Paths.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有 C++ 提交中击败了77.93%的用户</p>
<p>内存消耗 :11.3 MB, 在所有 C++ 提交中击败了92.75%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (260) Single Number III</title>
    <url>/be8d76615893/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> <code>[1,2,1,3,2,5]</code><br><strong>输出:</strong> <code>[3,5]</code></p>
<p><strong>注意:</strong></p>
<ol>
<li>结果输出的顺序并不重要，对于上面的例子， <code>[5, 3]</code> 也是正确答案。</li>
<li>你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</li>
</ol>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> diff = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="built_in">bit_xor</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        diff &amp;= -diff;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &amp; diff) res[<span class="number">0</span>] ^= a;</span><br><span class="line">            <span class="keyword">else</span> res[<span class="number">1</span>] ^= a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 69.30% of C++ online submissions for Single Number III.</p>
<p>Memory Usage: 9.8 MB, less than 53.28% of C++ online submissions for Single Number III.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :16 ms, 在所有 C++ 提交中击败了85.85%的用户</p>
<p>内存消耗 :9.8 MB, 在所有 C++ 提交中击败了54.30%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (26) Remove Duplicates from Sorted Array</title>
    <url>/535cd81d1a1f/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个排序数组，你需要在 <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地</a></strong> 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地</a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p>给定数组 nums &#x3D; <strong>[1,1,2]</strong> , </p>
<p>函数应该返回新的长度 <strong>2</strong> , 并且原数组 <em>nums</em> 的前两个元素被修改为 <strong><code>1</code></strong> , <strong><code>2</code></strong> 。 </p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p>给定 nums &#x3D; <strong>[0,0,1,1,1,2,2,3,3,4]</strong>,</p>
<p>函数应该返回新的长度 <strong>5</strong> , 并且原数组 nums 的前五个元素被修改为 <strong><code>0</code></strong> , <strong><code>1</code></strong> , <strong><code>2</code></strong> , <strong><code>3</code></strong> , <strong><code>4</code></strong> 。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// **nums** 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">removeDuplicates</span>(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中**该长度范围内**的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[j]) nums[++j] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 24 ms, faster than 99.14% of C++ online submissions for Remove Duplicates from Sorted Array.</p>
<p>Memory Usage: 9.7 MB, less than 100.00% of C++ online submissions for Remove Duplicates from Sorted Array.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 36 ms, 在Remove Duplicates from Sorted Array的C++提交中击败了32.40% 的用户</p>
<p>内存消耗 : 10.6 MB, 在Remove Duplicates from Sorted Array的C++提交中击败了0.95% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (262) Trips and Users</title>
    <url>/f5b2abf7fca1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>SQL架构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create table If Not Exists Trips (Id int, Client_Id int, Driver_Id int, City_Id int, Status ENUM(&#x27;completed&#x27;, &#x27;cancelled_by_driver&#x27;, &#x27;cancelled_by_client&#x27;), Request_at varchar(50))</span><br><span class="line">Create table If Not Exists Users (Users_Id int, Banned varchar(50), Role ENUM(&#x27;client&#x27;, &#x27;driver&#x27;, &#x27;partner&#x27;))</span><br><span class="line">Truncate table Trips</span><br><span class="line">insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (&#x27;1&#x27;, &#x27;1&#x27;, &#x27;10&#x27;, &#x27;1&#x27;, &#x27;completed&#x27;, &#x27;2013-10-01&#x27;)</span><br><span class="line">insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (&#x27;2&#x27;, &#x27;2&#x27;, &#x27;11&#x27;, &#x27;1&#x27;, &#x27;cancelled_by_driver&#x27;, &#x27;2013-10-01&#x27;)</span><br><span class="line">insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (&#x27;3&#x27;, &#x27;3&#x27;, &#x27;12&#x27;, &#x27;6&#x27;, &#x27;completed&#x27;, &#x27;2013-10-01&#x27;)</span><br><span class="line">insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (&#x27;4&#x27;, &#x27;4&#x27;, &#x27;13&#x27;, &#x27;6&#x27;, &#x27;cancelled_by_client&#x27;, &#x27;2013-10-01&#x27;)</span><br><span class="line">insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (&#x27;5&#x27;, &#x27;1&#x27;, &#x27;10&#x27;, &#x27;1&#x27;, &#x27;completed&#x27;, &#x27;2013-10-02&#x27;)</span><br><span class="line">insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (&#x27;6&#x27;, &#x27;2&#x27;, &#x27;11&#x27;, &#x27;6&#x27;, &#x27;completed&#x27;, &#x27;2013-10-02&#x27;)</span><br><span class="line">insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (&#x27;7&#x27;, &#x27;3&#x27;, &#x27;12&#x27;, &#x27;6&#x27;, &#x27;completed&#x27;, &#x27;2013-10-02&#x27;)</span><br><span class="line">insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (&#x27;8&#x27;, &#x27;2&#x27;, &#x27;12&#x27;, &#x27;12&#x27;, &#x27;completed&#x27;, &#x27;2013-10-03&#x27;)</span><br><span class="line">insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (&#x27;9&#x27;, &#x27;3&#x27;, &#x27;10&#x27;, &#x27;12&#x27;, &#x27;completed&#x27;, &#x27;2013-10-03&#x27;)</span><br><span class="line">insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (&#x27;10&#x27;, &#x27;4&#x27;, &#x27;13&#x27;, &#x27;12&#x27;, &#x27;cancelled_by_driver&#x27;, &#x27;2013-10-03&#x27;)</span><br><span class="line">Truncate table Users</span><br><span class="line">insert into Users (Users_Id, Banned, Role) values (&#x27;1&#x27;, &#x27;No&#x27;, &#x27;client&#x27;)</span><br><span class="line">insert into Users (Users_Id, Banned, Role) values (&#x27;2&#x27;, &#x27;Yes&#x27;, &#x27;client&#x27;)</span><br><span class="line">insert into Users (Users_Id, Banned, Role) values (&#x27;3&#x27;, &#x27;No&#x27;, &#x27;client&#x27;)</span><br><span class="line">insert into Users (Users_Id, Banned, Role) values (&#x27;4&#x27;, &#x27;No&#x27;, &#x27;client&#x27;)</span><br><span class="line">insert into Users (Users_Id, Banned, Role) values (&#x27;10&#x27;, &#x27;No&#x27;, &#x27;driver&#x27;)</span><br><span class="line">insert into Users (Users_Id, Banned, Role) values (&#x27;11&#x27;, &#x27;No&#x27;, &#x27;driver&#x27;)</span><br><span class="line">insert into Users (Users_Id, Banned, Role) values (&#x27;12&#x27;, &#x27;No&#x27;, &#x27;driver&#x27;)</span><br><span class="line">insert into Users (Users_Id, Banned, Role) values (&#x27;13&#x27;, &#x27;No&#x27;, &#x27;driver&#x27;)</span><br></pre></td></tr></table></figure>

<p><code>Trips</code> 表中存所有出租车的行程信息。每段行程有唯一键 Id，Client_Id 和 Driver_Id 是 Users 表中 Users_Id 的外键。Status 是枚举类型，枚举成员为 (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’)。</p>
<p>+—-+———–+———–+———+——————–+———-+<br>| Id | Client_Id| Driver_Id | City_Id |        Status      |Request_at|<br>+—-+———–+———–+———+——————–+———-+<br>| 1  |     1     |    10     |    1    |     completed      |2013-10-01|<br>| 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01|<br>| 3  |     3     |    12     |    6    |     completed      |2013-10-01|<br>| 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01|<br>| 5  |     1     |    10     |    1    |     completed      |2013-10-02|<br>| 6  |     2     |    11     |    6    |     completed      |2013-10-02|<br>| 7  |     3     |    12     |    6    |     completed      |2013-10-02|<br>| 8  |     2     |    12     |    12   |     completed      |2013-10-03|<br>| 9  |     3     |    10     |    12   |     completed      |2013-10-03|<br>| 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03|<br>+—-+———–+———–+———+——————–+———-+</p>
<p><code>Users</code> 表存所有用户。每个用户有唯一键 Users_Id。Banned 表示这个用户是否被禁止，Role 则是一个表示（‘client’, ‘driver’, ‘partner’）的枚举类型。</p>
<p>+———-+——–+——–+<br>| Users_Id | Banned |  Role  |<br>+———-+——–+——–+<br>|    1     |   No   | client |<br>|    2     |   Yes  | client |<br>|    3     |   No   | client |<br>|    4     |   No   | client |<br>|    10    |   No   | driver |<br>|    11    |   No   | driver |<br>|    12    |   No   | driver |<br>|    13    |   No   | driver |<br>+———-+——–+——–+</p>
<p>写一段 SQL 语句查出 <strong>2013年10月1日</strong> 至 <strong>2013年10月3日</strong> 期间非禁止用户的取消率。基于上表，你的 SQL 语句应返回如下结果，取消率（Cancellation Rate）保留两位小数。</p>
<p>+————+——————-+<br>|     Day    | Cancellation Rate |<br>+————+——————-+<br>| 2013-10-01 |       0.33        |<br>| 2013-10-02 |       0.00        |<br>| 2013-10-03 |       0.50        |<br>+————+——————-+</p>
<p><strong>致谢:</strong></p>
<p>非常感谢 <a href="https://leetcode.com/discuss/user/cak1erlizhou">@cak1erlizhou</a> 详细的提供了这道题和相应的测试用例。</p>
<h1 id="MySQL-解决方法"><a href="#MySQL-解决方法" class="headerlink" title="MySQL 解决方法"></a>MySQL 解决方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">SELECT Request_at Day, ROUND(COUNT(IF(Status != &#x27;completed&#x27;, TRUE, NULL)) / COUNT(*), 2) &#x27;Cancellation Rate&#x27;</span><br><span class="line">FROM Trips WHERE (Request_at BETWEEN &#x27;2013-10-01&#x27; AND &#x27;2013-10-03&#x27;) AND Client_Id IN</span><br><span class="line">(SELECT Users_Id FROM Users WHERE Banned = &#x27;No&#x27;) GROUP BY Request_at;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 200 ms, faster than 85.63% of MySQL online submissions for Trips and Users.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :635 ms, 在所有 MySQL 提交中击败了23.95%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (261) Graph Valid Tree</title>
    <url>/afa606ad0c75/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (263) Ugly Number</title>
    <url>/83bc32be6174/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个程序判断给定的数是否为丑数。</p>
<p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 6<br><strong>输出:</strong> true<br><strong>解释:</strong> 6 &#x3D; 2 × 3</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 8<br><strong>输出:</strong> true<br><strong>解释:</strong> 8 &#x3D; 2 × 2 × 2</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> 14<br><strong>输出:</strong> false<br><strong>解释:</strong> <code>14</code> 不是丑数，因为它包含了另外一个质因数 <code>7</code>。</p>
<p><strong>说明:</strong></p>
<ol>
<li><code>1</code> 是丑数。</li>
<li>输入不会超过 32 位有符号整数的范围:</li>
</ol>
<p>$$<br>[−2^{31},  2^{31} − 1]<br>$$</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUgly</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>) num /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">3</span> == <span class="number">0</span>) num /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">5</span> == <span class="number">0</span>) num /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 69.18% of C++ online submissions for Ugly Number.</p>
<p>Memory Usage: 8 MB, less than 80.16% of C++ online submissions for Ugly Number.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :8 ms, 在所有 C++ 提交中击败了63.54%的用户</p>
<p>内存消耗 :8.1 MB, 在所有 C++ 提交中击败了20.00%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (264) Ugly Number II</title>
    <url>/a6963a1e679b/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个程序，找出第 <code>n</code> 个丑数。</p>
<p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> n &#x3D; 10<br><strong>输出:</strong> 12<br><strong>解释:</strong> <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> 是前 10 个丑数。</p>
<p><strong>说明:</strong> </p>
<ol>
<li><code>1</code> 是丑数。</li>
<li><code>n</code> <strong>不超过</strong> 1690。</li>
</ol>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (res.<span class="built_in">size</span>() &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> m2 = res[i2] * <span class="number">2</span>, m3 = res[i3] * <span class="number">3</span>, m5 = res[i5] * <span class="number">5</span>;</span><br><span class="line">            <span class="type">int</span> mn = <span class="built_in">min</span>(m2, <span class="built_in">min</span>(m3, m5));</span><br><span class="line">            <span class="keyword">if</span> (mn == m2) ++i2;</span><br><span class="line">            <span class="keyword">if</span> (mn == m3) ++i3;</span><br><span class="line">            <span class="keyword">if</span> (mn == m5) ++i5;</span><br><span class="line">            res.<span class="built_in">push_back</span>(mn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 80.28% of C++ online submissions for Ugly Number II.</p>
<p>Memory Usage: 11.8 MB, less than 45.34% of C++ online submissions for Ugly Number II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 :24 ms, 在所有 C++ 提交中击败了31.23%的用户</p>
<p>内存消耗 :11.6 MB, 在所有 C++ 提交中击败了31.90%的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (28) Implement strStr()</title>
    <url>/897fe719c32d/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现 <a href="http://www.cplusplus.com/reference/cstring/strstr/">strStr()</a> 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  <strong>-1</strong>。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> haystack &#x3D; “hello”, needle &#x3D; “ll”<br><strong>输出:</strong> 2</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> haystack &#x3D; “aaaaa”, needle &#x3D; “bba”<br><strong>输出:</strong> -1</p>
<p><strong>说明:</strong></p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <a href="http://www.cplusplus.com/reference/cstring/strstr/">strstr()</a> 以及 Java的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a> 定义相符。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = haystack.<span class="built_in">size</span>(), n = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &lt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m - n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 93.26% of C++ online submissions for Implement strStr().</p>
<p>Memory Usage: 8.9 MB, less than 99.61% of C++ online submissions for Implement strStr().</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Implement strStr()的C++提交中击败了33.78% 的用户</p>
<p>内存消耗 : 8.8 MB, 在Implement strStr()的C++提交中击败了0.87% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (27) Remove Element</title>
    <url>/5fe1cc773328/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组 nums 和一个值 val ，你需要 <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地</a></strong> 移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地</a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p>给定 nums &#x3D; <strong>[3,2,2,3]</strong> , val &#x3D; <strong>3</strong> ,</p>
<p>函数应该返回新的长度 <strong>2</strong> , 并且 nums 中的前两个元素均为 <strong>2</strong> 。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p>给定 nums &#x3D; <strong>[0,1,2,2,3,0,4,2]</strong> , val &#x3D; <strong>2</strong> ,</p>
<p>函数应该返回新的长度 <strong><code>5</code></strong> , 并且 nums 中的前五个元素为 <strong><code>0</code></strong> , <strong><code>1</code></strong> , <strong><code>3</code></strong> , <strong><code>0</code></strong> , <strong><code>4</code></strong> 。</p>
<p>注意这五个元素可为任意顺序。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以 <strong>“引用”</strong> 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// **nums** 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">removeElement</span>(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中**该长度范围内**的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val) nums[res++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 8.27% of C++ online submissions for Remove Element.</p>
<p>Memory Usage: 8.7 MB, less than 99.75% of C++ online submissions for Remove Element.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Remove Element的C++提交中击败了14.52% 的用户</p>
<p>内存消耗 : 9.2 MB, 在Remove Element的C++提交中击败了0.39% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (29) Divide Two Integers</title>
    <url>/38f9cde3688c/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的商。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> dividend &#x3D; 10, divisor &#x3D; 3<br><strong>输出:</strong> 3</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> dividend &#x3D; 7, divisor &#x3D; -3<br><strong>输出:</strong> -2</p>
<p><strong>说明:</strong></p>
<ul>
<li>被除数和除数均为 32 位有符号整数。</li>
<li>除数不为 0。</li>
<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是</li>
</ul>
<p>$$<br>[−2^{31},  2^{31} − 1]<br>$$</p>
<p>本题中，如果除法结果溢出，则返回</p>
<p>$$<br>2^{31} − 1<br>$$</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> m = <span class="built_in">abs</span>((<span class="type">long</span> <span class="type">long</span>)dividend), n = <span class="built_in">abs</span>((<span class="type">long</span> <span class="type">long</span>)divisor);</span><br><span class="line">        <span class="keyword">if</span> (m &lt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> t = n, p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; (t &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            t &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            p &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += p + <span class="built_in">divide</span>(m - t, n);</span><br><span class="line">        <span class="keyword">if</span> ((dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>)) res = -res;</span><br><span class="line">        <span class="keyword">return</span> res &gt; INT_MAX ? INT_MAX : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.</p>
<p>Memory Usage: 8.2 MB, less than 99.69% of C++ online submissions for Divide Two Integers.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Divide Two Integers的C++提交中击败了98.31% 的用户</p>
<p>内存消耗 : 8.2 MB, 在Divide Two Integers的C++提交中击败了0.93% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (3) Longest Substring Without Repeating Characters</title>
    <url>/1810e9c10f90/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串，请你找出其中不含有重复字符的 **最长子串 **的长度。</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p><strong>输入:</strong> “abcabcbb”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;abc&quot;，所以其</code>长度为 3。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> “bbbbb”<br><strong>输出:</strong> 1<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;b&quot;</code>，所以其长度为 1。</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> “pwwkew”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;wke&quot;</code>，所以其长度为 3。<br>     请注意，你的答案必须是 <strong>子串</strong> 的长度，<code>&quot;pwke&quot;</code> 是一个<strong>子序列</strong>，不是<strong>子串</strong>。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">m</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            left = <span class="built_in">max</span>(left, m[s[i]]);</span><br><span class="line">            m[s[i]] = i;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 97.63% of C++ online submissions for Longest Substring Without Repeating Characters.</p>
<p>Memory Usage: 15.4 MB, less than 69.74% of C++ online submissions for Longest Substring Without Repeating Characters.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 48 ms, 在Longest Substring Without Repeating Characters的C++提交中击败了23.97% 的用户</p>
<p>内存消耗 : 15.2 MB, 在Longest Substring Without Repeating Characters的C++提交中击败了0.93% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (30) Substring with Concatenation of All Words</title>
    <url>/8cb6f2f72954/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 <strong>s</strong> 和一些长度相同的单词 <strong>words</strong> ，找出 <strong>s</strong> 中恰好可以由 <strong>words</strong> 中所有单词串联形成的子串的起始位置。</p>
<p>注意子串要与 <strong>words</strong> 中的单词完全匹配，中间不能有其他字符，但不需要考虑 <strong>words</strong> 中单词串联的顺序。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong><br>s &#x3D; “barfoothefoobarman”,<br><strong>words &#x3D;</strong> [“foo”,”bar”]<br><strong>输出:</strong> <code>[0,9]</code><br><strong>解释:</strong> 从索引 0 和 9 开始的子串分别是 “barfoor” 和 “foobar” 。输出的顺序不重要, [9,0] 也是有效答案。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong><br>s &#x3D; “wordgoodgoodgoodbestword”,<br><strong>words &#x3D;</strong> [“word”,”good”,”best”,”word”]<br><strong>输出:</strong> <code>[]</code></p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || words.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), cnt = words.<span class="built_in">size</span>(), len = words[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; m1;</span><br><span class="line">        <span class="keyword">for</span> (string w : words) ++m1[w];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> left = i, count = <span class="number">0</span>;</span><br><span class="line">            unordered_map&lt;string, <span class="type">int</span>&gt; m2;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - len; j += len) &#123;</span><br><span class="line">                string t = s.<span class="built_in">substr</span>(j, len);</span><br><span class="line">                <span class="keyword">if</span> (m1.<span class="built_in">count</span>(t)) &#123;</span><br><span class="line">                    ++m2[t];</span><br><span class="line">                    <span class="keyword">if</span> (m2[t] &lt;= m1[t]) &#123;</span><br><span class="line">                        ++count;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (m2[t] &gt; m1[t]) &#123;</span><br><span class="line">                            string t1 = s.<span class="built_in">substr</span>(left, len);</span><br><span class="line">                            --m2[t1];</span><br><span class="line">                            <span class="keyword">if</span> (m2[t1] &lt; m1[t1]) --count;</span><br><span class="line">                            left += len;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (count == cnt) &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(left);</span><br><span class="line">                        --m2[s.<span class="built_in">substr</span>(left, len)];</span><br><span class="line">                        --count;</span><br><span class="line">                        left += len;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    m2.<span class="built_in">clear</span>();</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    left = j + len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 32 ms, faster than 96.86% of C++ online submissions for Substring with Concatenation of All Words.</p>
<p>Memory Usage: 14.7 MB, less than 97.78% of C++ online submissions for Substring with Concatenation of All Words.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 80 ms, 在Substring with Concatenation of All Words的C++提交中击败了76.56% 的用户</p>
<p>内存消耗 : 14.7 MB, 在Substring with Concatenation of All Words的C++提交中击败了0.63% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (31) Next Permutation</title>
    <url>/9ae85780fd8f/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须 <strong><a href="http://en.wikipedia.org/wiki/In-place_algorithm">原地</a></strong> 修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="type">int</span> n = nums.<span class="built_in">size</span>(), i = n - <span class="number">2</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) --i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[j] &lt;= nums[i]) --j;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 100.00% of C++ online submissions for Next Permutation.</p>
<p>Memory Usage: 8.6 MB, less than 100.00% of C++ online submissions for Next Permutation.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Next Permutation的C++提交中击败了24.36% 的用户</p>
<p>内存消耗 : 8.4 MB, 在Next Permutation的C++提交中击败了0.99% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (33) Search in Rotated Sorted Array</title>
    <url>/4f8bc944d598/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 <strong>O(log n)</strong> 级别。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> nums &#x3D; [<code>4,5,6,7,0,1,2]</code>, target &#x3D; 0<br><strong>输出:</strong> 4</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> nums &#x3D; [<code>4,5,6,7,0,1,2]</code>, target &#x3D; 3<br><strong>输出:</strong> -1</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Search in Rotated Sorted Array.</p>
<p>Memory Usage: 8.8 MB, less than 98.94% of C++ online submissions for Search in Rotated Sorted Array.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Search in Rotated Sorted Array的C++提交中击败了11.35% 的用户</p>
<p>内存消耗 : 8.6 MB, 在Search in Rotated Sorted Array的C++提交中击败了0.77% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (32) Longest Valid Parentheses</title>
    <url>/95841a5cbdc2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> “(()”<br><strong>输出:</strong> 2<br><strong>解释:</strong> 最长有效括号子串为 <code>&quot;()&quot;</code></p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> “<code>)()())</code>“<br><strong>输出:</strong> 4<br><strong>解释:</strong> 最长有效括号子串为 <code>&quot;()()&quot;</code></p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) m.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.<span class="built_in">empty</span>()) start = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    m.<span class="built_in">pop</span>();</span><br><span class="line">                    res = m.<span class="built_in">empty</span>() ? <span class="built_in">max</span>(res, i - start + <span class="number">1</span>) : <span class="built_in">max</span>(res, i - m.<span class="built_in">top</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 98.68% of C++ online submissions for Longest Valid Parentheses.</p>
<p>Memory Usage: 9.5 MB, less than 99.43% of C++ online submissions for Longest Valid Parentheses.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Longest Valid Parentheses的C++提交中击败了37.58% 的用户</p>
<p>内存消耗 : 9.3 MB, 在Longest Valid Parentheses的C++提交中击败了0.67% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (34) Find First and Last Position of Element in Sorted Array</title>
    <url>/0e277455f1d4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 <strong>O(log n)</strong> 级别。</p>
<p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> nums &#x3D; [<code>5,7,7,8,8,10]</code>, target &#x3D; 8<br><strong>输出:</strong> [3,4]</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> nums &#x3D; [<code>5,7,7,8,8,10]</code>, target &#x3D; 6<br><strong>输出:</strong> [-1,-1]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">search</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, target);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">-1</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> left = idx, right = idx;</span><br><span class="line">        <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; nums[left - <span class="number">1</span>] == nums[idx]) --left;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[right + <span class="number">1</span>] == nums[idx]) ++right;</span><br><span class="line">        <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) <span class="keyword">return</span> <span class="built_in">search</span>(nums, mid + <span class="number">1</span>, right, target);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">search</span>(nums, left, mid - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 99.73% of C++ online submissions for Find First and Last Position of Element in Sorted Array.</p>
<p>Memory Usage: 10.4 MB, less than 99.35% of C++ online submissions for Find First and Last Position of Element in Sorted Array.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 20 ms, 在Find First and Last Position of Element in Sorted Array的C++提交中击败了12.31% 的用户</p>
<p>内存消耗 : 10.5 MB, 在Find First and Last Position of Element in Sorted Array的C++提交中击败了0.36% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (35) Search Insert Position</title>
    <url>/d7d7805d22bf/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [1,3,5,6], 5<br><strong>输出:</strong> 2</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [1,3,5,6], 2<br><strong>输出:</strong> 1</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> [1,3,5,6], 7<br><strong>输出:</strong> 4</p>
<h1 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h1><p><strong>输入:</strong> [1,3,5,6], 0<br><strong>输出:</strong> 0</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= target) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 98.53% of C++ online submissions for Search Insert Position.</p>
<p>Memory Usage: 8.8 MB, less than 98.80% of C++ online submissions for Search Insert Position.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Search Insert Position的C++提交中击败了16.06% 的用户</p>
<p>内存消耗 : 8.8 MB, 在Search Insert Position的C++提交中击败了0.27% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (36) Valid Sudoku</title>
    <url>/ac4617e7fe30/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>判断一个 9x9 的数独是否有效。只需要 <strong>根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ol>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"></p>
<p>上图是一个部分填充的有效的数独。</p>
<p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong><br>[<br>  [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong><br>[<br>  [“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br><strong>输出:</strong> false<br><strong>解释:</strong> 除了第一行的第一个数字从 <strong>5</strong> 改为 <strong>8</strong> 以外，空格内其他数字均与 示例1 相同。<br>     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</p>
<p><strong>说明:</strong></p>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>给定数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li>
<li>给定数独永远是 <code>9x9</code> 形式的。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.<span class="built_in">empty</span>() || board[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt; <span class="built_in">rowFlag</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt; <span class="built_in">colFlag</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt; <span class="built_in">cellFlag</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] &gt;= <span class="string">&#x27;1&#x27;</span> &amp;&amp; board[i][j] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> c = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (rowFlag[i][c] || colFlag[c][j] || cellFlag[<span class="number">3</span> * (i / <span class="number">3</span>) + j / <span class="number">3</span>][c]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    rowFlag[i][c] = <span class="literal">true</span>;</span><br><span class="line">                    colFlag[c][j] = <span class="literal">true</span>;</span><br><span class="line">                    cellFlag[<span class="number">3</span> * (i / <span class="number">3</span>) + j / <span class="number">3</span>][c] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 80.01% of C++ online submissions for Valid Sudoku.</p>
<p>Memory Usage: 10.8 MB, less than 97.65% of C++ online submissions for Valid Sudoku.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 48 ms, 在Valid Sudoku的C++提交中击败了1.35% 的用户</p>
<p>内存消耗 : 10.7 MB, 在Valid Sudoku的C++提交中击败了0.00% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (37) Sudoku Solver</title>
    <url>/7eb09184b82b/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个程序，通过已填充的空格来解决数独问题。</p>
<p>一个数独的解法需<strong>遵循如下规则</strong>：</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ol>
<p>空白格用 <code>&#39;.&#39;</code> 表示。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"></p>
<p>一个数独。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png"></p>
<p>答案被标成红色。</p>
<p><strong>说明:</strong></p>
<ul>
<li>给定的数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li>
<li>你可以假设给定的数独只有唯一解。</li>
<li>给定数独永远是 <code>9x9</code> 形式的。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.<span class="built_in">empty</span>() || board.<span class="built_in">size</span>() != <span class="number">9</span> || board[<span class="number">0</span>].<span class="built_in">size</span>() != <span class="number">9</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">solveSudokuDFS</span>(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">solveSudokuDFS</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt; &amp;board, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">9</span>) <span class="keyword">return</span> <span class="built_in">solveSudokuDFS</span>(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                board[i][j] = (<span class="type">char</span>)(k + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isValid</span>(board, i , j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">solveSudokuDFS</span>(board, i, j + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">solveSudokuDFS</span>(board, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt; &amp;board, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; ++col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col != j &amp;&amp; board[i][j] == board[i][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; ++row) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row != i &amp;&amp; board[i][j] == board[row][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> row = i / <span class="number">3</span> * <span class="number">3</span>; row &lt; i / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; ++row) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> col = j / <span class="number">3</span> * <span class="number">3</span>; col &lt; j / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; ++col) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((row != i || col != j) &amp;&amp; board[i][j] == board[row][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 48.27% of C++ online submissions for Sudoku Solver.</p>
<p>Memory Usage: 8.8 MB, less than 87.64% of C++ online submissions for Sudoku Solver.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 40 ms, 在Sudoku Solver的C++提交中击败了13.62% 的用户</p>
<p>内存消耗 : 8.7 MB, 在Sudoku Solver的C++提交中击败了0.98% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (38) Count and Say</title>
    <url>/dfd36a44e277/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p>
<p>1     1<br>2     11<br>3     21<br>4     1211<br>5     111221</p>
<p><code>1</code> 被读作 <code>&quot;one 1&quot;</code>  (<code>&quot;一个一&quot;</code>) , 即 <code>11</code>。<br><code>11</code> 被读作 <code>&quot;two 1s&quot;</code> (<code>&quot;两个一&quot;</code>）, 即 <code>21</code>。<br><code>21</code> 被读作 <code>&quot;one 2&quot;</code>,  “<code>one 1&quot;</code> （<code>&quot;一个二&quot;</code> ,  <code>&quot;一个一&quot;</code>) , 即 <code>1211</code>。</p>
<p>给定一个正整数 n(1 ≤ n ≤ 30)，输出报数序列的第 n 项。</p>
<p><strong>注意:</strong> 整数顺序将表示为一个字符串。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 1<br><strong>输出:</strong> “1”</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 4<br><strong>输出:</strong> “1211”</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string res = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (--n) &#123;</span><br><span class="line">            string cur = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (i + <span class="number">1</span> &lt; res.<span class="built_in">size</span>() &amp;&amp; res[i] == res[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += <span class="built_in">to_string</span>(cnt) + res[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Count and Say.</p>
<p>Memory Usage: 8.8 MB, less than 72.07% of C++ online submissions for Count and Say.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Count and Say的C++提交中击败了15.00% 的用户</p>
<p>内存消耗 : 8.8 MB, 在Count and Say的C++提交中击败了0.72% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (39) Combination Sum</title>
    <url>/56b5f66e21dd/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 <strong>无重复元素</strong> 的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的数字可以无限制重复被选取。</p>
<p><strong>说明:</strong></p>
<ul>
<li>所有数字（包括 <code>target</code>）都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> candidates &#x3D; <code>[2,3,6,7],</code> target &#x3D; <code>7</code>,<br><strong>所求解集为:</strong><br>[<br>  [7],<br>  [2,2,3]<br>]</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> candidates &#x3D; [2,3,5], target &#x3D; 8,<br><strong>所求解集为:</strong><br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candidates.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (candidates[i] == target) &#123;res.<span class="built_in">push_back</span>(&#123;candidates[i]&#125;); <span class="keyword">break</span>;&#125;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(candidates.<span class="built_in">begin</span>() + i, candidates.<span class="built_in">end</span>());</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; tmp = <span class="built_in">combinationSum</span>(vec, target - candidates[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> a : tmp) &#123;</span><br><span class="line">                a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), candidates[i]);</span><br><span class="line">                res.<span class="built_in">push_back</span>(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 28 ms, faster than 38.78% of C++ online submissions for Combination Sum.</p>
<p>Memory Usage: 12.9 MB, less than 42.50% of C++ online submissions for Combination Sum.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 76 ms, 在Combination Sum的C++提交中击败了34.02% 的用户</p>
<p>内存消耗 : 12.9 MB, 在Combination Sum的C++提交中击败了44.88% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (40) Combination Sum II</title>
    <url>/295fbb114cd0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<p><strong>说明:</strong></p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,<br><strong>所求解集为:</strong><br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,<br><strong>所求解集为:</strong><br>[<br>  [1,2,2],<br>  [5]<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt; &amp;num, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; out;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">combinationSum2DFS</span>(num, target, <span class="number">0</span>, out, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">combinationSum2DFS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;num, <span class="type">int</span> target, <span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt; &amp;out, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">0</span>) res.<span class="built_in">push_back</span>(out);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; num.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; start &amp;&amp; num[i] == num[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                out.<span class="built_in">push_back</span>(num[i]);</span><br><span class="line">                <span class="built_in">combinationSum2DFS</span>(num, target - num[i], i + <span class="number">1</span>, out, res);</span><br><span class="line">                out.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 81.70% of C++ online submissions for Combination Sum II.</p>
<p>Memory Usage: 9 MB, less than 100.00% of C++ online submissions for Combination Sum II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 20 ms, 在Combination Sum II的C++提交中击败了88.24% 的用户</p>
<p>内存消耗 : 8.9 MB, 在Combination Sum II的C++提交中击败了90.45% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (4) Median of Two Sorted Arrays</title>
    <url>/d87866a09655/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code> 和 <code>nums2</code>。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 </p>
<p>$$<br>O\log(m + n)<br>$$</p>
<p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p>nums1 &#x3D; [1, 3]<br>nums2 &#x3D; [2]</p>
<p>则中位数是 2.0</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p>nums1 &#x3D; [1, 2]<br>nums2 &#x3D; [3, 4]</p>
<p>则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &lt; n) <span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> ((<span class="type">double</span>)nums1[(m - <span class="number">1</span>) / <span class="number">2</span>] + (<span class="type">double</span>)nums1[m / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid2 = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> mid1 = m + n - mid2;</span><br><span class="line">            <span class="type">double</span> L1 = mid1 == <span class="number">0</span> ? INT_MIN : nums1[(mid1 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">            <span class="type">double</span> L2 = mid2 == <span class="number">0</span> ? INT_MIN : nums2[(mid2 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">            <span class="type">double</span> R1 = mid1 == m * <span class="number">2</span> ? INT_MAX : nums1[mid1 / <span class="number">2</span>];</span><br><span class="line">            <span class="type">double</span> R2 = mid2 == n * <span class="number">2</span> ? INT_MAX : nums2[mid2 / <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (L1 &gt; R2) left = mid2 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (L2 &gt; R1) right = mid2 - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">return</span> (<span class="built_in">max</span>(L1, L2) + <span class="built_in">min</span>(R1, R2)) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 40 ms, faster than 97.31% of C++ online submissions for Median of Two Sorted Arrays.</p>
<p>Memory Usage: 21.4 MB, less than 65.14% of C++ online submissions for Median of Two Sorted Arrays.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 68 ms, 在Median of Two Sorted Arrays的C++提交中击败了10.08% 的用户</p>
<p>内存消耗 : 21.2 MB, 在Median of Two Sorted Arrays的C++提交中击败了0.53% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (41) First Missing Positive</title>
    <url>/67038c6f7a7e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [1,2,0]<br><strong>输出:</strong> 3</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [3,4,-1,1]<br><strong>输出:</strong> 2</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> [7,8,9,11,12]<br><strong>输出:</strong> 1</p>
<p><strong>说明:</strong></p>
<p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for First Missing Positive.</p>
<p>Memory Usage: 8.6 MB, less than 100.00% of C++ online submissions for First Missing Positive.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在First Missing Positive的C++提交中击败了95.31% 的用户</p>
<p>内存消耗 : 8.6 MB, 在First Missing Positive的C++提交中击败了84.92% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (42) Trapping Rain Water</title>
    <url>/f49bd4e9ab5e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png"></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 <strong>感谢 Marcos</strong> 贡献此图。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> [0,1,0,2,1,0,1,3,2,1,2,1]<br><strong>输出:</strong> 6</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>() - <span class="number">1</span>, level = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> lower = height[(height[l] &lt; height[r]) ? l++ : r--];</span><br><span class="line">            level = <span class="built_in">max</span>(level, lower);</span><br><span class="line">            res += level - lower;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 98.98% of C++ online submissions for Trapping Rain Water.</p>
<p>Memory Usage: 8.9 MB, less than 100.00% of C++ online submissions for Trapping Rain Water.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Trapping Rain Water的C++提交中击败了97.02% 的用户</p>
<p>内存消耗 : 8.9 MB, 在Trapping Rain Water的C++提交中击败了96.71% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (43) Multiply Strings</title>
    <url>/4e0ad82f4d8e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> num1 &#x3D; “2”, num2 &#x3D; “3”<br><strong>输出:</strong> “6”</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> num1 &#x3D; “123”, num2 &#x3D; “456”<br><strong>输出:</strong> “56088”</p>
<p><strong>说明：</strong></p>
<ol>
<li><code>num1</code> 和 <code>num2</code> 的长度小于110。</li>
<li><code>num1</code> 和 <code>num2</code> 只包含数字 <code>0-9</code>。</li>
<li><code>num1</code> 和 <code>num2</code> 均不以零开头，除非是数字 0 本身。</li>
<li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li>
</ol>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> m = num1.<span class="built_in">size</span>(), n = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vals</span><span class="params">(m + n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="type">int</span> mul = (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="type">int</span> p1 = i + j, p2 = i + j + <span class="number">1</span>, sum = mul + vals[p2];</span><br><span class="line">                vals[p1] += sum / <span class="number">10</span>;</span><br><span class="line">                vals[p2] = sum % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!res.<span class="built_in">empty</span>() || val != <span class="number">0</span>) res.<span class="built_in">push_back</span>(val + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">empty</span>() ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 97.98% of C++ online submissions for Multiply Strings.</p>
<p>Memory Usage: 8.8 MB, less than 100.00% of C++ online submissions for Multiply Strings.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Multiply Strings的C++提交中击败了97.58% 的用户</p>
<p>内存消耗 : 8.7 MB, 在Multiply Strings的C++提交中击败了90.18% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (44) Wildcard Matching</title>
    <url>/4fcb0e174a70/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p>
<p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。</p>
<p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p>
<p><strong>说明:</strong></p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li>
</ul>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong><br>s &#x3D; “aa”<br>p &#x3D; “a”<br><strong>输出:</strong> false<br><strong>解释:</strong> “a” 无法匹配 “aa” 整个字符串。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong><br>s &#x3D; “aa”<br>p &#x3D; “<em>“<br><strong>输出:</strong> true<br><strong>解释:</strong> ‘</em>‘ 可以匹配任意字符串。</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong><br>s &#x3D; “cb”<br>p &#x3D; “?a”<br><strong>输出:</strong> false<br><strong>解释:</strong> ‘?’ 可以匹配 ‘c’, 但第二个 ‘a’ 无法匹配 ‘b’。</p>
<h1 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h1><p><strong>输入:</strong><br>s &#x3D; “adceb”<br>p &#x3D; “<em>a</em>b”<br><strong>输出:</strong> true<br><strong>解释:</strong> 第一个 ‘<em>‘ 可以匹配空字符串, 第二个 ‘</em>‘ 可以匹配字符串 “dce”.</p>
<h1 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h1><p><strong>输入:</strong><br>s &#x3D; “acdcb”<br>p &#x3D; “a*c?b”<br><strong>输入:</strong> false</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(s, p, <span class="number">0</span>, <span class="number">0</span>) &gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(string&amp; s, string&amp; p, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() &amp;&amp; j == p.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() &amp;&amp; p[j] != <span class="string">&#x27;*&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == p.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">helper</span>(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p[j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; p.<span class="built_in">size</span>() &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">helper</span>(s, p, i, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= (<span class="type">int</span>)s.<span class="built_in">size</span>() - i; ++k) &#123;</span><br><span class="line">                <span class="type">int</span> res = <span class="built_in">helper</span>(s, p, i + k, j + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (res == <span class="number">0</span> || res == <span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 99.74% of C++ online submissions for Wildcard Matching.</p>
<p>Memory Usage: 9 MB, less than 99.31% of C++ online submissions for Wildcard Matching.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 20 ms, 在Wildcard Matching的C++提交中击败了97.90% 的用户</p>
<p>内存消耗 : 8.7 MB, 在Wildcard Matching的C++提交中击败了93.93% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (45) Jump Game II</title>
    <url>/590b4ace76ff/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> [2,3,1,1,4]<br><strong>输出:</strong> 2<br><strong>解释:</strong> 跳到最后一个位置的最小跳跃数是 <code>2</code>。从下标为 0 跳到下标为 1 的位置，跳 <code>1</code> 步，然后跳 <code>3</code> 步到达数组的最后一个位置。</p>
<p><strong>说明:</strong></p>
<p>假设你总是可以到达数组的最后一个位置。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), last = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur = <span class="built_in">max</span>(cur, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == last) &#123;</span><br><span class="line">                last = cur;</span><br><span class="line">                ++res;</span><br><span class="line">                <span class="keyword">if</span> (cur &gt;= n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 98.06% of C++ online submissions for Jump Game II.</p>
<p>Memory Usage: 10.1 MB, less than 99.68% of C++ online submissions for Jump Game II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Jump Game II的C++提交中击败了95.42% 的用户</p>
<p>内存消耗 : 10.1 MB, 在Jump Game II的C++提交中击败了85.90% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (46) Permutations</title>
    <url>/cbe28d199951/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> [1,2,3]<br><strong>输出:</strong><br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; num) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        res.<span class="built_in">push_back</span>(num);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>())) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 100.00% of C++ online submissions for Permutations.</p>
<p>Memory Usage: 9.1 MB, less than 98.71% of C++ online submissions for Permutations.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 20 ms, 在Permutations的C++提交中击败了93.73% 的用户</p>
<p>内存消耗 : 9.1 MB, 在Permutations的C++提交中击败了89.67% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (49) Group Anagrams</title>
    <url>/9a60a3957b09/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> <code>[&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code>,<br><strong>输出:</strong><br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]</p>
<p><strong>说明:</strong></p>
<ul>
<li>所有输入均为小写字母。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (string str : strs) &#123;</span><br><span class="line">            string t = str;</span><br><span class="line">            <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">            m[t].<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : m) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(a.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 56 ms, faster than 50.61% of C++ online submissions for Group Anagrams.</p>
<p>Memory Usage: 19.9 MB, less than 59.97% of C++ online submissions for Group Anagrams.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 112 ms, 在Group Anagrams的C++提交中击败了40.56% 的用户</p>
<p>内存消耗 : 19.7 MB, 在Group Anagrams的C++提交中击败了47.72% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (47) Permutations II</title>
    <url>/28fe88475d97/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> [1,1,2]<br><strong>输出:</strong><br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 100.00% of C++ online submissions for Permutations II.</p>
<p>Memory Usage: 9.6 MB, less than 100.00% of C++ online submissions for Permutations II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 36 ms, 在Permutations II的C++提交中击败了95.33% 的用户</p>
<p>内存消耗 : 9.7 MB, 在Permutations II的C++提交中击败了95.40% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (5) Longest Palindromic Substring</title>
    <url>/c5d26dfbb19e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p><strong>输入:</strong> “babad”<br><strong>输出:</strong> “bab”<br><strong>注意:</strong> “aba” 也是一个有效答案。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> “cbbd”<br><strong>输出:</strong> “bb”</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), maxLen = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n - i &lt;= maxLen / <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> left = i, right = i;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; n - <span class="number">1</span> &amp;&amp; s[right + <span class="number">1</span>] == s[right]) ++right;</span><br><span class="line">            i = right + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; n - <span class="number">1</span> &amp;&amp; left &gt; <span class="number">0</span> &amp;&amp; s[right + <span class="number">1</span>] == s[left - <span class="number">1</span>]) &#123;</span><br><span class="line">                ++right; --left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxLen &lt; right - left + <span class="number">1</span>) &#123;</span><br><span class="line">                maxLen = right - left + <span class="number">1</span>;</span><br><span class="line">                start = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Longest Palindromic Substring.</p>
<p>Memory Usage: 9.4 MB, less than 82.32% of C++ online submissions for Longest Palindromic Substring.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Longest Palindromic Substring的C++提交中击败了84.52% 的用户</p>
<p>内存消耗 : 9.3 MB, 在Longest Palindromic Substring的C++提交中击败了11.80% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (48) Rotate Image</title>
    <url>/56b9f2057656/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 <strong>n × n</strong> 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p><strong>说明:</strong></p>
<p>你必须在 <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地</a></strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。 <strong>请不要</strong> 使用另一个矩阵来旋转图像。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p>给定 <strong>matrix</strong> &#x3D;<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p> <strong>原地</strong> 旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p>给定 <strong>matrix</strong> &#x3D;<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p>
<p> <strong>原地</strong> 旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i; ++j) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[n - <span class="number">1</span>- j][n - <span class="number">1</span> - i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[n - <span class="number">1</span> - i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Rotate Image.</p>
<p>Memory Usage: 8.9 MB, less than 99.70% of C++ online submissions for Rotate Image.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Rotate Image的C++提交中击败了95.32% 的用户</p>
<p>内存消耗 : 9 MB, 在Rotate Image的C++提交中击败了59.26% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (50) Pow(x, n)</title>
    <url>/f7d28f986132/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现 <a href="http://www.cplusplus.com/reference/valarray/pow/">pow(x, n)</a> ，即计算 x 的 n 次幂函数。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 2.00000, 10<br><strong>输出:</strong> 1024.00000</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 2.10000, 3<br><strong>输出:</strong> 9.26100</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> 2.00000, -2<br><strong>输出:</strong> 0.25000<br><strong>解释:</strong> 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</p>
<p><strong>说明:</strong></p>
<ul>
<li>-100.0 &lt; x &lt; 100.0</li>
<li>n 是 32 位有符号整数，其数值范围是</li>
</ul>
<p>$$<br>[−2^{31},  2^{31} − 1]<br>$$</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i != <span class="number">0</span>; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &lt; <span class="number">0</span> ? <span class="number">1</span> / res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Pow(x, n).</p>
<p>Memory Usage: 8.2 MB, less than 100.00% of C++ online submissions for Pow(x, n).</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Pow(x, n)的C++提交中击败了96.48% 的用户</p>
<p>内存消耗 : 8.2 MB, 在Pow(x, n)的C++提交中击败了94.59% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (51) N-Queens</title>
    <url>/b74213028991/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p> n 皇后问题研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/8-queens.png"></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 n ，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> 4<br><strong>输出:</strong> [<br> [“.Q..”,  &#x2F;&#x2F; 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p>
<p> [“..Q.”,  &#x2F;&#x2F; 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]<br><strong>解释:</strong> 4 皇后问题存在两个不同的解法。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">queens</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">helper</span>(<span class="number">0</span>, queens, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> curRow, vector&lt;string&gt;&amp; queens, vector&lt;vector&lt;string&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = queens.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (curRow == n) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(queens);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(queens, curRow, i)) &#123;</span><br><span class="line">                queens[curRow][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">helper</span>(curRow + <span class="number">1</span>, queens, res);</span><br><span class="line">                queens[curRow][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;string&gt;&amp; queens, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queens[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queens[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; queens.<span class="built_in">size</span>(); --i, ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queens[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 99.73% of C++ online submissions for N-Queens.</p>
<p>Memory Usage: 9.8 MB, less than 93.84% of C++ online submissions for N-Queens.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在N-Queens的C++提交中击败了92.57% 的用户</p>
<p>内存消耗 : 9.8 MB, 在N-Queens的C++提交中击败了97.49% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (52) N-Queens II</title>
    <url>/585e197c2a83/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p> n 皇后问题研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/8-queens.png"></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 n ，返回 n 皇后不同的解决方案的数量。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> 4<br><strong>输出:</strong> 2<br><strong>解释:</strong> 4 皇后问题存在如下两个不同的解法。<br>[<br> [“.Q..”,  &#x2F;&#x2F; 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p>
<p> [“..Q.”,  &#x2F;&#x2F; 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">totalNQueensDFS</span>(pos, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">totalNQueensDFS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;pos, <span class="type">int</span> row, <span class="type">int</span> &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = pos.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (row == n) ++res;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isValid</span>(pos, row, col)) &#123;</span><br><span class="line">                    pos[row] = col;</span><br><span class="line">                    <span class="built_in">totalNQueensDFS</span>(pos, row + <span class="number">1</span>, res);</span><br><span class="line">                    pos[row] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;pos, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col == pos[i] || <span class="built_in">abs</span>(row - i) == <span class="built_in">abs</span>(col - pos[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 53.72% of C++ online submissions for N-Queens II.</p>
<p>Memory Usage: 8.3 MB, less than 75.41% of C++ online submissions for N-Queens II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在N-Queens II的C++提交中击败了92.42% 的用户</p>
<p>内存消耗 : 8.1 MB, 在N-Queens II的C++提交中击败了93.06% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (53) Maximum Subarray</title>
    <url>/25c1fc956273/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> [-2,1,-3,4,-1,2,1,-5,4],<br><strong>输出:</strong> 6<br><strong>解释:</strong> 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p><strong>进阶:</strong></p>
<p>如果你已经实现复杂度为 O( n ) 的解法，尝试使用更为精妙的分治法求解。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN, curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            curSum = <span class="built_in">max</span>(curSum + num, num);</span><br><span class="line">            res = <span class="built_in">max</span>(res, curSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 99.26% of C++ online submissions for Maximum Subarray.</p>
<p>Memory Usage: 9.2 MB, less than 99.75% of C++ online submissions for Maximum Subarray.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Maximum Subarray的C++提交中击败了97.62% 的用户</p>
<p>内存消耗 : 9 MB, 在Maximum Subarray的C++提交中击败了97.47% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (54) Spiral Matrix</title>
    <url>/2b41eb0104a1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p> 给定一个包含 m x n 个元素的矩阵（ m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong><br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br><strong>输出:</strong> [1,2,3,6,9,8,7,4,5]</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong><br>[<br>  [1, 2, 3, 4],<br>  [5, 6, 7, 8],<br>  [9,10,11,12]<br>]<br><strong>输出:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> up = <span class="number">0</span>, down = m - <span class="number">1</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt;= right; ++j) res.<span class="built_in">push_back</span>(matrix[up][j]);</span><br><span class="line">            <span class="keyword">if</span> (++up &gt; down) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = up; i &lt;= down; ++i) res.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">            <span class="keyword">if</span> (--right &lt; left) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = right; j &gt;= left; --j) res.<span class="built_in">push_back</span>(matrix[down][j]);</span><br><span class="line">            <span class="keyword">if</span> (--down &lt; up) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = down; i &gt;= up; --i) res.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">            <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Spiral Matrix.</p>
<p>Memory Usage: 8.4 MB, less than 100.00% of C++ online submissions for Spiral Matrix.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Spiral Matrix的C++提交中击败了95.10% 的用户</p>
<p>内存消耗 : 8.6 MB, 在Spiral Matrix的C++提交中击败了51.27% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (55) Jump Game</title>
    <url>/051b858f9020/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [2,3,1,1,4]<br><strong>输出:</strong> true<br><strong>解释:</strong> 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [3,2,1,0,4]<br><strong>输出:</strong> false<br><strong>解释:</strong> 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), reach = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; reach || reach &gt;= n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            reach = <span class="built_in">max</span>(reach, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reach &gt;= n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 98.55% of C++ online submissions for Jump Game.</p>
<p>Memory Usage: 9.9 MB, less than 97.61% of C++ online submissions for Jump Game.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Jump Game的C++提交中击败了95.76% 的用户</p>
<p>内存消耗 : 9.7 MB, 在Jump Game的C++提交中击败了96.98% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (56) Merge Intervals</title>
    <url>/ab935b1a7174/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [[1,3],[2,6],[8,10],[15,18]]<br><strong>输出:</strong> [[1,6],[8,10],[15,18]]<br><strong>解释:</strong> 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [[1,4],[4,5]]<br><strong>输出:</strong> [[1,5]]<br><strong>解释:</strong> 区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res&#123;intervals[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">back</span>()[<span class="number">1</span>]&lt; intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(res.<span class="built_in">back</span>()[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 24 ms, faster than 25.21% of C++ online submissions for Merge Intervals.</p>
<p>Memory Usage: 12.6 MB, less than 5.16% of C++ online submissions for Merge Intervals.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 60 ms, 在Merge Intervals的C++提交中击败了15.97% 的用户</p>
<p>内存消耗 : 12.4 MB, 在Merge Intervals的C++提交中击败了5.08% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (59) Spiral Matrix II</title>
    <url>/9833700a18b1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个正整数 n，生成一个包含 1 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> 3<br><strong>输出:</strong><br>[<br> [ 1, 2, 3 ],<br> [ 8, 9, 4 ],<br> [ 7, 6, 5 ]<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> up = <span class="number">0</span>, down = n - <span class="number">1</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>, val = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt;= right; ++j) res[up][j] = val++;</span><br><span class="line">            <span class="keyword">if</span> (++up &gt; down) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = up; i &lt;= down; ++i) res[i][right] = val++;</span><br><span class="line">            <span class="keyword">if</span> (--right &lt; left) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = right; j &gt;= left; --j) res[down][j] = val++;</span><br><span class="line">            <span class="keyword">if</span> (--down &lt; up) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = down; i &gt;= up; --i) res[i][left] = val++;</span><br><span class="line">            <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Spiral Matrix II.</p>
<p>Memory Usage: 9 MB, less than 79.41% of C++ online submissions for Spiral Matrix II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Spiral Matrix II的C++提交中击败了89.94% 的用户</p>
<p>内存消耗 : 8.7 MB, 在Spiral Matrix II的C++提交中击败了95.57% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (57) Insert Interval</title>
    <url>/d29d4a0080cf/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个<strong>无重叠的</strong>，按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]<br><strong>输出:</strong> [[1,5],[6,9]]</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> intervals &#x3D; <code>[[1,2],[3,5],[6,7],[8,10],[12,16]]</code>, newInterval &#x3D; <code>[4,8]</code><br><strong>输出:</strong> [[1,2],[3,10],[12,16]]<br><strong>解释:</strong> 这是因为新的区间 <code>[4,8]</code> 与 <code>[3,5],[6,7],[8,10]</code> 重叠。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>(), cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; n &amp;&amp; intervals[cur][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(intervals[cur]);</span><br><span class="line">            ++cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; n &amp;&amp; intervals[cur][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>]) &#123;</span><br><span class="line">            newInterval[<span class="number">0</span>] = <span class="built_in">min</span>(newInterval[<span class="number">0</span>], intervals[cur][<span class="number">0</span>]);</span><br><span class="line">            newInterval[<span class="number">1</span>] = <span class="built_in">max</span>(newInterval[<span class="number">1</span>], intervals[cur][<span class="number">1</span>]);</span><br><span class="line">            ++cur;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; n) res.<span class="built_in">push_back</span>(intervals[cur++]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 40.60% of C++ online submissions for Insert Interval.</p>
<p>Memory Usage: 12.4 MB, less than 5.37% of C++ online submissions for Insert Interval.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 28 ms, 在Insert Interval的C++提交中击败了58.72% 的用户</p>
<p>内存消耗 : 12.4 MB, 在Insert Interval的C++提交中击败了5.23% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (58) Length of Last Word</title>
    <url>/329204249cbd/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串，返回其最后一个单词的长度。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p><strong>说明:</strong> 一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> “Hello World”<br><strong>输出:</strong> 5</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> right = s.<span class="built_in">size</span>() - <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &gt;= <span class="number">0</span> &amp;&amp; s[right] == <span class="string">&#x27; &#x27;</span>) --right;</span><br><span class="line">        <span class="keyword">while</span> (right &gt;= <span class="number">0</span> &amp;&amp; s[right] != <span class="string">&#x27; &#x27;</span> ) &#123;</span><br><span class="line">            --right; </span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Length of Last Word.</p>
<p>Memory Usage: 8.7 MB, less than 100.00% of C++ online submissions for Length of Last Word.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Length of Last Word的C++提交中击败了97.09% 的用户</p>
<p>内存消耗 : 8.9 MB, 在Length of Last Word的C++提交中击败了66.25% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (6) ZigZag Conversion</title>
    <url>/c666f1cd7187/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure>

<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>

<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p><strong>输入:</strong> s &#x3D; “LEETCODEISHIRING”, numRows &#x3D; 3<br><strong>输出:</strong> “LCIRETOESIIGEDHN”</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> s &#x3D; “LEETCODEISHIRING”, numRows &#x3D; 4<br><strong>输出:</strong> “LDREOEIIECIHNTSG”<br><strong>解释:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> nRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nRows &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">2</span> * nRows - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nRows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j += size) &#123;</span><br><span class="line">                res += s[j];</span><br><span class="line">                <span class="type">int</span> tmp = j + size - <span class="number">2</span> * i;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != nRows - <span class="number">1</span> &amp;&amp; tmp &lt; s.<span class="built_in">size</span>()) res += s[tmp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 98.10% of C++ online submissions for ZigZag Conversion.</p>
<p>Memory Usage: 16.9 MB, less than 63.17% of C++ online submissions for ZigZag Conversion.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 40 ms, 在ZigZag Conversion的C++提交中击败了20.84% 的用户</p>
<p>内存消耗 : 16.6 MB, 在ZigZag Conversion的C++提交中击败了0.76% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (60) Permutation Sequence</title>
    <url>/9dedde6eddd1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出集合 <code>[1,2,3,…,n]</code>，其所有元素共有 n! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 n &#x3D; 3 时, 所有排列如下：</p>
<ol>
<li><code>&quot;123&quot;</code></li>
<li><code>&quot;132&quot;</code></li>
<li><code>&quot;213&quot;</code></li>
<li><code>&quot;231&quot;</code></li>
<li><code>&quot;312&quot;</code></li>
<li><code>&quot;321&quot;</code></li>
</ol>
<p>给定 n 和 k，返回第 k 个排列。</p>
<p><strong>说明：</strong></p>
<ul>
<li>给定 n 的范围是 [1, 9]。</li>
<li>给定 k 的范围是[1,  n!]。</li>
</ul>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> n &#x3D; 3, k &#x3D; 3<br><strong>输出:</strong> “213”</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> n &#x3D; 4, k &#x3D; 9<br><strong>输出:</strong> “2314”</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        string num = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) f[i] = f[i - <span class="number">1</span>] * i;</span><br><span class="line">        --k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> j = k / f[i - <span class="number">1</span>];</span><br><span class="line">            k %= f[i - <span class="number">1</span>];</span><br><span class="line">            res.<span class="built_in">push_back</span>(num[j]);</span><br><span class="line">            num.<span class="built_in">erase</span>(j, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Permutation Sequence.</p>
<p>Memory Usage: 8.3 MB, less than 99.40% of C++ online submissions for Permutation Sequence.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Permutation Sequence的C++提交中击败了97.29% 的用户</p>
<p>内存消耗 : 8.3 MB, 在Permutation Sequence的C++提交中击败了69.40% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (62) Unique Paths</title>
    <url>/05ecd6935787/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png"></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p><strong>说明</strong> m 和 n 的值均不超过 100。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> m &#x3D; 3, n &#x3D; 2<br><strong>输出:</strong> 3<br><strong>解释:</strong><br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下</li>
<li>向右 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向右</li>
</ol>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> m &#x3D; 7, n &#x3D; 3<br><strong>输出:</strong> 28</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> num = <span class="number">1</span>, denom = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> small = m &gt; n ? n : m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= small - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            num *= m + n - <span class="number">1</span> - i;</span><br><span class="line">            denom *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(num / denom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Unique Paths.</p>
<p>Memory Usage: 8.3 MB, less than 62.24% of C++ online submissions for Unique Paths.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Unique Paths的C++提交中击败了23.76% 的用户</p>
<p>内存消耗 : 8.2 MB, 在Unique Paths的C++提交中击败了57.04% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (63) Unique Paths II</title>
    <url>/6f96ad340e0c/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png"></p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><strong>说明:</strong> m 和 n 的值均不超过 100。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> [<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br><strong>输出:</strong> 2<br><strong>解释:</strong><br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 <code>2</code> 条不同的路径：</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li>
</ol>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid.<span class="built_in">empty</span>() || obstacleGrid[<span class="number">0</span>].<span class="built_in">empty</span>() || obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Unique Paths II.</p>
<p>Memory Usage: 9.3 MB, less than 27.31% of C++ online submissions for Unique Paths II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Unique Paths II的C++提交中击败了95.33% 的用户</p>
<p>内存消耗 : 9.1 MB, 在Unique Paths II的C++提交中击败了78.45% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (61) Rotate List</title>
    <url>/fb30bed75969/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2<br><strong>输出:</strong> 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br><strong>解释:</strong><br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4<br><strong>输出:</strong> <code>2-&gt;0-&gt;1-&gt;NULL</code><br><strong>解释:</strong><br>向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>向右旋转 3 步: <code>0-&gt;1-&gt;2-&gt;NULL</code><br>向右旋转 4 步: <code>2-&gt;0-&gt;1-&gt;NULL</code></p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">rotateRight</span><span class="params">(ListNode *head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            ++n;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        k %= n;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast) fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fast) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast-&gt;next = head;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 100.00% of C++ online submissions for Rotate List.</p>
<p>Memory Usage: 9.1 MB, less than 99.26% of C++ online submissions for Rotate List.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Rotate List的C++提交中击败了97.06% 的用户</p>
<p>内存消耗 : 9 MB, 在Rotate List的C++提交中击败了75.46% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (65) Valid Number</title>
    <url>/950868274a69/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>验证给定的字符串是否可以解释为十进制数字。</p>
<p>例如:</p>
<p><code>&quot;0&quot;</code> &#x3D;&gt; <code>true</code><br><code>&quot; 0.1 &quot;</code> &#x3D;&gt; <code>true</code><br><code>&quot;abc&quot;</code> &#x3D;&gt; <code>false</code><br><code>&quot;1 a&quot;</code> &#x3D;&gt; <code>false</code><br><code>&quot;2e10&quot;</code> &#x3D;&gt; <code>true</code><br><code>&quot; -90e3   &quot;</code> &#x3D;&gt; <code>true</code><br><code>&quot; 1e&quot;</code> &#x3D;&gt; <code>false</code><br><code>&quot;e3&quot;</code> &#x3D;&gt; <code>false</code><br><code>&quot; 6e-1&quot;</code> &#x3D;&gt; <code>true</code><br><code>&quot; 99e2.5 &quot;</code> &#x3D;&gt; <code>false</code><br><code>&quot;53.5e93&quot;</code> &#x3D;&gt; <code>true</code><br><code>&quot; --6 &quot;</code> &#x3D;&gt; <code>false</code><br><code>&quot;-+3&quot;</code> &#x3D;&gt; <code>false</code><br><code>&quot;95a54e53&quot;</code> &#x3D;&gt; <code>false</code></p>
<p><strong>说明:</strong> 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。这里给出一份可能存在于有效十进制数字中的字符列表：</p>
<ul>
<li>数字 0-9</li>
<li>指数 - “e”</li>
<li>正&#x2F;负号 - “+”&#x2F;“-“</li>
<li>小数点 - “.”</li>
</ul>
<p>当然，在输入中，这些字符的上下文也很重要。</p>
<p><strong>更新于 2015-02-10:</strong><br><code>C++</code>函数的形式已经更新了。如果你仍然看见你的函数接收 <code>const char *</code> 类型的参数，请点击重载按钮重置你的代码。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> num = <span class="literal">false</span>, numAfterE = <span class="literal">true</span>, dot = <span class="literal">false</span>, exp = <span class="literal">false</span>, sign = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; s[i + <span class="number">1</span>] != <span class="string">&#x27; &#x27;</span> &amp;&amp; (num || dot || exp || sign)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27;e&#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                sign = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                num = <span class="literal">true</span>;</span><br><span class="line">                numAfterE = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dot || exp) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                dot = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exp || !num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                exp = <span class="literal">true</span>;</span><br><span class="line">                numAfterE = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num &amp;&amp; numAfterE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 99.37% of C++ online submissions for Valid Number.</p>
<p>Memory Usage: 8.3 MB, less than 100.00% of C++ online submissions for Valid Number.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Valid Number的C++提交中击败了98.68% 的用户</p>
<p>内存消耗 : 8.2 MB, 在Valid Number的C++提交中击败了70.00% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (67) Add Binary</title>
    <url>/a0270b0ce263/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为<strong>非空</strong>字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> a &#x3D; “11”, b &#x3D; “1”<br><strong>输出:</strong> “100”</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> a &#x3D; “1010”, b &#x3D; “1011”<br><strong>输出:</strong> “10101”</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> na = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> nb = b.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">max</span>(na, nb);</span><br><span class="line">        <span class="type">bool</span> carry = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (na &gt; nb) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; na - nb; ++i) b.<span class="built_in">insert</span>(b.<span class="built_in">begin</span>(), <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (na &lt; nb) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nb - na; ++i) a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (carry) tmp = (a[i] - <span class="string">&#x27;0&#x27;</span>) + (b[i] - <span class="string">&#x27;0&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> tmp = (a[i] - <span class="string">&#x27;0&#x27;</span>) + (b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(), <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                carry = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmp == <span class="number">1</span>) &#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(), <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                carry = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmp == <span class="number">2</span>) &#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(), <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                carry = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmp == <span class="number">3</span>) &#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(), <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                carry = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry) res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(), <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Add Binary.</p>
<p>Memory Usage: 8.8 MB, less than 43.65% of C++ online submissions for Add Binary.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Add Binary的C++提交中击败了38.18% 的用户</p>
<p>内存消耗 : 8.9 MB, 在Add Binary的C++提交中击败了36.80% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (64) Minimum Path Sum</title>
    <url>/24c20f2dcfab/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明:</strong> 每次只能向下或者向右移动一步。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong><br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br><strong>输出:</strong> 7<br><strong>解释:</strong> 因为路径 1→3→1→1→1 的总和最小。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) dp[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) dp[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i] + dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 97.89% of C++ online submissions for Minimum Path Sum.</p>
<p>Memory Usage: 10.8 MB, less than 86.48% of C++ online submissions for Minimum Path Sum.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Minimum Path Sum的C++提交中击败了96.14% 的用户</p>
<p>内存消耗 : 10.6 MB, 在Minimum Path Sum的C++提交中击败了88.35% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (66) Plus One</title>
    <url>/b76cff66fcf3/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [1,2,3]<br><strong>输出:</strong> [1,2,4]<br><strong>解释:</strong> 输入数组表示数字 123。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [4,3,2,1]<br><strong>输出:</strong> [4,3,2,2]<br><strong>解释:</strong> 输入数组表示数字 4321。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> digits;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">1</span>, n = digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (carry == <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">            <span class="type">int</span> sum = digits[i] + carry;</span><br><span class="line">            digits[i] = sum % <span class="number">10</span>;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) digits.<span class="built_in">insert</span>(digits.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Plus One.</p>
<p>Memory Usage: 8.6 MB, less than 61.14% of C++ online submissions for Plus One.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Plus One的C++提交中击败了96.65% 的用户</p>
<p>内存消耗 : 8.7 MB, 在Plus One的C++提交中击败了5.45% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (68) Text Justification</title>
    <url>/db2f74fc231e/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个单词数组和一个长度 <strong>maxWidth</strong>，重新排版单词，使其成为每行恰好有 <strong>maxWidth</strong> 个字符，且左右两端对齐的文本。</p>
<p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 <code>&#39; &#39;</code> 填充，使得每行恰好有 <strong>maxWidth</strong> 个字符。</p>
<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>
<p>文本的最后一行应为左对齐，且单词之间不插入<strong>额外的</strong>空格。</p>
<p><strong>说明:</strong></p>
<ul>
<li>单词是指由非空格字符组成的字符序列。</li>
<li>每个单词的长度大于 0，小于等于 <strong>maxWidth</strong>。</li>
<li>输入单词数组 <code>words</code> 至少包含一个单词。</li>
</ul>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong><br>words &#x3D; [“This”, “is”, “an”, “example”, “of”, “text”, “justification.”]<br>maxWidth &#x3D; 16<br><strong>输出:</strong><br>[<br>   “This    is    an”,<br>   “example  of text”,<br>   “justification.  “<br>]</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong><br>words &#x3D; [“What”,”must”,”be”,”acknowledgment”,”shall”,”be”]<br>maxWidth &#x3D; 16<br><strong>输出:</strong><br>[<br>  “What   must   be”,<br>  “acknowledgment  “,<br>  “shall be        “<br>]<br><strong>解释:</strong> 注意最后一行的格式应为 “shall be    “ 而不是 “shall     be”,<br>     因为最后一行应为左对齐，而不是左右两端对齐。<br>     第二行同样为左对齐，这是因为这行只包含一个单词。</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong><br>words &#x3D; [“Science”,”is”,”what”,”we”,”understand”,”well”,”enough”,”to”,”explain”,<br>         “to”,”a”,”computer.”,”Art”,”is”,”everything”,”else”,”we”,”do”]<br>maxWidth &#x3D; 20<br><strong>输出:</strong><br>[<br>  “Science  is  what we”,<br>  “understand      well”,<br>  “enough to explain to”,<br>  “a  computer.  Art is”,<br>  “everything  else  we”,<br>  “do                  “<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">fullJustify</span><span class="params">(vector&lt;string&gt; &amp;words, <span class="type">int</span> L)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; words.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> j = i, len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; words.<span class="built_in">size</span>() &amp;&amp; len + words[j].<span class="built_in">size</span>() + j - i &lt;= L) &#123;</span><br><span class="line">                len += words[j++].<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            string out;</span><br><span class="line">            <span class="type">int</span> space = L - len;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; ++k) &#123;</span><br><span class="line">                out += words[k];</span><br><span class="line">                <span class="keyword">if</span> (space &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> tmp;</span><br><span class="line">                    <span class="keyword">if</span> (j == words.<span class="built_in">size</span>()) &#123; </span><br><span class="line">                        <span class="keyword">if</span> (j - k == <span class="number">1</span>) tmp = space;</span><br><span class="line">                        <span class="keyword">else</span> tmp = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j - k - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (space % (j - k - <span class="number">1</span>) == <span class="number">0</span>) tmp = space / (j - k - <span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">else</span> tmp = space / (j - k - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> tmp = space;</span><br><span class="line">                    &#125;</span><br><span class="line">                    out.<span class="built_in">append</span>(tmp, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                    space -= tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(out);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Text Justification.</p>
<p>Memory Usage: 9.1 MB, less than 47.52% of C++ online submissions for Text Justification.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Text Justification的C++提交中击败了96.00% 的用户</p>
<p>内存消耗 : 9.1 MB, 在Text Justification的C++提交中击败了42.97% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (69) Sqrt(x)</title>
    <url>/fcb408ef4c6f/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 4<br><strong>输出:</strong> 2</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 8<br><strong>输出:</strong> 2<br><strong>说明:</strong> 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">abs</span>(res - pre) &gt; <span class="number">1e-6</span>) &#123;</span><br><span class="line">            pre = res;</span><br><span class="line">            res = (res + x / res) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Sqrt(x).</p>
<p>Memory Usage: 8.3 MB, less than 99.14% of C++ online submissions for Sqrt(x).</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Sqrt(x)的C++提交中击败了99.19% 的用户</p>
<p>内存消耗 : 8.3 MB, 在Sqrt(x)的C++提交中击败了74.02% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (7) Reverse Integer</title>
    <url>/19b8682af4c2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p><strong>输入:</strong> 123<br><strong>输出:</strong> 321</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> -123<br><strong>输出:</strong> -321</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> 120<br><strong>输出:</strong> 21</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            res = <span class="number">10</span> * res + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res &gt; INT_MAX || res &lt; INT_MIN) ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 98.36% of C++ online submissions for Reverse Integer.</p>
<p>Memory Usage: 14 MB, less than 57.59% of C++ online submissions for Reverse Integer.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 28 ms, 在Reverse Integer的C++提交中击败了10.39% 的用户</p>
<p>内存消耗 : 13.7 MB, 在Reverse Integer的C++提交中击败了0.67% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (70) Climbing Stairs</title>
    <url>/c58063a5fd6f/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意:</strong> 给定 n 是一个正整数。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入：</strong> 2<br><strong>输出：</strong> 2<br><strong>解释：</strong> 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入：</strong> 3<br><strong>输出：</strong> 3<br><strong>解释：</strong> 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Climbing Stairs.</p>
<p>Memory Usage: 8.2 MB, less than 98.04% of C++ online submissions for Climbing Stairs.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Climbing Stairs的C++提交中击败了84.42% 的用户</p>
<p>内存消耗 : 8.1 MB, 在Climbing Stairs的C++提交中击败了93.80% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (71) Simplify Path</title>
    <url>/140063f9200c/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>以 Unix 风格给出一个文件的<strong>绝对路径</strong>，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://www.linuxnix.com/abslute-path-vs-relative-path-in-linuxunix/">Linux &#x2F; Unix中的绝对路径 vs 相对路径</a></p>
<p>请注意，返回的规范路径必须始终以斜杠 <code>/</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong>以 <code>/</code> 结尾。此外，规范路径必须是表示绝对路径的<strong>最短</strong>字符串。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> <code>/home/</code><br><strong>输出:</strong> <code>/home</code><br><strong>解释:</strong> 注意，最后一个目录名后面没有斜杠。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> <code>/../</code><br><strong>输出:</strong> <code>/</code><br><strong>解释:</strong> 从根目录向上一级是不可行的，因为根是你可以到达的最高级。</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> <code>/home//foo/</code><br><strong>输出:</strong> <code>/home/foo</code><br><strong>解释:</strong> 在规范路径中，多个连续斜杠需要用一个斜杠替换。</p>
<h1 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h1><p><strong>输入:</strong> <code>/a/./b/../../c/</code><br><strong>输出:</strong> <code>/c</code></p>
<h1 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h1><p><strong>输入:</strong> <code>/a/../../b/../c//.//</code><br><strong>输出:</strong> <code>/c</code></p>
<h1 id="示例-6"><a href="#示例-6" class="headerlink" title="示例 6"></a>示例 6</h1><p><strong>输入:</strong> <code>/a//b////c/d//././/..</code><br><strong>输出:</strong> <code>/a/b/c</code></p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">simplifyPath</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; v;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; path.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (path[i] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; i &lt; path.<span class="built_in">size</span>()) ++i;</span><br><span class="line">            <span class="keyword">if</span> (i == path.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> start = i;</span><br><span class="line">            <span class="keyword">while</span> (path[i] != <span class="string">&#x27;/&#x27;</span> &amp;&amp; i &lt; path.<span class="built_in">size</span>()) ++i;</span><br><span class="line">            <span class="type">int</span> end = i - <span class="number">1</span>;</span><br><span class="line">            string s = path.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="string">&quot;..&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!v.<span class="built_in">empty</span>()) v.<span class="built_in">pop_back</span>(); </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s != <span class="string">&quot;.&quot;</span>) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res += <span class="string">&#x27;/&#x27;</span> + v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 99.77% of C++ online submissions for Simplify Path.</p>
<p>Memory Usage: 10 MB, less than 98.77% of C++ online submissions for Simplify Path.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Simplify Path的C++提交中击败了96.30% 的用户</p>
<p>内存消耗 : 9.9 MB, 在Simplify Path的C++提交中击败了92.07% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (72) Edit Distance</title>
    <url>/816e4dc52bae/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> word1 &#x3D; “horse”, word2 &#x3D; “ros”<br><strong>输出:</strong> 3<br><strong>解释:</strong><br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> word1 &#x3D; “intention”, word2 &#x3D; “execution”<br><strong>输出:</strong> 5<br><strong>解释:</strong><br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = word1.<span class="built_in">size</span>(), n = word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 77.42% of C++ online submissions for Edit Distance.</p>
<p>Memory Usage: 11.3 MB, less than 31.73% of C++ online submissions for Edit Distance.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 40 ms, 在Edit Distance的C++提交中击败了25.00% 的用户</p>
<p>内存消耗 : 11.4 MB, 在Edit Distance的C++提交中击败了7.92% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (73) Set Matrix Zeroes</title>
    <url>/d55de5ba7f57/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用<a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地算法</a>。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong><br>[<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]<br><strong>输出:</strong><br>[<br>  [1,0,1],<br>  [0,0,0],<br>  [1,0,1]<br>]</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong><br>[<br>  [0,1,2,0],<br>  [3,4,5,2],<br>  [1,3,1,5]<br>]<br><strong>输出:</strong><br>[<br>  [0,0,0,0],<br>  [0,4,5,0],<br>  [0,3,1,0]<br>]</p>
<p><strong>进阶:</strong></p>
<ul>
<li>一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。</li>
<li>一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。</li>
<li>你能想出一个常数空间的解决方案吗？</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">bool</span> rowZero = <span class="literal">false</span>, colZero = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) colZero = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="number">0</span>) rowZero = <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span> || matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rowZero) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (colZero) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 48 ms, faster than 99.20% of C++ online submissions for Set Matrix Zeroes.</p>
<p>Memory Usage: 11.6 MB, less than 46.13% of C++ online submissions for Set Matrix Zeroes.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 116 ms, 在Set Matrix Zeroes的C++提交中击败了34.34% 的用户</p>
<p>内存消耗 : 11.3 MB, 在Set Matrix Zeroes的C++提交中击败了80.79% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (74) Search a 2D Matrix</title>
    <url>/a356c18fdb86/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong><br>matrix &#x3D; [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target &#x3D; 3<br><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong><br>matrix &#x3D; [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target &#x3D; 13<br><strong>输出:</strong> false</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix.<span class="built_in">back</span>().<span class="built_in">back</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid / n][mid % n] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid / n][mid % n] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 98.57% of C++ online submissions for Search a 2D Matrix.</p>
<p>Memory Usage: 10 MB, less than 100.00% of C++ online submissions for Search a 2D Matrix.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Search a 2D Matrix的C++提交中击败了94.04% 的用户</p>
<p>内存消耗 : 9.7 MB, 在Search a 2D Matrix的C++提交中击败了90.95% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (75) Sort Colors</title>
    <url>/2559fbb9ee0a/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，<a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地</a>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> [2,0,2,1,1,0]<br><strong>输出:</strong> [0,0,1,1,2,2]</p>
<p><strong>进阶：</strong></p>
<ul>
<li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">colors</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) ++colors[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, cur = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; colors[i]; ++j) &#123;</span><br><span class="line">                nums[cur++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Sort Colors.</p>
<p>Memory Usage: 8.6 MB, less than 55.43% of C++ online submissions for Sort Colors.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Sort Colors的C++提交中击败了95.25% 的用户</p>
<p>内存消耗 : 8.7 MB, 在Sort Colors的C++提交中击败了10.04% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (76) Minimum Window Substring</title>
    <url>/b253a88e7eab/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>**输入: ** S &#x3D; “ADOBECODEBANC”, T &#x3D; “ABC”<br><strong>输出:</strong> “BANC”</p>
<p><strong>说明：</strong></p>
<ul>
<li>如果 S 中不存这样的子串，则返回空字符串 <code>&quot;&quot;</code>。</li>
<li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">letterCnt</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t) ++letterCnt[c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--letterCnt[s[i]] &gt;= <span class="number">0</span>) ++cnt;</span><br><span class="line">            <span class="keyword">while</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                    res = s.<span class="built_in">substr</span>(left, minLen);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++letterCnt[s[left]] &gt; <span class="number">0</span>) --cnt;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 75.17% of C++ online submissions for Minimum Window Substring.</p>
<p>Memory Usage: 18.8 MB, less than 6.93% of C++ online submissions for Minimum Window Substring.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 36 ms, 在Minimum Window Substring的C++提交中击败了61.16% 的用户</p>
<p>内存消耗 : 18.5 MB, 在Minimum Window Substring的C++提交中击败了18.92% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (78) Subsets</title>
    <url>/78ec236069ff/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一组<strong>不含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明:</strong> 解集不能包含重复的子集。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> nums &#x3D; [1,2,3]<br><strong>输出:</strong><br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt; &amp;S) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">res</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sort</span>(S.<span class="built_in">begin</span>(), S.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> size = res.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; ++j) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(res[j]);</span><br><span class="line">                res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(S[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 100.00% of C++ online submissions for Subsets.</p>
<p>Memory Usage: 9.1 MB, less than 76.42% of C++ online submissions for Subsets.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Subsets的C++提交中击败了96.28% 的用户</p>
<p>内存消耗 : 9.2 MB, 在Subsets的C++提交中击败了50.89% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (77) Combinations</title>
    <url>/ee6e9a1b5c5a/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> n &#x3D; 4, k &#x3D; 2<br><strong>输出:</strong><br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">out</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ++out[i];</span><br><span class="line">            <span class="keyword">if</span> (out[i] &gt; n) --i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == k - <span class="number">1</span>) res.<span class="built_in">push_back</span>(out);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                out[i] = out[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 72 ms, faster than 86.50% of C++ online submissions for Combinations.</p>
<p>Memory Usage: 11.8 MB, less than 81.82% of C++ online submissions for Combinations.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 196 ms, 在Combinations的C++提交中击败了44.65% 的用户</p>
<p>内存消耗 : 11.8 MB, 在Combinations的C++提交中击败了75.47% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (79) Word Search</title>
    <url>/1f52c23fe1a1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>board &#x3D;<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p>
<p>给定 word &#x3D; “<strong>ABCCED</strong>“, 返回 <strong>true</strong>.<br>给定 word &#x3D; “<strong>SEE</strong>“, 返回 <strong>true</strong>.<br>给定 word &#x3D; “<strong>ABCB</strong>“, 返回 <strong>false</strong>.</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.<span class="built_in">empty</span>() || board[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">search</span>(board, word, <span class="number">0</span>, i, j, visited)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> idx, <span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == word.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || visited[i][j] || board[i][j] != word[idx]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">bool</span> res = <span class="built_in">search</span>(board, word, idx + <span class="number">1</span>, i - <span class="number">1</span>, j, visited) </span><br><span class="line">                 || <span class="built_in">search</span>(board, word, idx + <span class="number">1</span>, i + <span class="number">1</span>, j, visited)</span><br><span class="line">                 || <span class="built_in">search</span>(board, word, idx + <span class="number">1</span>, i, j - <span class="number">1</span>, visited)</span><br><span class="line">                 || <span class="built_in">search</span>(board, word, idx + <span class="number">1</span>, i, j + <span class="number">1</span>, visited);</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 336 ms, faster than 23.00% of C++ online submissions for Word Search.</p>
<p>Memory Usage: 158.7 MB, less than 29.45% of C++ online submissions for Word Search.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 692 ms, 在Word Search的C++提交中击败了19.74% 的用户</p>
<p>内存消耗 : 158.7 MB, 在Word Search的C++提交中击败了31.10% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (8) String to Integer (atoi)</title>
    <url>/4b2daca1ed35/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p><strong>说明：</strong></p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 </p>
<p>$$<br>[−2^{31},  2^{31} − 1]<br>$$</p>
<p>如果数值超过这个范围，请返回</p>
<p>$$<br>INT\_MAX (2^{31} − 1)<br>$$</p>
<p>或</p>
<p>$$<br>INT\_MIN (−2^{31})<br>$$</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p><strong>输入:</strong> “42”<br><strong>输出:</strong> 42</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> “   -42”<br><strong>输出:</strong> -42<br><strong>解释:</strong> 第一个非空白字符为 ‘-‘, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> “4193 with words”<br><strong>输出:</strong> 4193<br><strong>解释:</strong> 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p>
<h1 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h1><p><strong>输入:</strong> “words and 987”<br><strong>输出:</strong> 0<br><strong>解释:</strong> 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。</p>
<h1 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h1><p><strong>输入:</strong> “-91283472332”<br><strong>输出:</strong> -2147483648<br><strong>解释:</strong> 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 </p>
<p>$$<br>INT\_MIN (−2^{31})<br>$$</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sign = <span class="number">1</span>, base = <span class="number">0</span>, i = <span class="number">0</span>, n = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; str[i] == <span class="string">&#x27; &#x27;</span>) ++i;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n &amp;&amp; (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">            sign = (str[i++] == <span class="string">&#x27;+&#x27;</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (base &gt; INT_MAX / <span class="number">10</span> || (base == INT_MAX / <span class="number">10</span> &amp;&amp; str[i] - <span class="string">&#x27;0&#x27;</span> &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> (sign == <span class="number">1</span>) ? INT_MAX : INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            base = <span class="number">10</span> * base + (str[i++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> base * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 24 ms, faster than 15.46% of C++ online submissions for String to Integer (atoi).</p>
<p>Memory Usage: 14.5 MB, less than 66.80% of C++ online submissions for String to Integer (atoi).</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 36 ms, 在String to Integer (atoi)的C++提交中击败了3.71% 的用户</p>
<p>内存消耗 : 14.3 MB, 在String to Integer (atoi)的C++提交中击败了0.67% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (80) Remove Duplicates from Sorted Array II</title>
    <url>/4f996f6be558/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个排序数组，你需要在 <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地</a></strong> 删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地</a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p>给定 nums &#x3D; <strong>[1,1,1,2,2,3]</strong>,</p>
<p>函数应返回新长度 length &#x3D; <strong><code>5</code></strong> , 并且原数组的前五个元素被修改为 <strong><code>1, 1, 2, 2,</code></strong>  <strong>3</strong> 。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p>给定 nums &#x3D; <strong>[0,0,1,1,1,1,2,3,3]</strong>,</p>
<p>函数应返回新长度 length &#x3D; <strong><code>7</code></strong> , 并且原数组的前五个元素被修改为 <strong><code>0</code></strong> , <strong>0</strong> , <strong>1</strong> , <strong>1</strong> , <strong>2</strong>, <strong>3</strong>, <strong>3</strong> 。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// **nums** 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">removeDuplicates</span>(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中**该长度范围内**的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> elems = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> <span class="type">const</span> ne = nums.<span class="built_in">end</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> insert_pos = nums.<span class="built_in">begin</span>(), walker = nums.<span class="built_in">begin</span>(); walker != ne;) &#123;</span><br><span class="line">            <span class="keyword">auto</span> target_val = *walker;</span><br><span class="line">            <span class="type">int</span> local_elems = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; walker != ne <span class="keyword">and</span> *walker == target_val; ++walker) &#123;</span><br><span class="line">                <span class="keyword">if</span> (local_elems &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    *insert_pos++ = target_val;</span><br><span class="line">                    ++local_elems;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            elems += local_elems;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elems;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 100.00% of C++ online submissions for Remove Duplicates from Sorted Array II.</p>
<p>Memory Usage: 9 MB, less than 100.00% of C++ online submissions for Remove Duplicates from Sorted Array II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 36 ms, 在Remove Duplicates from Sorted Array II的C++提交中击败了38.39% 的用户</p>
<p>内存消耗 : 9 MB, 在Remove Duplicates from Sorted Array II的C++提交中击败了71.79% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (81) Search in Rotated Sorted Array II</title>
    <url>/ad4f59e44246/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,0,1,2,2,5,6]</code> 可能变为 <code>[2,5,6,0,0,1,2]</code> )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> nums &#x3D; [2<code>,5,6,0,0,1,2]</code>, target &#x3D; 0<br><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> nums &#x3D; [2<code>,5,6,0,0,1,2]</code>, target &#x3D; 3<br><strong>输出:</strong> false</p>
<p><strong>进阶:</strong></p>
<ul>
<li>这是 <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/">搜索旋转排序数组</a> 的延伸题目，本题中的 <code>nums</code>  可能包含重复元素。</li>
<li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li>
</ul>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchCore</span>(nums, target, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchCore</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[begin] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - begin == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[end] == target || nums[begin] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[begin] &lt; nums[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">binarySearch</span>(nums, target, begin, end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = (end - begin) / <span class="number">2</span> + begin;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> left = <span class="built_in">searchCore</span>(nums, target, begin, mid);</span><br><span class="line">        <span class="type">bool</span> right = <span class="built_in">searchCore</span>(nums, target, mid, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left || right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">binarySearch</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (end - begin)/ <span class="number">2</span> + begin;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> begin = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 9.29% of C++ online submissions for Search in Rotated Sorted Array II.</p>
<p>Memory Usage: 9 MB, less than 6.80% of C++ online submissions for Search in Rotated Sorted Array II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Search in Rotated Sorted Array II的C++提交中击败了94.39% 的用户</p>
<p>内存消耗 : 8.8 MB, 在Search in Rotated Sorted Array II的C++提交中击败了9.85% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (82) Remove Duplicates from Sorted List II</title>
    <url>/e072f7e35da1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <strong>没有重复出现</strong> 的数字。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br><strong>输出:</strong> 1-&gt;2-&gt;5</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 1-&gt;1-&gt;1-&gt;2-&gt;3<br><strong>输出:</strong> 2-&gt;3</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *pre = dummy;</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span> (pre-&gt;next) &#123;</span><br><span class="line">            ListNode *cur = pre-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val) &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur != pre-&gt;next) pre-&gt;next = cur-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 23.47% of C++ online submissions for Remove Duplicates from Sorted List II.</p>
<p>Memory Usage: 9.3 MB, less than 19.90% of C++ online submissions for Remove Duplicates from Sorted List II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Remove Duplicates from Sorted List II的C++提交中击败了95.61% 的用户</p>
<p>内存消耗 : 9 MB, 在Remove Duplicates from Sorted List II的C++提交中击败了56.65% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (83) Remove Duplicates from Sorted List</title>
    <url>/beae963f9102/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 1-&gt;1-&gt;2<br><strong>输出:</strong> 1-&gt;2</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;3<br><strong>输出:</strong> 1-&gt;2-&gt;3</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 12 ms, faster than 99.73% of C++ online submissions for Remove Duplicates from Sorted List.</p>
<p>Memory Usage: 9.3 MB, less than 34.87% of C++ online submissions for Remove Duplicates from Sorted List.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 20 ms, 在Remove Duplicates from Sorted List的C++提交中击败了96.36% 的用户</p>
<p>内存消耗 : 9.4 MB, 在Remove Duplicates from Sorted List的C++提交中击败了5.13% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (84) Largest Rectangle in Histogram</title>
    <url>/8b57cdba14b4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram.png"></p>
<p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png"></p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> [2,1,5,6,2,3]<br><strong>输出:</strong> 10</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; height.<span class="built_in">size</span>() &amp;&amp; height[i] &lt;= height[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> minH = height[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                minH = <span class="built_in">min</span>(minH, height[j]);</span><br><span class="line">                <span class="type">int</span> area = minH * (i - j + <span class="number">1</span>);</span><br><span class="line">                res = <span class="built_in">max</span>(res, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 16 ms, faster than 84.03% of C++ online submissions for Largest Rectangle in Histogram.</p>
<p>Memory Usage: 9.9 MB, less than 90.91% of C++ online submissions for Largest Rectangle in Histogram.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 24 ms, 在Largest Rectangle in Histogram的C++提交中击败了55.10% 的用户</p>
<p>内存消耗 : 9.8 MB, 在Largest Rectangle in Histogram的C++提交中击败了91.03% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (85) Maximal Rectangle</title>
    <url>/f20009b2dbf3/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong><br>[<br>  [“1”,”0”,”1”,”0”,”0”],<br>  [“1”,”0”,”<strong>1</strong>“,”<strong>1</strong>“,”<strong>1</strong>“],<br>  [“1”,”1”,”<strong>1</strong>“,”<strong>1</strong>“,”<strong>1</strong>“],<br>  [“1”,”0”,”0”,”1”,”0”]<br>]<br><strong>输出:</strong> 6</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">height</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">left</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">right</span><span class="params">(n, n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur_left = <span class="number">0</span>, cur_right = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ++height[j];</span><br><span class="line">                    left[j] = <span class="built_in">max</span>(left[j], cur_left);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    height[j] = <span class="number">0</span>;</span><br><span class="line">                    left[j] = <span class="number">0</span>;</span><br><span class="line">                    cur_left = j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    right[j] = <span class="built_in">min</span>(right[j], cur_right);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right[j] = n;</span><br><span class="line">                    cur_right = j;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, (right[j] - left[j]) * height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 98.06% of C++ online submissions for Maximal Rectangle.</p>
<p>Memory Usage: 10.7 MB, less than 100.00% of C++ online submissions for Maximal Rectangle.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 44 ms, 在Maximal Rectangle的C++提交中击败了45.90% 的用户</p>
<p>内存消耗 : 10.7 MB, 在Maximal Rectangle的C++提交中击败了91.26% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (86) Partition List</title>
    <url>/b30678eafcfe/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3<br><strong>输出:</strong> 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">partition</span><span class="params">(ListNode *head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummy, *cur = head;;</span><br><span class="line">        <span class="keyword">while</span> (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;val &lt; x) pre = pre-&gt;next;</span><br><span class="line">        cur = pre;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val &lt; x) &#123;</span><br><span class="line">                ListNode *tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = tmp-&gt;next;</span><br><span class="line">                tmp-&gt;next = pre-&gt;next;</span><br><span class="line">                pre-&gt;next = tmp;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Partition List.</p>
<p>Memory Usage: 8.6 MB, less than 63.78% of C++ online submissions for Partition List.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 20 ms, 在Partition List的C++提交中击败了37.21% 的用户</p>
<p>内存消耗 : 8.7 MB, 在Partition List的C++提交中击败了19.42% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (88) Merge Sorted Array</title>
    <url>/b08e3f13f508/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<p><strong>说明:</strong></p>
<ul>
<li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</li>
<li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong><br>nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3<br>nums2 &#x3D; [2,5,6],       n &#x3D; 3</p>
<p><strong>输出:</strong> [1,2,2,3,5,6]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k--] = (i &gt;= <span class="number">0</span> &amp;&amp; nums1[i] &gt; nums2[j]) ? nums1[i--] : nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 99.67% of C++ online submissions for Merge Sorted Array.</p>
<p>Memory Usage: 8.6 MB, less than 100.00% of C++ online submissions for Merge Sorted Array.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Merge Sorted Array的C++提交中击败了97.24% 的用户</p>
<p>内存消耗 : 8.7 MB, 在Merge Sorted Array的C++提交中击败了84.60% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (9) Palindrome Number</title>
    <url>/a2052e527229/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p><strong>输入:</strong> 121<br><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> -121<br><strong>输出:</strong> false<br><strong>解释:</strong> 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p>
<h1 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h1><p><strong>输入:</strong> 10<br><strong>输出:</strong> false<br><strong>解释:</strong> 从右向左读, 为 01 。因此它不是一个回文数。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> revertNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertNum) &#123;</span><br><span class="line">            revertNum = revertNum * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == revertNum || x == revertNum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 112 ms, faster than 85.43% of C++ online submissions for Palindrome Number.</p>
<p>Memory Usage: 73.1 MB, less than 45.79% of C++ online submissions for Palindrome Number.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 248 ms, 在Palindrome Number的C++提交中击败了5.13% 的用户</p>
<p>内存消耗 : 73 MB, 在Palindrome Number的C++提交中击败了0.54% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (87) Scramble String</title>
    <url>/918e30b7df15/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。</p>
<p>下图是字符串 s1 &#x3D; <code>&quot;great&quot;</code> 的一种可能的表示形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   great</span><br><span class="line">   /    \</span><br><span class="line">  gr    eat</span><br><span class="line"> / \    /  \</span><br><span class="line">g   r  e   at</span><br><span class="line">           / \</span><br><span class="line">          a   t</span><br></pre></td></tr></table></figure>

<p>在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。</p>
<p>例如，如果我们挑选非叶节点 <code>&quot;gr&quot;</code> ，交换它的两个子节点，将会产生扰乱字符串 <code>&quot;rgeat&quot;</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   rgeat</span><br><span class="line">   /    \</span><br><span class="line">  rg    eat</span><br><span class="line"> / \    /  \</span><br><span class="line">r   g  e   at</span><br><span class="line">           / \</span><br><span class="line">          a   t</span><br></pre></td></tr></table></figure>

<p>我们将 <code>&quot;rgeat”</code> 称作 <code>&quot;great&quot;</code> 的一个扰乱字符串。</p>
<p>同样地，如果我们继续将其节点 <code>&quot;eat&quot;</code> 和 <code>&quot;at&quot;</code> 进行交换，将会产生另一个新的扰乱字符串 <code>&quot;rgtae&quot;</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   rgtae</span><br><span class="line">   /    \</span><br><span class="line">  rg    tae</span><br><span class="line"> / \    /  \</span><br><span class="line">r   g  ta  e</span><br><span class="line">       / \</span><br><span class="line">      t   a</span><br></pre></td></tr></table></figure>

<p>我们将 <code>&quot;rgtae”</code> 称作 <code>&quot;great&quot;</code> 的一个扰乱字符串。</p>
<p>给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> s1 &#x3D; “great”, s2 &#x3D; “rgeat”<br><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> s1 &#x3D; “abcde”, s2 &#x3D; “caebd”<br><strong>输出:</strong> false</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isScramble</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1.<span class="built_in">size</span>() != s2.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = s1.<span class="built_in">size</span>(), m[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++m[s1[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            --m[s2[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(<span class="number">0</span>, i), s2.<span class="built_in">substr</span>(<span class="number">0</span>, i)) &amp;&amp; <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(i), s2.<span class="built_in">substr</span>(i))) || (<span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(<span class="number">0</span>, i), s2.<span class="built_in">substr</span>(n - i)) &amp;&amp; <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(i), s2.<span class="built_in">substr</span>(<span class="number">0</span>, n - i)))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Scramble String.</p>
<p>Memory Usage: 9.8 MB, less than 64.28% of C++ online submissions for Scramble String.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 12 ms, 在Scramble String的C++提交中击败了93.45% 的用户</p>
<p>内存消耗 : 9.6 MB, 在Scramble String的C++提交中击败了83.33% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (89) Gray Code</title>
    <url>/763bc1ed6fda/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>
<p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> 2<br><strong>输出:</strong> <code>[0,1,3,2]</code><br><strong>解释:</strong><br>00 - 0<br>01 - 1<br>11 - 3<br>10 - 2</p>
<p>对于给定的 n，其格雷编码序列并不唯一。<br>例如，<code>[0,2,3,1]</code> 也是一个有效的格雷编码序列。</p>
<p>00 - 0<br>10 - 2<br>11 - 3<br>01 - 1</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> 0<br><strong>输出:</strong> [0]<br><strong>解释:</strong> 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n &#x3D; 0 时，长度为 20 &#x3D; 1。<br>     因此，当 n &#x3D; 0 时，其格雷编码序列为 [0]。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> size = res.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = size - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(res[j] | (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 98.77% of C++ online submissions for Gray Code.</p>
<p>Memory Usage: 8.6 MB, less than 55.98% of C++ online submissions for Gray Code.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 4 ms, 在Gray Code的C++提交中击败了100.00% 的用户</p>
<p>内存消耗 : 8.6 MB, 在Gray Code的C++提交中击败了34.55% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (90) Subsets II</title>
    <url>/70ac02bdc769/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个可能包含重复元素的整数数组 <strong>nums</strong>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明:</strong> 解集不能包含重复的子集。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> [1,2,2]<br><strong>输出:</strong><br>[<br>  [2],<br>  [1],<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt; &amp;S) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sort</span>(S.<span class="built_in">begin</span>(), S.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> size = <span class="number">1</span>, last = S[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last != S[i]) &#123;</span><br><span class="line">                last = S[i];</span><br><span class="line">                size = res.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> newSize = res.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = newSize - size; j &lt; newSize; ++j) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(res[j]);</span><br><span class="line">                res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(S[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 98.49% of C++ online submissions for Subsets II.</p>
<p>Memory Usage: 9.4 MB, less than 59.14% of C++ online submissions for Subsets II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Subsets II的C++提交中击败了98.57% 的用户</p>
<p>内存消耗 : 9.3 MB, 在Subsets II的C++提交中击败了68.98% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (91) Decode Ways</title>
    <url>/d1e9175c2325/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一条包含字母 <code>A-Z</code> 的消息通过以下方式进行了编码：</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26</p>
<p>给定一个只包含数字的<strong>非空</strong>字符串，请计算解码方法的总数。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> “12”<br><strong>输出:</strong> 2<br><strong>解释:</strong> 它可以解码为 “AB”（1 2）或者 “L”（12）。</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> “226”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || s.<span class="built_in">front</span>() == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> c1 = <span class="number">1</span>, c2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) c1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || (s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;6&#x27;</span>)) &#123;</span><br><span class="line">                c1 = c1 + c2;</span><br><span class="line">                c2 = c1 - c2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c2 = c1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Decode Ways.</p>
<p>Memory Usage: 8.3 MB, less than 85.79% of C++ online submissions for Decode Ways.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 4 ms, 在Decode Ways的C++提交中击败了98.25% 的用户</p>
<p>内存消耗 : 8.3 MB, 在Decode Ways的C++提交中击败了85.54% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (92) Reverse Linked List II</title>
    <url>/c436edb77ba4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p><strong>说明:</strong><br>1 ≤ m ≤ n ≤ 链表长度。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong><br><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4<br><strong>输出:</strong> 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *pre = dummy;</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) pre = pre-&gt;next;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; n; ++i) &#123;</span><br><span class="line">            ListNode *t = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = t-&gt;next;</span><br><span class="line">            t-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 33.74% of C++ online submissions for Reverse Linked List II.</p>
<p>Memory Usage: 8.6 MB, less than 86.14% of C++ online submissions for Reverse Linked List II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Reverse Linked List II的C++提交中击败了96.62% 的用户</p>
<p>内存消耗 : 8.8 MB, 在Reverse Linked List II的C++提交中击败了47.52% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (93) Restore IP Addresses</title>
    <url>/743ac0c27f4c/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> “25525511135”<br><strong>输出:</strong> <code>[&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</code></p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt; <span class="number">4</span>; ++a) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">1</span>; b &lt; <span class="number">4</span>; ++b) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt; <span class="number">4</span>; ++c) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt; <span class="number">4</span>; ++d) </span><br><span class="line">            <span class="keyword">if</span> (a + b + c + d == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> A = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, a));</span><br><span class="line">                <span class="type">int</span> B = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(a, b));</span><br><span class="line">                <span class="type">int</span> C = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(a + b, c));</span><br><span class="line">                <span class="type">int</span> D = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(a + b + c, d));</span><br><span class="line">                <span class="keyword">if</span> (A &lt;= <span class="number">255</span> &amp;&amp; B &lt;= <span class="number">255</span> &amp;&amp; C &lt;= <span class="number">255</span> &amp;&amp; D &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">                    string t = <span class="built_in">to_string</span>(A) + <span class="string">&quot;.&quot;</span> + <span class="built_in">to_string</span>(B) + <span class="string">&quot;.&quot;</span> + <span class="built_in">to_string</span>(C) + <span class="string">&quot;.&quot;</span> + <span class="built_in">to_string</span>(D);</span><br><span class="line">                    <span class="keyword">if</span> (t.<span class="built_in">size</span>() == s.<span class="built_in">size</span>() + <span class="number">3</span>) res.<span class="built_in">push_back</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 97.33% of C++ online submissions for Restore IP Addresses.</p>
<p>Memory Usage: 8.9 MB, less than 23.36% of C++ online submissions for Restore IP Addresses.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 8 ms, 在Restore IP Addresses的C++提交中击败了96.78% 的用户</p>
<p>内存消耗 : 8.9 MB, 在Restore IP Addresses的C++提交中击败了18.39% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (94) Binary Tree Inorder Traversal</title>
    <url>/769fdc04f645/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，返回它的 <strong>中序</strong> 遍历。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> [1,null,2,3]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> [1,3,2]</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() || p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Inorder Traversal.</p>
<p>Memory Usage: 9.5 MB, less than 21.09% of C++ online submissions for Binary Tree Inorder Traversal.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 4 ms, 在Binary Tree Inorder Traversal的C++提交中击败了98.68% 的用户</p>
<p>内存消耗 : 9.1 MB, 在Binary Tree Inorder Traversal的C++提交中击败了59.13% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (95) Unique Binary Search Trees II</title>
    <url>/ecaa43709b43/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的<strong>二叉搜索树</strong>。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> 3<br><strong>输出:</strong><br>[<br>  [1,null,3,2],<br>  [3,2,null,1],<br>  [3,1,null,null,2],<br>  [2,1,3],<br>  [1,null,2,null,3]<br>]<br><strong>解释:</strong><br>以上的输出对应以下 5 种不同结构的二叉搜索树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1         3     3      2      1</span><br><span class="line"> \       /     /      / \      \</span><br><span class="line">  3     2     1      1   3      2</span><br><span class="line"> /     /       \                 \</span><br><span class="line">2     1         2                 3</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode *&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">generateTreesDFS</span>(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; *<span class="title">generateTreesDFS</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; *subTree = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) subTree-&gt;<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">                vector&lt;TreeNode*&gt; *leftSubTree = <span class="built_in">generateTreesDFS</span>(start, i - <span class="number">1</span>);</span><br><span class="line">                vector&lt;TreeNode*&gt; *rightSubTree = <span class="built_in">generateTreesDFS</span>(i + <span class="number">1</span>, end);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; leftSubTree-&gt;<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; rightSubTree-&gt;<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                        node-&gt;left = (*leftSubTree)[j];</span><br><span class="line">                        node-&gt;right = (*rightSubTree)[k];</span><br><span class="line">                        subTree-&gt;<span class="built_in">push_back</span>(node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 91.77% of C++ online submissions for Unique Binary Search Trees II.</p>
<p>Memory Usage: 17.9 MB, less than 6.31% of C++ online submissions for Unique Binary Search Trees II.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 48 ms, 在Unique Binary Search Trees II的C++提交中击败了42.79% 的用户</p>
<p>内存消耗 : 18 MB, 在Unique Binary Search Trees II的C++提交中击败了5.01% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (97) Interleaving String</title>
    <url>/67acf080945d/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> s1 &#x3D; “aabcc”, s2 &#x3D; “dbbca”, s3 &#x3D; “aadbbcbcac”<br><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> s1 &#x3D; “aabcc”, s2 &#x3D; “dbbca”, s3 &#x3D; “aadbbbaccc”<br><strong>输出:</strong> false</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.<span class="built_in">size</span>() + s2.<span class="built_in">size</span>() != s3.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n1 = s1.<span class="built_in">size</span>(), n2 = s2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (n2 + <span class="number">1</span>, <span class="literal">false</span>)); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n1; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n2; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]) || (dp[i][j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 4 ms, faster than 99.29% of C++ online submissions for Interleaving String.</p>
<p>Memory Usage: 8.9 MB, less than 25.01% of C++ online submissions for Interleaving String.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 16 ms, 在Interleaving String的C++提交中击败了38.14% 的用户</p>
<p>内存消耗 : 8.9 MB, 在Interleaving String的C++提交中击败了25.73% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (96) Unique Binary Search Trees</title>
    <url>/8fa4f8ac18af/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入:</strong> 3<br><strong>输出:</strong> 5<br><strong>解释:</strong> 给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1         3     3      2      1</span><br><span class="line"> \       /     /      / \      \</span><br><span class="line">  3     2     1      1   3      2</span><br><span class="line"> /     /       \                 \</span><br><span class="line">2     1         2                 3</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                dp[i] += dp[j] * dp[i - j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Unique Binary Search Trees.</p>
<p>Memory Usage: 8.4 MB, less than 12.53% of C++ online submissions for Unique Binary Search Trees.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 4 ms, 在Unique Binary Search Trees的C++提交中击败了98.48% 的用户</p>
<p>内存消耗 : 8.4 MB, 在Unique Binary Search Trees的C++提交中击败了7.43% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (99) Recover Binary Search Tree</title>
    <url>/d5b1f363840d/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>二叉搜索树中的两个节点被错误地交换。</p>
<p>请在不改变其结构的情况下，恢复这棵树。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong> [1,3,null,null,2]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> /</span><br><span class="line">3</span><br><span class="line"> \</span><br><span class="line">  2</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> [3,1,null,null,2]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> /</span><br><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br></pre></td></tr></table></figure>

<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong> [3,1,4,null,null,2]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  2</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> [2,1,4,null,null,3]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  3</span><br></pre></td></tr></table></figure>

<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *first = <span class="literal">NULL</span>, *second = <span class="literal">NULL</span>, *parent = <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode *cur, *pre;</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent &amp;&amp; parent-&gt;val &gt; cur-&gt;val) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!first) first = parent;</span><br><span class="line">                    second = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (pre-&gt;right &amp;&amp; pre-&gt;right != cur) pre = pre-&gt;right;</span><br><span class="line">                <span class="keyword">if</span> (!pre-&gt;right) &#123;</span><br><span class="line">                    pre-&gt;right = cur;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="keyword">if</span> (parent-&gt;val &gt; cur-&gt;val) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!first) first = parent;</span><br><span class="line">                        second = cur;</span><br><span class="line">                    &#125;</span><br><span class="line">                    parent = cur;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(first-&gt;val, second-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 20 ms, faster than 99.27% of C++ online submissions for Recover Binary Search Tree.</p>
<p>Memory Usage: 17.9 MB, less than 76.24% of C++ online submissions for Recover Binary Search Tree.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 60 ms, 在Recover Binary Search Tree的C++提交中击败了69.66% 的用户</p>
<p>内存消耗 : 17.5 MB, 在Recover Binary Search Tree的C++提交中击败了96.19% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode (98) Validate Binary Search Tree</title>
    <url>/ed04cb26b641/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li>
<li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</li>
</ul>
<p><strong>说明:</strong></p>
<ul>
<li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</li>
<li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</li>
</ul>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><p><strong>输入:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> true</p>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h1><p><strong>输入:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  5</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong> false<br><strong>解释:</strong> 输入为: [5,1,4,null,null,3,6]。<br>     根节点的值为 5 ，但是其右子节点值为 4 。</p>
<h1 id="C-解决方法"><a href="#C-解决方法" class="headerlink" title="C++解决方法"></a>C++解决方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        TreeNode *cur = root, *pre, *parent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent &amp;&amp; parent-&gt;val &gt;= cur-&gt;val) res = <span class="literal">false</span>;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (pre-&gt;right &amp;&amp; pre-&gt;right != cur) pre = pre-&gt;right;</span><br><span class="line">                <span class="keyword">if</span> (!pre-&gt;right) &#123;</span><br><span class="line">                    pre-&gt;right = cur;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="keyword">if</span> (parent-&gt;val &gt;= cur-&gt;val) res = <span class="literal">false</span>;</span><br><span class="line">                    parent = cur;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p>Runtime: 8 ms, faster than 99.83% of C++ online submissions for Validate Binary Search Tree.</p>
<p>Memory Usage: 20.6 MB, less than 62.75% of C++ online submissions for Validate Binary Search Tree.</p>
<h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p>执行用时 : 24 ms, 在Validate Binary Search Tree的C++提交中击败了95.78% 的用户</p>
<p>内存消耗 : 20.7 MB, 在Validate Binary Search Tree的C++提交中击败了42.51% 的用户</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法（一）</title>
    <url>/8f421c76eedf/</url>
    <content><![CDATA[<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>**这是加粗的文字**</code><br><code>*这是倾斜的文字*</code><br><code>***这是斜体加粗的文字***</code><br><code>~~这是加删除线的文字~~</code></p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><em><strong>这是斜体加粗的文字</strong></em><br><del>这是加删除线的文字</del></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p><code>&gt;这是引用的内容</code><br><code>&gt;&gt;这是引用的内容</code><br><code>&gt;&gt;&gt;这是引用的内容</code></p>
<h2 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h2><blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p><code>---</code><br><code>- - - - -</code><br><code>***</code><br><code>*****</code></p>
<h2 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h2><hr>
<hr>
<hr>
<hr>
<h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p><code>$$</code><br><code>e=mc^2</code><br><code>$$</code></p>
<p><code>$$</code><br><code>\frac&#123;\partial u&#125;&#123;\partial t&#125;</code><br><code>= h^2 \left( \frac&#123;\partial^2 u&#125;&#123;\partial x^2&#125; +</code><br><code>\frac&#123;\partial^2 u&#125;&#123;\partial y^2&#125; +</code><br><code>\frac&#123;\partial^2 u&#125;&#123;\partial z^2&#125;\right)</code><br><code>$$</code></p>
<p><code>$$</code><br><code>cos 2\theta = \cos^2 \theta - \sin^2 \theta = 2 \cos^2 \theta - 1</code><br><code>$$</code></p>
<p><code>$$</code><br><code>\begin&#123;aligned&#125;</code><br><code>\dot&#123;x&#125; &amp; = \sigma(y-x) \\\\</code><br><code>\dot&#123;y&#125; &amp; = \rho x - y - xz \\\\</code><br><code>\dot&#123;z&#125; &amp; = -\beta z + xy</code><br><code>\end&#123;aligned&#125;</code><br><code>$$</code></p>
<p><code>$$</code><br><code>\begin&#123;aligned&#125;</code><br><code>a &amp;= b + c \\\\</code><br><code>&amp;= d + e + f + g \\\\</code><br><code>&amp;= h + i</code><br><code>\end&#123;aligned&#125;</code><br><code>$$</code></p>
<h2 id="效果-3"><a href="#效果-3" class="headerlink" title="效果"></a>效果</h2><p>$$<br>e&#x3D;mc^2<br>$$</p>
<p>$$<br>\frac{\partial u}{\partial t}<br>&#x3D; h^2 \left( \frac{\partial^2 u}{\partial x^2} +<br>\frac{\partial^2 u}{\partial y^2} +<br>\frac{\partial^2 u}{\partial z^2}\right)<br>$$</p>
<p>$$<br>cos 2\theta &#x3D; \cos^2 \theta - \sin^2 \theta &#x3D; 2 \cos^2 \theta - 1<br>$$</p>
<p>$$<br>\begin{aligned}<br>\dot{x} &amp; &#x3D; \sigma(y-x) \\<br>\dot{y} &amp; &#x3D; \rho x - y - xz \\<br>\dot{z} &amp; &#x3D; -\beta z + xy<br>\end{aligned}<br>$$</p>
<p>$$<br>\begin{aligned}<br>a &amp;&#x3D; b + c \\<br>  &amp;&#x3D; d + e + f + g \\<br>  &amp;&#x3D; h + i<br>\end{aligned}<br>$$</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法（二）</title>
    <url>/f4711c5ec721/</url>
    <content><![CDATA[<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>列表项目标记通常放在最左边，项目标记后面要接一个字符的空格。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>无序列表</strong>：使用星号、加号或是减号作为列表标记</p>
<p><code>- Red</code><br><code>- Green</code><br><code>- Blue</code></p>
<p><strong>有序列表</strong>：使用数字接着一个英文句点</p>
<p><code>1. Red</code><br><code>2. Green</code><br><code>3. Blue</code></p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><strong>无序列表</strong>：</p>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p><strong>有序列表</strong>：</p>
<ol>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ol>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>方括号显示说明，圆括号内显示网址， Markdown 会自动把它转成链接。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p><code>[胡心小筑](https://blog.mhxcalfred.com)</code></p>
<h2 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h2><p><a href="https://blog.mhxcalfred.com/">胡心小筑</a></p>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p><code>First Header | Second Header | Third Header</code><br><code>------------ | ------------- | ------------</code><br><code>Content Cell | Content Cell  | Content Cell</code><br><code>Content Cell | Content Cell  | Content Cell</code></p>
<h2 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h2><table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
<th>Third Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
